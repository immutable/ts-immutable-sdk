## Immutable Passport SDK Example App Generator - Part 1: Create the App

# Overview
This prompt helps you create a new React example app that demonstrates the event-handling feature of the Immutable Passport SDK. The output will be a fully functional, self-contained example with proper documentation and adherence to best practices.

# App Information
- Feature name: event-handling
- Framework: nextjs

# Step 1: Core Setup
Create a new example app named event-handling-with-nextjs in /examples/passport/ with this structure:

```
/examples/passport/event-handling-with-nextjs/
├── src/app/
│   ├── page.tsx                    # Main landing page with feature links
│   ├── event-handling/page.tsx     # Primary feature implementation
│   ├── redirect/page.tsx           # Auth redirect handler
│   ├── logout/page.tsx             # Logout functionality
│   ├── utils/                      # Shared utilities
│   │   ├── setupDefault.ts         # SDK initialization
│   │   └── wrapper.tsx             # App context wrapper
│   ├── tests/                      # Test directory
│   │   └── unit/                   # Unit tests
│   │       └── passport.test.js    # Feature tests
│   ├── layout.tsx                  # App layout with wrapper
│   └── globals.css                 # Basic styles
├── README.md                       # Documentation
├── package.json                    # Dependencies
├── next.config.mjs                 # Next.js config
├── tsconfig.json                   # TypeScript config
├── .env.example                    # Environment variables
├── .gitignore                      # Git ignore file
├── jest.config.js                  # Jest configuration
└── babel.config.jest.js            # Babel config for tests
```

Copy these essential files from an existing example (e.g., login-with-nextjs):
- package.json (update the name to "event-handling-with-nextjs", but keep ALL dependency versions the same)
- next.config.mjs
- tsconfig.json
- .env.example
- .gitignore
- src/app/utils/setupDefault.ts
- src/app/utils/wrapper.tsx
- src/app/layout.tsx (modify to use AppWrapper)
- src/app/globals.css

# Step 2: Component Implementation

## Critical Import/Export Requirements
For ALL component files:
- ALWAYS use default exports for page components (export default function ComponentName)
- ALWAYS import React explicitly if using JSX fragments (<>...</>): import React from 'react'
- Verify all imports are correctly spelled and point to existing files
- When importing from libraries, verify the component exists in that library
- For Next.js client components, always include 'use client' at the top of the file

## Main Landing Page (src/app/page.tsx)
Create a simple landing page with:
- Brief description of the Passport event handling features
- Link to the event-handling implementation page
- Clear, concise UI using standard HTML (h1, h2, p) and Biom3 Button components

## Feature Implementation (src/app/event-handling/page.tsx)
Create a self-contained implementation that:
- Demonstrates all available Passport events 
- Uses proper initialization and cleanup patterns
- Shows user feedback for different event states
- Uses standard HTML tags (h1, h2, p) for text (NOT Text component)
- Uses Biom3 components for UI elements
- Displays event data in the UI for user feedback
- Thoroughly validates all props and types
- Shows how to properly handle connection state changes

Include examples of handling these events:
- connect
- disconnect
- chainChanged
- accountsChanged
- any other relevant Passport events

## Redirect and Logout Pages
Create minimal, functional redirect and logout pages:
- Ensure the redirect page properly handles the authentication callback
- Implement robust error handling for failed auth callbacks
- For the logout page, implement proper token cleanup
- VERIFY that all components used in these pages are properly imported

# Step 3: Documentation
Create a comprehensive README.md including:
- Event handling feature description and purpose
- Setup instructions including environment variables
- Usage instructions with code examples for all event types
- Common issues and troubleshooting
- References to official documentation
- Event cleanup best practices

# Step 4: Testing Files

## Jest Configuration
Create jest.config.js:
```javascript
module.exports = {
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.(js|jsx|ts|tsx)$': ['babel-jest', { configFile: './babel.config.jest.js' }],
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  testPathIgnorePatterns: ['/node_modules/', '/.next/'],
  transformIgnorePatterns: [
    '/node_modules/(?!(@biom3|@imtbl)/)',
  ],
  coverageThreshold: {
    global: {
      lines: 80,
    }
  },
  setupFilesAfterEnv: ['<rootDir>/src/app/tests/setup.js'],
};
```

## Test Setup File
Create src/app/tests/setup.js:
```javascript
// Add custom jest matchers from testing-library
require('@testing-library/jest-dom');

// Mock Next.js navigation
jest.mock('next/navigation', () => ({
  useRouter: () => ({
    push: jest.fn(),
    replace: jest.fn(),
    prefetch: jest.fn(),
  }),
  usePathname: () => '/',
  useSearchParams: () => new URLSearchParams(),
}));

// Suppress specific console errors during tests
const originalConsoleError = console.error;
console.error = (...args) => {
  if (
    typeof args[0] === 'string' && 
    (args[0].includes('Warning: ReactDOM.render') || 
     args[0].includes('Error: Uncaught [Error'))
  ) {
    return;
  }
  originalConsoleError(...args);
};

// Setup global mocks that might be needed across tests
global.ResizeObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  unobserve: jest.fn(),
  disconnect: jest.fn(),
}));
```

## Babel Configuration
Create babel.config.jest.js:
```javascript
module.exports = {
  presets: [
    ['@babel/preset-env', { targets: { node: 'current' } }],
    '@babel/preset-typescript',
    ['@babel/preset-react', { runtime: 'automatic' }],
  ],
};
```

## Unit Tests
Create comprehensive tests in src/app/tests/unit/passport.test.js:
- Use CommonJS syntax (require instead of import)
- Mock ALL external dependencies thoroughly:
  ```javascript
  // Example of complete component mocking
  jest.mock('@biom3/react', () => ({
    Button: ({ children, onClick, disabled }) => (
      <button onClick={onClick} disabled={disabled} data-testid="biom3-button">
        {children}
      </button>
    ),
    // Include ALL components you use from the library
    Heading: ({ children, size, className }) => (
      <h2 className={className} data-testid={`biom3-heading-${size}`}>
        {children}
      </h2>
    ),
    Stack: ({ children, alignItems, gap, direction }) => (
      <div data-testid="biom3-stack" data-align={alignItems} data-gap={gap} data-direction={direction}>
        {children}
      </div>
    ),
    Text: ({ children, variant }) => (
      <span data-testid="biom3-text" data-variant={variant}>
        {children}
      </span>
    ),
    Spinner: ({ size }) => <div data-testid="biom3-spinner" data-size={size}></div>,
    BiomeCombinedProviders: ({ children }) => <div data-testid="biom3-providers">{children}</div>,
  }));
  ```
- Create detailed mocks for the SDK:
  ```javascript
  const mockProvider = {
    on: jest.fn(),
    removeListener: jest.fn(),
    disconnect: jest.fn(),
    connected: false,
  };
  
  const mockPassportInstance = {
    isAuthenticated: jest.fn(),
    login: jest.fn(),
    loginCallback: jest.fn(),
    logout: jest.fn(),
    provider: mockProvider,
  };
  
  jest.mock('../../../app/utils/setupDefault', () => ({
    passportInstance: mockPassportInstance,
  }));
  ```
- Test event handling functionality thoroughly with all possible scenarios
- Test UI rendering for all event states
- Test all event handling and cleanup
- Explicitly validate that components render without errors
- Use act() for all asynchronous operations
- Aim for >90% code coverage

# Step 5: Implementation Guidelines

## SDK Usage Best Practices
- Use only documented public API methods
- If using internal properties, document with comments and type assertions
- Always implement proper cleanup in useEffect hooks
- Use local type definitions instead of importing non-exported types
- Add robust error handling for all events and operations
- Log important event changes
- Add TypeScript type guards for any SDK properties that might be undefined

## Event Handling Best Practices
- Demonstrate proper event listener setup and cleanup
- Show different types of events (connect, disconnect, chainChanged, etc.)
- Display event data in UI for user feedback
- Include comprehensive error handling
- ALWAYS check if the provider exists before adding event listeners
- Use try/catch blocks around all event handler operations
- Implement robust cleanup of all event listeners in useEffect return functions
- Verify connection state changes are properly tracked and displayed

## UI Best Practices
- Use standard HTML elements (h1, h2, h3, p) for text content, NOT Text component
- Use Biom3 Button and other UI components as documented
- Show clear loading/error states
- Provide user feedback for events
- Keep UI simple and focused on demonstrating the event handling

## Critical Error Prevention
- Always check if objects exist before accessing their properties or methods
- Use optional chaining when accessing potentially undefined properties: obj?.prop?.method?.()
- Wrap all event listener setup and teardown in try/catch blocks
- Test component mounting/unmounting thoroughly to catch cleanup issues

## Common Pitfalls to Avoid
- DO NOT call methods that don't exist on the SDK instances
- DO NOT try to import types that aren't explicitly exported
- DO NOT forget to clean up event listeners, subscriptions, intervals
- DO NOT use custom components or providers unless necessary
- DO NOT modify dependency versions in package.json
- DO NOT use inconsistent import methods (mixing default and named imports)
- DO NOT forget to include 'use client' directive in client components
- DO NOT assume any property or method exists without checking first 