"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/merkletreejs@0.3.11";
exports.ids = ["vendor-chunks/merkletreejs@0.3.11"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/Base.js":
/*!**********************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/Base.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Base = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst crypto_js_1 = __importDefault(__webpack_require__(/*! crypto-js */ \"(ssr)/../../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/index.js\"));\nclass Base {\n    /**\n     * print\n     * @desc Prints out a visual representation of the merkle tree.\n     * @example\n     *```js\n     *tree.print()\n     *```\n     */\n    print() {\n        Base.print(this);\n    }\n    /**\n     * bufferIndexOf\n     * @desc Returns the first index of which given buffer is found in array.\n     * @param {Buffer[]} haystack - Array of buffers.\n     * @param {Buffer} needle - Buffer to find.\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.bufferIndexOf(haystack, needle)\n     *```\n     */\n    bufferIndexOf(array, element, isSorted = false) {\n        if (isSorted) {\n            return this.binarySearch(array, element, buffer_1.Buffer.compare);\n        }\n        const eqChecker = (buffer1, buffer2) => buffer1.equals(buffer2);\n        return this.linearSearch(array, element, eqChecker);\n    }\n    /**\n     * binarySearch\n     * @desc Returns the first index of which given item is found in array using binary search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} compareFunction\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = MerkleTree.binarySearch(array, element, Buffer.compare)\n     *```\n     */\n    static binarySearch(array, element, compareFunction) {\n        let start = 0;\n        let end = array.length - 1;\n        // Iterate while start not meets end\n        while (start <= end) {\n            // Find the mid index\n            const mid = Math.floor((start + end) / 2);\n            // Check if the mid value is greater than, equal to, or less than search element.\n            const ordering = compareFunction(array[mid], element);\n            // If element is present at mid, start iterating for searching first appearance.\n            if (ordering === 0) {\n                // Linear reverse iteration until the first matching item index is found.\n                for (let i = mid - 1; i >= 0; i--) {\n                    if (compareFunction(array[i], element) === 0)\n                        continue;\n                    return i + 1;\n                }\n                return 0;\n            } /* Else look in left or right half accordingly */\n            else if (ordering < 0) {\n                start = mid + 1;\n            }\n            else {\n                end = mid - 1;\n            }\n        }\n        return -1;\n    }\n    /**\n     * binarySearch\n     * @desc Returns the first index of which given item is found in array using binary search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} compareFunction\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.binarySearch(array, element, Buffer.compare)\n     *```\n     */\n    binarySearch(array, element, compareFunction) {\n        return Base.binarySearch(array, element, compareFunction);\n    }\n    /**\n     * linearSearch\n     * @desc Returns the first index of which given item is found in array using linear search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} eqChecker\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = MerkleTree.linearSearch(array, element, (a, b) => a === b)\n     *```\n     */\n    static linearSearch(array, element, eqChecker) {\n        for (let i = 0; i < array.length; i++) {\n            if (eqChecker(array[i], element)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * linearSearch\n     * @desc Returns the first index of which given item is found in array using linear search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} eqChecker\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.linearSearch(array, element, (a, b) => a === b)\n     *```\n     */\n    linearSearch(array, element, eqChecker) {\n        return Base.linearSearch(array, element, eqChecker);\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer|ArrayBuffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = MerkleTree.bufferify('0x1234')\n     *```\n     */\n    static bufferify(value) {\n        if (!buffer_1.Buffer.isBuffer(value)) {\n            // crypto-js support\n            if (typeof value === 'object' && value.words) {\n                return buffer_1.Buffer.from(value.toString(crypto_js_1.default.enc.Hex), 'hex');\n            }\n            else if (Base.isHexString(value)) {\n                return buffer_1.Buffer.from(value.replace(/^0x/, ''), 'hex');\n            }\n            else if (typeof value === 'string') {\n                return buffer_1.Buffer.from(value);\n            }\n            else if (typeof value === 'bigint') {\n                return buffer_1.Buffer.from(value.toString(16), 'hex');\n            }\n            else if (value instanceof Uint8Array) {\n                return buffer_1.Buffer.from(value.buffer);\n            }\n            else if (typeof value === 'number') {\n                let s = value.toString();\n                if (s.length % 2) {\n                    s = `0${s}`;\n                }\n                return buffer_1.Buffer.from(s, 'hex');\n            }\n            else if (ArrayBuffer.isView(value)) {\n                return buffer_1.Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n            }\n        }\n        return value;\n    }\n    bigNumberify(value) {\n        return Base.bigNumberify(value);\n    }\n    static bigNumberify(value) {\n        if (typeof value === 'bigint') {\n            return value;\n        }\n        if (typeof value === 'string') {\n            if (value.startsWith('0x') && Base.isHexString(value)) {\n                return BigInt('0x' + value.replace('0x', '').toString());\n            }\n            return BigInt(value);\n        }\n        if (buffer_1.Buffer.isBuffer(value)) {\n            return BigInt('0x' + value.toString('hex'));\n        }\n        if (value instanceof Uint8Array) {\n            return BigInt(value);\n        }\n        if (typeof value === 'number') {\n            return BigInt(value);\n        }\n        throw new Error('cannot bigNumberify');\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n    static isHexString(v) {\n        return typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n    }\n    /**\n     * print\n     * @desc Prints out a visual representation of the given merkle tree.\n     * @param {Object} tree - Merkle tree instance.\n     * @return {String}\n     * @example\n     *```js\n     *MerkleTree.print(tree)\n     *```\n     */\n    static print(tree) {\n        console.log(tree.toString());\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = tree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n    bufferToHex(value, withPrefix = true) {\n        return Base.bufferToHex(value, withPrefix);\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n    static bufferToHex(value, withPrefix = true) {\n        return `${withPrefix ? '0x' : ''}${(value || buffer_1.Buffer.alloc(0)).toString('hex')}`;\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = tree.bufferify('0x1234')\n     *```\n     */\n    bufferify(value) {\n        return Base.bufferify(value);\n    }\n    /**\n     * bufferifyFn\n     * @desc Returns a function that will bufferify the return value.\n     * @param {Function}\n     * @return {Function}\n     *\n     * @example\n     * ```js\n     *const fn = tree.bufferifyFn((value) => sha256(value))\n     *```\n     */\n    bufferifyFn(f) {\n        return (value) => {\n            const v = f(value);\n            if (buffer_1.Buffer.isBuffer(v)) {\n                return v;\n            }\n            if (this.isHexString(v)) {\n                return buffer_1.Buffer.from(v.replace('0x', ''), 'hex');\n            }\n            if (typeof v === 'string') {\n                return buffer_1.Buffer.from(v);\n            }\n            if (typeof v === 'bigint') {\n                return buffer_1.Buffer.from(value.toString(16), 'hex');\n            }\n            if (ArrayBuffer.isView(v)) {\n                return buffer_1.Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n            }\n            // crypto-js support\n            return buffer_1.Buffer.from(f(crypto_js_1.default.enc.Hex.parse(value.toString('hex'))).toString(crypto_js_1.default.enc.Hex), 'hex');\n        };\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n    isHexString(value) {\n        return Base.isHexString(value);\n    }\n    /**\n     * log2\n     * @desc Returns the log2 of number.\n     * @param {Number} value\n     * @return {Number}\n     */\n    log2(n) {\n        return n === 1 ? 0 : 1 + this.log2((n / 2) | 0);\n    }\n    /**\n     * zip\n     * @desc Returns true if value is a hex string.\n     * @param {String[]|Number[]|Buffer[]} a - first array\n     * @param {String[]|Number[]|Buffer[]} b -  second array\n     * @return {String[][]|Number[][]|Buffer[][]}\n     *\n     * @example\n     * ```js\n     *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n     *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n     *```\n     */\n    zip(a, b) {\n        return a.map((e, i) => [e, b[i]]);\n    }\n    static hexZeroPad(hexStr, length) {\n        return '0x' + hexStr.replace('0x', '').padStart(length, '0');\n    }\n}\nexports.Base = Base;\nexports[\"default\"] = Base;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21lcmtsZXRyZWVqc0AwLjMuMTEvbm9kZV9tb2R1bGVzL21lcmtsZXRyZWVqcy9kaXN0L0Jhc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsb0NBQW9DLG1CQUFPLENBQUMsb0dBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUNBQXlDO0FBQ3hELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsRUFBRTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QixFQUFFLG9EQUFvRDtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkJBQTZCO0FBQzVDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0MsZUFBZSw0QkFBNEI7QUFDM0MsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZXhhbXBsZXMvbG9naW4td2l0aC1wYXNzcG9ydC1zaWxlbnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21lcmtsZXRyZWVqc0AwLjMuMTEvbm9kZV9tb2R1bGVzL21lcmtsZXRyZWVqcy9kaXN0L0Jhc2UuanM/NmUyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZSA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbmNvbnN0IGNyeXB0b19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjcnlwdG8tanNcIikpO1xuY2xhc3MgQmFzZSB7XG4gICAgLyoqXG4gICAgICogcHJpbnRcbiAgICAgKiBAZGVzYyBQcmludHMgb3V0IGEgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXJrbGUgdHJlZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKnRyZWUucHJpbnQoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgcHJpbnQoKSB7XG4gICAgICAgIEJhc2UucHJpbnQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJ1ZmZlckluZGV4T2ZcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvZiB3aGljaCBnaXZlbiBidWZmZXIgaXMgZm91bmQgaW4gYXJyYXkuXG4gICAgICogQHBhcmFtIHtCdWZmZXJbXX0gaGF5c3RhY2sgLSBBcnJheSBvZiBidWZmZXJzLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBuZWVkbGUgLSBCdWZmZXIgdG8gZmluZC5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gSW5kZXggbnVtYmVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBpbmRleCA9IHRyZWUuYnVmZmVySW5kZXhPZihoYXlzdGFjaywgbmVlZGxlKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgYnVmZmVySW5kZXhPZihhcnJheSwgZWxlbWVudCwgaXNTb3J0ZWQgPSBmYWxzZSkge1xuICAgICAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVNlYXJjaChhcnJheSwgZWxlbWVudCwgYnVmZmVyXzEuQnVmZmVyLmNvbXBhcmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVxQ2hlY2tlciA9IChidWZmZXIxLCBidWZmZXIyKSA9PiBidWZmZXIxLmVxdWFscyhidWZmZXIyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZWFyU2VhcmNoKGFycmF5LCBlbGVtZW50LCBlcUNoZWNrZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBiaW5hcnlTZWFyY2hcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvZiB3aGljaCBnaXZlbiBpdGVtIGlzIGZvdW5kIGluIGFycmF5IHVzaW5nIGJpbmFyeSBzZWFyY2guXG4gICAgICogQHBhcmFtIHtCdWZmZXJbXX0gYXJyYXkgLSBBcnJheSBvZiBpdGVtcy5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gZWxlbWVudCAtIEl0ZW0gdG8gZmluZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlRnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gSW5kZXggbnVtYmVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBpbmRleCA9IE1lcmtsZVRyZWUuYmluYXJ5U2VhcmNoKGFycmF5LCBlbGVtZW50LCBCdWZmZXIuY29tcGFyZSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBiaW5hcnlTZWFyY2goYXJyYXksIGVsZW1lbnQsIGNvbXBhcmVGdW5jdGlvbikge1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICAgICAgLy8gSXRlcmF0ZSB3aGlsZSBzdGFydCBub3QgbWVldHMgZW5kXG4gICAgICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1pZCBpbmRleFxuICAgICAgICAgICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbWlkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiwgZXF1YWwgdG8sIG9yIGxlc3MgdGhhbiBzZWFyY2ggZWxlbWVudC5cbiAgICAgICAgICAgIGNvbnN0IG9yZGVyaW5nID0gY29tcGFyZUZ1bmN0aW9uKGFycmF5W21pZF0sIGVsZW1lbnQpO1xuICAgICAgICAgICAgLy8gSWYgZWxlbWVudCBpcyBwcmVzZW50IGF0IG1pZCwgc3RhcnQgaXRlcmF0aW5nIGZvciBzZWFyY2hpbmcgZmlyc3QgYXBwZWFyYW5jZS5cbiAgICAgICAgICAgIGlmIChvcmRlcmluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIExpbmVhciByZXZlcnNlIGl0ZXJhdGlvbiB1bnRpbCB0aGUgZmlyc3QgbWF0Y2hpbmcgaXRlbSBpbmRleCBpcyBmb3VuZC5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWlkIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVGdW5jdGlvbihhcnJheVtpXSwgZWxlbWVudCkgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0gLyogRWxzZSBsb29rIGluIGxlZnQgb3IgcmlnaHQgaGFsZiBhY2NvcmRpbmdseSAqL1xuICAgICAgICAgICAgZWxzZSBpZiAob3JkZXJpbmcgPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJpbmFyeVNlYXJjaFxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9mIHdoaWNoIGdpdmVuIGl0ZW0gaXMgZm91bmQgaW4gYXJyYXkgdXNpbmcgYmluYXJ5IHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBhcnJheSAtIEFycmF5IG9mIGl0ZW1zLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBlbGVtZW50IC0gSXRlbSB0byBmaW5kLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVGdW5jdGlvblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gLSBJbmRleCBudW1iZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IGluZGV4ID0gdHJlZS5iaW5hcnlTZWFyY2goYXJyYXksIGVsZW1lbnQsIEJ1ZmZlci5jb21wYXJlKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgYmluYXJ5U2VhcmNoKGFycmF5LCBlbGVtZW50LCBjb21wYXJlRnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIEJhc2UuYmluYXJ5U2VhcmNoKGFycmF5LCBlbGVtZW50LCBjb21wYXJlRnVuY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBsaW5lYXJTZWFyY2hcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvZiB3aGljaCBnaXZlbiBpdGVtIGlzIGZvdW5kIGluIGFycmF5IHVzaW5nIGxpbmVhciBzZWFyY2guXG4gICAgICogQHBhcmFtIHtCdWZmZXJbXX0gYXJyYXkgLSBBcnJheSBvZiBpdGVtcy5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gZWxlbWVudCAtIEl0ZW0gdG8gZmluZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcUNoZWNrZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gSW5kZXggbnVtYmVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBpbmRleCA9IE1lcmtsZVRyZWUubGluZWFyU2VhcmNoKGFycmF5LCBlbGVtZW50LCAoYSwgYikgPT4gYSA9PT0gYilcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBsaW5lYXJTZWFyY2goYXJyYXksIGVsZW1lbnQsIGVxQ2hlY2tlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZXFDaGVja2VyKGFycmF5W2ldLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbGluZWFyU2VhcmNoXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb2Ygd2hpY2ggZ2l2ZW4gaXRlbSBpcyBmb3VuZCBpbiBhcnJheSB1c2luZyBsaW5lYXIgc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyW119IGFycmF5IC0gQXJyYXkgb2YgaXRlbXMuXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGVsZW1lbnQgLSBJdGVtIHRvIGZpbmQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXFDaGVja2VyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIEluZGV4IG51bWJlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgaW5kZXggPSB0cmVlLmxpbmVhclNlYXJjaChhcnJheSwgZWxlbWVudCwgKGEsIGIpID0+IGEgPT09IGIpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBsaW5lYXJTZWFyY2goYXJyYXksIGVsZW1lbnQsIGVxQ2hlY2tlcikge1xuICAgICAgICByZXR1cm4gQmFzZS5saW5lYXJTZWFyY2goYXJyYXksIGVsZW1lbnQsIGVxQ2hlY2tlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGJ1ZmZlcmlmeVxuICAgICAqIEBkZXNjIFJldHVybnMgYSBidWZmZXIgdHlwZSBmb3IgdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxPYmplY3R8QnVmZmVyfEFycmF5QnVmZmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IGJ1ZiA9IE1lcmtsZVRyZWUuYnVmZmVyaWZ5KCcweDEyMzQnKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgc3RhdGljIGJ1ZmZlcmlmeSh2YWx1ZSkge1xuICAgICAgICBpZiAoIWJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGNyeXB0by1qcyBzdXBwb3J0XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS53b3Jkcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbSh2YWx1ZS50b1N0cmluZyhjcnlwdG9fanNfMS5kZWZhdWx0LmVuYy5IZXgpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChCYXNlLmlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbSh2YWx1ZS5yZXBsYWNlKC9eMHgvLCAnJyksICdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbSh2YWx1ZS50b1N0cmluZygxNiksICdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbSh2YWx1ZS5idWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGxldCBzID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBgMCR7c31gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20ocywgJ2hleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbSh2YWx1ZS5idWZmZXIsIHZhbHVlLmJ5dGVPZmZzZXQsIHZhbHVlLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgYmlnTnVtYmVyaWZ5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBCYXNlLmJpZ051bWJlcmlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBiaWdOdW1iZXJpZnkodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJzB4JykgJiYgQmFzZS5pc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KCcweCcgKyB2YWx1ZS5yZXBsYWNlKCcweCcsICcnKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KCcweCcgKyB2YWx1ZS50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBiaWdOdW1iZXJpZnknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaXNIZXhTdHJpbmdcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBoZXggc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zb2xlLmxvZyhNZXJrbGVUcmVlLmlzSGV4U3RyaW5nKCcweDEyMzQnKSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBpc0hleFN0cmluZyh2KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgL14oMHgpP1swLTlBLUZhLWZdKiQvLnRlc3Qodik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHByaW50XG4gICAgICogQGRlc2MgUHJpbnRzIG91dCBhIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gbWVya2xlIHRyZWUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyZWUgLSBNZXJrbGUgdHJlZSBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpNZXJrbGVUcmVlLnByaW50KHRyZWUpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgcHJpbnQodHJlZSkge1xuICAgICAgICBjb25zb2xlLmxvZyh0cmVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBidWZmZXJUb0hleFxuICAgICAqIEBkZXNjIFJldHVybnMgYSBoZXggc3RyaW5nIHdpdGggMHggcHJlZml4IGZvciBnaXZlbiBidWZmZXIuXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgaGV4U3RyID0gdHJlZS5idWZmZXJUb0hleChCdWZmZXIuZnJvbSgnQScpKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgYnVmZmVyVG9IZXgodmFsdWUsIHdpdGhQcmVmaXggPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBCYXNlLmJ1ZmZlclRvSGV4KHZhbHVlLCB3aXRoUHJlZml4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYnVmZmVyVG9IZXhcbiAgICAgKiBAZGVzYyBSZXR1cm5zIGEgaGV4IHN0cmluZyB3aXRoIDB4IHByZWZpeCBmb3IgZ2l2ZW4gYnVmZmVyLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGhleFN0ciA9IE1lcmtsZVRyZWUuYnVmZmVyVG9IZXgoQnVmZmVyLmZyb20oJ0EnKSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBidWZmZXJUb0hleCh2YWx1ZSwgd2l0aFByZWZpeCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGAke3dpdGhQcmVmaXggPyAnMHgnIDogJyd9JHsodmFsdWUgfHwgYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDApKS50b1N0cmluZygnaGV4Jyl9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYnVmZmVyaWZ5XG4gICAgICogQGRlc2MgUmV0dXJucyBhIGJ1ZmZlciB0eXBlIGZvciB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfE9iamVjdHxCdWZmZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7QnVmZmVyfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgYnVmID0gdHJlZS5idWZmZXJpZnkoJzB4MTIzNCcpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBidWZmZXJpZnkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEJhc2UuYnVmZmVyaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYnVmZmVyaWZ5Rm5cbiAgICAgKiBAZGVzYyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJ1ZmZlcmlmeSB0aGUgcmV0dXJuIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBmbiA9IHRyZWUuYnVmZmVyaWZ5Rm4oKHZhbHVlKSA9PiBzaGEyNTYodmFsdWUpKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgYnVmZmVyaWZ5Rm4oZikge1xuICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2ID0gZih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0hleFN0cmluZyh2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbSh2LnJlcGxhY2UoJzB4JywgJycpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbSh2YWx1ZS50b1N0cmluZygxNiksICdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20odi5idWZmZXIsIHYuYnl0ZU9mZnNldCwgdi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNyeXB0by1qcyBzdXBwb3J0XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20oZihjcnlwdG9fanNfMS5kZWZhdWx0LmVuYy5IZXgucGFyc2UodmFsdWUudG9TdHJpbmcoJ2hleCcpKSkudG9TdHJpbmcoY3J5cHRvX2pzXzEuZGVmYXVsdC5lbmMuSGV4KSwgJ2hleCcpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBpc0hleFN0cmluZ1xuICAgICAqIEBkZXNjIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGhleCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnNvbGUubG9nKE1lcmtsZVRyZWUuaXNIZXhTdHJpbmcoJzB4MTIzNCcpKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgaXNIZXhTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEJhc2UuaXNIZXhTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBsb2cyXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgbG9nMiBvZiBudW1iZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGxvZzIobikge1xuICAgICAgICByZXR1cm4gbiA9PT0gMSA/IDAgOiAxICsgdGhpcy5sb2cyKChuIC8gMikgfCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogemlwXG4gICAgICogQGRlc2MgUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgaGV4IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfE51bWJlcltdfEJ1ZmZlcltdfSBhIC0gZmlyc3QgYXJyYXlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfE51bWJlcltdfEJ1ZmZlcltdfSBiIC0gIHNlY29uZCBhcnJheVxuICAgICAqIEByZXR1cm4ge1N0cmluZ1tdW118TnVtYmVyW11bXXxCdWZmZXJbXVtdfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgemlwcGVkID0gdHJlZS56aXAoWydhJywgJ2InXSxbJ0EnLCAnQiddKVxuICAgICAqY29uc29sZS5sb2coemlwcGVkKSAvLyBbIFsgJ2EnLCAnQScgXSwgWyAnYicsICdCJyBdIF1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHppcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm1hcCgoZSwgaSkgPT4gW2UsIGJbaV1dKTtcbiAgICB9XG4gICAgc3RhdGljIGhleFplcm9QYWQoaGV4U3RyLCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyBoZXhTdHIucmVwbGFjZSgnMHgnLCAnJykucGFkU3RhcnQobGVuZ3RoLCAnMCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZSA9IEJhc2U7XG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/Base.js\n");

/***/ }),

/***/ "(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/IncrementalMerkleTree.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/IncrementalMerkleTree.js ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IncrementalMerkleTree = void 0;\nconst Base_1 = __importDefault(__webpack_require__(/*! ./Base */ \"(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/Base.js\"));\nconst treeify_1 = __importDefault(__webpack_require__(/*! treeify */ \"(ssr)/../../../node_modules/.pnpm/treeify@1.1.0/node_modules/treeify/treeify.js\"));\nclass IncrementalMerkleTree extends Base_1.default {\n    constructor(hashFn, options) {\n        super();\n        this.hashFn = hashFn;\n        if (options.depth) {\n            this.depth = options.depth;\n        }\n        if (options.arity) {\n            this.arity = options.arity;\n        }\n        if (this.depth < 1) {\n            throw new Error('depth must be greater than 0');\n        }\n        if (this.arity < 1) {\n            throw new Error('arity must be greater than 0');\n        }\n        const nodes = [];\n        let zeroValue = options.zeroValue;\n        this.zeroValue = zeroValue;\n        this.zeroes = [];\n        if (this.depth) {\n            for (let i = 0; i < this.depth; i++) {\n                this.zeroes.push(zeroValue);\n                nodes[i] = [];\n                zeroValue = this.hashFn(Array(this.arity).fill(zeroValue));\n            }\n        }\n        this.nodes = nodes;\n        this.root = zeroValue;\n    }\n    getRoot() {\n        return this.root;\n    }\n    getHexRoot() {\n        return this.bufferToHex(this.bufferify(this.getRoot()));\n    }\n    insert(leaf) {\n        if (this.depth && this.arity) {\n            if (this.nodes[0].length >= this.getMaxLeaves()) {\n                throw new Error('tree is full');\n            }\n        }\n        let node = leaf;\n        let index = this.nodes[0].length;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            this.nodes[level][index] = node;\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i < this.nodes[level].length) {\n                    children.push(this.nodes[level][i]);\n                }\n                else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this.hashFn(children);\n            index = Math.floor(index / this.arity);\n        }\n        this.root = node;\n    }\n    delete(index) {\n        this.update(index, this.zeroValue);\n    }\n    update(index, newLeaf) {\n        if (index < 0 || index >= this.nodes[0].length) {\n            throw new Error('out of bounds');\n        }\n        let node = newLeaf;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            this.nodes[level][index] = node;\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i < this.nodes[level].length) {\n                    children.push(this.nodes[level][i]);\n                }\n                else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this.hashFn(children);\n            index = Math.floor(index / this.arity);\n        }\n        this.root = node;\n    }\n    getDepth() {\n        return this.depth;\n    }\n    getArity() {\n        return this.arity;\n    }\n    getMaxLeaves() {\n        return Math.pow(this.depth, this.arity);\n    }\n    indexOf(leaf) {\n        return this.nodes[0].indexOf(leaf);\n    }\n    getLeaves() {\n        const leaves = this.copyList(this.nodes[0]);\n        const index = this.nodes[0].length;\n        for (let i = index; i < this.getMaxLeaves(); i++) {\n            leaves[i] = this.zeroValue;\n        }\n        return leaves;\n    }\n    copyList(list) {\n        return list.map((x) => BigInt(x));\n    }\n    getLayers() {\n        const layers = [];\n        for (const list of this.nodes) {\n            layers.push(this.copyList(list));\n        }\n        if (layers[0].length < this.getMaxLeaves()) {\n            let index = layers[0].length;\n            for (let i = index; i < this.getMaxLeaves(); i++) {\n                layers[0][i] = this.zeroValue;\n            }\n            for (let level = 0; level < this.depth; level++) {\n                const position = index % this.arity;\n                const levelStartIndex = index - position;\n                const levelEndIndex = levelStartIndex + this.arity;\n                for (let i = levelStartIndex; i < levelEndIndex; i++) {\n                    if (i >= layers[level].length) {\n                        layers[level][i] = this.zeroes[level];\n                    }\n                }\n                index = Math.floor(index / this.arity);\n            }\n        }\n        layers.push([this.root]);\n        return layers;\n    }\n    getHexLayers() {\n        return this.getLayers().reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.push(item.map(layer => this.bufferToHex(this.bufferify(layer))));\n            }\n            else {\n                acc.push(item);\n            }\n            return acc;\n        }, []);\n    }\n    getLayersAsObject() {\n        const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(this.bufferify(value), false)));\n        const objs = [];\n        for (let i = 0; i < layers.length; i++) {\n            const arr = [];\n            for (let j = 0; j < layers[i].length; j++) {\n                const obj = { [layers[i][j]]: null };\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    const a = objs.shift();\n                    const akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        const b = objs.shift();\n                        const bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push(...arr);\n        }\n        return objs[0];\n    }\n    computeRoot() {\n        let node;\n        let index = this.nodes[0].length;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            const children = [];\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i < this.nodes[level].length) {\n                    children.push(this.nodes[level][i]);\n                }\n                else {\n                    children.push(this.zeroes[level]);\n                }\n            }\n            node = this.hashFn(children);\n            index = Math.floor(index / this.arity);\n        }\n        return node;\n    }\n    getProof(index) {\n        if (index < 0 || index >= this.nodes[0].length) {\n            throw new Error('The leaf does not exist in this tree');\n        }\n        const siblings = [];\n        const pathIndices = [];\n        const leafIndex = index;\n        for (let level = 0; level < this.depth; level += 1) {\n            const position = index % this.arity;\n            const levelStartIndex = index - position;\n            const levelEndIndex = levelStartIndex + this.arity;\n            pathIndices[level] = position;\n            siblings[level] = [];\n            for (let i = levelStartIndex; i < levelEndIndex; i += 1) {\n                if (i !== index) {\n                    if (i < this.nodes[level].length) {\n                        siblings[level].push(this.nodes[level][i]);\n                    }\n                    else {\n                        siblings[level].push(this.zeroes[level]);\n                    }\n                }\n            }\n            index = Math.floor(index / this.arity);\n        }\n        return { root: this.root, leaf: this.nodes[0][leafIndex], pathIndices, siblings };\n    }\n    verify(proof) {\n        let node = proof.leaf;\n        for (let i = 0; i < proof.siblings.length; i += 1) {\n            const children = proof.siblings[i].slice();\n            children.splice(proof.pathIndices[i], 0, node);\n            node = this.hashFn(children);\n        }\n        return proof.root === node;\n    }\n    toString() {\n        return this.toTreeString();\n    }\n    toTreeString() {\n        const obj = this.getLayersAsObject();\n        return treeify_1.default.asTree(obj, true);\n    }\n}\nexports.IncrementalMerkleTree = IncrementalMerkleTree;\nif (typeof window !== 'undefined') {\n    ;\n    window.IncrementalMerkleTree = IncrementalMerkleTree;\n}\nexports[\"default\"] = IncrementalMerkleTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21lcmtsZXRyZWVqc0AwLjMuMTEvbm9kZV9tb2R1bGVzL21lcmtsZXRyZWVqcy9kaXN0L0luY3JlbWVudGFsTWVya2xlVHJlZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QiwrQkFBK0IsbUJBQU8sQ0FBQyw0R0FBUTtBQUMvQyxrQ0FBa0MsbUJBQU8sQ0FBQyxnR0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxtQkFBbUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGV4YW1wbGVzL2xvZ2luLXdpdGgtcGFzc3BvcnQtc2lsZW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tZXJrbGV0cmVlanNAMC4zLjExL25vZGVfbW9kdWxlcy9tZXJrbGV0cmVlanMvZGlzdC9JbmNyZW1lbnRhbE1lcmtsZVRyZWUuanM/OTU2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5jcmVtZW50YWxNZXJrbGVUcmVlID0gdm9pZCAwO1xuY29uc3QgQmFzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0Jhc2VcIikpO1xuY29uc3QgdHJlZWlmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0cmVlaWZ5XCIpKTtcbmNsYXNzIEluY3JlbWVudGFsTWVya2xlVHJlZSBleHRlbmRzIEJhc2VfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoRm4sIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oYXNoRm4gPSBoYXNoRm47XG4gICAgICAgIGlmIChvcHRpb25zLmRlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLmRlcHRoID0gb3B0aW9ucy5kZXB0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hcml0eSkge1xuICAgICAgICAgICAgdGhpcy5hcml0eSA9IG9wdGlvbnMuYXJpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVwdGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlcHRoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcml0eSA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICAgIGxldCB6ZXJvVmFsdWUgPSBvcHRpb25zLnplcm9WYWx1ZTtcbiAgICAgICAgdGhpcy56ZXJvVmFsdWUgPSB6ZXJvVmFsdWU7XG4gICAgICAgIHRoaXMuemVyb2VzID0gW107XG4gICAgICAgIGlmICh0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGVwdGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuemVyb2VzLnB1c2goemVyb1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgIHplcm9WYWx1ZSA9IHRoaXMuaGFzaEZuKEFycmF5KHRoaXMuYXJpdHkpLmZpbGwoemVyb1ZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgICB0aGlzLnJvb3QgPSB6ZXJvVmFsdWU7XG4gICAgfVxuICAgIGdldFJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gICAgfVxuICAgIGdldEhleFJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclRvSGV4KHRoaXMuYnVmZmVyaWZ5KHRoaXMuZ2V0Um9vdCgpKSk7XG4gICAgfVxuICAgIGluc2VydChsZWFmKSB7XG4gICAgICAgIGlmICh0aGlzLmRlcHRoICYmIHRoaXMuYXJpdHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzWzBdLmxlbmd0aCA+PSB0aGlzLmdldE1heExlYXZlcygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmVlIGlzIGZ1bGwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZSA9IGxlYWY7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubm9kZXNbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGhpcy5kZXB0aDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBpbmRleCAlIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICBjb25zdCBsZXZlbFN0YXJ0SW5kZXggPSBpbmRleCAtIHBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxFbmRJbmRleCA9IGxldmVsU3RhcnRJbmRleCArIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1tsZXZlbF1baW5kZXhdID0gbm9kZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZXZlbFN0YXJ0SW5kZXg7IGkgPCBsZXZlbEVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IHRoaXMubm9kZXNbbGV2ZWxdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMubm9kZXNbbGV2ZWxdW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy56ZXJvZXNbbGV2ZWxdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gdGhpcy5oYXNoRm4oY2hpbGRyZW4pO1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5hcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290ID0gbm9kZTtcbiAgICB9XG4gICAgZGVsZXRlKGluZGV4KSB7XG4gICAgICAgIHRoaXMudXBkYXRlKGluZGV4LCB0aGlzLnplcm9WYWx1ZSk7XG4gICAgfVxuICAgIHVwZGF0ZShpbmRleCwgbmV3TGVhZikge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubm9kZXNbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dCBvZiBib3VuZHMnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZSA9IG5ld0xlYWY7XG4gICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCB0aGlzLmRlcHRoOyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGluZGV4ICUgdGhpcy5hcml0eTtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsU3RhcnRJbmRleCA9IGluZGV4IC0gcG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCBsZXZlbEVuZEluZGV4ID0gbGV2ZWxTdGFydEluZGV4ICsgdGhpcy5hcml0eTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2xldmVsXVtpbmRleF0gPSBub2RlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxldmVsU3RhcnRJbmRleDsgaSA8IGxldmVsRW5kSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgdGhpcy5ub2Rlc1tsZXZlbF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5ub2Rlc1tsZXZlbF1baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLnplcm9lc1tsZXZlbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmhhc2hGbihjaGlsZHJlbik7XG4gICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLmFyaXR5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvb3QgPSBub2RlO1xuICAgIH1cbiAgICBnZXREZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGg7XG4gICAgfVxuICAgIGdldEFyaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcml0eTtcbiAgICB9XG4gICAgZ2V0TWF4TGVhdmVzKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3codGhpcy5kZXB0aCwgdGhpcy5hcml0eSk7XG4gICAgfVxuICAgIGluZGV4T2YobGVhZikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXS5pbmRleE9mKGxlYWYpO1xuICAgIH1cbiAgICBnZXRMZWF2ZXMoKSB7XG4gICAgICAgIGNvbnN0IGxlYXZlcyA9IHRoaXMuY29weUxpc3QodGhpcy5ub2Rlc1swXSk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5ub2Rlc1swXS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IHRoaXMuZ2V0TWF4TGVhdmVzKCk7IGkrKykge1xuICAgICAgICAgICAgbGVhdmVzW2ldID0gdGhpcy56ZXJvVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlYXZlcztcbiAgICB9XG4gICAgY29weUxpc3QobGlzdCkge1xuICAgICAgICByZXR1cm4gbGlzdC5tYXAoKHgpID0+IEJpZ0ludCh4KSk7XG4gICAgfVxuICAgIGdldExheWVycygpIHtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbGlzdCBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBsYXllcnMucHVzaCh0aGlzLmNvcHlMaXN0KGxpc3QpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5ZXJzWzBdLmxlbmd0aCA8IHRoaXMuZ2V0TWF4TGVhdmVzKCkpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGxheWVyc1swXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCB0aGlzLmdldE1heExlYXZlcygpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsYXllcnNbMF1baV0gPSB0aGlzLnplcm9WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCB0aGlzLmRlcHRoOyBsZXZlbCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBpbmRleCAlIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGV2ZWxTdGFydEluZGV4ID0gaW5kZXggLSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBsZXZlbEVuZEluZGV4ID0gbGV2ZWxTdGFydEluZGV4ICsgdGhpcy5hcml0eTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbGV2ZWxTdGFydEluZGV4OyBpIDwgbGV2ZWxFbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID49IGxheWVyc1tsZXZlbF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcnNbbGV2ZWxdW2ldID0gdGhpcy56ZXJvZXNbbGV2ZWxdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuYXJpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxheWVycy5wdXNoKFt0aGlzLnJvb3RdKTtcbiAgICAgICAgcmV0dXJuIGxheWVycztcbiAgICB9XG4gICAgZ2V0SGV4TGF5ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcnMoKS5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBhY2MucHVzaChpdGVtLm1hcChsYXllciA9PiB0aGlzLmJ1ZmZlclRvSGV4KHRoaXMuYnVmZmVyaWZ5KGxheWVyKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICBnZXRMYXllcnNBc09iamVjdCgpIHtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0gdGhpcy5nZXRMYXllcnMoKS5tYXAoKGxheWVyKSA9PiBsYXllci5tYXAoKHZhbHVlKSA9PiB0aGlzLmJ1ZmZlclRvSGV4KHRoaXMuYnVmZmVyaWZ5KHZhbHVlKSwgZmFsc2UpKSk7XG4gICAgICAgIGNvbnN0IG9ianMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsYXllcnNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB7IFtsYXllcnNbaV1bal1dOiBudWxsIH07XG4gICAgICAgICAgICAgICAgaWYgKG9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtsYXllcnNbaV1bal1dID0ge307XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBvYmpzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFrZXkgPSBPYmplY3Qua2V5cyhhKVswXTtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2xheWVyc1tpXVtqXV1bYWtleV0gPSBhW2FrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBvYmpzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBia2V5ID0gT2JqZWN0LmtleXMoYilbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbbGF5ZXJzW2ldW2pdXVtia2V5XSA9IGJbYmtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyLnB1c2gob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ianMucHVzaCguLi5hcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmpzWzBdO1xuICAgIH1cbiAgICBjb21wdXRlUm9vdCgpIHtcbiAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubm9kZXNbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGhpcy5kZXB0aDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBpbmRleCAlIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICBjb25zdCBsZXZlbFN0YXJ0SW5kZXggPSBpbmRleCAtIHBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxFbmRJbmRleCA9IGxldmVsU3RhcnRJbmRleCArIHRoaXMuYXJpdHk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxldmVsU3RhcnRJbmRleDsgaSA8IGxldmVsRW5kSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgdGhpcy5ub2Rlc1tsZXZlbF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5ub2Rlc1tsZXZlbF1baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLnplcm9lc1tsZXZlbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmhhc2hGbihjaGlsZHJlbik7XG4gICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLmFyaXR5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZ2V0UHJvb2YoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLm5vZGVzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbGVhZiBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIHRyZWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IFtdO1xuICAgICAgICBjb25zdCBwYXRoSW5kaWNlcyA9IFtdO1xuICAgICAgICBjb25zdCBsZWFmSW5kZXggPSBpbmRleDtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggJSB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxTdGFydEluZGV4ID0gaW5kZXggLSBwb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsRW5kSW5kZXggPSBsZXZlbFN0YXJ0SW5kZXggKyB0aGlzLmFyaXR5O1xuICAgICAgICAgICAgcGF0aEluZGljZXNbbGV2ZWxdID0gcG9zaXRpb247XG4gICAgICAgICAgICBzaWJsaW5nc1tsZXZlbF0gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZXZlbFN0YXJ0SW5kZXg7IGkgPCBsZXZlbEVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCB0aGlzLm5vZGVzW2xldmVsXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzW2xldmVsXS5wdXNoKHRoaXMubm9kZXNbbGV2ZWxdW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzW2xldmVsXS5wdXNoKHRoaXMuemVyb2VzW2xldmVsXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLmFyaXR5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByb290OiB0aGlzLnJvb3QsIGxlYWY6IHRoaXMubm9kZXNbMF1bbGVhZkluZGV4XSwgcGF0aEluZGljZXMsIHNpYmxpbmdzIH07XG4gICAgfVxuICAgIHZlcmlmeShwcm9vZikge1xuICAgICAgICBsZXQgbm9kZSA9IHByb29mLmxlYWY7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvb2Yuc2libGluZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcHJvb2Yuc2libGluZ3NbaV0uc2xpY2UoKTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShwcm9vZi5wYXRoSW5kaWNlc1tpXSwgMCwgbm9kZSk7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5oYXNoRm4oY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9vZi5yb290ID09PSBub2RlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9UcmVlU3RyaW5nKCk7XG4gICAgfVxuICAgIHRvVHJlZVN0cmluZygpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5nZXRMYXllcnNBc09iamVjdCgpO1xuICAgICAgICByZXR1cm4gdHJlZWlmeV8xLmRlZmF1bHQuYXNUcmVlKG9iaiwgdHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbmNyZW1lbnRhbE1lcmtsZVRyZWUgPSBJbmNyZW1lbnRhbE1lcmtsZVRyZWU7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICA7XG4gICAgd2luZG93LkluY3JlbWVudGFsTWVya2xlVHJlZSA9IEluY3JlbWVudGFsTWVya2xlVHJlZTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEluY3JlbWVudGFsTWVya2xlVHJlZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/IncrementalMerkleTree.js\n");

/***/ }),

/***/ "(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/MerkleMountainRange.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/MerkleMountainRange.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MerkleMountainRange = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst sha256_1 = __importDefault(__webpack_require__(/*! crypto-js/sha256 */ \"(ssr)/../../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha256.js\"));\nconst Base_1 = __importDefault(__webpack_require__(/*! ./Base */ \"(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/Base.js\"));\n// @credit: https://github.com/wanseob/solidity-mmr\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\nclass MerkleMountainRange extends Base_1.default {\n    constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {\n        super();\n        this.root = buffer_1.Buffer.alloc(0);\n        this.size = 0;\n        this.width = 0;\n        this.hashes = {};\n        this.data = {};\n        leaves = leaves.map(this.bufferify);\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.hashLeafFn = hashLeafFn;\n        this.peakBaggingFn = peakBaggingFn;\n        this.hashBranchFn = hashBranchFn;\n        for (const leaf of leaves) {\n            this.append(leaf);\n        }\n    }\n    /**\n     * @desc This only stores the hashed value of the leaf.\n     * If you need to retrieve the detail data later, use a map to store them.\n     */\n    append(data) {\n        data = this.bufferify(data);\n        const dataHash = this.hashFn(data);\n        const dataHashHex = this.bufferToHex(dataHash);\n        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n            this.data[dataHashHex] = data;\n        }\n        const leaf = this.hashLeaf(this.size + 1, dataHash);\n        this.hashes[this.size + 1] = leaf;\n        this.width += 1;\n        // find peaks for enlarged tree\n        const peakIndexes = this.getPeakIndexes(this.width);\n        // the right most peak's value is the new size of the updated tree\n        this.size = this.getSize(this.width);\n        // starting from the left-most peak, get all peak hashes\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n        }\n        // update the tree root hash\n        this.root = this.peakBagging(this.width, peaks);\n    }\n    /**\n     * @desc It returns the hash of a leaf node with hash(M | DATA )\n     *       M is the index of the node.\n     */\n    hashLeaf(index, dataHash) {\n        dataHash = this.bufferify(dataHash);\n        if (this.hashLeafFn) {\n            return this.bufferify(this.hashLeafFn(index, dataHash));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));\n    }\n    /**\n     * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n     *       M is the index of the node.\n     */\n    hashBranch(index, left, right) {\n        if (this.hashBranchFn) {\n            return this.bufferify(this.hashBranchFn(index, left, right));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n    }\n    getPeaks() {\n        const peakIndexes = this.getPeakIndexes(this.width);\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this.hashes[peakIndexes[i]];\n        }\n        return peaks;\n    }\n    getLeafIndex(width) {\n        if (width % 2 === 1) {\n            return this.getSize(width);\n        }\n        return this.getSize(width - 1) + 1;\n    }\n    /**\n     * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n     *       the given index(size).\n     */\n    getPeakIndexes(width) {\n        const numPeaks = this.numOfPeaks(width);\n        const peakIndexes = [];\n        let count = 0;\n        let size = 0;\n        for (let i = 255; i > 0; i--) {\n            if ((width & (1 << (i - 1))) !== 0) {\n                // peak exists\n                size = size + (1 << i) - 1;\n                peakIndexes[count++] = size;\n                if (peakIndexes.length >= numPeaks) {\n                    break;\n                }\n            }\n        }\n        if (count !== peakIndexes.length) {\n            throw new Error('invalid bit calculation');\n        }\n        return peakIndexes;\n    }\n    numOfPeaks(width) {\n        let bits = width;\n        let num = 0;\n        while (bits > 0) {\n            if (bits % 2 === 1) {\n                num++;\n            }\n            bits = bits >> 1;\n        }\n        return num;\n    }\n    peakBagging(width, peaks) {\n        const size = this.getSize(width);\n        if (this.numOfPeaks(width) !== peaks.length) {\n            throw new Error('received invalid number of peaks');\n        }\n        if (width === 0 && !peaks.length) {\n            return buffer_1.Buffer.alloc(0);\n        }\n        if (this.peakBaggingFn) {\n            return this.bufferify(this.peakBaggingFn(size, peaks));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));\n    }\n    /**\n     * @desc It returns the size of the tree.\n     */\n    getSize(width) {\n        return (width << 1) - this.numOfPeaks(width);\n    }\n    /**\n     * @desc It returns the root value of the tree.\n     */\n    getRoot() {\n        return this.root;\n    }\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n     */\n    getNode(index) {\n        return this.hashes[index];\n    }\n    /**\n     * @desc It returns the height of the highest peak.\n     */\n    mountainHeight(size) {\n        let height = 1;\n        while (1 << height <= size + height) {\n            height++;\n        }\n        return height - 1;\n    }\n    /**\n     * @desc It returns the height of the index.\n     */\n    heightAt(index) {\n        let reducedIndex = index;\n        let peakIndex = 0;\n        let height = 0;\n        // if an index has a left mountain then subtract the mountain\n        while (reducedIndex > peakIndex) {\n            reducedIndex -= (1 << height) - 1;\n            height = this.mountainHeight(reducedIndex);\n            peakIndex = (1 << height) - 1;\n        }\n        // index is on the right slope\n        return height - (peakIndex - reducedIndex);\n    }\n    /**\n     * @desc It returns whether the index is the leaf node or not\n     */\n    isLeaf(index) {\n        return this.heightAt(index) === 1;\n    }\n    /**\n     * @desc It returns the children when it is a parent node.\n     */\n    getChildren(index) {\n        const left = index - (1 << (this.heightAt(index) - 1));\n        const right = index - 1;\n        if (left === right) {\n            throw new Error('not a parent');\n        }\n        return [left, right];\n    }\n    /**\n     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n     */\n    getMerkleProof(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.isLeaf(index)) {\n            throw new Error('not a leaf');\n        }\n        const root = this.root;\n        const width = this.width;\n        // find all peaks for bagging\n        const peaks = this.getPeakIndexes(this.width);\n        const peakBagging = [];\n        let cursor = 0;\n        for (let i = 0; i < peaks.length; i++) {\n            // collect the hash of all peaks\n            peakBagging[i] = this.hashes[peaks[i]];\n            // find the peak which includes the target index\n            if (peaks[i] >= index && cursor === 0) {\n                cursor = peaks[i];\n            }\n        }\n        let left = 0;\n        let right = 0;\n        // get hashes of the siblings in the mountain which the index belgons to.\n        // it moves the cursor from the summit of the mountain down to the target index\n        let height = this.heightAt(cursor);\n        const siblings = [];\n        while (cursor !== index) {\n            height--;\n            ([left, right] = this.getChildren(cursor));\n            // move the cursor down to the left size or right size\n            cursor = index <= left ? left : right;\n            // remaining node is the sibling\n            siblings[height - 1] = this.hashes[index <= left ? right : left];\n        }\n        return {\n            root,\n            width,\n            peakBagging,\n            siblings\n        };\n    }\n    /**\n     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n    verify(root, width, index, value, peaks, siblings) {\n        value = this.bufferify(value);\n        const size = this.getSize(width);\n        if (size < index) {\n            throw new Error('index is out of range');\n        }\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        // find the mountain where the target index belongs to\n        let cursor = 0;\n        let targetPeak;\n        const peakIndexes = this.getPeakIndexes(width);\n        for (let i = 0; i < peakIndexes.length; i++) {\n            if (peakIndexes[i] >= index) {\n                targetPeak = peaks[i];\n                cursor = peakIndexes[i];\n                break;\n            }\n        }\n        if (!targetPeak) {\n            throw new Error('target not found');\n        }\n        // find the path climbing down\n        let height = siblings.length + 1;\n        const path = new Array(height);\n        let left = 0;\n        let right = 0;\n        while (height > 0) {\n            // record the current cursor and climb down\n            path[--height] = cursor;\n            if (cursor === index) {\n                // on the leaf node. Stop climbing down\n                break;\n            }\n            else {\n                // on the parent node. Go left or right\n                ([left, right] = this.getChildren(cursor));\n                cursor = index > left ? right : left;\n                continue;\n            }\n        }\n        // calculate the summit hash climbing up again\n        let node;\n        while (height < path.length) {\n            // move cursor\n            cursor = path[height];\n            if (height === 0) {\n                // cusor is on the leaf\n                node = this.hashLeaf(cursor, this.hashFn(value));\n            }\n            else if (cursor - 1 === path[height - 1]) {\n                // cursor is on a parent and a siblings is on the left\n                node = this.hashBranch(cursor, siblings[height - 1], node);\n            }\n            else {\n                // cursor is on a parent and a siblings is on the right\n                node = this.hashBranch(cursor, node, siblings[height - 1]);\n            }\n            // climb up\n            height++;\n        }\n        // computed hash value of the summit should equal to the target peak hash\n        if (!node.equals(targetPeak)) {\n            throw new Error('hashed peak is invalid');\n        }\n        return true;\n    }\n    peaksToPeakMap(width, peaks) {\n        const peakMap = {};\n        let bitIndex = 0;\n        let peakRef = 0;\n        let count = peaks.length;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            peakRef = 1 << (height - 1);\n            if ((width & peakRef) !== 0) {\n                peakMap[bitIndex] = peaks[--count];\n            }\n            else {\n                peakMap[bitIndex] = 0;\n            }\n        }\n        if (count !== 0) {\n            throw new Error('invalid number of peaks');\n        }\n        return peakMap;\n    }\n    peakMapToPeaks(width, peakMap) {\n        const arrLength = this.numOfPeaks(width);\n        const peaks = new Array(arrLength);\n        let count = 0;\n        for (let i = 0; i < 32; i++) {\n            if (peakMap[i] !== 0) {\n                peaks[count++] = peakMap[i];\n            }\n        }\n        if (count !== arrLength) {\n            throw new Error('invalid number of peaks');\n        }\n        return peaks;\n    }\n    peakUpdate(width, prevPeakMap, itemHash) {\n        const nextPeakMap = {};\n        const newWidth = width + 1;\n        let cursorIndex = this.getLeafIndex(newWidth);\n        let cursorNode = this.hashLeaf(cursorIndex, itemHash);\n        let bitIndex = 0;\n        let peakRef = 0;\n        let prevPeakExist = false;\n        let nextPeakExist = false;\n        let obtained = false;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            if (obtained) {\n                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            }\n            else {\n                peakRef = 1 << (height - 1);\n                prevPeakExist = (width & peakRef) !== 0;\n                nextPeakExist = (newWidth & peakRef) !== 0;\n                // get new cursor node with hashing the peak and the current cursor\n                cursorIndex++;\n                if (prevPeakExist) {\n                    cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n                }\n                // if new peak exists for the bit index\n                if (nextPeakExist) {\n                    // if prev peak exists for the bit index\n                    if (prevPeakExist) {\n                        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n                    }\n                    else {\n                        nextPeakMap[bitIndex] = cursorNode;\n                    }\n                    obtained = true;\n                }\n                else {\n                    nextPeakMap[bitIndex] = 0;\n                }\n            }\n        }\n        return nextPeakMap;\n    }\n    rollUp(root, width, peaks, itemHashes) {\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        let tmpWidth = width;\n        let tmpPeakMap = this.peaksToPeakMap(width, peaks);\n        for (let i = 0; i < itemHashes.length; i++) {\n            tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n            tmpWidth++;\n        }\n        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n    /**\n     * @desc It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function.\n     */\n    _getOrCreateNode(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.hashes[index]) {\n            const [leftIndex, rightIndex] = this.getChildren(index);\n            const leftHash = this._getOrCreateNode(leftIndex);\n            const rightHash = this._getOrCreateNode(rightIndex);\n            this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n        }\n        return this.hashes[index];\n    }\n}\nexports.MerkleMountainRange = MerkleMountainRange;\nif (typeof window !== 'undefined') {\n    ;\n    window.MerkleMountainRange = MerkleMountainRange;\n}\nexports[\"default\"] = MerkleMountainRange;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21lcmtsZXRyZWVqc0AwLjMuMTEvbm9kZV9tb2R1bGVzL21lcmtsZXRyZWVqcy9kaXN0L01lcmtsZU1vdW50YWluUmFuZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsaUNBQWlDLG1CQUFPLENBQUMsNEdBQWtCO0FBQzNELCtCQUErQixtQkFBTyxDQUFDLDRHQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGV4YW1wbGVzL2xvZ2luLXdpdGgtcGFzc3BvcnQtc2lsZW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tZXJrbGV0cmVlanNAMC4zLjExL25vZGVfbW9kdWxlcy9tZXJrbGV0cmVlanMvZGlzdC9NZXJrbGVNb3VudGFpblJhbmdlLmpzPzc2NDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lcmtsZU1vdW50YWluUmFuZ2UgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG5jb25zdCBzaGEyNTZfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3J5cHRvLWpzL3NoYTI1NlwiKSk7XG5jb25zdCBCYXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vQmFzZVwiKSk7XG4vLyBAY3JlZGl0OiBodHRwczovL2dpdGh1Yi5jb20vd2Fuc2VvYi9zb2xpZGl0eS1tbXJcbi8qKlxuICogQGRlc2MgVGhlIGluZGV4IG9mIHRoaXMgTU1SIGltcGxlbWVudGF0aW9uIHN0YXJ0cyBmcm9tIDEgbm90IDAuXG4gKi9cbmNsYXNzIE1lcmtsZU1vdW50YWluUmFuZ2UgZXh0ZW5kcyBCYXNlXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3IoaGFzaEZuID0gc2hhMjU2XzEuZGVmYXVsdCwgbGVhdmVzID0gW10sIGhhc2hMZWFmRm4sIHBlYWtCYWdnaW5nRm4sIGhhc2hCcmFuY2hGbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJvb3QgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLmhhc2hlcyA9IHt9O1xuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICAgICAgbGVhdmVzID0gbGVhdmVzLm1hcCh0aGlzLmJ1ZmZlcmlmeSk7XG4gICAgICAgIHRoaXMuaGFzaEZuID0gdGhpcy5idWZmZXJpZnlGbihoYXNoRm4pO1xuICAgICAgICB0aGlzLmhhc2hMZWFmRm4gPSBoYXNoTGVhZkZuO1xuICAgICAgICB0aGlzLnBlYWtCYWdnaW5nRm4gPSBwZWFrQmFnZ2luZ0ZuO1xuICAgICAgICB0aGlzLmhhc2hCcmFuY2hGbiA9IGhhc2hCcmFuY2hGbjtcbiAgICAgICAgZm9yIChjb25zdCBsZWFmIG9mIGxlYXZlcykge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQobGVhZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2MgVGhpcyBvbmx5IHN0b3JlcyB0aGUgaGFzaGVkIHZhbHVlIG9mIHRoZSBsZWFmLlxuICAgICAqIElmIHlvdSBuZWVkIHRvIHJldHJpZXZlIHRoZSBkZXRhaWwgZGF0YSBsYXRlciwgdXNlIGEgbWFwIHRvIHN0b3JlIHRoZW0uXG4gICAgICovXG4gICAgYXBwZW5kKGRhdGEpIHtcbiAgICAgICAgZGF0YSA9IHRoaXMuYnVmZmVyaWZ5KGRhdGEpO1xuICAgICAgICBjb25zdCBkYXRhSGFzaCA9IHRoaXMuaGFzaEZuKGRhdGEpO1xuICAgICAgICBjb25zdCBkYXRhSGFzaEhleCA9IHRoaXMuYnVmZmVyVG9IZXgoZGF0YUhhc2gpO1xuICAgICAgICBpZiAoIXRoaXMuZGF0YVtkYXRhSGFzaEhleF0gfHwgdGhpcy5idWZmZXJUb0hleCh0aGlzLmhhc2hGbih0aGlzLmRhdGFbZGF0YUhhc2hIZXhdKSkgIT09IGRhdGFIYXNoSGV4KSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbZGF0YUhhc2hIZXhdID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZWFmID0gdGhpcy5oYXNoTGVhZih0aGlzLnNpemUgKyAxLCBkYXRhSGFzaCk7XG4gICAgICAgIHRoaXMuaGFzaGVzW3RoaXMuc2l6ZSArIDFdID0gbGVhZjtcbiAgICAgICAgdGhpcy53aWR0aCArPSAxO1xuICAgICAgICAvLyBmaW5kIHBlYWtzIGZvciBlbmxhcmdlZCB0cmVlXG4gICAgICAgIGNvbnN0IHBlYWtJbmRleGVzID0gdGhpcy5nZXRQZWFrSW5kZXhlcyh0aGlzLndpZHRoKTtcbiAgICAgICAgLy8gdGhlIHJpZ2h0IG1vc3QgcGVhaydzIHZhbHVlIGlzIHRoZSBuZXcgc2l6ZSBvZiB0aGUgdXBkYXRlZCB0cmVlXG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuZ2V0U2l6ZSh0aGlzLndpZHRoKTtcbiAgICAgICAgLy8gc3RhcnRpbmcgZnJvbSB0aGUgbGVmdC1tb3N0IHBlYWssIGdldCBhbGwgcGVhayBoYXNoZXNcbiAgICAgICAgY29uc3QgcGVha3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZWFrSW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGVha3NbaV0gPSB0aGlzLl9nZXRPckNyZWF0ZU5vZGUocGVha0luZGV4ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdHJlZSByb290IGhhc2hcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5wZWFrQmFnZ2luZyh0aGlzLndpZHRoLCBwZWFrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjIEl0IHJldHVybnMgdGhlIGhhc2ggb2YgYSBsZWFmIG5vZGUgd2l0aCBoYXNoKE0gfCBEQVRBIClcbiAgICAgKiAgICAgICBNIGlzIHRoZSBpbmRleCBvZiB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBoYXNoTGVhZihpbmRleCwgZGF0YUhhc2gpIHtcbiAgICAgICAgZGF0YUhhc2ggPSB0aGlzLmJ1ZmZlcmlmeShkYXRhSGFzaCk7XG4gICAgICAgIGlmICh0aGlzLmhhc2hMZWFmRm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmlmeSh0aGlzLmhhc2hMZWFmRm4oaW5kZXgsIGRhdGFIYXNoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaEZuKGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW3RoaXMuYnVmZmVyaWZ5KGluZGV4KSwgZGF0YUhhc2hdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjIEl0IHJldHVybnMgdGhlIGhhc2ggYSBwYXJlbnQgbm9kZSB3aXRoIGhhc2goTSB8IExlZnQgY2hpbGQgfCBSaWdodCBjaGlsZClcbiAgICAgKiAgICAgICBNIGlzIHRoZSBpbmRleCBvZiB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBoYXNoQnJhbmNoKGluZGV4LCBsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAodGhpcy5oYXNoQnJhbmNoRm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmlmeSh0aGlzLmhhc2hCcmFuY2hGbihpbmRleCwgbGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYXNoRm4oYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbdGhpcy5idWZmZXJpZnkoaW5kZXgpLCB0aGlzLmJ1ZmZlcmlmeShsZWZ0KSwgdGhpcy5idWZmZXJpZnkocmlnaHQpXSkpO1xuICAgIH1cbiAgICBnZXRQZWFrcygpIHtcbiAgICAgICAgY29uc3QgcGVha0luZGV4ZXMgPSB0aGlzLmdldFBlYWtJbmRleGVzKHRoaXMud2lkdGgpO1xuICAgICAgICBjb25zdCBwZWFrcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlYWtJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwZWFrc1tpXSA9IHRoaXMuaGFzaGVzW3BlYWtJbmRleGVzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGVha3M7XG4gICAgfVxuICAgIGdldExlYWZJbmRleCh3aWR0aCkge1xuICAgICAgICBpZiAod2lkdGggJSAyID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTaXplKHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTaXplKHdpZHRoIC0gMSkgKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzYyBJdCByZXR1cm5zIGFsbCBwZWFrcyBvZiB0aGUgc21hbGxlc3QgbWVya2xlIG1vdW50YWluIHJhbmdlIHRyZWUgd2hpY2ggaW5jbHVkZXNcbiAgICAgKiAgICAgICB0aGUgZ2l2ZW4gaW5kZXgoc2l6ZSkuXG4gICAgICovXG4gICAgZ2V0UGVha0luZGV4ZXMod2lkdGgpIHtcbiAgICAgICAgY29uc3QgbnVtUGVha3MgPSB0aGlzLm51bU9mUGVha3Mod2lkdGgpO1xuICAgICAgICBjb25zdCBwZWFrSW5kZXhlcyA9IFtdO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAyNTU7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICgod2lkdGggJiAoMSA8PCAoaSAtIDEpKSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBwZWFrIGV4aXN0c1xuICAgICAgICAgICAgICAgIHNpemUgPSBzaXplICsgKDEgPDwgaSkgLSAxO1xuICAgICAgICAgICAgICAgIHBlYWtJbmRleGVzW2NvdW50KytdID0gc2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAocGVha0luZGV4ZXMubGVuZ3RoID49IG51bVBlYWtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgIT09IHBlYWtJbmRleGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJpdCBjYWxjdWxhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwZWFrSW5kZXhlcztcbiAgICB9XG4gICAgbnVtT2ZQZWFrcyh3aWR0aCkge1xuICAgICAgICBsZXQgYml0cyA9IHdpZHRoO1xuICAgICAgICBsZXQgbnVtID0gMDtcbiAgICAgICAgd2hpbGUgKGJpdHMgPiAwKSB7XG4gICAgICAgICAgICBpZiAoYml0cyAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBudW0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHMgPSBiaXRzID4+IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgcGVha0JhZ2dpbmcod2lkdGgsIHBlYWtzKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUod2lkdGgpO1xuICAgICAgICBpZiAodGhpcy5udW1PZlBlYWtzKHdpZHRoKSAhPT0gcGVha3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2VpdmVkIGludmFsaWQgbnVtYmVyIG9mIHBlYWtzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoID09PSAwICYmICFwZWFrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVha0JhZ2dpbmdGbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyaWZ5KHRoaXMucGVha0JhZ2dpbmdGbihzaXplLCBwZWFrcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hGbihidWZmZXJfMS5CdWZmZXIuY29uY2F0KFt0aGlzLmJ1ZmZlcmlmeShzaXplKSwgLi4ucGVha3MubWFwKHRoaXMuYnVmZmVyaWZ5KV0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2MgSXQgcmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgdHJlZS5cbiAgICAgKi9cbiAgICBnZXRTaXplKHdpZHRoKSB7XG4gICAgICAgIHJldHVybiAod2lkdGggPDwgMSkgLSB0aGlzLm51bU9mUGVha3Mod2lkdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzYyBJdCByZXR1cm5zIHRoZSByb290IHZhbHVlIG9mIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIGdldFJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gICAgfVxuICAgIGdldEhleFJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclRvSGV4KHRoaXMuZ2V0Um9vdCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRldiBJdCByZXR1cm5zIHRoZSBoYXNoIHZhbHVlIG9mIGEgbm9kZSBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uLiBOb3RlIHRoYXQgdGhlIGluZGV4IHN0YXJ0cyBmcm9tIDEuXG4gICAgICovXG4gICAgZ2V0Tm9kZShpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNoZXNbaW5kZXhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzYyBJdCByZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGhpZ2hlc3QgcGVhay5cbiAgICAgKi9cbiAgICBtb3VudGFpbkhlaWdodChzaXplKSB7XG4gICAgICAgIGxldCBoZWlnaHQgPSAxO1xuICAgICAgICB3aGlsZSAoMSA8PCBoZWlnaHQgPD0gc2l6ZSArIGhlaWdodCkge1xuICAgICAgICAgICAgaGVpZ2h0Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlaWdodCAtIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjIEl0IHJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgaW5kZXguXG4gICAgICovXG4gICAgaGVpZ2h0QXQoaW5kZXgpIHtcbiAgICAgICAgbGV0IHJlZHVjZWRJbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgcGVha0luZGV4ID0gMDtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIC8vIGlmIGFuIGluZGV4IGhhcyBhIGxlZnQgbW91bnRhaW4gdGhlbiBzdWJ0cmFjdCB0aGUgbW91bnRhaW5cbiAgICAgICAgd2hpbGUgKHJlZHVjZWRJbmRleCA+IHBlYWtJbmRleCkge1xuICAgICAgICAgICAgcmVkdWNlZEluZGV4IC09ICgxIDw8IGhlaWdodCkgLSAxO1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5tb3VudGFpbkhlaWdodChyZWR1Y2VkSW5kZXgpO1xuICAgICAgICAgICAgcGVha0luZGV4ID0gKDEgPDwgaGVpZ2h0KSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5kZXggaXMgb24gdGhlIHJpZ2h0IHNsb3BlXG4gICAgICAgIHJldHVybiBoZWlnaHQgLSAocGVha0luZGV4IC0gcmVkdWNlZEluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2MgSXQgcmV0dXJucyB3aGV0aGVyIHRoZSBpbmRleCBpcyB0aGUgbGVhZiBub2RlIG9yIG5vdFxuICAgICAqL1xuICAgIGlzTGVhZihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHRBdChpbmRleCkgPT09IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjIEl0IHJldHVybnMgdGhlIGNoaWxkcmVuIHdoZW4gaXQgaXMgYSBwYXJlbnQgbm9kZS5cbiAgICAgKi9cbiAgICBnZXRDaGlsZHJlbihpbmRleCkge1xuICAgICAgICBjb25zdCBsZWZ0ID0gaW5kZXggLSAoMSA8PCAodGhpcy5oZWlnaHRBdChpbmRleCkgLSAxKSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gaW5kZXggLSAxO1xuICAgICAgICBpZiAobGVmdCA9PT0gcmlnaHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGEgcGFyZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjIEl0IHJldHVybnMgYSBtZXJrbGUgcHJvb2YgZm9yIGEgbGVhZi4gTm90ZSB0aGF0IHRoZSBpbmRleCBzdGFydHMgZnJvbSAxLlxuICAgICAqL1xuICAgIGdldE1lcmtsZVByb29mKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA+IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNMZWFmKGluZGV4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgYSBsZWFmJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAvLyBmaW5kIGFsbCBwZWFrcyBmb3IgYmFnZ2luZ1xuICAgICAgICBjb25zdCBwZWFrcyA9IHRoaXMuZ2V0UGVha0luZGV4ZXModGhpcy53aWR0aCk7XG4gICAgICAgIGNvbnN0IHBlYWtCYWdnaW5nID0gW107XG4gICAgICAgIGxldCBjdXJzb3IgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlYWtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSBoYXNoIG9mIGFsbCBwZWFrc1xuICAgICAgICAgICAgcGVha0JhZ2dpbmdbaV0gPSB0aGlzLmhhc2hlc1twZWFrc1tpXV07XG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBwZWFrIHdoaWNoIGluY2x1ZGVzIHRoZSB0YXJnZXQgaW5kZXhcbiAgICAgICAgICAgIGlmIChwZWFrc1tpXSA+PSBpbmRleCAmJiBjdXJzb3IgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBwZWFrc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVmdCA9IDA7XG4gICAgICAgIGxldCByaWdodCA9IDA7XG4gICAgICAgIC8vIGdldCBoYXNoZXMgb2YgdGhlIHNpYmxpbmdzIGluIHRoZSBtb3VudGFpbiB3aGljaCB0aGUgaW5kZXggYmVsZ29ucyB0by5cbiAgICAgICAgLy8gaXQgbW92ZXMgdGhlIGN1cnNvciBmcm9tIHRoZSBzdW1taXQgb2YgdGhlIG1vdW50YWluIGRvd24gdG8gdGhlIHRhcmdldCBpbmRleFxuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5oZWlnaHRBdChjdXJzb3IpO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IFtdO1xuICAgICAgICB3aGlsZSAoY3Vyc29yICE9PSBpbmRleCkge1xuICAgICAgICAgICAgaGVpZ2h0LS07XG4gICAgICAgICAgICAoW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0Q2hpbGRyZW4oY3Vyc29yKSk7XG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBjdXJzb3IgZG93biB0byB0aGUgbGVmdCBzaXplIG9yIHJpZ2h0IHNpemVcbiAgICAgICAgICAgIGN1cnNvciA9IGluZGV4IDw9IGxlZnQgPyBsZWZ0IDogcmlnaHQ7XG4gICAgICAgICAgICAvLyByZW1haW5pbmcgbm9kZSBpcyB0aGUgc2libGluZ1xuICAgICAgICAgICAgc2libGluZ3NbaGVpZ2h0IC0gMV0gPSB0aGlzLmhhc2hlc1tpbmRleCA8PSBsZWZ0ID8gcmlnaHQgOiBsZWZ0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgcGVha0JhZ2dpbmcsXG4gICAgICAgICAgICBzaWJsaW5nc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzYyBJdCByZXR1cm5zIHRydWUgd2hlbiB0aGUgZ2l2ZW4gcGFyYW1zIHZlcmlmaWVzIHRoYXQgdGhlIGdpdmVuIHZhbHVlIGV4aXN0cyBpbiB0aGUgdHJlZSBvciByZXZlcnRzIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB2ZXJpZnkocm9vdCwgd2lkdGgsIGluZGV4LCB2YWx1ZSwgcGVha3MsIHNpYmxpbmdzKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5idWZmZXJpZnkodmFsdWUpO1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKHdpZHRoKTtcbiAgICAgICAgaWYgKHNpemUgPCBpbmRleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmRleCBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayB0aGUgcm9vdCBlcXVhbHMgdGhlIHBlYWsgYmFnZ2luZyBoYXNoXG4gICAgICAgIGlmICghcm9vdC5lcXVhbHModGhpcy5wZWFrQmFnZ2luZyh3aWR0aCwgcGVha3MpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJvb3QgaGFzaCBmcm9tIHRoZSBwZWFrcycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmQgdGhlIG1vdW50YWluIHdoZXJlIHRoZSB0YXJnZXQgaW5kZXggYmVsb25ncyB0b1xuICAgICAgICBsZXQgY3Vyc29yID0gMDtcbiAgICAgICAgbGV0IHRhcmdldFBlYWs7XG4gICAgICAgIGNvbnN0IHBlYWtJbmRleGVzID0gdGhpcy5nZXRQZWFrSW5kZXhlcyh3aWR0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVha0luZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwZWFrSW5kZXhlc1tpXSA+PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFBlYWsgPSBwZWFrc1tpXTtcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBwZWFrSW5kZXhlc1tpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldFBlYWspIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmQgdGhlIHBhdGggY2xpbWJpbmcgZG93blxuICAgICAgICBsZXQgaGVpZ2h0ID0gc2libGluZ3MubGVuZ3RoICsgMTtcbiAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgICBsZXQgbGVmdCA9IDA7XG4gICAgICAgIGxldCByaWdodCA9IDA7XG4gICAgICAgIHdoaWxlIChoZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAvLyByZWNvcmQgdGhlIGN1cnJlbnQgY3Vyc29yIGFuZCBjbGltYiBkb3duXG4gICAgICAgICAgICBwYXRoWy0taGVpZ2h0XSA9IGN1cnNvcjtcbiAgICAgICAgICAgIGlmIChjdXJzb3IgPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gb24gdGhlIGxlYWYgbm9kZS4gU3RvcCBjbGltYmluZyBkb3duXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvbiB0aGUgcGFyZW50IG5vZGUuIEdvIGxlZnQgb3IgcmlnaHRcbiAgICAgICAgICAgICAgICAoW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0Q2hpbGRyZW4oY3Vyc29yKSk7XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gaW5kZXggPiBsZWZ0ID8gcmlnaHQgOiBsZWZ0O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgc3VtbWl0IGhhc2ggY2xpbWJpbmcgdXAgYWdhaW5cbiAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgIHdoaWxlIChoZWlnaHQgPCBwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gbW92ZSBjdXJzb3JcbiAgICAgICAgICAgIGN1cnNvciA9IHBhdGhbaGVpZ2h0XTtcbiAgICAgICAgICAgIGlmIChoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBjdXNvciBpcyBvbiB0aGUgbGVhZlxuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmhhc2hMZWFmKGN1cnNvciwgdGhpcy5oYXNoRm4odmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnNvciAtIDEgPT09IHBhdGhbaGVpZ2h0IC0gMV0pIHtcbiAgICAgICAgICAgICAgICAvLyBjdXJzb3IgaXMgb24gYSBwYXJlbnQgYW5kIGEgc2libGluZ3MgaXMgb24gdGhlIGxlZnRcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5oYXNoQnJhbmNoKGN1cnNvciwgc2libGluZ3NbaGVpZ2h0IC0gMV0sIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY3Vyc29yIGlzIG9uIGEgcGFyZW50IGFuZCBhIHNpYmxpbmdzIGlzIG9uIHRoZSByaWdodFxuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmhhc2hCcmFuY2goY3Vyc29yLCBub2RlLCBzaWJsaW5nc1toZWlnaHQgLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbGltYiB1cFxuICAgICAgICAgICAgaGVpZ2h0Kys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcHV0ZWQgaGFzaCB2YWx1ZSBvZiB0aGUgc3VtbWl0IHNob3VsZCBlcXVhbCB0byB0aGUgdGFyZ2V0IHBlYWsgaGFzaFxuICAgICAgICBpZiAoIW5vZGUuZXF1YWxzKHRhcmdldFBlYWspKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hlZCBwZWFrIGlzIGludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcGVha3NUb1BlYWtNYXAod2lkdGgsIHBlYWtzKSB7XG4gICAgICAgIGNvbnN0IHBlYWtNYXAgPSB7fTtcbiAgICAgICAgbGV0IGJpdEluZGV4ID0gMDtcbiAgICAgICAgbGV0IHBlYWtSZWYgPSAwO1xuICAgICAgICBsZXQgY291bnQgPSBwZWFrcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGhlaWdodCA9IDE7IGhlaWdodCA8PSAzMjsgaGVpZ2h0KyspIHtcbiAgICAgICAgICAgIC8vIGluZGV4IHN0YXJ0cyBmcm9tIHRoZSByaWdodCBtb3N0IGJpdFxuICAgICAgICAgICAgYml0SW5kZXggPSAzMiAtIGhlaWdodDtcbiAgICAgICAgICAgIHBlYWtSZWYgPSAxIDw8IChoZWlnaHQgLSAxKTtcbiAgICAgICAgICAgIGlmICgod2lkdGggJiBwZWFrUmVmKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHBlYWtNYXBbYml0SW5kZXhdID0gcGVha3NbLS1jb3VudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWFrTWFwW2JpdEluZGV4XSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbnVtYmVyIG9mIHBlYWtzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlYWtNYXA7XG4gICAgfVxuICAgIHBlYWtNYXBUb1BlYWtzKHdpZHRoLCBwZWFrTWFwKSB7XG4gICAgICAgIGNvbnN0IGFyckxlbmd0aCA9IHRoaXMubnVtT2ZQZWFrcyh3aWR0aCk7XG4gICAgICAgIGNvbnN0IHBlYWtzID0gbmV3IEFycmF5KGFyckxlbmd0aCk7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBlYWtNYXBbaV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBwZWFrc1tjb3VudCsrXSA9IHBlYWtNYXBbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ICE9PSBhcnJMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBudW1iZXIgb2YgcGVha3MnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGVha3M7XG4gICAgfVxuICAgIHBlYWtVcGRhdGUod2lkdGgsIHByZXZQZWFrTWFwLCBpdGVtSGFzaCkge1xuICAgICAgICBjb25zdCBuZXh0UGVha01hcCA9IHt9O1xuICAgICAgICBjb25zdCBuZXdXaWR0aCA9IHdpZHRoICsgMTtcbiAgICAgICAgbGV0IGN1cnNvckluZGV4ID0gdGhpcy5nZXRMZWFmSW5kZXgobmV3V2lkdGgpO1xuICAgICAgICBsZXQgY3Vyc29yTm9kZSA9IHRoaXMuaGFzaExlYWYoY3Vyc29ySW5kZXgsIGl0ZW1IYXNoKTtcbiAgICAgICAgbGV0IGJpdEluZGV4ID0gMDtcbiAgICAgICAgbGV0IHBlYWtSZWYgPSAwO1xuICAgICAgICBsZXQgcHJldlBlYWtFeGlzdCA9IGZhbHNlO1xuICAgICAgICBsZXQgbmV4dFBlYWtFeGlzdCA9IGZhbHNlO1xuICAgICAgICBsZXQgb2J0YWluZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaGVpZ2h0ID0gMTsgaGVpZ2h0IDw9IDMyOyBoZWlnaHQrKykge1xuICAgICAgICAgICAgLy8gaW5kZXggc3RhcnRzIGZyb20gdGhlIHJpZ2h0IG1vc3QgYml0XG4gICAgICAgICAgICBiaXRJbmRleCA9IDMyIC0gaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKG9idGFpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBlYWtNYXBbYml0SW5kZXhdID0gcHJldlBlYWtNYXBbYml0SW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVha1JlZiA9IDEgPDwgKGhlaWdodCAtIDEpO1xuICAgICAgICAgICAgICAgIHByZXZQZWFrRXhpc3QgPSAod2lkdGggJiBwZWFrUmVmKSAhPT0gMDtcbiAgICAgICAgICAgICAgICBuZXh0UGVha0V4aXN0ID0gKG5ld1dpZHRoICYgcGVha1JlZikgIT09IDA7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IG5ldyBjdXJzb3Igbm9kZSB3aXRoIGhhc2hpbmcgdGhlIHBlYWsgYW5kIHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAgICAgICAgICAgIGN1cnNvckluZGV4Kys7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZQZWFrRXhpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yTm9kZSA9IHRoaXMuaGFzaEJyYW5jaChjdXJzb3JJbmRleCwgcHJldlBlYWtNYXBbYml0SW5kZXhdLCBjdXJzb3JOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgbmV3IHBlYWsgZXhpc3RzIGZvciB0aGUgYml0IGluZGV4XG4gICAgICAgICAgICAgICAgaWYgKG5leHRQZWFrRXhpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgcHJldiBwZWFrIGV4aXN0cyBmb3IgdGhlIGJpdCBpbmRleFxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldlBlYWtFeGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBlYWtNYXBbYml0SW5kZXhdID0gcHJldlBlYWtNYXBbYml0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBlYWtNYXBbYml0SW5kZXhdID0gY3Vyc29yTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYnRhaW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UGVha01hcFtiaXRJbmRleF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dFBlYWtNYXA7XG4gICAgfVxuICAgIHJvbGxVcChyb290LCB3aWR0aCwgcGVha3MsIGl0ZW1IYXNoZXMpIHtcbiAgICAgICAgLy8gY2hlY2sgdGhlIHJvb3QgZXF1YWxzIHRoZSBwZWFrIGJhZ2dpbmcgaGFzaFxuICAgICAgICBpZiAoIXJvb3QuZXF1YWxzKHRoaXMucGVha0JhZ2dpbmcod2lkdGgsIHBlYWtzKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByb290IGhhc2ggZnJvbSB0aGUgcGVha3MnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG1wV2lkdGggPSB3aWR0aDtcbiAgICAgICAgbGV0IHRtcFBlYWtNYXAgPSB0aGlzLnBlYWtzVG9QZWFrTWFwKHdpZHRoLCBwZWFrcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbUhhc2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG1wUGVha01hcCA9IHRoaXMucGVha1VwZGF0ZSh0bXBXaWR0aCwgdG1wUGVha01hcCwgaXRlbUhhc2hlc1tpXSk7XG4gICAgICAgICAgICB0bXBXaWR0aCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBlYWtCYWdnaW5nKHRtcFdpZHRoLCB0aGlzLnBlYWtNYXBUb1BlYWtzKHRtcFdpZHRoLCB0bXBQZWFrTWFwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjIEl0IHJldHVybnMgdGhlIGhhc2ggdmFsdWUgb2YgdGhlIG5vZGUgZm9yIHRoZSBpbmRleC5cbiAgICAgKiAgICAgIElmIHRoZSBoYXNoIGFscmVhZHkgZXhpc3RzIGl0IHNpbXBseSByZXR1cm5zIHRoZSBzdG9yZWQgdmFsdWUuIE9uIHRoZSBvdGhlciBoYW5kLFxuICAgICAqICAgICAgaXQgY29tcHV0ZXMgaGFzaGVzIHJlY3Vyc2l2ZWx5IGRvd253YXJkLlxuICAgICAqICAgICAgT25seSBhcHBlbmRpbmcgYW4gaXRlbSBjYWxscyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIF9nZXRPckNyZWF0ZU5vZGUoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID4gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5oYXNoZXNbaW5kZXhdKSB7XG4gICAgICAgICAgICBjb25zdCBbbGVmdEluZGV4LCByaWdodEluZGV4XSA9IHRoaXMuZ2V0Q2hpbGRyZW4oaW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgbGVmdEhhc2ggPSB0aGlzLl9nZXRPckNyZWF0ZU5vZGUobGVmdEluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0SGFzaCA9IHRoaXMuX2dldE9yQ3JlYXRlTm9kZShyaWdodEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuaGFzaGVzW2luZGV4XSA9IHRoaXMuaGFzaEJyYW5jaChpbmRleCwgbGVmdEhhc2gsIHJpZ2h0SGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaGVzW2luZGV4XTtcbiAgICB9XG59XG5leHBvcnRzLk1lcmtsZU1vdW50YWluUmFuZ2UgPSBNZXJrbGVNb3VudGFpblJhbmdlO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgO1xuICAgIHdpbmRvdy5NZXJrbGVNb3VudGFpblJhbmdlID0gTWVya2xlTW91bnRhaW5SYW5nZTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1lcmtsZU1vdW50YWluUmFuZ2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/MerkleMountainRange.js\n");

/***/ }),

/***/ "(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/MerkleSumTree.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/MerkleSumTree.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MerkleSumTree = exports.ProofStep = exports.Leaf = exports.Bucket = void 0;\nconst Base_1 = __webpack_require__(/*! ./Base */ \"(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/Base.js\");\nclass Bucket {\n    constructor(size, hashed) {\n        this.size = BigInt(size);\n        this.hashed = hashed;\n        // each node in the tree can have a parent, and a left or right sibling\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexports.Bucket = Bucket;\nclass Leaf {\n    constructor(hashFn, rng, data) {\n        this.hashFn = hashFn;\n        this.rng = rng.map(x => BigInt(x));\n        this.data = data;\n    }\n    getBucket() {\n        let hashed;\n        if (this.data) {\n            hashed = this.hashFn(this.data);\n        }\n        else {\n            hashed = Buffer.alloc(32);\n        }\n        return new Bucket(BigInt(this.rng[1]) - BigInt(this.rng[0]), hashed);\n    }\n}\nexports.Leaf = Leaf;\nclass ProofStep {\n    constructor(bucket, right) {\n        this.bucket = bucket;\n        this.right = right; // whether the bucket hash should be appeded on the right side in this step (default is left\n    }\n}\nexports.ProofStep = ProofStep;\nclass MerkleSumTree extends Base_1.Base {\n    constructor(leaves, hashFn) {\n        super();\n        this.leaves = leaves;\n        this.hashFn = hashFn;\n        MerkleSumTree.checkConsecutive(leaves);\n        this.buckets = [];\n        for (const l of leaves) {\n            this.buckets.push(l.getBucket());\n        }\n        let buckets = [];\n        for (const bucket of this.buckets) {\n            buckets.push(bucket);\n        }\n        while (buckets.length !== 1) {\n            const newBuckets = [];\n            while (buckets.length) {\n                if (buckets.length >= 2) {\n                    const b1 = buckets.shift();\n                    const b2 = buckets.shift();\n                    const size = b1.size + b2.size;\n                    const hashed = this.hashFn(Buffer.concat([this.sizeToBuffer(b1.size), this.bufferify(b1.hashed), this.sizeToBuffer(b2.size), this.bufferify(b2.hashed)]));\n                    const b = new Bucket(size, hashed);\n                    b2.parent = b;\n                    b1.parent = b2.parent;\n                    b1.right = b2;\n                    b2.left = b1;\n                    newBuckets.push(b);\n                }\n                else {\n                    newBuckets.push(buckets.shift());\n                }\n            }\n            buckets = newBuckets;\n        }\n        this.root = buckets[0];\n    }\n    sizeToBuffer(size) {\n        const buf = Buffer.alloc(8);\n        const view = new DataView(buf.buffer);\n        view.setBigInt64(0, BigInt(size), false); // true when little endian\n        return buf;\n    }\n    static checkConsecutive(leaves) {\n        let curr = BigInt(0);\n        for (const leaf of leaves) {\n            if (leaf.rng[0] !== curr) {\n                throw new Error('leaf ranges are invalid');\n            }\n            curr = BigInt(leaf.rng[1]);\n        }\n    }\n    // gets inclusion/exclusion proof of a bucket in the specified index\n    getProof(index) {\n        let curr = this.buckets[Number(index)];\n        const proof = [];\n        while (curr && curr.parent) {\n            const right = !!curr.right;\n            const bucket = curr.right ? curr.right : curr.left;\n            curr = curr.parent;\n            proof.push(new ProofStep(bucket, right));\n        }\n        return proof;\n    }\n    sum(arr) {\n        let total = BigInt(0);\n        for (const value of arr) {\n            total += BigInt(value);\n        }\n        return total;\n    }\n    // validates the suppplied proof for a specified leaf according to the root bucket\n    verifyProof(root, leaf, proof) {\n        const rng = [this.sum(proof.filter(x => !x.right).map(x => x.bucket.size)), BigInt(root.size) - this.sum(proof.filter(x => x.right).map(x => x.bucket.size))];\n        if (!(rng[0] === leaf.rng[0] && rng[1] === leaf.rng[1])) {\n            // supplied steps are not routing to the range specified\n            return false;\n        }\n        let curr = leaf.getBucket();\n        let hashed;\n        for (const step of proof) {\n            if (step.right) {\n                hashed = this.hashFn(Buffer.concat([this.sizeToBuffer(curr.size), this.bufferify(curr.hashed), this.sizeToBuffer(step.bucket.size), this.bufferify(step.bucket.hashed)]));\n            }\n            else {\n                hashed = this.hashFn(Buffer.concat([this.sizeToBuffer(step.bucket.size), this.bufferify(step.bucket.hashed), this.sizeToBuffer(curr.size), this.bufferify(curr.hashed)]));\n            }\n            curr = new Bucket(BigInt(curr.size) + BigInt(step.bucket.size), hashed);\n        }\n        return curr.size === root.size && curr.hashed.toString('hex') === root.hashed.toString('hex');\n    }\n}\nexports.MerkleSumTree = MerkleSumTree;\nif (typeof window !== 'undefined') {\n    ;\n    window.MerkleSumTree = MerkleSumTree;\n}\nexports[\"default\"] = MerkleSumTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21lcmtsZXRyZWVqc0AwLjMuMTEvbm9kZV9tb2R1bGVzL21lcmtsZXRyZWVqcy9kaXN0L01lcmtsZVN1bVRyZWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLGNBQWM7QUFDekUsZUFBZSxtQkFBTyxDQUFDLDRHQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZXhhbXBsZXMvbG9naW4td2l0aC1wYXNzcG9ydC1zaWxlbnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21lcmtsZXRyZWVqc0AwLjMuMTEvbm9kZV9tb2R1bGVzL21lcmtsZXRyZWVqcy9kaXN0L01lcmtsZVN1bVRyZWUuanM/NWU4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVya2xlU3VtVHJlZSA9IGV4cG9ydHMuUHJvb2ZTdGVwID0gZXhwb3J0cy5MZWFmID0gZXhwb3J0cy5CdWNrZXQgPSB2b2lkIDA7XG5jb25zdCBCYXNlXzEgPSByZXF1aXJlKFwiLi9CYXNlXCIpO1xuY2xhc3MgQnVja2V0IHtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBoYXNoZWQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gQmlnSW50KHNpemUpO1xuICAgICAgICB0aGlzLmhhc2hlZCA9IGhhc2hlZDtcbiAgICAgICAgLy8gZWFjaCBub2RlIGluIHRoZSB0cmVlIGNhbiBoYXZlIGEgcGFyZW50LCBhbmQgYSBsZWZ0IG9yIHJpZ2h0IHNpYmxpbmdcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmxlZnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkJ1Y2tldCA9IEJ1Y2tldDtcbmNsYXNzIExlYWYge1xuICAgIGNvbnN0cnVjdG9yKGhhc2hGbiwgcm5nLCBkYXRhKSB7XG4gICAgICAgIHRoaXMuaGFzaEZuID0gaGFzaEZuO1xuICAgICAgICB0aGlzLnJuZyA9IHJuZy5tYXAoeCA9PiBCaWdJbnQoeCkpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBnZXRCdWNrZXQoKSB7XG4gICAgICAgIGxldCBoYXNoZWQ7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIGhhc2hlZCA9IHRoaXMuaGFzaEZuKHRoaXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYXNoZWQgPSBCdWZmZXIuYWxsb2MoMzIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnVja2V0KEJpZ0ludCh0aGlzLnJuZ1sxXSkgLSBCaWdJbnQodGhpcy5ybmdbMF0pLCBoYXNoZWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVhZiA9IExlYWY7XG5jbGFzcyBQcm9vZlN0ZXAge1xuICAgIGNvbnN0cnVjdG9yKGJ1Y2tldCwgcmlnaHQpIHtcbiAgICAgICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDsgLy8gd2hldGhlciB0aGUgYnVja2V0IGhhc2ggc2hvdWxkIGJlIGFwcGVkZWQgb24gdGhlIHJpZ2h0IHNpZGUgaW4gdGhpcyBzdGVwIChkZWZhdWx0IGlzIGxlZnRcbiAgICB9XG59XG5leHBvcnRzLlByb29mU3RlcCA9IFByb29mU3RlcDtcbmNsYXNzIE1lcmtsZVN1bVRyZWUgZXh0ZW5kcyBCYXNlXzEuQmFzZSB7XG4gICAgY29uc3RydWN0b3IobGVhdmVzLCBoYXNoRm4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sZWF2ZXMgPSBsZWF2ZXM7XG4gICAgICAgIHRoaXMuaGFzaEZuID0gaGFzaEZuO1xuICAgICAgICBNZXJrbGVTdW1UcmVlLmNoZWNrQ29uc2VjdXRpdmUobGVhdmVzKTtcbiAgICAgICAgdGhpcy5idWNrZXRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbCBvZiBsZWF2ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYnVja2V0cy5wdXNoKGwuZ2V0QnVja2V0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBidWNrZXRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYnVja2V0IG9mIHRoaXMuYnVja2V0cykge1xuICAgICAgICAgICAgYnVja2V0cy5wdXNoKGJ1Y2tldCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGJ1Y2tldHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdCdWNrZXRzID0gW107XG4gICAgICAgICAgICB3aGlsZSAoYnVja2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVja2V0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiMSA9IGJ1Y2tldHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYjIgPSBidWNrZXRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBiMS5zaXplICsgYjIuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaGVkID0gdGhpcy5oYXNoRm4oQnVmZmVyLmNvbmNhdChbdGhpcy5zaXplVG9CdWZmZXIoYjEuc2l6ZSksIHRoaXMuYnVmZmVyaWZ5KGIxLmhhc2hlZCksIHRoaXMuc2l6ZVRvQnVmZmVyKGIyLnNpemUpLCB0aGlzLmJ1ZmZlcmlmeShiMi5oYXNoZWQpXSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gbmV3IEJ1Y2tldChzaXplLCBoYXNoZWQpO1xuICAgICAgICAgICAgICAgICAgICBiMi5wYXJlbnQgPSBiO1xuICAgICAgICAgICAgICAgICAgICBiMS5wYXJlbnQgPSBiMi5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGIxLnJpZ2h0ID0gYjI7XG4gICAgICAgICAgICAgICAgICAgIGIyLmxlZnQgPSBiMTtcbiAgICAgICAgICAgICAgICAgICAgbmV3QnVja2V0cy5wdXNoKGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3QnVja2V0cy5wdXNoKGJ1Y2tldHMuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVja2V0cyA9IG5ld0J1Y2tldHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290ID0gYnVja2V0c1swXTtcbiAgICB9XG4gICAgc2l6ZVRvQnVmZmVyKHNpemUpIHtcbiAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKDgpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIpO1xuICAgICAgICB2aWV3LnNldEJpZ0ludDY0KDAsIEJpZ0ludChzaXplKSwgZmFsc2UpOyAvLyB0cnVlIHdoZW4gbGl0dGxlIGVuZGlhblxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBzdGF0aWMgY2hlY2tDb25zZWN1dGl2ZShsZWF2ZXMpIHtcbiAgICAgICAgbGV0IGN1cnIgPSBCaWdJbnQoMCk7XG4gICAgICAgIGZvciAoY29uc3QgbGVhZiBvZiBsZWF2ZXMpIHtcbiAgICAgICAgICAgIGlmIChsZWFmLnJuZ1swXSAhPT0gY3Vycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGVhZiByYW5nZXMgYXJlIGludmFsaWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnIgPSBCaWdJbnQobGVhZi5ybmdbMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGdldHMgaW5jbHVzaW9uL2V4Y2x1c2lvbiBwcm9vZiBvZiBhIGJ1Y2tldCBpbiB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgZ2V0UHJvb2YoaW5kZXgpIHtcbiAgICAgICAgbGV0IGN1cnIgPSB0aGlzLmJ1Y2tldHNbTnVtYmVyKGluZGV4KV07XG4gICAgICAgIGNvbnN0IHByb29mID0gW107XG4gICAgICAgIHdoaWxlIChjdXJyICYmIGN1cnIucGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9ICEhY3Vyci5yaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGJ1Y2tldCA9IGN1cnIucmlnaHQgPyBjdXJyLnJpZ2h0IDogY3Vyci5sZWZ0O1xuICAgICAgICAgICAgY3VyciA9IGN1cnIucGFyZW50O1xuICAgICAgICAgICAgcHJvb2YucHVzaChuZXcgUHJvb2ZTdGVwKGJ1Y2tldCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvb2Y7XG4gICAgfVxuICAgIHN1bShhcnIpIHtcbiAgICAgICAgbGV0IHRvdGFsID0gQmlnSW50KDApO1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFycikge1xuICAgICAgICAgICAgdG90YWwgKz0gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIC8vIHZhbGlkYXRlcyB0aGUgc3VwcHBsaWVkIHByb29mIGZvciBhIHNwZWNpZmllZCBsZWFmIGFjY29yZGluZyB0byB0aGUgcm9vdCBidWNrZXRcbiAgICB2ZXJpZnlQcm9vZihyb290LCBsZWFmLCBwcm9vZikge1xuICAgICAgICBjb25zdCBybmcgPSBbdGhpcy5zdW0ocHJvb2YuZmlsdGVyKHggPT4gIXgucmlnaHQpLm1hcCh4ID0+IHguYnVja2V0LnNpemUpKSwgQmlnSW50KHJvb3Quc2l6ZSkgLSB0aGlzLnN1bShwcm9vZi5maWx0ZXIoeCA9PiB4LnJpZ2h0KS5tYXAoeCA9PiB4LmJ1Y2tldC5zaXplKSldO1xuICAgICAgICBpZiAoIShybmdbMF0gPT09IGxlYWYucm5nWzBdICYmIHJuZ1sxXSA9PT0gbGVhZi5ybmdbMV0pKSB7XG4gICAgICAgICAgICAvLyBzdXBwbGllZCBzdGVwcyBhcmUgbm90IHJvdXRpbmcgdG8gdGhlIHJhbmdlIHNwZWNpZmllZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyID0gbGVhZi5nZXRCdWNrZXQoKTtcbiAgICAgICAgbGV0IGhhc2hlZDtcbiAgICAgICAgZm9yIChjb25zdCBzdGVwIG9mIHByb29mKSB7XG4gICAgICAgICAgICBpZiAoc3RlcC5yaWdodCkge1xuICAgICAgICAgICAgICAgIGhhc2hlZCA9IHRoaXMuaGFzaEZuKEJ1ZmZlci5jb25jYXQoW3RoaXMuc2l6ZVRvQnVmZmVyKGN1cnIuc2l6ZSksIHRoaXMuYnVmZmVyaWZ5KGN1cnIuaGFzaGVkKSwgdGhpcy5zaXplVG9CdWZmZXIoc3RlcC5idWNrZXQuc2l6ZSksIHRoaXMuYnVmZmVyaWZ5KHN0ZXAuYnVja2V0Lmhhc2hlZCldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYXNoZWQgPSB0aGlzLmhhc2hGbihCdWZmZXIuY29uY2F0KFt0aGlzLnNpemVUb0J1ZmZlcihzdGVwLmJ1Y2tldC5zaXplKSwgdGhpcy5idWZmZXJpZnkoc3RlcC5idWNrZXQuaGFzaGVkKSwgdGhpcy5zaXplVG9CdWZmZXIoY3Vyci5zaXplKSwgdGhpcy5idWZmZXJpZnkoY3Vyci5oYXNoZWQpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyciA9IG5ldyBCdWNrZXQoQmlnSW50KGN1cnIuc2l6ZSkgKyBCaWdJbnQoc3RlcC5idWNrZXQuc2l6ZSksIGhhc2hlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnIuc2l6ZSA9PT0gcm9vdC5zaXplICYmIGN1cnIuaGFzaGVkLnRvU3RyaW5nKCdoZXgnKSA9PT0gcm9vdC5oYXNoZWQudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVya2xlU3VtVHJlZSA9IE1lcmtsZVN1bVRyZWU7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICA7XG4gICAgd2luZG93Lk1lcmtsZVN1bVRyZWUgPSBNZXJrbGVTdW1UcmVlO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gTWVya2xlU3VtVHJlZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/MerkleSumTree.js\n");

/***/ }),

/***/ "(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/MerkleTree.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/MerkleTree.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MerkleTree = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst buffer_reverse_1 = __importDefault(__webpack_require__(/*! buffer-reverse */ \"(ssr)/../../../node_modules/.pnpm/buffer-reverse@1.0.1/node_modules/buffer-reverse/index.js\"));\nconst sha256_1 = __importDefault(__webpack_require__(/*! crypto-js/sha256 */ \"(ssr)/../../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha256.js\"));\nconst treeify_1 = __importDefault(__webpack_require__(/*! treeify */ \"(ssr)/../../../node_modules/.pnpm/treeify@1.1.0/node_modules/treeify/treeify.js\"));\nconst Base_1 = __importDefault(__webpack_require__(/*! ./Base */ \"(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/Base.js\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nclass MerkleTree extends Base_1.default {\n    /**\n     * @desc Constructs a Merkle Tree.\n     * All nodes and leaves are stored as Buffers.\n     * Lonely leaf nodes are promoted to the next level up without being hashed again.\n     * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n     * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @example\n     *```js\n     *const MerkleTree = require('merkletreejs')\n     *const crypto = require('crypto')\n     *\n     *function sha256(data) {\n     *  // returns Buffer\n     *  return crypto.createHash('sha256').update(data).digest()\n     *}\n     *\n     *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n     *\n     *const tree = new MerkleTree(leaves, sha256)\n     *```\n     */\n    constructor(leaves, hashFn = sha256_1.default, options = {}) {\n        super();\n        this.duplicateOdd = false;\n        this.concatenator = buffer_1.Buffer.concat;\n        this.hashLeaves = false;\n        this.isBitcoinTree = false;\n        this.leaves = [];\n        this.layers = [];\n        this.sortLeaves = false;\n        this.sortPairs = false;\n        this.sort = false;\n        this.fillDefaultHash = null;\n        this.complete = false;\n        if (options.complete) {\n            if (options.isBitcoinTree) {\n                throw new Error('option \"complete\" is incompatible with \"isBitcoinTree\"');\n            }\n            if (options.duplicateOdd) {\n                throw new Error('option \"complete\" is incompatible with \"duplicateOdd\"');\n            }\n        }\n        this.isBitcoinTree = !!options.isBitcoinTree;\n        this.hashLeaves = !!options.hashLeaves;\n        this.sortLeaves = !!options.sortLeaves;\n        this.sortPairs = !!options.sortPairs;\n        this.complete = !!options.complete;\n        if (options.fillDefaultHash) {\n            if (typeof options.fillDefaultHash === 'function') {\n                this.fillDefaultHash = options.fillDefaultHash;\n            }\n            else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n                this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n            }\n            else {\n                throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n            }\n        }\n        this.sort = !!options.sort;\n        if (this.sort) {\n            this.sortLeaves = true;\n            this.sortPairs = true;\n        }\n        this.duplicateOdd = !!options.duplicateOdd;\n        if (options.concatenator) {\n            this.concatenator = options.concatenator;\n        }\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.processLeaves(leaves);\n    }\n    getOptions() {\n        var _a, _b;\n        return {\n            complete: this.complete,\n            isBitcoinTree: this.isBitcoinTree,\n            hashLeaves: this.hashLeaves,\n            sortLeaves: this.sortLeaves,\n            sortPairs: this.sortPairs,\n            sort: this.sort,\n            fillDefaultHash: (_b = (_a = this.fillDefaultHash) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null,\n            duplicateOdd: this.duplicateOdd\n        };\n    }\n    processLeaves(leaves) {\n        if (this.hashLeaves) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.leaves = leaves.map(this.bufferify);\n        if (this.sortLeaves) {\n            this.leaves = this.leaves.sort(buffer_1.Buffer.compare);\n        }\n        if (this.fillDefaultHash) {\n            for (let i = this.leaves.length; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n                this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n            }\n        }\n        this.createHashes(this.leaves);\n    }\n    createHashes(nodes) {\n        this.layers = [nodes];\n        while (nodes.length > 1) {\n            const layerIndex = this.layers.length;\n            this.layers.push([]);\n            const layerLimit = this.complete && layerIndex === 1 && !Number.isInteger(Math.log2(nodes.length))\n                ? (2 * nodes.length) - (Math.pow(2, Math.ceil(Math.log2(nodes.length))))\n                : nodes.length;\n            for (let i = 0; i < nodes.length; i += 2) {\n                if (i >= layerLimit) {\n                    this.layers[layerIndex].push(...nodes.slice(layerLimit));\n                    break;\n                }\n                else if (i + 1 === nodes.length) {\n                    if (nodes.length % 2 === 1) {\n                        const data = nodes[nodes.length - 1];\n                        let hash = data;\n                        // is bitcoin tree\n                        if (this.isBitcoinTree) {\n                            // Bitcoin method of duplicating the odd ending nodes\n                            hash = this.hashFn(this.concatenator([buffer_reverse_1.default(data), buffer_reverse_1.default(data)]));\n                            hash = buffer_reverse_1.default(this.hashFn(hash));\n                            this.layers[layerIndex].push(hash);\n                            continue;\n                        }\n                        else {\n                            if (this.duplicateOdd) {\n                                // continue with creating layer\n                            }\n                            else {\n                                // push copy of hash and continue iteration\n                                this.layers[layerIndex].push(nodes[i]);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                const left = nodes[i];\n                const right = i + 1 === nodes.length ? left : nodes[i + 1];\n                let combined = null;\n                if (this.isBitcoinTree) {\n                    combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n                }\n                else {\n                    combined = [left, right];\n                }\n                if (this.sortPairs) {\n                    combined.sort(buffer_1.Buffer.compare);\n                }\n                let hash = this.hashFn(this.concatenator(combined));\n                // double hash if bitcoin tree\n                if (this.isBitcoinTree) {\n                    hash = buffer_reverse_1.default(this.hashFn(hash));\n                }\n                this.layers[layerIndex].push(hash);\n            }\n            nodes = this.layers[layerIndex];\n        }\n    }\n    /**\n     * addLeaf\n     * @desc Adds a leaf to the tree and re-calculates layers.\n     * @param {String|Buffer} - Leaf\n     * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaf(newLeaf)\n     *```\n     */\n    addLeaf(leaf, shouldHash = false) {\n        if (shouldHash) {\n            leaf = this.hashFn(leaf);\n        }\n        this.processLeaves(this.leaves.concat(leaf));\n    }\n    /**\n     * addLeaves\n     * @desc Adds multiple leaves to the tree and re-calculates layers.\n     * @param {String[]|Buffer[]} - Array of leaves\n     * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaves(newLeaves)\n     *```\n     */\n    addLeaves(leaves, shouldHash = false) {\n        if (shouldHash) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.processLeaves(this.leaves.concat(leaves));\n    }\n    /**\n     * getLeaves\n     * @desc Returns array of leaves of Merkle Tree.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *```\n     */\n    getLeaves(values) {\n        if (Array.isArray(values)) {\n            if (this.hashLeaves) {\n                values = values.map(this.hashFn);\n                if (this.sortLeaves) {\n                    values = values.sort(buffer_1.Buffer.compare);\n                }\n            }\n            return this.leaves.filter(leaf => this.bufferIndexOf(values, leaf, this.sortLeaves) !== -1);\n        }\n        return this.leaves;\n    }\n    /**\n     * getLeaf\n     * @desc Returns the leaf at the given index.\n     * @param {Number} - Index number\n     * @return {Buffer}\n     * @example\n     *```js\n     *const leaf = tree.getLeaf(1)\n     *```\n     */\n    getLeaf(index) {\n        if (index < 0 || index > this.leaves.length - 1) {\n            return buffer_1.Buffer.from([]);\n        }\n        return this.leaves[index];\n    }\n    /**\n     * getLeafIndex\n     * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n     * @param {String|Buffer} - Target leaf\n     * @return {number}\n     * @example\n     *```js\n     *const leaf = Buffer.from('abc')\n     *const index = tree.getLeafIndex(leaf)\n     *```\n     */\n    getLeafIndex(target) {\n        target = this.bufferify(target);\n        const leaves = this.getLeaves();\n        for (let i = 0; i < leaves.length; i++) {\n            const leaf = leaves[i];\n            if (leaf.equals(target)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * getLeafCount\n     * @desc Returns the total number of leaves.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLeafCount()\n     *```\n     */\n    getLeafCount() {\n        return this.leaves.length;\n    }\n    /**\n     * getHexLeaves\n     * @desc Returns array of leaves of Merkle Tree as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const leaves = tree.getHexLeaves()\n     *```\n     */\n    getHexLeaves() {\n        return this.leaves.map(leaf => this.bufferToHex(leaf));\n    }\n    /**\n     * marshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a JSON string.\n     * @param {String[]|Buffer[]} - Merkle tree leaves\n     * @return {String} - List of leaves as JSON string\n     * @example\n     *```js\n     *const jsonStr = MerkleTree.marshalLeaves(leaves)\n     *```\n     */\n    static marshalLeaves(leaves) {\n        return JSON.stringify(leaves.map(leaf => MerkleTree.bufferToHex(leaf)), null, 2);\n    }\n    /**\n     * unmarshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a Buffers.\n     * @param {String|Object} - JSON stringified leaves\n     * @return {Buffer[]} - Unmarshalled list of leaves\n     * @example\n     *```js\n     *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n     *```\n     */\n    static unmarshalLeaves(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(MerkleTree.bufferify);\n    }\n    /**\n     * getLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[][]}\n     * @example\n     *```js\n     *const layers = tree.getLayers()\n     *```\n     */\n    getLayers() {\n        return this.layers;\n    }\n    /**\n     * getHexLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n     * @return {String[][]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayers()\n     *```\n     */\n    getHexLayers() {\n        return this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.push(item.map(layer => this.bufferToHex(layer)));\n            }\n            else {\n                acc.push(item);\n            }\n            return acc;\n        }, []);\n    }\n    /**\n     * getLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayersFlat()\n     *```\n     */\n    getLayersFlat() {\n        const layers = this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.unshift(...item);\n            }\n            else {\n                acc.unshift(item);\n            }\n            return acc;\n        }, []);\n        layers.unshift(buffer_1.Buffer.from([0]));\n        return layers;\n    }\n    /**\n     * getHexLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayersFlat()\n     *```\n     */\n    getHexLayersFlat() {\n        return this.getLayersFlat().map(layer => this.bufferToHex(layer));\n    }\n    /**\n     * getLayerCount\n     * @desc Returns the total number of layers.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLayerCount()\n     *```\n     */\n    getLayerCount() {\n        return this.getLayers().length;\n    }\n    /**\n     * getRoot\n     * @desc Returns the Merkle root hash as a Buffer.\n     * @return {Buffer}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *```\n     */\n    getRoot() {\n        if (this.layers.length === 0) {\n            return buffer_1.Buffer.from([]);\n        }\n        return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);\n    }\n    /**\n     * getHexRoot\n     * @desc Returns the Merkle root hash as a hex string.\n     * @return {String}\n     * @example\n     *```js\n     *const root = tree.getHexRoot()\n     *```\n     */\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * getProof\n     * @desc Returns the proof for a target leaf.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer.\n     * @example\n     * ```js\n     *const proof = tree.getProof(leaves[2])\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proof = tree.getProof(leaves[2], 2)\n     *```\n     */\n    getProof(leaf, index) {\n        if (typeof leaf === 'undefined') {\n            throw new Error('leaf is required');\n        }\n        leaf = this.bufferify(leaf);\n        const proof = [];\n        if (!Number.isInteger(index)) {\n            index = -1;\n            for (let i = 0; i < this.leaves.length; i++) {\n                if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {\n                    index = i;\n                }\n            }\n        }\n        if (index <= -1) {\n            return [];\n        }\n        for (let i = 0; i < this.layers.length; i++) {\n            const layer = this.layers[i];\n            const isRightNode = index % 2;\n            const pairIndex = (isRightNode ? index - 1\n                : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1\n                    // Proof Generation for Bitcoin Trees\n                    ? index\n                    // Proof Generation for Non-Bitcoin Trees\n                    : index + 1);\n            if (pairIndex < layer.length) {\n                proof.push({\n                    position: isRightNode ? 'left' : 'right',\n                    data: layer[pairIndex]\n                });\n            }\n            // set index to parent index\n            index = (index / 2) | 0;\n        }\n        return proof;\n    }\n    /**\n     * getHexProof\n     * @desc Returns the proof for a target leaf as hex strings.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {String[]} - Proof array as hex strings.\n     * @example\n     * ```js\n     *const proof = tree.getHexProof(leaves[2])\n     *```\n     */\n    getHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(item => this.bufferToHex(item.data));\n    }\n    /**\n     * getProofs\n     * @desc Returns the proofs for all leaves.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer for all leaves.\n     * @example\n     * ```js\n     *const proofs = tree.getProofs()\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proofs = tree.getProofs()\n     *```\n     */\n    getProofs() {\n        const proof = [];\n        const proofs = [];\n        this.getProofsDFS(this.layers.length - 1, 0, proof, proofs);\n        return proofs;\n    }\n    /**\n     * getProofsDFS\n     * @desc Get all proofs through single traverse\n     * @param {Number} currentLayer - Current layer index in traverse.\n     * @param {Number} index - Current tarvese node index in traverse.\n     * @param {Object[]} proof - Proof chain for single leaf.\n     * @param {Object[]} proofs - Proofs for all leaves\n     * @example\n     * ```js\n     *const layers = tree.getLayers()\n     *const index = 0;\n     *let proof = [];\n     *let proofs = [];\n     *const proof = tree.getProofsDFS(layers, index, proof, proofs)\n     *```\n     */\n    getProofsDFS(currentLayer, index, proof, proofs) {\n        const isRightNode = index % 2;\n        if (currentLayer === -1) {\n            if (!isRightNode)\n                proofs.push([...proof].reverse());\n            return;\n        }\n        if (index >= this.layers[currentLayer].length)\n            return;\n        const layer = this.layers[currentLayer];\n        const pairIndex = isRightNode ? index - 1 : index + 1;\n        let pushed = false;\n        if (pairIndex < layer.length) {\n            pushed = true;\n            proof.push({\n                position: isRightNode ? 'left' : 'right',\n                data: layer[pairIndex]\n            });\n        }\n        const leftchildIndex = index * 2;\n        const rightchildIndex = index * 2 + 1;\n        this.getProofsDFS(currentLayer - 1, leftchildIndex, proof, proofs);\n        this.getProofsDFS(currentLayer - 1, rightchildIndex, proof, proofs);\n        if (pushed)\n            proof.splice(proof.length - 1, 1);\n    }\n    /**\n     * getHexProofs\n     * @desc Returns the proofs for all leaves as hex strings.\n     * @return {String[]} - Proofs array as hex strings.\n     * @example\n     * ```js\n     *const proofs = tree.getHexProofs()\n     *```\n     */\n    getHexProofs() {\n        return this.getProofs().map(item => this.bufferToHex(item.data));\n    }\n    /**\n    * getPositionalHexProof\n    * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n    * @param {Buffer} leaf - Target leaf\n    * @param {Number} [index] - Target leaf index in leaves array.\n    * Use if there are leaves containing duplicate data in order to distinguish it.\n    * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n    * @example\n    * ```js\n    *const proof = tree.getPositionalHexProof(leaves[2])\n    *```\n    */\n    getPositionalHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(item => {\n            return [\n                item.position === 'left' ? 0 : 1,\n                this.bufferToHex(item.data)\n            ];\n        });\n    }\n    /**\n     * marshalProof\n     * @desc Returns proof array as JSON string.\n     * @param {String[]|Object[]} proof - Merkle tree proof array\n     * @return {String} - Proof array as JSON string.\n     * @example\n     * ```js\n     *const jsonStr = MerkleTree.marshalProof(proof)\n     *```\n     */\n    static marshalProof(proof) {\n        const json = proof.map(item => {\n            if (typeof item === 'string') {\n                return item;\n            }\n            if (buffer_1.Buffer.isBuffer(item)) {\n                return MerkleTree.bufferToHex(item);\n            }\n            return {\n                position: item.position,\n                data: MerkleTree.bufferToHex(item.data)\n            };\n        });\n        return JSON.stringify(json, null, 2);\n    }\n    /**\n     * unmarshalProof\n     * @desc Returns the proof for a target leaf as a list of Buffers.\n     * @param {String|Object} - Merkle tree leaves\n     * @return {String|Object} - Marshalled proof\n     * @example\n     * ```js\n     *const proof = MerkleTree.unmarshalProof(jsonStr)\n     *```\n     */\n    static unmarshalProof(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(item => {\n            if (typeof item === 'string') {\n                return MerkleTree.bufferify(item);\n            }\n            else if (item instanceof Object) {\n                return {\n                    position: item.position,\n                    data: MerkleTree.bufferify(item.data)\n                };\n            }\n            else {\n                throw new Error('Expected item to be of type string or object');\n            }\n        });\n    }\n    static marshalTree(tree) {\n        const root = tree.getHexRoot();\n        const leaves = tree.leaves.map(leaf => MerkleTree.bufferToHex(leaf));\n        const layers = tree.getHexLayers();\n        const options = tree.getOptions();\n        return JSON.stringify({\n            options,\n            root,\n            layers,\n            leaves\n        }, null, 2);\n    }\n    static unmarshalTree(jsonStr, hashFn = sha256_1.default, options = {}) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            throw new Error('could not parse json');\n        }\n        options = Object.assign({}, parsed.options || {}, options);\n        return new MerkleTree(parsed.leaves, hashFn, options);\n    }\n    /**\n     * getProofIndices\n     * @desc Returns the proof indices for given tree indices.\n     * @param {Number[]} treeIndices - Tree indices\n     * @param {Number} depth - Tree depth; number of layers.\n     * @return {Number[]} - Proof indices\n     * @example\n     * ```js\n     *const proofIndices = tree.getProofIndices([2,5,6], 4)\n     *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n     *```\n     */\n    getProofIndices(treeIndices, depth) {\n        const leafCount = Math.pow(2, depth);\n        let maximalIndices = new Set();\n        for (const index of treeIndices) {\n            let x = leafCount + index;\n            while (x > 1) {\n                maximalIndices.add(x ^ 1);\n                x = (x / 2) | 0;\n            }\n        }\n        const a = treeIndices.map(index => leafCount + index);\n        const b = Array.from(maximalIndices).sort((a, b) => a - b).reverse();\n        maximalIndices = a.concat(b);\n        const redundantIndices = new Set();\n        const proof = [];\n        for (let index of maximalIndices) {\n            if (!redundantIndices.has(index)) {\n                proof.push(index);\n                while (index > 1) {\n                    redundantIndices.add(index);\n                    if (!redundantIndices.has(index ^ 1))\n                        break;\n                    index = (index / 2) | 0;\n                }\n            }\n        }\n        return proof.filter(index => {\n            return !treeIndices.includes(index - leafCount);\n        });\n    }\n    getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n        const depth = Math.ceil(Math.log2(leavesCount));\n        const unevenLayers = [];\n        for (let index = 0; index < depth; index++) {\n            const unevenLayer = leavesCount % 2 !== 0;\n            if (unevenLayer) {\n                unevenLayers.push({ index, leavesCount });\n            }\n            leavesCount = Math.ceil(leavesCount / 2);\n        }\n        const proofIndices = [];\n        let layerNodes = sortedLeafIndices;\n        for (let layerIndex = 0; layerIndex < depth; layerIndex++) {\n            const siblingIndices = layerNodes.map((index) => {\n                if (index % 2 === 0) {\n                    return index + 1;\n                }\n                return index - 1;\n            });\n            let proofNodeIndices = siblingIndices.filter((index) => !layerNodes.includes(index));\n            const unevenLayer = unevenLayers.find(({ index }) => index === layerIndex);\n            if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n                proofNodeIndices = proofNodeIndices.slice(0, -1);\n            }\n            proofIndices.push(proofNodeIndices);\n            layerNodes = [...new Set(layerNodes.map((index) => {\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))];\n        }\n        return proofIndices;\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *```\n     */\n    getMultiProof(tree, indices) {\n        if (!this.complete) {\n            console.warn('Warning: For correct multiProofs it\\'s strongly recommended to set complete: true');\n        }\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayersFlat();\n        }\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            if (indices.every(Number.isInteger)) {\n                return this.getMultiProofForUnevenTree(indices);\n            }\n        }\n        if (!indices.every(Number.isInteger)) {\n            let els = indices;\n            if (this.sortPairs) {\n                els = els.sort(buffer_1.Buffer.compare);\n            }\n            let ids = els.map((el) => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n            if (!ids.every((idx) => idx !== -1)) {\n                throw new Error('Element does not exist in Merkle tree');\n            }\n            const hashes = [];\n            const proof = [];\n            let nextIds = [];\n            for (let i = 0; i < this.layers.length; i++) {\n                const layer = this.layers[i];\n                for (let j = 0; j < ids.length; j++) {\n                    const idx = ids[j];\n                    const pairElement = this.getPairNode(layer, idx);\n                    hashes.push(layer[idx]);\n                    if (pairElement) {\n                        proof.push(pairElement);\n                    }\n                    nextIds.push((idx / 2) | 0);\n                }\n                ids = nextIds.filter((value, i, self) => self.indexOf(value) === i);\n                nextIds = [];\n            }\n            return proof.filter((value) => !hashes.includes(value));\n        }\n        return this.getProofIndices(indices, Math.log2((tree.length / 2) | 0)).map(index => tree[index]);\n    }\n    getMultiProofForUnevenTree(tree, indices) {\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayers();\n        }\n        let proofHashes = [];\n        let currentLayerIndices = indices;\n        for (const treeLayer of tree) {\n            const siblings = [];\n            for (const index of currentLayerIndices) {\n                if (index % 2 === 0) {\n                    const idx = index + 1;\n                    if (!currentLayerIndices.includes(idx)) {\n                        if (treeLayer[idx]) {\n                            siblings.push(treeLayer[idx]);\n                            continue;\n                        }\n                    }\n                }\n                const idx = index - 1;\n                if (!currentLayerIndices.includes(idx)) {\n                    if (treeLayer[idx]) {\n                        siblings.push(treeLayer[idx]);\n                        continue;\n                    }\n                }\n            }\n            proofHashes = proofHashes.concat(siblings);\n            const uniqueIndices = new Set();\n            for (const index of currentLayerIndices) {\n                if (index % 2 === 0) {\n                    uniqueIndices.add(index / 2);\n                    continue;\n                }\n                if (index % 2 === 0) {\n                    uniqueIndices.add((index + 1) / 2);\n                    continue;\n                }\n                uniqueIndices.add((index - 1) / 2);\n            }\n            currentLayerIndices = Array.from(uniqueIndices);\n        }\n        return proofHashes;\n    }\n    /**\n     * getHexMultiProof\n     * @desc Returns the multiproof for given tree indices as hex strings.\n     * @param {Number[]} indices - Tree indices.\n     * @return {String[]} - Multiproofs as hex strings.\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getHexMultiProof(indices)\n     *```\n     */\n    getHexMultiProof(tree, indices) {\n        return this.getMultiProof(tree, indices).map((x) => this.bufferToHex(x));\n    }\n    /**\n     * getProofFlags\n     * @desc Returns list of booleans where proofs should be used instead of hashing.\n     * Proof flags are used in the Solidity multiproof verifiers.\n     * @param {Number[]|Buffer[]} leaves\n     * @param {Buffer[]} proofs\n     * @return {Boolean[]} - Boolean flags\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *const proofFlags = tree.getProofFlags(leaves, proof)\n     *```\n     */\n    getProofFlags(leaves, proofs) {\n        if (!Array.isArray(leaves) || leaves.length <= 0) {\n            throw new Error('Invalid Inputs!');\n        }\n        let ids;\n        if (leaves.every(Number.isInteger)) {\n            ids = [...leaves].sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n        }\n        else {\n            ids = leaves.map((el) => this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n        }\n        if (!ids.every((idx) => idx !== -1)) {\n            throw new Error('Element does not exist in Merkle tree');\n        }\n        const _proofs = proofs.map(item => this.bufferify(item));\n        const tested = [];\n        const flags = [];\n        for (let index = 0; index < this.layers.length; index++) {\n            const layer = this.layers[index];\n            ids = ids.reduce((ids, idx) => {\n                const skipped = tested.includes(layer[idx]);\n                if (!skipped) {\n                    const pairElement = this.getPairNode(layer, idx);\n                    const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n                    pairElement && flags.push(!proofUsed);\n                    tested.push(layer[idx]);\n                    tested.push(pairElement);\n                }\n                ids.push((idx / 2) | 0);\n                return ids;\n            }, []);\n        }\n        return flags;\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const proof = tree.getProof(leaves[2])\n     *const verified = tree.verify(proof, leaves[2], root)\n     *```\n     */\n    verify(proof, targetNode, root) {\n        let hash = this.bufferify(targetNode);\n        root = this.bufferify(root);\n        if (!Array.isArray(proof) ||\n            !targetNode ||\n            !root) {\n            return false;\n        }\n        for (let i = 0; i < proof.length; i++) {\n            const node = proof[i];\n            let data = null;\n            let isLeftNode = null;\n            // case for when proof is hex values only\n            if (typeof node === 'string') {\n                data = this.bufferify(node);\n                isLeftNode = true;\n            }\n            else if (Array.isArray(node)) {\n                isLeftNode = (node[0] === 0);\n                data = this.bufferify(node[1]);\n            }\n            else if (buffer_1.Buffer.isBuffer(node)) {\n                data = node;\n                isLeftNode = true;\n            }\n            else if (node instanceof Object) {\n                data = this.bufferify(node.data);\n                isLeftNode = (node.position === 'left');\n            }\n            else {\n                throw new Error('Expected node to be of type string or object');\n            }\n            const buffers = [];\n            if (this.isBitcoinTree) {\n                buffers.push(buffer_reverse_1.default(hash));\n                buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n                hash = this.hashFn(this.concatenator(buffers));\n                hash = buffer_reverse_1.default(this.hashFn(hash));\n            }\n            else {\n                if (this.sortPairs) {\n                    if (buffer_1.Buffer.compare(hash, data) === -1) {\n                        buffers.push(hash, data);\n                        hash = this.hashFn(this.concatenator(buffers));\n                    }\n                    else {\n                        buffers.push(data, hash);\n                        hash = this.hashFn(this.concatenator(buffers));\n                    }\n                }\n                else {\n                    buffers.push(hash);\n                    buffers[isLeftNode ? 'unshift' : 'push'](data);\n                    hash = this.hashFn(this.concatenator(buffers));\n                }\n            }\n        }\n        return buffer_1.Buffer.compare(hash, root) === 0;\n    }\n    /**\n     * verifyMultiProof\n     * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n     * @param {Buffer} root - Merkle tree root\n     * @param {Number[]} proofIndices - Leave indices for proof\n     * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n     * @param {Number} leavesCount - Count of original leaves\n     * @param {Buffer[]} proof - Multiproofs given indices\n     * @return {Boolean}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *const root = tree.getRoot()\n     *const treeFlat = tree.getLayersFlat()\n     *const leavesCount = leaves.length\n     *const proofIndices = [2, 5, 6]\n     *const proofLeaves = proofIndices.map(i => leaves[i])\n     *const proof = tree.getMultiProof(treeFlat, indices)\n     *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n     *```\n     */\n    verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            // TODO: combine these functions and simplify\n            return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n        }\n        const depth = Math.ceil(Math.log2(leavesCount));\n        root = this.bufferify(root);\n        proofLeaves = proofLeaves.map(leaf => this.bufferify(leaf));\n        proof = proof.map(leaf => this.bufferify(leaf));\n        const tree = {};\n        for (const [index, leaf] of this.zip(proofIndices, proofLeaves)) {\n            tree[(Math.pow(2, depth)) + index] = leaf;\n        }\n        for (const [index, proofitem] of this.zip(this.getProofIndices(proofIndices, depth), proof)) {\n            tree[index] = proofitem;\n        }\n        let indexqueue = Object.keys(tree).map(value => +value).sort((a, b) => a - b);\n        indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n        let i = 0;\n        while (i < indexqueue.length) {\n            const index = indexqueue[i];\n            if (index >= 2 && ({}).hasOwnProperty.call(tree, index ^ 1)) {\n                let pair = [tree[index - (index % 2)], tree[index - (index % 2) + 1]];\n                if (this.sortPairs) {\n                    pair = pair.sort(buffer_1.Buffer.compare);\n                }\n                const hash = pair[1] ? this.hashFn(this.concatenator(pair)) : pair[0];\n                tree[(index / 2) | 0] = hash;\n                indexqueue.push((index / 2) | 0);\n            }\n            i += 1;\n        }\n        return !proofIndices.length || (({}).hasOwnProperty.call(tree, 1) && tree[1].equals(root));\n    }\n    verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n        root = this.bufferify(root);\n        leaves = leaves.map(this.bufferify);\n        proofs = proofs.map(this.bufferify);\n        const leavesLen = leaves.length;\n        const totalHashes = proofFlag.length;\n        const hashes = [];\n        let leafPos = 0;\n        let hashPos = 0;\n        let proofPos = 0;\n        for (let i = 0; i < totalHashes; i++) {\n            const bufA = proofFlag[i] ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++]) : proofs[proofPos++];\n            const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            const buffers = [bufA, bufB].sort(buffer_1.Buffer.compare);\n            hashes[i] = this.hashFn(this.concatenator(buffers));\n        }\n        return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;\n    }\n    verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n        root = this.bufferify(root);\n        leaves = leaves.map(leaf => this.bufferify(leaf));\n        proof = proof.map(leaf => this.bufferify(leaf));\n        const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n        return root.equals(computedRoot);\n    }\n    /**\n     * getDepth\n     * @desc Returns the tree depth (number of layers)\n     * @return {Number}\n     * @example\n     *```js\n     *const depth = tree.getDepth()\n     *```\n     */\n    getDepth() {\n        return this.getLayers().length - 1;\n    }\n    /**\n     * getLayersAsObject\n     * @desc Returns the layers as nested objects instead of an array.\n     * @example\n     *```js\n     *const layersObj = tree.getLayersAsObject()\n     *```\n     */\n    getLayersAsObject() {\n        const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(value, false)));\n        const objs = [];\n        for (let i = 0; i < layers.length; i++) {\n            const arr = [];\n            for (let j = 0; j < layers[i].length; j++) {\n                const obj = { [layers[i][j]]: null };\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    const a = objs.shift();\n                    const akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        const b = objs.shift();\n                        const bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push(...arr);\n        }\n        return objs[0];\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @return {Boolean}\n     * @example\n     *```js\n     *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n     *```\n     */\n    static verify(proof, targetNode, root, hashFn = sha256_1.default, options = {}) {\n        const tree = new MerkleTree([], hashFn, options);\n        return tree.verify(proof, targetNode, root);\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Buffer[]} tree - Tree as a flat array.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     *\n     *@example\n     * ```js\n     *const flatTree = tree.getLayersFlat()\n     *const indices = [2, 5, 6]\n     *const proof = MerkleTree.getMultiProof(flatTree, indices)\n     *```\n     */\n    static getMultiProof(tree, indices) {\n        const t = new MerkleTree([]);\n        return t.getMultiProof(tree, indices);\n    }\n    /**\n     * resetTree\n     * @desc Resets the tree by clearing the leaves and layers.\n     * @example\n     *```js\n     *tree.resetTree()\n     *```\n     */\n    resetTree() {\n        this.leaves = [];\n        this.layers = [];\n    }\n    /**\n     * getPairNode\n     * @desc Returns the node at the index for given layer.\n     * @param {Buffer[]} layer - Tree layer\n     * @param {Number} index - Index at layer.\n     * @return {Buffer} - Node\n     *\n     *@example\n     * ```js\n     *const node = tree.getPairNode(layer, index)\n     *```\n     */\n    getPairNode(layer, idx) {\n        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n        if (pairIdx < layer.length) {\n            return layer[pairIdx];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * toTreeString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @return {String}\n     * @example\n     *```js\n     *console.log(tree.toTreeString())\n     *```\n     */\n    toTreeString() {\n        const obj = this.getLayersAsObject();\n        return treeify_1.default.asTree(obj, true);\n    }\n    /**\n     * toString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @example\n     *```js\n     *console.log(tree.toString())\n     *```\n     */\n    toString() {\n        return this.toTreeString();\n    }\n    isUnevenTree(treeLayers) {\n        const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();\n        return !this.isPowOf2(depth);\n    }\n    isPowOf2(v) {\n        return v && !(v & (v - 1));\n    }\n    calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n        const leafTuples = this.zip(leafIndices, leafHashes).sort(([indexA], [indexB]) => indexA - indexB);\n        const leafTupleIndices = leafTuples.map(([index]) => index);\n        const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n        let nextSliceStart = 0;\n        const proofTuplesByLayers = [];\n        for (let i = 0; i < proofIndices.length; i++) {\n            const indices = proofIndices[i];\n            const sliceStart = nextSliceStart;\n            nextSliceStart += indices.length;\n            proofTuplesByLayers[i] = this.zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n        }\n        const tree = [leafTuples];\n        for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {\n            const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(([indexA], [indexB]) => indexA - indexB)\n                .map(([, hash]) => hash);\n            const s = tree[layerIndex].map(([layerIndex]) => layerIndex);\n            const parentIndices = [...new Set(s.map((index) => {\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))];\n            const parentLayer = [];\n            for (let i = 0; i < parentIndices.length; i++) {\n                const parentNodeTreeIndex = parentIndices[i];\n                const bufA = currentLayer[i * 2];\n                const bufB = currentLayer[i * 2 + 1];\n                const hash = bufB ? this.hashFn(this.concatenator([bufA, bufB])) : bufA;\n                parentLayer.push([parentNodeTreeIndex, hash]);\n            }\n            tree.push(parentLayer);\n        }\n        return tree[tree.length - 1][0][1];\n    }\n}\nexports.MerkleTree = MerkleTree;\nif (typeof window !== 'undefined') {\n    ;\n    window.MerkleTree = MerkleTree;\n}\nexports[\"default\"] = MerkleTree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21lcmtsZXRyZWVqc0AwLjMuMTEvbm9kZV9tb2R1bGVzL21lcmtsZXRyZWVqcy9kaXN0L01lcmtsZVRyZWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMseUNBQXlDLG1CQUFPLENBQUMsbUhBQWdCO0FBQ2pFLGlDQUFpQyxtQkFBTyxDQUFDLDRHQUFrQjtBQUMzRCxrQ0FBa0MsbUJBQU8sQ0FBQyxnR0FBUztBQUNuRCwrQkFBK0IsbUJBQU8sQ0FBQyw0R0FBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkRBQTJEO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRLG9CQUFvQjtBQUMzQyxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0JBQW9CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxVQUFVO0FBQ3pCLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlDQUF5QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZXhhbXBsZXMvbG9naW4td2l0aC1wYXNzcG9ydC1zaWxlbnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21lcmtsZXRyZWVqc0AwLjMuMTEvbm9kZV9tb2R1bGVzL21lcmtsZXRyZWVqcy9kaXN0L01lcmtsZVRyZWUuanM/MzY3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVya2xlVHJlZSA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbmNvbnN0IGJ1ZmZlcl9yZXZlcnNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJ1ZmZlci1yZXZlcnNlXCIpKTtcbmNvbnN0IHNoYTI1Nl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjcnlwdG8tanMvc2hhMjU2XCIpKTtcbmNvbnN0IHRyZWVpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidHJlZWlmeVwiKSk7XG5jb25zdCBCYXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vQmFzZVwiKSk7XG4vKipcbiAqIENsYXNzIHJlcHJlbnNlbnRpbmcgYSBNZXJrbGUgVHJlZVxuICogQG5hbWVzcGFjZSBNZXJrbGVUcmVlXG4gKi9cbmNsYXNzIE1lcmtsZVRyZWUgZXh0ZW5kcyBCYXNlXzEuZGVmYXVsdCB7XG4gICAgLyoqXG4gICAgICogQGRlc2MgQ29uc3RydWN0cyBhIE1lcmtsZSBUcmVlLlxuICAgICAqIEFsbCBub2RlcyBhbmQgbGVhdmVzIGFyZSBzdG9yZWQgYXMgQnVmZmVycy5cbiAgICAgKiBMb25lbHkgbGVhZiBub2RlcyBhcmUgcHJvbW90ZWQgdG8gdGhlIG5leHQgbGV2ZWwgdXAgd2l0aG91dCBiZWluZyBoYXNoZWQgYWdhaW4uXG4gICAgICogQHBhcmFtIHtCdWZmZXJbXX0gbGVhdmVzIC0gQXJyYXkgb2YgaGFzaGVkIGxlYXZlcy4gRWFjaCBsZWFmIG11c3QgYmUgYSBCdWZmZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzaEZ1bmN0aW9uIC0gSGFzaCBmdW5jdGlvbiB0byB1c2UgZm9yIGhhc2hpbmcgbGVhdmVzIGFuZCBub2Rlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBNZXJrbGVUcmVlID0gcmVxdWlyZSgnbWVya2xldHJlZWpzJylcbiAgICAgKmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG4gICAgICpcbiAgICAgKmZ1bmN0aW9uIHNoYTI1NihkYXRhKSB7XG4gICAgICogIC8vIHJldHVybnMgQnVmZmVyXG4gICAgICogIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gICAgICp9XG4gICAgICpcbiAgICAgKmNvbnN0IGxlYXZlcyA9IFsnYScsICdiJywgJ2MnXS5tYXAodmFsdWUgPT4ga2VjY2FrKHZhbHVlKSlcbiAgICAgKlxuICAgICAqY29uc3QgdHJlZSA9IG5ldyBNZXJrbGVUcmVlKGxlYXZlcywgc2hhMjU2KVxuICAgICAqYGBgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGVhdmVzLCBoYXNoRm4gPSBzaGEyNTZfMS5kZWZhdWx0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5kdXBsaWNhdGVPZGQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25jYXRlbmF0b3IgPSBidWZmZXJfMS5CdWZmZXIuY29uY2F0O1xuICAgICAgICB0aGlzLmhhc2hMZWF2ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0JpdGNvaW5UcmVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVhdmVzID0gW107XG4gICAgICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgICAgIHRoaXMuc29ydExlYXZlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNvcnRQYWlycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNvcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maWxsRGVmYXVsdEhhc2ggPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pc0JpdGNvaW5UcmVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb24gXCJjb21wbGV0ZVwiIGlzIGluY29tcGF0aWJsZSB3aXRoIFwiaXNCaXRjb2luVHJlZVwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kdXBsaWNhdGVPZGQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbiBcImNvbXBsZXRlXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggXCJkdXBsaWNhdGVPZGRcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNCaXRjb2luVHJlZSA9ICEhb3B0aW9ucy5pc0JpdGNvaW5UcmVlO1xuICAgICAgICB0aGlzLmhhc2hMZWF2ZXMgPSAhIW9wdGlvbnMuaGFzaExlYXZlcztcbiAgICAgICAgdGhpcy5zb3J0TGVhdmVzID0gISFvcHRpb25zLnNvcnRMZWF2ZXM7XG4gICAgICAgIHRoaXMuc29ydFBhaXJzID0gISFvcHRpb25zLnNvcnRQYWlycztcbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9ICEhb3B0aW9ucy5jb21wbGV0ZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmlsbERlZmF1bHRIYXNoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsbERlZmF1bHRIYXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsRGVmYXVsdEhhc2ggPSBvcHRpb25zLmZpbGxEZWZhdWx0SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmZpbGxEZWZhdWx0SGFzaCkgfHwgdHlwZW9mIG9wdGlvbnMuZmlsbERlZmF1bHRIYXNoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsbERlZmF1bHRIYXNoID0gKGlkeCwgaGFzaEZuKSA9PiBvcHRpb25zLmZpbGxEZWZhdWx0SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIFwiZmlsbERlZmF1bHRIYXNoXCIgbXVzdCBiZSBhIGZ1bmN0aW9uLCBCdWZmZXIsIG9yIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ydCA9ICEhb3B0aW9ucy5zb3J0O1xuICAgICAgICBpZiAodGhpcy5zb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRMZWF2ZXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zb3J0UGFpcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHVwbGljYXRlT2RkID0gISFvcHRpb25zLmR1cGxpY2F0ZU9kZDtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29uY2F0ZW5hdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmNhdGVuYXRvciA9IG9wdGlvbnMuY29uY2F0ZW5hdG9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzaEZuID0gdGhpcy5idWZmZXJpZnlGbihoYXNoRm4pO1xuICAgICAgICB0aGlzLnByb2Nlc3NMZWF2ZXMobGVhdmVzKTtcbiAgICB9XG4gICAgZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbXBsZXRlOiB0aGlzLmNvbXBsZXRlLFxuICAgICAgICAgICAgaXNCaXRjb2luVHJlZTogdGhpcy5pc0JpdGNvaW5UcmVlLFxuICAgICAgICAgICAgaGFzaExlYXZlczogdGhpcy5oYXNoTGVhdmVzLFxuICAgICAgICAgICAgc29ydExlYXZlczogdGhpcy5zb3J0TGVhdmVzLFxuICAgICAgICAgICAgc29ydFBhaXJzOiB0aGlzLnNvcnRQYWlycyxcbiAgICAgICAgICAgIHNvcnQ6IHRoaXMuc29ydCxcbiAgICAgICAgICAgIGZpbGxEZWZhdWx0SGFzaDogKF9iID0gKF9hID0gdGhpcy5maWxsRGVmYXVsdEhhc2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLFxuICAgICAgICAgICAgZHVwbGljYXRlT2RkOiB0aGlzLmR1cGxpY2F0ZU9kZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwcm9jZXNzTGVhdmVzKGxlYXZlcykge1xuICAgICAgICBpZiAodGhpcy5oYXNoTGVhdmVzKSB7XG4gICAgICAgICAgICBsZWF2ZXMgPSBsZWF2ZXMubWFwKHRoaXMuaGFzaEZuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlYXZlcyA9IGxlYXZlcy5tYXAodGhpcy5idWZmZXJpZnkpO1xuICAgICAgICBpZiAodGhpcy5zb3J0TGVhdmVzKSB7XG4gICAgICAgICAgICB0aGlzLmxlYXZlcyA9IHRoaXMubGVhdmVzLnNvcnQoYnVmZmVyXzEuQnVmZmVyLmNvbXBhcmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbGxEZWZhdWx0SGFzaCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVhdmVzLmxlbmd0aDsgaSA8IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIodGhpcy5sZWF2ZXMubGVuZ3RoKSkpOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy5wdXNoKHRoaXMuYnVmZmVyaWZ5KHRoaXMuZmlsbERlZmF1bHRIYXNoKGksIHRoaXMuaGFzaEZuKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlSGFzaGVzKHRoaXMubGVhdmVzKTtcbiAgICB9XG4gICAgY3JlYXRlSGFzaGVzKG5vZGVzKSB7XG4gICAgICAgIHRoaXMubGF5ZXJzID0gW25vZGVzXTtcbiAgICAgICAgd2hpbGUgKG5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxheWVySW5kZXggPSB0aGlzLmxheWVycy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmxheWVycy5wdXNoKFtdKTtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyTGltaXQgPSB0aGlzLmNvbXBsZXRlICYmIGxheWVySW5kZXggPT09IDEgJiYgIU51bWJlci5pc0ludGVnZXIoTWF0aC5sb2cyKG5vZGVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgPyAoMiAqIG5vZGVzLmxlbmd0aCkgLSAoTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nMihub2Rlcy5sZW5ndGgpKSkpXG4gICAgICAgICAgICAgICAgOiBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gbGF5ZXJMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxheWVyc1tsYXllckluZGV4XS5wdXNoKC4uLm5vZGVzLnNsaWNlKGxheWVyTGltaXQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgKyAxID09PSBub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoYXNoID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGJpdGNvaW4gdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNCaXRjb2luVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJpdGNvaW4gbWV0aG9kIG9mIGR1cGxpY2F0aW5nIHRoZSBvZGQgZW5kaW5nIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaCA9IHRoaXMuaGFzaEZuKHRoaXMuY29uY2F0ZW5hdG9yKFtidWZmZXJfcmV2ZXJzZV8xLmRlZmF1bHQoZGF0YSksIGJ1ZmZlcl9yZXZlcnNlXzEuZGVmYXVsdChkYXRhKV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoID0gYnVmZmVyX3JldmVyc2VfMS5kZWZhdWx0KHRoaXMuaGFzaEZuKGhhc2gpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxheWVyc1tsYXllckluZGV4XS5wdXNoKGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZHVwbGljYXRlT2RkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIHdpdGggY3JlYXRpbmcgbGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggY29weSBvZiBoYXNoIGFuZCBjb250aW51ZSBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXllcnNbbGF5ZXJJbmRleF0ucHVzaChub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBpICsgMSA9PT0gbm9kZXMubGVuZ3RoID8gbGVmdCA6IG5vZGVzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBsZXQgY29tYmluZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQml0Y29pblRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tYmluZWQgPSBbYnVmZmVyX3JldmVyc2VfMS5kZWZhdWx0KGxlZnQpLCBidWZmZXJfcmV2ZXJzZV8xLmRlZmF1bHQocmlnaHQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkID0gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc29ydFBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkLnNvcnQoYnVmZmVyXzEuQnVmZmVyLmNvbXBhcmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaGFzaCA9IHRoaXMuaGFzaEZuKHRoaXMuY29uY2F0ZW5hdG9yKGNvbWJpbmVkKSk7XG4gICAgICAgICAgICAgICAgLy8gZG91YmxlIGhhc2ggaWYgYml0Y29pbiB0cmVlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNCaXRjb2luVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNoID0gYnVmZmVyX3JldmVyc2VfMS5kZWZhdWx0KHRoaXMuaGFzaEZuKGhhc2gpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sYXllcnNbbGF5ZXJJbmRleF0ucHVzaChoYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzID0gdGhpcy5sYXllcnNbbGF5ZXJJbmRleF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYWRkTGVhZlxuICAgICAqIEBkZXNjIEFkZHMgYSBsZWFmIHRvIHRoZSB0cmVlIGFuZCByZS1jYWxjdWxhdGVzIGxheWVycy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IC0gTGVhZlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gLSBTZXQgdG8gdHJ1ZSBpZiB0aGUgbGVhZiBzaG91bGQgYmUgaGFzaGVkIGJlZm9yZSBiZWluZyBhZGRlZCB0byB0cmVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqdHJlZS5hZGRMZWFmKG5ld0xlYWYpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBhZGRMZWFmKGxlYWYsIHNob3VsZEhhc2ggPSBmYWxzZSkge1xuICAgICAgICBpZiAoc2hvdWxkSGFzaCkge1xuICAgICAgICAgICAgbGVhZiA9IHRoaXMuaGFzaEZuKGxlYWYpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc0xlYXZlcyh0aGlzLmxlYXZlcy5jb25jYXQobGVhZikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhZGRMZWF2ZXNcbiAgICAgKiBAZGVzYyBBZGRzIG11bHRpcGxlIGxlYXZlcyB0byB0aGUgdHJlZSBhbmQgcmUtY2FsY3VsYXRlcyBsYXllcnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxCdWZmZXJbXX0gLSBBcnJheSBvZiBsZWF2ZXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IC0gU2V0IHRvIHRydWUgaWYgdGhlIGxlYXZlcyBzaG91bGQgYmUgaGFzaGVkIGJlZm9yZSBiZWluZyBhZGRlZCB0byB0cmVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqdHJlZS5hZGRMZWF2ZXMobmV3TGVhdmVzKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgYWRkTGVhdmVzKGxlYXZlcywgc2hvdWxkSGFzaCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChzaG91bGRIYXNoKSB7XG4gICAgICAgICAgICBsZWF2ZXMgPSBsZWF2ZXMubWFwKHRoaXMuaGFzaEZuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NMZWF2ZXModGhpcy5sZWF2ZXMuY29uY2F0KGxlYXZlcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRMZWF2ZXNcbiAgICAgKiBAZGVzYyBSZXR1cm5zIGFycmF5IG9mIGxlYXZlcyBvZiBNZXJrbGUgVHJlZS5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJbXX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGxlYXZlcyA9IHRyZWUuZ2V0TGVhdmVzKClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldExlYXZlcyh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzaExlYXZlcykge1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAodGhpcy5oYXNoRm4pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvcnRMZWF2ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLnNvcnQoYnVmZmVyXzEuQnVmZmVyLmNvbXBhcmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlYXZlcy5maWx0ZXIobGVhZiA9PiB0aGlzLmJ1ZmZlckluZGV4T2YodmFsdWVzLCBsZWFmLCB0aGlzLnNvcnRMZWF2ZXMpICE9PSAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGVhdmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRMZWFmXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgbGVhZiBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IC0gSW5kZXggbnVtYmVyXG4gICAgICogQHJldHVybiB7QnVmZmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgbGVhZiA9IHRyZWUuZ2V0TGVhZigxKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0TGVhZihpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5sZWF2ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sZWF2ZXNbaW5kZXhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRMZWFmSW5kZXhcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gbGVhZiwgb3IgLTEgaWYgdGhlIGxlYWYgaXMgbm90IGZvdW5kLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gLSBUYXJnZXQgbGVhZlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGxlYWYgPSBCdWZmZXIuZnJvbSgnYWJjJylcbiAgICAgKmNvbnN0IGluZGV4ID0gdHJlZS5nZXRMZWFmSW5kZXgobGVhZilcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldExlYWZJbmRleCh0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5idWZmZXJpZnkodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgbGVhdmVzID0gdGhpcy5nZXRMZWF2ZXMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxlYWYgPSBsZWF2ZXNbaV07XG4gICAgICAgICAgICBpZiAobGVhZi5lcXVhbHModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0TGVhZkNvdW50XG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGxlYXZlcy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBjb3VudCA9IHRyZWUuZ2V0TGVhZkNvdW50KClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldExlYWZDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVhdmVzLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0SGV4TGVhdmVzXG4gICAgICogQGRlc2MgUmV0dXJucyBhcnJheSBvZiBsZWF2ZXMgb2YgTWVya2xlIFRyZWUgYXMgaGV4IHN0cmluZ3MuXG4gICAgICogQHJldHVybiB7U3RyaW5nW119XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBsZWF2ZXMgPSB0cmVlLmdldEhleExlYXZlcygpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRIZXhMZWF2ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlYXZlcy5tYXAobGVhZiA9PiB0aGlzLmJ1ZmZlclRvSGV4KGxlYWYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbWFyc2hhbExlYXZlc1xuICAgICAqIEBkZXNjIFJldHVybnMgYXJyYXkgb2YgbGVhdmVzIG9mIE1lcmtsZSBUcmVlIGFzIGEgSlNPTiBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxCdWZmZXJbXX0gLSBNZXJrbGUgdHJlZSBsZWF2ZXNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IC0gTGlzdCBvZiBsZWF2ZXMgYXMgSlNPTiBzdHJpbmdcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGpzb25TdHIgPSBNZXJrbGVUcmVlLm1hcnNoYWxMZWF2ZXMobGVhdmVzKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgc3RhdGljIG1hcnNoYWxMZWF2ZXMobGVhdmVzKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShsZWF2ZXMubWFwKGxlYWYgPT4gTWVya2xlVHJlZS5idWZmZXJUb0hleChsZWFmKSksIG51bGwsIDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1bm1hcnNoYWxMZWF2ZXNcbiAgICAgKiBAZGVzYyBSZXR1cm5zIGFycmF5IG9mIGxlYXZlcyBvZiBNZXJrbGUgVHJlZSBhcyBhIEJ1ZmZlcnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSAtIEpTT04gc3RyaW5naWZpZWQgbGVhdmVzXG4gICAgICogQHJldHVybiB7QnVmZmVyW119IC0gVW5tYXJzaGFsbGVkIGxpc3Qgb2YgbGVhdmVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBsZWF2ZXMgPSBNZXJrbGVUcmVlLnVubWFyc2hhbExlYXZlcyhqc29uU3RyKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgc3RhdGljIHVubWFyc2hhbExlYXZlcyhqc29uU3RyKSB7XG4gICAgICAgIGxldCBwYXJzZWQgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGpzb25TdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGpzb25TdHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb25TdHIgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IGpzb25TdHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHR5cGUgb2Ygc3RyaW5nIG9yIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnNlZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgSlNPTiBzdHJpbmcgdG8gYmUgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkLm1hcChNZXJrbGVUcmVlLmJ1ZmZlcmlmeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldExheWVyc1xuICAgICAqIEBkZXNjIFJldHVybnMgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgb2YgYWxsIGxheWVycyBvZiBNZXJrbGUgVHJlZSwgaW5jbHVkaW5nIGxlYXZlcyBhbmQgcm9vdC5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJbXVtdfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgbGF5ZXJzID0gdHJlZS5nZXRMYXllcnMoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0TGF5ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXllcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldEhleExheWVyc1xuICAgICAqIEBkZXNjIFJldHVybnMgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgb2YgYWxsIGxheWVycyBvZiBNZXJrbGUgVHJlZSwgaW5jbHVkaW5nIGxlYXZlcyBhbmQgcm9vdCBhcyBoZXggc3RyaW5ncy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmdbXVtdfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgbGF5ZXJzID0gdHJlZS5nZXRIZXhMYXllcnMoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0SGV4TGF5ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXllcnMucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goaXRlbS5tYXAobGF5ZXIgPT4gdGhpcy5idWZmZXJUb0hleChsYXllcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRMYXllcnNGbGF0XG4gICAgICogQGRlc2MgUmV0dXJucyBzaW5nbGUgZmxhdCBhcnJheSBvZiBhbGwgbGF5ZXJzIG9mIE1lcmtsZSBUcmVlLCBpbmNsdWRpbmcgbGVhdmVzIGFuZCByb290LlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcltdfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3QgbGF5ZXJzID0gdHJlZS5nZXRMYXllcnNGbGF0KClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldExheWVyc0ZsYXQoKSB7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IHRoaXMubGF5ZXJzLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGFjYy51bnNoaWZ0KC4uLml0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWNjLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIGxheWVycy51bnNoaWZ0KGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFswXSkpO1xuICAgICAgICByZXR1cm4gbGF5ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRIZXhMYXllcnNGbGF0XG4gICAgICogQGRlc2MgUmV0dXJucyBzaW5nbGUgZmxhdCBhcnJheSBvZiBhbGwgbGF5ZXJzIG9mIE1lcmtsZSBUcmVlLCBpbmNsdWRpbmcgbGVhdmVzIGFuZCByb290IGFzIGhleCBzdHJpbmcuXG4gICAgICogQHJldHVybiB7U3RyaW5nW119XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBsYXllcnMgPSB0cmVlLmdldEhleExheWVyc0ZsYXQoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0SGV4TGF5ZXJzRmxhdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXJzRmxhdCgpLm1hcChsYXllciA9PiB0aGlzLmJ1ZmZlclRvSGV4KGxheWVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldExheWVyQ291bnRcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgbGF5ZXJzLlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGNvdW50ID0gdHJlZS5nZXRMYXllckNvdW50KClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldExheWVyQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExheWVycygpLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0Um9vdFxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIE1lcmtsZSByb290IGhhc2ggYXMgYSBCdWZmZXIuXG4gICAgICogQHJldHVybiB7QnVmZmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc3Qgcm9vdCA9IHRyZWUuZ2V0Um9vdCgpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRSb290KCkge1xuICAgICAgICBpZiAodGhpcy5sYXllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20oW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVyc1t0aGlzLmxheWVycy5sZW5ndGggLSAxXVswXSB8fCBidWZmZXJfMS5CdWZmZXIuZnJvbShbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldEhleFJvb3RcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBNZXJrbGUgcm9vdCBoYXNoIGFzIGEgaGV4IHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCByb290ID0gdHJlZS5nZXRIZXhSb290KClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldEhleFJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclRvSGV4KHRoaXMuZ2V0Um9vdCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0UHJvb2ZcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBwcm9vZiBmb3IgYSB0YXJnZXQgbGVhZi5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gbGVhZiAtIFRhcmdldCBsZWFmXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF0gLSBUYXJnZXQgbGVhZiBpbmRleCBpbiBsZWF2ZXMgYXJyYXkuXG4gICAgICogVXNlIGlmIHRoZXJlIGFyZSBsZWF2ZXMgY29udGFpbmluZyBkdXBsaWNhdGUgZGF0YSBpbiBvcmRlciB0byBkaXN0aW5ndWlzaCBpdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gLSBBcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYSBwb3NpdGlvbiBwcm9wZXJ0eSBvZiB0eXBlIHN0cmluZ1xuICAgICAqIHdpdGggdmFsdWVzIG9mICdsZWZ0JyBvciAncmlnaHQnIGFuZCBhIGRhdGEgcHJvcGVydHkgb2YgdHlwZSBCdWZmZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgcHJvb2YgPSB0cmVlLmdldFByb29mKGxlYXZlc1syXSlcbiAgICAgKmBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBsZWF2ZXMgPSBbJ2EnLCAnYicsICdhJ10ubWFwKHZhbHVlID0+IGtlY2Nhayh2YWx1ZSkpXG4gICAgICpjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUobGVhdmVzLCBrZWNjYWspXG4gICAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0UHJvb2YobGVhdmVzWzJdLCAyKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0UHJvb2YobGVhZiwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsZWFmID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZWFmIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGVhZiA9IHRoaXMuYnVmZmVyaWZ5KGxlYWYpO1xuICAgICAgICBjb25zdCBwcm9vZiA9IFtdO1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaW5kZXgpKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlYXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXJfMS5CdWZmZXIuY29tcGFyZShsZWFmLCB0aGlzLmxlYXZlc1tpXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPD0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgaXNSaWdodE5vZGUgPSBpbmRleCAlIDI7XG4gICAgICAgICAgICBjb25zdCBwYWlySW5kZXggPSAoaXNSaWdodE5vZGUgPyBpbmRleCAtIDFcbiAgICAgICAgICAgICAgICA6IHRoaXMuaXNCaXRjb2luVHJlZSAmJiBpbmRleCA9PT0gbGF5ZXIubGVuZ3RoIC0gMSAmJiBpIDwgdGhpcy5sYXllcnMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICAvLyBQcm9vZiBHZW5lcmF0aW9uIGZvciBCaXRjb2luIFRyZWVzXG4gICAgICAgICAgICAgICAgICAgID8gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvb2YgR2VuZXJhdGlvbiBmb3IgTm9uLUJpdGNvaW4gVHJlZXNcbiAgICAgICAgICAgICAgICAgICAgOiBpbmRleCArIDEpO1xuICAgICAgICAgICAgaWYgKHBhaXJJbmRleCA8IGxheWVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHByb29mLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaXNSaWdodE5vZGUgPyAnbGVmdCcgOiAncmlnaHQnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBsYXllcltwYWlySW5kZXhdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgaW5kZXggdG8gcGFyZW50IGluZGV4XG4gICAgICAgICAgICBpbmRleCA9IChpbmRleCAvIDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvb2Y7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldEhleFByb29mXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgcHJvb2YgZm9yIGEgdGFyZ2V0IGxlYWYgYXMgaGV4IHN0cmluZ3MuXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGxlYWYgLSBUYXJnZXQgbGVhZlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdIC0gVGFyZ2V0IGxlYWYgaW5kZXggaW4gbGVhdmVzIGFycmF5LlxuICAgICAqIFVzZSBpZiB0aGVyZSBhcmUgbGVhdmVzIGNvbnRhaW5pbmcgZHVwbGljYXRlIGRhdGEgaW4gb3JkZXIgdG8gZGlzdGluZ3Vpc2ggaXQuXG4gICAgICogQHJldHVybiB7U3RyaW5nW119IC0gUHJvb2YgYXJyYXkgYXMgaGV4IHN0cmluZ3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgcHJvb2YgPSB0cmVlLmdldEhleFByb29mKGxlYXZlc1syXSlcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldEhleFByb29mKGxlYWYsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByb29mKGxlYWYsIGluZGV4KS5tYXAoaXRlbSA9PiB0aGlzLmJ1ZmZlclRvSGV4KGl0ZW0uZGF0YSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRQcm9vZnNcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBwcm9vZnMgZm9yIGFsbCBsZWF2ZXMuXG4gICAgICogQHJldHVybiB7T2JqZWN0W119IC0gQXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGEgcG9zaXRpb24gcHJvcGVydHkgb2YgdHlwZSBzdHJpbmdcbiAgICAgKiB3aXRoIHZhbHVlcyBvZiAnbGVmdCcgb3IgJ3JpZ2h0JyBhbmQgYSBkYXRhIHByb3BlcnR5IG9mIHR5cGUgQnVmZmVyIGZvciBhbGwgbGVhdmVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IHByb29mcyA9IHRyZWUuZ2V0UHJvb2ZzKClcbiAgICAgKmBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBsZWF2ZXMgPSBbJ2EnLCAnYicsICdhJ10ubWFwKHZhbHVlID0+IGtlY2Nhayh2YWx1ZSkpXG4gICAgICpjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUobGVhdmVzLCBrZWNjYWspXG4gICAgICpjb25zdCBwcm9vZnMgPSB0cmVlLmdldFByb29mcygpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRQcm9vZnMoKSB7XG4gICAgICAgIGNvbnN0IHByb29mID0gW107XG4gICAgICAgIGNvbnN0IHByb29mcyA9IFtdO1xuICAgICAgICB0aGlzLmdldFByb29mc0RGUyh0aGlzLmxheWVycy5sZW5ndGggLSAxLCAwLCBwcm9vZiwgcHJvb2ZzKTtcbiAgICAgICAgcmV0dXJuIHByb29mcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0UHJvb2ZzREZTXG4gICAgICogQGRlc2MgR2V0IGFsbCBwcm9vZnMgdGhyb3VnaCBzaW5nbGUgdHJhdmVyc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3VycmVudExheWVyIC0gQ3VycmVudCBsYXllciBpbmRleCBpbiB0cmF2ZXJzZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBDdXJyZW50IHRhcnZlc2Ugbm9kZSBpbmRleCBpbiB0cmF2ZXJzZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBwcm9vZiAtIFByb29mIGNoYWluIGZvciBzaW5nbGUgbGVhZi5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBwcm9vZnMgLSBQcm9vZnMgZm9yIGFsbCBsZWF2ZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBsYXllcnMgPSB0cmVlLmdldExheWVycygpXG4gICAgICpjb25zdCBpbmRleCA9IDA7XG4gICAgICpsZXQgcHJvb2YgPSBbXTtcbiAgICAgKmxldCBwcm9vZnMgPSBbXTtcbiAgICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRQcm9vZnNERlMobGF5ZXJzLCBpbmRleCwgcHJvb2YsIHByb29mcylcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldFByb29mc0RGUyhjdXJyZW50TGF5ZXIsIGluZGV4LCBwcm9vZiwgcHJvb2ZzKSB7XG4gICAgICAgIGNvbnN0IGlzUmlnaHROb2RlID0gaW5kZXggJSAyO1xuICAgICAgICBpZiAoY3VycmVudExheWVyID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKCFpc1JpZ2h0Tm9kZSlcbiAgICAgICAgICAgICAgICBwcm9vZnMucHVzaChbLi4ucHJvb2ZdLnJldmVyc2UoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMubGF5ZXJzW2N1cnJlbnRMYXllcl0ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzW2N1cnJlbnRMYXllcl07XG4gICAgICAgIGNvbnN0IHBhaXJJbmRleCA9IGlzUmlnaHROb2RlID8gaW5kZXggLSAxIDogaW5kZXggKyAxO1xuICAgICAgICBsZXQgcHVzaGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChwYWlySW5kZXggPCBsYXllci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHB1c2hlZCA9IHRydWU7XG4gICAgICAgICAgICBwcm9vZi5wdXNoKHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogaXNSaWdodE5vZGUgPyAnbGVmdCcgOiAncmlnaHQnLFxuICAgICAgICAgICAgICAgIGRhdGE6IGxheWVyW3BhaXJJbmRleF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlZnRjaGlsZEluZGV4ID0gaW5kZXggKiAyO1xuICAgICAgICBjb25zdCByaWdodGNoaWxkSW5kZXggPSBpbmRleCAqIDIgKyAxO1xuICAgICAgICB0aGlzLmdldFByb29mc0RGUyhjdXJyZW50TGF5ZXIgLSAxLCBsZWZ0Y2hpbGRJbmRleCwgcHJvb2YsIHByb29mcyk7XG4gICAgICAgIHRoaXMuZ2V0UHJvb2ZzREZTKGN1cnJlbnRMYXllciAtIDEsIHJpZ2h0Y2hpbGRJbmRleCwgcHJvb2YsIHByb29mcyk7XG4gICAgICAgIGlmIChwdXNoZWQpXG4gICAgICAgICAgICBwcm9vZi5zcGxpY2UocHJvb2YubGVuZ3RoIC0gMSwgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldEhleFByb29mc1xuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIHByb29mcyBmb3IgYWxsIGxlYXZlcyBhcyBoZXggc3RyaW5ncy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0gLSBQcm9vZnMgYXJyYXkgYXMgaGV4IHN0cmluZ3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgcHJvb2ZzID0gdHJlZS5nZXRIZXhQcm9vZnMoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0SGV4UHJvb2ZzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9vZnMoKS5tYXAoaXRlbSA9PiB0aGlzLmJ1ZmZlclRvSGV4KGl0ZW0uZGF0YSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIGdldFBvc2l0aW9uYWxIZXhQcm9vZlxuICAgICogQGRlc2MgUmV0dXJucyB0aGUgcHJvb2YgZm9yIGEgdGFyZ2V0IGxlYWYgYXMgaGV4IHN0cmluZ3MgYW5kIHRoZSBwb3NpdGlvbiBpbiBiaW5hcnkgKGxlZnQgPT0gMCkuXG4gICAgKiBAcGFyYW0ge0J1ZmZlcn0gbGVhZiAtIFRhcmdldCBsZWFmXG4gICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSAtIFRhcmdldCBsZWFmIGluZGV4IGluIGxlYXZlcyBhcnJheS5cbiAgICAqIFVzZSBpZiB0aGVyZSBhcmUgbGVhdmVzIGNvbnRhaW5pbmcgZHVwbGljYXRlIGRhdGEgaW4gb3JkZXIgdG8gZGlzdGluZ3Vpc2ggaXQuXG4gICAgKiBAcmV0dXJuIHsoc3RyaW5nIHwgbnVtYmVyKVtdW119IC0gUHJvb2YgYXJyYXkgYXMgaGV4IHN0cmluZ3MuIHBvc2l0aW9uIGF0IGluZGV4IDBcbiAgICAqIEBleGFtcGxlXG4gICAgKiBgYGBqc1xuICAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0UG9zaXRpb25hbEhleFByb29mKGxlYXZlc1syXSlcbiAgICAqYGBgXG4gICAgKi9cbiAgICBnZXRQb3NpdGlvbmFsSGV4UHJvb2YobGVhZiwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvb2YobGVhZiwgaW5kZXgpLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgaXRlbS5wb3NpdGlvbiA9PT0gJ2xlZnQnID8gMCA6IDEsXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJUb0hleChpdGVtLmRhdGEpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbWFyc2hhbFByb29mXG4gICAgICogQGRlc2MgUmV0dXJucyBwcm9vZiBhcnJheSBhcyBKU09OIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfE9iamVjdFtdfSBwcm9vZiAtIE1lcmtsZSB0cmVlIHByb29mIGFycmF5XG4gICAgICogQHJldHVybiB7U3RyaW5nfSAtIFByb29mIGFycmF5IGFzIEpTT04gc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IGpzb25TdHIgPSBNZXJrbGVUcmVlLm1hcnNoYWxQcm9vZihwcm9vZilcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBtYXJzaGFsUHJvb2YocHJvb2YpIHtcbiAgICAgICAgY29uc3QganNvbiA9IHByb29mLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWVya2xlVHJlZS5idWZmZXJUb0hleChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGl0ZW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZGF0YTogTWVya2xlVHJlZS5idWZmZXJUb0hleChpdGVtLmRhdGEpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGpzb24sIG51bGwsIDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1bm1hcnNoYWxQcm9vZlxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIHByb29mIGZvciBhIHRhcmdldCBsZWFmIGFzIGEgbGlzdCBvZiBCdWZmZXJzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gLSBNZXJrbGUgdHJlZSBsZWF2ZXNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd8T2JqZWN0fSAtIE1hcnNoYWxsZWQgcHJvb2ZcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBwcm9vZiA9IE1lcmtsZVRyZWUudW5tYXJzaGFsUHJvb2YoanNvblN0cilcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHN0YXRpYyB1bm1hcnNoYWxQcm9vZihqc29uU3RyKSB7XG4gICAgICAgIGxldCBwYXJzZWQgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGpzb25TdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGpzb25TdHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb25TdHIgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IGpzb25TdHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHR5cGUgb2Ygc3RyaW5nIG9yIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnNlZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgSlNPTiBzdHJpbmcgdG8gYmUgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWVya2xlVHJlZS5idWZmZXJpZnkoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGl0ZW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE1lcmtsZVRyZWUuYnVmZmVyaWZ5KGl0ZW0uZGF0YSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpdGVtIHRvIGJlIG9mIHR5cGUgc3RyaW5nIG9yIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIG1hcnNoYWxUcmVlKHRyZWUpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRyZWUuZ2V0SGV4Um9vdCgpO1xuICAgICAgICBjb25zdCBsZWF2ZXMgPSB0cmVlLmxlYXZlcy5tYXAobGVhZiA9PiBNZXJrbGVUcmVlLmJ1ZmZlclRvSGV4KGxlYWYpKTtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0gdHJlZS5nZXRIZXhMYXllcnMoKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRyZWUuZ2V0T3B0aW9ucygpO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBsYXllcnMsXG4gICAgICAgICAgICBsZWF2ZXNcbiAgICAgICAgfSwgbnVsbCwgMik7XG4gICAgfVxuICAgIHN0YXRpYyB1bm1hcnNoYWxUcmVlKGpzb25TdHIsIGhhc2hGbiA9IHNoYTI1Nl8xLmRlZmF1bHQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgcGFyc2VkID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uU3RyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShqc29uU3RyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqc29uU3RyIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBqc29uU3RyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0eXBlIG9mIHN0cmluZyBvciBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcGFyc2UganNvbicpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJzZWQub3B0aW9ucyB8fCB7fSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgTWVya2xlVHJlZShwYXJzZWQubGVhdmVzLCBoYXNoRm4sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRQcm9vZkluZGljZXNcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBwcm9vZiBpbmRpY2VzIGZvciBnaXZlbiB0cmVlIGluZGljZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gdHJlZUluZGljZXMgLSBUcmVlIGluZGljZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVwdGggLSBUcmVlIGRlcHRoOyBudW1iZXIgb2YgbGF5ZXJzLlxuICAgICAqIEByZXR1cm4ge051bWJlcltdfSAtIFByb29mIGluZGljZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICpjb25zdCBwcm9vZkluZGljZXMgPSB0cmVlLmdldFByb29mSW5kaWNlcyhbMiw1LDZdLCA0KVxuICAgICAqY29uc29sZS5sb2cocHJvb2ZJbmRpY2VzKSAvLyBbIDIzLCAyMCwgMTksIDgsIDMgXVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0UHJvb2ZJbmRpY2VzKHRyZWVJbmRpY2VzLCBkZXB0aCkge1xuICAgICAgICBjb25zdCBsZWFmQ291bnQgPSBNYXRoLnBvdygyLCBkZXB0aCk7XG4gICAgICAgIGxldCBtYXhpbWFsSW5kaWNlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiB0cmVlSW5kaWNlcykge1xuICAgICAgICAgICAgbGV0IHggPSBsZWFmQ291bnQgKyBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlICh4ID4gMSkge1xuICAgICAgICAgICAgICAgIG1heGltYWxJbmRpY2VzLmFkZCh4IF4gMSk7XG4gICAgICAgICAgICAgICAgeCA9ICh4IC8gMikgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGEgPSB0cmVlSW5kaWNlcy5tYXAoaW5kZXggPT4gbGVhZkNvdW50ICsgaW5kZXgpO1xuICAgICAgICBjb25zdCBiID0gQXJyYXkuZnJvbShtYXhpbWFsSW5kaWNlcykuc29ydCgoYSwgYikgPT4gYSAtIGIpLnJldmVyc2UoKTtcbiAgICAgICAgbWF4aW1hbEluZGljZXMgPSBhLmNvbmNhdChiKTtcbiAgICAgICAgY29uc3QgcmVkdW5kYW50SW5kaWNlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgcHJvb2YgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggb2YgbWF4aW1hbEluZGljZXMpIHtcbiAgICAgICAgICAgIGlmICghcmVkdW5kYW50SW5kaWNlcy5oYXMoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcHJvb2YucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZWR1bmRhbnRJbmRpY2VzLmFkZChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVkdW5kYW50SW5kaWNlcy5oYXMoaW5kZXggXiAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IChpbmRleCAvIDIpIHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb29mLmZpbHRlcihpbmRleCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIXRyZWVJbmRpY2VzLmluY2x1ZGVzKGluZGV4IC0gbGVhZkNvdW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFByb29mSW5kaWNlc0ZvclVuZXZlblRyZWUoc29ydGVkTGVhZkluZGljZXMsIGxlYXZlc0NvdW50KSB7XG4gICAgICAgIGNvbnN0IGRlcHRoID0gTWF0aC5jZWlsKE1hdGgubG9nMihsZWF2ZXNDb3VudCkpO1xuICAgICAgICBjb25zdCB1bmV2ZW5MYXllcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGRlcHRoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCB1bmV2ZW5MYXllciA9IGxlYXZlc0NvdW50ICUgMiAhPT0gMDtcbiAgICAgICAgICAgIGlmICh1bmV2ZW5MYXllcikge1xuICAgICAgICAgICAgICAgIHVuZXZlbkxheWVycy5wdXNoKHsgaW5kZXgsIGxlYXZlc0NvdW50IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVhdmVzQ291bnQgPSBNYXRoLmNlaWwobGVhdmVzQ291bnQgLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9vZkluZGljZXMgPSBbXTtcbiAgICAgICAgbGV0IGxheWVyTm9kZXMgPSBzb3J0ZWRMZWFmSW5kaWNlcztcbiAgICAgICAgZm9yIChsZXQgbGF5ZXJJbmRleCA9IDA7IGxheWVySW5kZXggPCBkZXB0aDsgbGF5ZXJJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nSW5kaWNlcyA9IGxheWVyTm9kZXMubWFwKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4IC0gMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHByb29mTm9kZUluZGljZXMgPSBzaWJsaW5nSW5kaWNlcy5maWx0ZXIoKGluZGV4KSA9PiAhbGF5ZXJOb2Rlcy5pbmNsdWRlcyhpbmRleCkpO1xuICAgICAgICAgICAgY29uc3QgdW5ldmVuTGF5ZXIgPSB1bmV2ZW5MYXllcnMuZmluZCgoeyBpbmRleCB9KSA9PiBpbmRleCA9PT0gbGF5ZXJJbmRleCk7XG4gICAgICAgICAgICBpZiAodW5ldmVuTGF5ZXIgJiYgbGF5ZXJOb2Rlcy5pbmNsdWRlcyh1bmV2ZW5MYXllci5sZWF2ZXNDb3VudCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgcHJvb2ZOb2RlSW5kaWNlcyA9IHByb29mTm9kZUluZGljZXMuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvb2ZJbmRpY2VzLnB1c2gocHJvb2ZOb2RlSW5kaWNlcyk7XG4gICAgICAgICAgICBsYXllck5vZGVzID0gWy4uLm5ldyBTZXQobGF5ZXJOb2Rlcy5tYXAoKGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCArIDEpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4IC0gMSkgLyAyO1xuICAgICAgICAgICAgICAgIH0pKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb29mSW5kaWNlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0TXVsdGlQcm9vZlxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIG11bHRpcHJvb2YgZm9yIGdpdmVuIHRyZWUgaW5kaWNlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBpbmRpY2VzIC0gVHJlZSBpbmRpY2VzLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcltdfSAtIE11bHRpcHJvb2ZzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgaW5kaWNlcyA9IFsyLCA1LCA2XVxuICAgICAqY29uc3QgcHJvb2YgPSB0cmVlLmdldE11bHRpUHJvb2YoaW5kaWNlcylcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldE11bHRpUHJvb2YodHJlZSwgaW5kaWNlcykge1xuICAgICAgICBpZiAoIXRoaXMuY29tcGxldGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogRm9yIGNvcnJlY3QgbXVsdGlQcm9vZnMgaXRcXCdzIHN0cm9uZ2x5IHJlY29tbWVuZGVkIHRvIHNldCBjb21wbGV0ZTogdHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5kaWNlcykge1xuICAgICAgICAgICAgaW5kaWNlcyA9IHRyZWU7XG4gICAgICAgICAgICB0cmVlID0gdGhpcy5nZXRMYXllcnNGbGF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNVbmV2ZW4gPSB0aGlzLmlzVW5ldmVuVHJlZSgpO1xuICAgICAgICBpZiAoaXNVbmV2ZW4pIHtcbiAgICAgICAgICAgIGlmIChpbmRpY2VzLmV2ZXJ5KE51bWJlci5pc0ludGVnZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TXVsdGlQcm9vZkZvclVuZXZlblRyZWUoaW5kaWNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbmRpY2VzLmV2ZXJ5KE51bWJlci5pc0ludGVnZXIpKSB7XG4gICAgICAgICAgICBsZXQgZWxzID0gaW5kaWNlcztcbiAgICAgICAgICAgIGlmICh0aGlzLnNvcnRQYWlycykge1xuICAgICAgICAgICAgICAgIGVscyA9IGVscy5zb3J0KGJ1ZmZlcl8xLkJ1ZmZlci5jb21wYXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpZHMgPSBlbHMubWFwKChlbCkgPT4gdGhpcy5idWZmZXJJbmRleE9mKHRoaXMubGVhdmVzLCBlbCwgdGhpcy5zb3J0TGVhdmVzKSkuc29ydCgoYSwgYikgPT4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMSk7XG4gICAgICAgICAgICBpZiAoIWlkcy5ldmVyeSgoaWR4KSA9PiBpZHggIT09IC0xKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBkb2VzIG5vdCBleGlzdCBpbiBNZXJrbGUgdHJlZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFzaGVzID0gW107XG4gICAgICAgICAgICBjb25zdCBwcm9vZiA9IFtdO1xuICAgICAgICAgICAgbGV0IG5leHRJZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGlkc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFpckVsZW1lbnQgPSB0aGlzLmdldFBhaXJOb2RlKGxheWVyLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICBoYXNoZXMucHVzaChsYXllcltpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhaXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9vZi5wdXNoKHBhaXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0SWRzLnB1c2goKGlkeCAvIDIpIHwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkcyA9IG5leHRJZHMuZmlsdGVyKCh2YWx1ZSwgaSwgc2VsZikgPT4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaSk7XG4gICAgICAgICAgICAgICAgbmV4dElkcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb29mLmZpbHRlcigodmFsdWUpID0+ICFoYXNoZXMuaW5jbHVkZXModmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9vZkluZGljZXMoaW5kaWNlcywgTWF0aC5sb2cyKCh0cmVlLmxlbmd0aCAvIDIpIHwgMCkpLm1hcChpbmRleCA9PiB0cmVlW2luZGV4XSk7XG4gICAgfVxuICAgIGdldE11bHRpUHJvb2ZGb3JVbmV2ZW5UcmVlKHRyZWUsIGluZGljZXMpIHtcbiAgICAgICAgaWYgKCFpbmRpY2VzKSB7XG4gICAgICAgICAgICBpbmRpY2VzID0gdHJlZTtcbiAgICAgICAgICAgIHRyZWUgPSB0aGlzLmdldExheWVycygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcm9vZkhhc2hlcyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudExheWVySW5kaWNlcyA9IGluZGljZXM7XG4gICAgICAgIGZvciAoY29uc3QgdHJlZUxheWVyIG9mIHRyZWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmdzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGN1cnJlbnRMYXllckluZGljZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50TGF5ZXJJbmRpY2VzLmluY2x1ZGVzKGlkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmVlTGF5ZXJbaWR4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnB1c2godHJlZUxheWVyW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGluZGV4IC0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRMYXllckluZGljZXMuaW5jbHVkZXMoaWR4KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJlZUxheWVyW2lkeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnB1c2godHJlZUxheWVyW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9vZkhhc2hlcyA9IHByb29mSGFzaGVzLmNvbmNhdChzaWJsaW5ncyk7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVJbmRpY2VzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBjdXJyZW50TGF5ZXJJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVJbmRpY2VzLmFkZChpbmRleCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVJbmRpY2VzLmFkZCgoaW5kZXggKyAxKSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5pcXVlSW5kaWNlcy5hZGQoKGluZGV4IC0gMSkgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRMYXllckluZGljZXMgPSBBcnJheS5mcm9tKHVuaXF1ZUluZGljZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9vZkhhc2hlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0SGV4TXVsdGlQcm9vZlxuICAgICAqIEBkZXNjIFJldHVybnMgdGhlIG11bHRpcHJvb2YgZm9yIGdpdmVuIHRyZWUgaW5kaWNlcyBhcyBoZXggc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBpbmRpY2VzIC0gVHJlZSBpbmRpY2VzLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ1tdfSAtIE11bHRpcHJvb2ZzIGFzIGhleCBzdHJpbmdzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IGluZGljZXMgPSBbMiwgNSwgNl1cbiAgICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRIZXhNdWx0aVByb29mKGluZGljZXMpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXRIZXhNdWx0aVByb29mKHRyZWUsIGluZGljZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TXVsdGlQcm9vZih0cmVlLCBpbmRpY2VzKS5tYXAoKHgpID0+IHRoaXMuYnVmZmVyVG9IZXgoeCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRQcm9vZkZsYWdzXG4gICAgICogQGRlc2MgUmV0dXJucyBsaXN0IG9mIGJvb2xlYW5zIHdoZXJlIHByb29mcyBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIGhhc2hpbmcuXG4gICAgICogUHJvb2YgZmxhZ3MgYXJlIHVzZWQgaW4gdGhlIFNvbGlkaXR5IG11bHRpcHJvb2YgdmVyaWZpZXJzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW118QnVmZmVyW119IGxlYXZlc1xuICAgICAqIEBwYXJhbSB7QnVmZmVyW119IHByb29mc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW5bXX0gLSBCb29sZWFuIGZsYWdzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgaW5kaWNlcyA9IFsyLCA1LCA2XVxuICAgICAqY29uc3QgcHJvb2YgPSB0cmVlLmdldE11bHRpUHJvb2YoaW5kaWNlcylcbiAgICAgKmNvbnN0IHByb29mRmxhZ3MgPSB0cmVlLmdldFByb29mRmxhZ3MobGVhdmVzLCBwcm9vZilcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldFByb29mRmxhZ3MobGVhdmVzLCBwcm9vZnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxlYXZlcykgfHwgbGVhdmVzLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSW5wdXRzIScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZHM7XG4gICAgICAgIGlmIChsZWF2ZXMuZXZlcnkoTnVtYmVyLmlzSW50ZWdlcikpIHtcbiAgICAgICAgICAgIGlkcyA9IFsuLi5sZWF2ZXNdLnNvcnQoKGEsIGIpID0+IGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTEpOyAvLyBJbmRpY2VzIHdoZXJlIHBhc3NlZFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWRzID0gbGVhdmVzLm1hcCgoZWwpID0+IHRoaXMuYnVmZmVySW5kZXhPZih0aGlzLmxlYXZlcywgZWwsIHRoaXMuc29ydExlYXZlcykpLnNvcnQoKGEsIGIpID0+IGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaWRzLmV2ZXJ5KChpZHgpID0+IGlkeCAhPT0gLTEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gTWVya2xlIHRyZWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfcHJvb2ZzID0gcHJvb2ZzLm1hcChpdGVtID0+IHRoaXMuYnVmZmVyaWZ5KGl0ZW0pKTtcbiAgICAgICAgY29uc3QgdGVzdGVkID0gW107XG4gICAgICAgIGNvbnN0IGZsYWdzID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmxheWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnNbaW5kZXhdO1xuICAgICAgICAgICAgaWRzID0gaWRzLnJlZHVjZSgoaWRzLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBza2lwcGVkID0gdGVzdGVkLmluY2x1ZGVzKGxheWVyW2lkeF0pO1xuICAgICAgICAgICAgICAgIGlmICghc2tpcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWlyRWxlbWVudCA9IHRoaXMuZ2V0UGFpck5vZGUobGF5ZXIsIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb29mVXNlZCA9IF9wcm9vZnMuaW5jbHVkZXMobGF5ZXJbaWR4XSkgfHwgX3Byb29mcy5pbmNsdWRlcyhwYWlyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJFbGVtZW50ICYmIGZsYWdzLnB1c2goIXByb29mVXNlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RlZC5wdXNoKGxheWVyW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICB0ZXN0ZWQucHVzaChwYWlyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkcy5wdXNoKChpZHggLyAyKSB8IDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZHM7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB2ZXJpZnlcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRydWUgaWYgdGhlIHByb29mIHBhdGggKGFycmF5IG9mIGhhc2hlcykgY2FuIGNvbm5lY3QgdGhlIHRhcmdldCBub2RlXG4gICAgICogdG8gdGhlIE1lcmtsZSByb290LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHByb29mIC0gQXJyYXkgb2YgcHJvb2Ygb2JqZWN0cyB0aGF0IHNob3VsZCBjb25uZWN0XG4gICAgICogdGFyZ2V0IG5vZGUgdG8gTWVya2xlIHJvb3QuXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IHRhcmdldE5vZGUgLSBUYXJnZXQgbm9kZSBCdWZmZXJcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gcm9vdCAtIE1lcmtsZSByb290IEJ1ZmZlclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCByb290ID0gdHJlZS5nZXRSb290KClcbiAgICAgKmNvbnN0IHByb29mID0gdHJlZS5nZXRQcm9vZihsZWF2ZXNbMl0pXG4gICAgICpjb25zdCB2ZXJpZmllZCA9IHRyZWUudmVyaWZ5KHByb29mLCBsZWF2ZXNbMl0sIHJvb3QpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICB2ZXJpZnkocHJvb2YsIHRhcmdldE5vZGUsIHJvb3QpIHtcbiAgICAgICAgbGV0IGhhc2ggPSB0aGlzLmJ1ZmZlcmlmeSh0YXJnZXROb2RlKTtcbiAgICAgICAgcm9vdCA9IHRoaXMuYnVmZmVyaWZ5KHJvb3QpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvb2YpIHx8XG4gICAgICAgICAgICAhdGFyZ2V0Tm9kZSB8fFxuICAgICAgICAgICAgIXJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb29mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gcHJvb2ZbaV07XG4gICAgICAgICAgICBsZXQgZGF0YSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgaXNMZWZ0Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBjYXNlIGZvciB3aGVuIHByb29mIGlzIGhleCB2YWx1ZXMgb25seVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmJ1ZmZlcmlmeShub2RlKTtcbiAgICAgICAgICAgICAgICBpc0xlZnROb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpc0xlZnROb2RlID0gKG5vZGVbMF0gPT09IDApO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmJ1ZmZlcmlmeShub2RlWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcihub2RlKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBub2RlO1xuICAgICAgICAgICAgICAgIGlzTGVmdE5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmJ1ZmZlcmlmeShub2RlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGlzTGVmdE5vZGUgPSAobm9kZS5wb3NpdGlvbiA9PT0gJ2xlZnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbm9kZSB0byBiZSBvZiB0eXBlIHN0cmluZyBvciBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQml0Y29pblRyZWUpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goYnVmZmVyX3JldmVyc2VfMS5kZWZhdWx0KGhhc2gpKTtcbiAgICAgICAgICAgICAgICBidWZmZXJzW2lzTGVmdE5vZGUgPyAndW5zaGlmdCcgOiAncHVzaCddKGJ1ZmZlcl9yZXZlcnNlXzEuZGVmYXVsdChkYXRhKSk7XG4gICAgICAgICAgICAgICAgaGFzaCA9IHRoaXMuaGFzaEZuKHRoaXMuY29uY2F0ZW5hdG9yKGJ1ZmZlcnMpKTtcbiAgICAgICAgICAgICAgICBoYXNoID0gYnVmZmVyX3JldmVyc2VfMS5kZWZhdWx0KHRoaXMuaGFzaEZuKGhhc2gpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvcnRQYWlycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyXzEuQnVmZmVyLmNvbXBhcmUoaGFzaCwgZGF0YSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goaGFzaCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoID0gdGhpcy5oYXNoRm4odGhpcy5jb25jYXRlbmF0b3IoYnVmZmVycykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKGRhdGEsIGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaCA9IHRoaXMuaGFzaEZuKHRoaXMuY29uY2F0ZW5hdG9yKGJ1ZmZlcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJzW2lzTGVmdE5vZGUgPyAndW5zaGlmdCcgOiAncHVzaCddKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBoYXNoID0gdGhpcy5oYXNoRm4odGhpcy5jb25jYXRlbmF0b3IoYnVmZmVycykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmNvbXBhcmUoaGFzaCwgcm9vdCkgPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHZlcmlmeU11bHRpUHJvb2ZcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRydWUgaWYgdGhlIG11bHRpcHJvb2ZzIGNhbiBjb25uZWN0IHRoZSBsZWF2ZXMgdG8gdGhlIE1lcmtsZSByb290LlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSByb290IC0gTWVya2xlIHRyZWUgcm9vdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHByb29mSW5kaWNlcyAtIExlYXZlIGluZGljZXMgZm9yIHByb29mXG4gICAgICogQHBhcmFtIHtCdWZmZXJbXX0gcHJvb2ZMZWF2ZXMgLSBMZWFmIHZhbHVlcyBhdCBpbmRpY2VzIGZvciBwcm9vZlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWF2ZXNDb3VudCAtIENvdW50IG9mIG9yaWdpbmFsIGxlYXZlc1xuICAgICAqIEBwYXJhbSB7QnVmZmVyW119IHByb29mIC0gTXVsdGlwcm9vZnMgZ2l2ZW4gaW5kaWNlc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICpjb25zdCBsZWF2ZXMgPSB0cmVlLmdldExlYXZlcygpXG4gICAgICpjb25zdCByb290ID0gdHJlZS5nZXRSb290KClcbiAgICAgKmNvbnN0IHRyZWVGbGF0ID0gdHJlZS5nZXRMYXllcnNGbGF0KClcbiAgICAgKmNvbnN0IGxlYXZlc0NvdW50ID0gbGVhdmVzLmxlbmd0aFxuICAgICAqY29uc3QgcHJvb2ZJbmRpY2VzID0gWzIsIDUsIDZdXG4gICAgICpjb25zdCBwcm9vZkxlYXZlcyA9IHByb29mSW5kaWNlcy5tYXAoaSA9PiBsZWF2ZXNbaV0pXG4gICAgICpjb25zdCBwcm9vZiA9IHRyZWUuZ2V0TXVsdGlQcm9vZih0cmVlRmxhdCwgaW5kaWNlcylcbiAgICAgKmNvbnN0IHZlcmlmaWVkID0gdHJlZS52ZXJpZnlNdWx0aVByb29mKHJvb3QsIHByb29mSW5kaWNlcywgcHJvb2ZMZWF2ZXMsIGxlYXZlc0NvdW50LCBwcm9vZilcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHZlcmlmeU11bHRpUHJvb2Yocm9vdCwgcHJvb2ZJbmRpY2VzLCBwcm9vZkxlYXZlcywgbGVhdmVzQ291bnQsIHByb29mKSB7XG4gICAgICAgIGNvbnN0IGlzVW5ldmVuID0gdGhpcy5pc1VuZXZlblRyZWUoKTtcbiAgICAgICAgaWYgKGlzVW5ldmVuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBjb21iaW5lIHRoZXNlIGZ1bmN0aW9ucyBhbmQgc2ltcGxpZnlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeU11bHRpUHJvb2ZGb3JVbmV2ZW5UcmVlKHJvb3QsIHByb29mSW5kaWNlcywgcHJvb2ZMZWF2ZXMsIGxlYXZlc0NvdW50LCBwcm9vZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVwdGggPSBNYXRoLmNlaWwoTWF0aC5sb2cyKGxlYXZlc0NvdW50KSk7XG4gICAgICAgIHJvb3QgPSB0aGlzLmJ1ZmZlcmlmeShyb290KTtcbiAgICAgICAgcHJvb2ZMZWF2ZXMgPSBwcm9vZkxlYXZlcy5tYXAobGVhZiA9PiB0aGlzLmJ1ZmZlcmlmeShsZWFmKSk7XG4gICAgICAgIHByb29mID0gcHJvb2YubWFwKGxlYWYgPT4gdGhpcy5idWZmZXJpZnkobGVhZikpO1xuICAgICAgICBjb25zdCB0cmVlID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBsZWFmXSBvZiB0aGlzLnppcChwcm9vZkluZGljZXMsIHByb29mTGVhdmVzKSkge1xuICAgICAgICAgICAgdHJlZVsoTWF0aC5wb3coMiwgZGVwdGgpKSArIGluZGV4XSA9IGxlYWY7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIHByb29maXRlbV0gb2YgdGhpcy56aXAodGhpcy5nZXRQcm9vZkluZGljZXMocHJvb2ZJbmRpY2VzLCBkZXB0aCksIHByb29mKSkge1xuICAgICAgICAgICAgdHJlZVtpbmRleF0gPSBwcm9vZml0ZW07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4cXVldWUgPSBPYmplY3Qua2V5cyh0cmVlKS5tYXAodmFsdWUgPT4gK3ZhbHVlKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgIGluZGV4cXVldWUgPSBpbmRleHF1ZXVlLnNsaWNlKDAsIGluZGV4cXVldWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBpbmRleHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpbmRleHF1ZXVlW2ldO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDIgJiYgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRyZWUsIGluZGV4IF4gMSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFpciA9IFt0cmVlW2luZGV4IC0gKGluZGV4ICUgMildLCB0cmVlW2luZGV4IC0gKGluZGV4ICUgMikgKyAxXV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc29ydFBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXIgPSBwYWlyLnNvcnQoYnVmZmVyXzEuQnVmZmVyLmNvbXBhcmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gcGFpclsxXSA/IHRoaXMuaGFzaEZuKHRoaXMuY29uY2F0ZW5hdG9yKHBhaXIpKSA6IHBhaXJbMF07XG4gICAgICAgICAgICAgICAgdHJlZVsoaW5kZXggLyAyKSB8IDBdID0gaGFzaDtcbiAgICAgICAgICAgICAgICBpbmRleHF1ZXVlLnB1c2goKGluZGV4IC8gMikgfCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXByb29mSW5kaWNlcy5sZW5ndGggfHwgKCh7fSkuaGFzT3duUHJvcGVydHkuY2FsbCh0cmVlLCAxKSAmJiB0cmVlWzFdLmVxdWFscyhyb290KSk7XG4gICAgfVxuICAgIHZlcmlmeU11bHRpUHJvb2ZXaXRoRmxhZ3Mocm9vdCwgbGVhdmVzLCBwcm9vZnMsIHByb29mRmxhZykge1xuICAgICAgICByb290ID0gdGhpcy5idWZmZXJpZnkocm9vdCk7XG4gICAgICAgIGxlYXZlcyA9IGxlYXZlcy5tYXAodGhpcy5idWZmZXJpZnkpO1xuICAgICAgICBwcm9vZnMgPSBwcm9vZnMubWFwKHRoaXMuYnVmZmVyaWZ5KTtcbiAgICAgICAgY29uc3QgbGVhdmVzTGVuID0gbGVhdmVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdG90YWxIYXNoZXMgPSBwcm9vZkZsYWcubGVuZ3RoO1xuICAgICAgICBjb25zdCBoYXNoZXMgPSBbXTtcbiAgICAgICAgbGV0IGxlYWZQb3MgPSAwO1xuICAgICAgICBsZXQgaGFzaFBvcyA9IDA7XG4gICAgICAgIGxldCBwcm9vZlBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxIYXNoZXM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYnVmQSA9IHByb29mRmxhZ1tpXSA/IChsZWFmUG9zIDwgbGVhdmVzTGVuID8gbGVhdmVzW2xlYWZQb3MrK10gOiBoYXNoZXNbaGFzaFBvcysrXSkgOiBwcm9vZnNbcHJvb2ZQb3MrK107XG4gICAgICAgICAgICBjb25zdCBidWZCID0gbGVhZlBvcyA8IGxlYXZlc0xlbiA/IGxlYXZlc1tsZWFmUG9zKytdIDogaGFzaGVzW2hhc2hQb3MrK107XG4gICAgICAgICAgICBjb25zdCBidWZmZXJzID0gW2J1ZkEsIGJ1ZkJdLnNvcnQoYnVmZmVyXzEuQnVmZmVyLmNvbXBhcmUpO1xuICAgICAgICAgICAgaGFzaGVzW2ldID0gdGhpcy5oYXNoRm4odGhpcy5jb25jYXRlbmF0b3IoYnVmZmVycykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuY29tcGFyZShoYXNoZXNbdG90YWxIYXNoZXMgLSAxXSwgcm9vdCkgPT09IDA7XG4gICAgfVxuICAgIHZlcmlmeU11bHRpUHJvb2ZGb3JVbmV2ZW5UcmVlKHJvb3QsIGluZGljZXMsIGxlYXZlcywgbGVhdmVzQ291bnQsIHByb29mKSB7XG4gICAgICAgIHJvb3QgPSB0aGlzLmJ1ZmZlcmlmeShyb290KTtcbiAgICAgICAgbGVhdmVzID0gbGVhdmVzLm1hcChsZWFmID0+IHRoaXMuYnVmZmVyaWZ5KGxlYWYpKTtcbiAgICAgICAgcHJvb2YgPSBwcm9vZi5tYXAobGVhZiA9PiB0aGlzLmJ1ZmZlcmlmeShsZWFmKSk7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkUm9vdCA9IHRoaXMuY2FsY3VsYXRlUm9vdEZvclVuZXZlblRyZWUoaW5kaWNlcywgbGVhdmVzLCBsZWF2ZXNDb3VudCwgcHJvb2YpO1xuICAgICAgICByZXR1cm4gcm9vdC5lcXVhbHMoY29tcHV0ZWRSb290KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0RGVwdGhcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSB0cmVlIGRlcHRoIChudW1iZXIgb2YgbGF5ZXJzKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGRlcHRoID0gdHJlZS5nZXREZXB0aCgpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXREZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXJzKCkubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0TGF5ZXJzQXNPYmplY3RcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBsYXllcnMgYXMgbmVzdGVkIG9iamVjdHMgaW5zdGVhZCBvZiBhbiBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IGxheWVyc09iaiA9IHRyZWUuZ2V0TGF5ZXJzQXNPYmplY3QoKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0TGF5ZXJzQXNPYmplY3QoKSB7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKCkubWFwKChsYXllcikgPT4gbGF5ZXIubWFwKCh2YWx1ZSkgPT4gdGhpcy5idWZmZXJUb0hleCh2YWx1ZSwgZmFsc2UpKSk7XG4gICAgICAgIGNvbnN0IG9ianMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsYXllcnNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB7IFtsYXllcnNbaV1bal1dOiBudWxsIH07XG4gICAgICAgICAgICAgICAgaWYgKG9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtsYXllcnNbaV1bal1dID0ge307XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBvYmpzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFrZXkgPSBPYmplY3Qua2V5cyhhKVswXTtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2xheWVyc1tpXVtqXV1bYWtleV0gPSBhW2FrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBvYmpzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBia2V5ID0gT2JqZWN0LmtleXMoYilbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbbGF5ZXJzW2ldW2pdXVtia2V5XSA9IGJbYmtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyLnB1c2gob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ianMucHVzaCguLi5hcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmpzWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB2ZXJpZnlcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRydWUgaWYgdGhlIHByb29mIHBhdGggKGFycmF5IG9mIGhhc2hlcykgY2FuIGNvbm5lY3QgdGhlIHRhcmdldCBub2RlXG4gICAgICogdG8gdGhlIE1lcmtsZSByb290LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHByb29mIC0gQXJyYXkgb2YgcHJvb2Ygb2JqZWN0cyB0aGF0IHNob3VsZCBjb25uZWN0XG4gICAgICogdGFyZ2V0IG5vZGUgdG8gTWVya2xlIHJvb3QuXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IHRhcmdldE5vZGUgLSBUYXJnZXQgbm9kZSBCdWZmZXJcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gcm9vdCAtIE1lcmtsZSByb290IEJ1ZmZlclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc2hGdW5jdGlvbiAtIEhhc2ggZnVuY3Rpb24gZm9yIGhhc2hpbmcgbGVhdmVzIGFuZCBub2Rlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnN0IHZlcmlmaWVkID0gTWVya2xlVHJlZS52ZXJpZnkocHJvb2YsIGxlYWYsIHJvb3QsIHNoYTI1Niwgb3B0aW9ucylcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHN0YXRpYyB2ZXJpZnkocHJvb2YsIHRhcmdldE5vZGUsIHJvb3QsIGhhc2hGbiA9IHNoYTI1Nl8xLmRlZmF1bHQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUoW10sIGhhc2hGbiwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0cmVlLnZlcmlmeShwcm9vZiwgdGFyZ2V0Tm9kZSwgcm9vdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldE11bHRpUHJvb2ZcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBtdWx0aXByb29mIGZvciBnaXZlbiB0cmVlIGluZGljZXMuXG4gICAgICogQHBhcmFtIHtCdWZmZXJbXX0gdHJlZSAtIFRyZWUgYXMgYSBmbGF0IGFycmF5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGluZGljZXMgLSBUcmVlIGluZGljZXMuXG4gICAgICogQHJldHVybiB7QnVmZmVyW119IC0gTXVsdGlwcm9vZnNcbiAgICAgKlxuICAgICAqQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqY29uc3QgZmxhdFRyZWUgPSB0cmVlLmdldExheWVyc0ZsYXQoKVxuICAgICAqY29uc3QgaW5kaWNlcyA9IFsyLCA1LCA2XVxuICAgICAqY29uc3QgcHJvb2YgPSBNZXJrbGVUcmVlLmdldE11bHRpUHJvb2YoZmxhdFRyZWUsIGluZGljZXMpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0TXVsdGlQcm9vZih0cmVlLCBpbmRpY2VzKSB7XG4gICAgICAgIGNvbnN0IHQgPSBuZXcgTWVya2xlVHJlZShbXSk7XG4gICAgICAgIHJldHVybiB0LmdldE11bHRpUHJvb2YodHJlZSwgaW5kaWNlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlc2V0VHJlZVxuICAgICAqIEBkZXNjIFJlc2V0cyB0aGUgdHJlZSBieSBjbGVhcmluZyB0aGUgbGVhdmVzIGFuZCBsYXllcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYGpzXG4gICAgICp0cmVlLnJlc2V0VHJlZSgpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICByZXNldFRyZWUoKSB7XG4gICAgICAgIHRoaXMubGVhdmVzID0gW107XG4gICAgICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldFBhaXJOb2RlXG4gICAgICogQGRlc2MgUmV0dXJucyB0aGUgbm9kZSBhdCB0aGUgaW5kZXggZm9yIGdpdmVuIGxheWVyLlxuICAgICAqIEBwYXJhbSB7QnVmZmVyW119IGxheWVyIC0gVHJlZSBsYXllclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIEluZGV4IGF0IGxheWVyLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gLSBOb2RlXG4gICAgICpcbiAgICAgKkBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKmNvbnN0IG5vZGUgPSB0cmVlLmdldFBhaXJOb2RlKGxheWVyLCBpbmRleClcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldFBhaXJOb2RlKGxheWVyLCBpZHgpIHtcbiAgICAgICAgY29uc3QgcGFpcklkeCA9IGlkeCAlIDIgPT09IDAgPyBpZHggKyAxIDogaWR4IC0gMTtcbiAgICAgICAgaWYgKHBhaXJJZHggPCBsYXllci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXllcltwYWlySWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRvVHJlZVN0cmluZ1xuICAgICAqIEBkZXNjIFJldHVybnMgYSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1lcmtsZSB0cmVlIGFzIGEgc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqYGBganNcbiAgICAgKmNvbnNvbGUubG9nKHRyZWUudG9UcmVlU3RyaW5nKCkpXG4gICAgICpgYGBcbiAgICAgKi9cbiAgICB0b1RyZWVTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuZ2V0TGF5ZXJzQXNPYmplY3QoKTtcbiAgICAgICAgcmV0dXJuIHRyZWVpZnlfMS5kZWZhdWx0LmFzVHJlZShvYmosIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0b1N0cmluZ1xuICAgICAqIEBkZXNjIFJldHVybnMgYSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1lcmtsZSB0cmVlIGFzIGEgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpgYGBqc1xuICAgICAqY29uc29sZS5sb2codHJlZS50b1N0cmluZygpKVxuICAgICAqYGBgXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvVHJlZVN0cmluZygpO1xuICAgIH1cbiAgICBpc1VuZXZlblRyZWUodHJlZUxheWVycykge1xuICAgICAgICBjb25zdCBkZXB0aCA9ICh0cmVlTGF5ZXJzID09PSBudWxsIHx8IHRyZWVMYXllcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyZWVMYXllcnMubGVuZ3RoKSB8fCB0aGlzLmdldERlcHRoKCk7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc1Bvd09mMihkZXB0aCk7XG4gICAgfVxuICAgIGlzUG93T2YyKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgJiYgISh2ICYgKHYgLSAxKSk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZVJvb3RGb3JVbmV2ZW5UcmVlKGxlYWZJbmRpY2VzLCBsZWFmSGFzaGVzLCB0b3RhbExlYXZlc0NvdW50LCBwcm9vZkhhc2hlcykge1xuICAgICAgICBjb25zdCBsZWFmVHVwbGVzID0gdGhpcy56aXAobGVhZkluZGljZXMsIGxlYWZIYXNoZXMpLnNvcnQoKFtpbmRleEFdLCBbaW5kZXhCXSkgPT4gaW5kZXhBIC0gaW5kZXhCKTtcbiAgICAgICAgY29uc3QgbGVhZlR1cGxlSW5kaWNlcyA9IGxlYWZUdXBsZXMubWFwKChbaW5kZXhdKSA9PiBpbmRleCk7XG4gICAgICAgIGNvbnN0IHByb29mSW5kaWNlcyA9IHRoaXMuZ2V0UHJvb2ZJbmRpY2VzRm9yVW5ldmVuVHJlZShsZWFmVHVwbGVJbmRpY2VzLCB0b3RhbExlYXZlc0NvdW50KTtcbiAgICAgICAgbGV0IG5leHRTbGljZVN0YXJ0ID0gMDtcbiAgICAgICAgY29uc3QgcHJvb2ZUdXBsZXNCeUxheWVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb29mSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IHByb29mSW5kaWNlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlU3RhcnQgPSBuZXh0U2xpY2VTdGFydDtcbiAgICAgICAgICAgIG5leHRTbGljZVN0YXJ0ICs9IGluZGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgcHJvb2ZUdXBsZXNCeUxheWVyc1tpXSA9IHRoaXMuemlwKGluZGljZXMsIHByb29mSGFzaGVzLnNsaWNlKHNsaWNlU3RhcnQsIG5leHRTbGljZVN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJlZSA9IFtsZWFmVHVwbGVzXTtcbiAgICAgICAgZm9yIChsZXQgbGF5ZXJJbmRleCA9IDA7IGxheWVySW5kZXggPCBwcm9vZlR1cGxlc0J5TGF5ZXJzLmxlbmd0aDsgbGF5ZXJJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGF5ZXIgPSBwcm9vZlR1cGxlc0J5TGF5ZXJzW2xheWVySW5kZXhdLmNvbmNhdCh0cmVlW2xheWVySW5kZXhdKS5zb3J0KChbaW5kZXhBXSwgW2luZGV4Ql0pID0+IGluZGV4QSAtIGluZGV4QilcbiAgICAgICAgICAgICAgICAubWFwKChbLCBoYXNoXSkgPT4gaGFzaCk7XG4gICAgICAgICAgICBjb25zdCBzID0gdHJlZVtsYXllckluZGV4XS5tYXAoKFtsYXllckluZGV4XSkgPT4gbGF5ZXJJbmRleCk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJbmRpY2VzID0gWy4uLm5ldyBTZXQocy5tYXAoKGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCArIDEpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4IC0gMSkgLyAyO1xuICAgICAgICAgICAgICAgIH0pKV07XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRMYXllciA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZVRyZWVJbmRleCA9IHBhcmVudEluZGljZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmQSA9IGN1cnJlbnRMYXllcltpICogMl07XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmQiA9IGN1cnJlbnRMYXllcltpICogMiArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBidWZCID8gdGhpcy5oYXNoRm4odGhpcy5jb25jYXRlbmF0b3IoW2J1ZkEsIGJ1ZkJdKSkgOiBidWZBO1xuICAgICAgICAgICAgICAgIHBhcmVudExheWVyLnB1c2goW3BhcmVudE5vZGVUcmVlSW5kZXgsIGhhc2hdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyZWUucHVzaChwYXJlbnRMYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWVbdHJlZS5sZW5ndGggLSAxXVswXVsxXTtcbiAgICB9XG59XG5leHBvcnRzLk1lcmtsZVRyZWUgPSBNZXJrbGVUcmVlO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgO1xuICAgIHdpbmRvdy5NZXJrbGVUcmVlID0gTWVya2xlVHJlZTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1lcmtsZVRyZWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/MerkleTree.js\n");

/***/ }),

/***/ "(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/index.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/index.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MerkleTree = void 0;\nconst MerkleTree_1 = __importDefault(__webpack_require__(/*! ./MerkleTree */ \"(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/MerkleTree.js\"));\nexports.MerkleTree = MerkleTree_1.default;\nvar MerkleMountainRange_1 = __webpack_require__(/*! ./MerkleMountainRange */ \"(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/MerkleMountainRange.js\");\nObject.defineProperty(exports, \"MerkleMountainRange\", ({ enumerable: true, get: function () { return MerkleMountainRange_1.MerkleMountainRange; } }));\nvar IncrementalMerkleTree_1 = __webpack_require__(/*! ./IncrementalMerkleTree */ \"(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/IncrementalMerkleTree.js\");\nObject.defineProperty(exports, \"IncrementalMerkleTree\", ({ enumerable: true, get: function () { return IncrementalMerkleTree_1.IncrementalMerkleTree; } }));\nvar MerkleSumTree_1 = __webpack_require__(/*! ./MerkleSumTree */ \"(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/MerkleSumTree.js\");\nObject.defineProperty(exports, \"MerkleSumTree\", ({ enumerable: true, get: function () { return MerkleSumTree_1.MerkleSumTree; } }));\nexports[\"default\"] = MerkleTree_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21lcmtsZXRyZWVqc0AwLjMuMTEvbm9kZV9tb2R1bGVzL21lcmtsZXRyZWVqcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLHFDQUFxQyxtQkFBTyxDQUFDLHdIQUFjO0FBQzNELGtCQUFrQjtBQUNsQiw0QkFBNEIsbUJBQU8sQ0FBQywwSUFBdUI7QUFDM0QsdURBQXNELEVBQUUscUNBQXFDLHFEQUFxRCxFQUFDO0FBQ25KLDhCQUE4QixtQkFBTyxDQUFDLDhJQUF5QjtBQUMvRCx5REFBd0QsRUFBRSxxQ0FBcUMseURBQXlELEVBQUM7QUFDekosc0JBQXNCLG1CQUFPLENBQUMsOEhBQWlCO0FBQy9DLGlEQUFnRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUNqSSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL0BleGFtcGxlcy9sb2dpbi13aXRoLXBhc3Nwb3J0LXNpbGVudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbWVya2xldHJlZWpzQDAuMy4xMS9ub2RlX21vZHVsZXMvbWVya2xldHJlZWpzL2Rpc3QvaW5kZXguanM/YzY5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVya2xlVHJlZSA9IHZvaWQgMDtcbmNvbnN0IE1lcmtsZVRyZWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9NZXJrbGVUcmVlXCIpKTtcbmV4cG9ydHMuTWVya2xlVHJlZSA9IE1lcmtsZVRyZWVfMS5kZWZhdWx0O1xudmFyIE1lcmtsZU1vdW50YWluUmFuZ2VfMSA9IHJlcXVpcmUoXCIuL01lcmtsZU1vdW50YWluUmFuZ2VcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXJrbGVNb3VudGFpblJhbmdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBNZXJrbGVNb3VudGFpblJhbmdlXzEuTWVya2xlTW91bnRhaW5SYW5nZTsgfSB9KTtcbnZhciBJbmNyZW1lbnRhbE1lcmtsZVRyZWVfMSA9IHJlcXVpcmUoXCIuL0luY3JlbWVudGFsTWVya2xlVHJlZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkluY3JlbWVudGFsTWVya2xlVHJlZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSW5jcmVtZW50YWxNZXJrbGVUcmVlXzEuSW5jcmVtZW50YWxNZXJrbGVUcmVlOyB9IH0pO1xudmFyIE1lcmtsZVN1bVRyZWVfMSA9IHJlcXVpcmUoXCIuL01lcmtsZVN1bVRyZWVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXJrbGVTdW1UcmVlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBNZXJrbGVTdW1UcmVlXzEuTWVya2xlU3VtVHJlZTsgfSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1lcmtsZVRyZWVfMS5kZWZhdWx0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/.pnpm/merkletreejs@0.3.11/node_modules/merkletreejs/dist/index.js\n");

/***/ })

};
;