"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@0xsequence+core@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_";
exports.ids = ["vendor-chunks/@0xsequence+core@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/.pnpm/@0xsequence+core@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/core/dist/0xsequence-core.esm.js":
/*!***************************************************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@0xsequence+core@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/core/dist/0xsequence-core.esm.js ***!
  \***************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   allVersions: () => (/* binding */ allVersions),\n/* harmony export */   commons: () => (/* binding */ index$1),\n/* harmony export */   universal: () => (/* binding */ index),\n/* harmony export */   v1: () => (/* binding */ v1),\n/* harmony export */   v2: () => (/* binding */ v2)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/solidity.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/message.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/hashes.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @0xsequence/abi */ \"(ssr)/../../../node_modules/.pnpm/@0xsequence+abi@2.2.13/node_modules/@0xsequence/abi/dist/0xsequence-abi.esm.js\");\n/* harmony import */ var _0xsequence_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @0xsequence/utils */ \"(ssr)/../../../node_modules/.pnpm/@0xsequence+utils@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/utils/dist/0xsequence-utils.esm.js\");\n\n\n\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\nfunction subdigestOf(payload) {\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['bytes', 'uint256', 'address', 'bytes32'], ['0x1901', payload.chainId, payload.address, payload.digest]);\n}\nfunction isSignedPayload(payload) {\n  return payload.digest !== undefined && payload.chainId !== undefined && payload.address !== undefined;\n}\n\nvar signature$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  subdigestOf: subdigestOf,\n  isSignedPayload: isSignedPayload\n});\n\nconst EIP1271_MAGIC_VALUE = '0x1626ba7e';\nconst EIP1271_ABI = [{\n  inputs: [{\n    internalType: 'bytes32',\n    type: 'bytes32'\n  }, {\n    internalType: 'bytes',\n    type: 'bytes'\n  }],\n  name: 'isValidSignature',\n  outputs: [{\n    internalType: 'bytes4',\n    type: 'bytes4'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}];\nasync function isValidEIP1271Signature(address, digest, signature, provider) {\n  const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(address, EIP1271_ABI, provider);\n  const result = await contract.isValidSignature(digest, signature);\n  return result === EIP1271_MAGIC_VALUE;\n}\n\nvar validateEIP1271 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  isValidEIP1271Signature: isValidEIP1271Signature\n});\n\nlet SigType = /*#__PURE__*/function (SigType) {\n  SigType[SigType[\"EIP712\"] = 1] = \"EIP712\";\n  SigType[SigType[\"ETH_SIGN\"] = 2] = \"ETH_SIGN\";\n  SigType[SigType[\"WALLET_BYTES32\"] = 3] = \"WALLET_BYTES32\";\n  return SigType;\n}({});\nfunction canRecover(signature) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  const type = bytes[bytes.length - 1];\n  return type === SigType.EIP712 || type === SigType.ETH_SIGN;\n}\nfunction recoverSigner(digest, signature) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  const digestBytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(digest);\n\n  // type is last byte\n  const type = bytes[bytes.length - 1];\n\n  // Split r:s:v\n  const r = ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(0, 32));\n  const s = ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(32, 64));\n  const v = Number(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(64, 65)));\n  const splitSignature = {\n    r,\n    s,\n    v\n  };\n  if (type === SigType.EIP712) {\n    return ethers__WEBPACK_IMPORTED_MODULE_5__.recoverAddress(digestBytes, splitSignature);\n  }\n  if (type === SigType.ETH_SIGN) {\n    return ethers__WEBPACK_IMPORTED_MODULE_5__.recoverAddress(ethers__WEBPACK_IMPORTED_MODULE_6__.hashMessage(digestBytes), splitSignature);\n  }\n  throw new Error(`Unsupported signature type: ${type}`);\n}\nfunction isValidSignature(address, digest, signature, provider) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n\n  // type is last byte\n  const type = bytes[bytes.length - 1];\n  if (type === SigType.EIP712 || type === SigType.ETH_SIGN) {\n    return address === recoverSigner(digest, signature);\n  }\n  if (type === SigType.WALLET_BYTES32) {\n    return isValidEIP1271Signature(address, ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(digest), bytes.slice(0, -1), provider);\n  }\n  throw new Error(`Unsupported signature type: ${type}`);\n}\nfunction tryRecoverSigner(digest, signature) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  if (bytes.length !== 66) return undefined;\n  try {\n    return recoverSigner(digest, bytes);\n  } catch (_unused) {}\n  return undefined;\n}\n\nvar signer = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SigType: SigType,\n  canRecover: canRecover,\n  recoverSigner: recoverSigner,\n  isValidSignature: isValidSignature,\n  tryRecoverSigner: tryRecoverSigner\n});\n\nlet SignaturePartType$1 = /*#__PURE__*/function (SignaturePartType) {\n  SignaturePartType[SignaturePartType[\"EOASignature\"] = 0] = \"EOASignature\";\n  SignaturePartType[SignaturePartType[\"Address\"] = 1] = \"Address\";\n  SignaturePartType[SignaturePartType[\"DynamicSignature\"] = 2] = \"DynamicSignature\";\n  return SignaturePartType;\n}({});\nfunction isAddressMember(member) {\n  return member.address !== undefined && !isUnrecoveredSignatureMember(member);\n}\nfunction isUnrecoveredSignatureMember(member) {\n  return member.signature !== undefined && member.weight !== undefined && member.isDynamic !== undefined;\n}\nfunction isUnrecoveredSignature$1(signature) {\n  return signature.threshold !== undefined && signature.signers !== undefined;\n}\nfunction decodeSignature$1(signature) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  const threshold = bytes[0] << 8 | bytes[1];\n  const signers = [];\n  for (let i = 2; i < bytes.length;) {\n    const type = bytes[i++];\n    const weight = bytes[i++];\n    switch (type) {\n      case SignaturePartType$1.EOASignature:\n        signers.push({\n          unrecovered: true,\n          weight,\n          signature: ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(i, i + 66)),\n          isDynamic: false\n        });\n        i += 66;\n        break;\n      case SignaturePartType$1.Address:\n        signers.push({\n          weight,\n          address: ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(i, i + 20)))\n        });\n        i += 20;\n        break;\n      case SignaturePartType$1.DynamicSignature:\n        const address = ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(i, i + 20)));\n        i += 20;\n        const size = bytes[i] << 8 | bytes[i + 1];\n        i += 2;\n        signers.push({\n          unrecovered: true,\n          weight,\n          signature: ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(i, i + size)),\n          address,\n          isDynamic: true\n        });\n        i += size;\n        break;\n      default:\n        throw new Error(`Unknown signature part type: ${type}`);\n    }\n  }\n  return {\n    version: 1,\n    threshold,\n    signers\n  };\n}\nfunction encodeSignature$1(signature) {\n  if (ethers__WEBPACK_IMPORTED_MODULE_4__.isBytesLike(signature)) {\n    return ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(signature);\n  }\n  const {\n    signers,\n    threshold\n  } = isUnrecoveredSignature$1(signature) ? signature : signature.config;\n  const encodedSigners = signers.map(s => {\n    if (isAddressMember(s)) {\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'address'], [SignaturePartType$1.Address, s.weight, s.address]);\n    }\n    if (s.isDynamic) {\n      const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(s.signature);\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'address', 'uint16', 'bytes'], [SignaturePartType$1.DynamicSignature, s.weight, s.address, bytes.length, bytes]);\n    }\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'bytes'], [SignaturePartType$1.EOASignature, s.weight, s.signature]);\n  });\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint16', ...new Array(encodedSigners.length).fill('bytes')], [threshold, ...encodedSigners]);\n}\nasync function recoverSignature$1(data, payload, provider) {\n  const subdigest = subdigestOf(payload);\n  const signers = await Promise.all(data.signers.map(async s => {\n    if (isAddressMember(s)) {\n      return s;\n    }\n    if (s.isDynamic) {\n      if (!s.address) throw new Error('Dynamic signature part must have address');\n      if (!isValidSignature(s.address, subdigest, s.signature, provider)) {\n        throw new Error(`Invalid dynamic signature part ${s.address}`);\n      }\n      return {\n        address: s.address,\n        weight: s.weight,\n        signature: s.signature\n      };\n    } else {\n      const address = recoverSigner(subdigest, s.signature);\n      return {\n        address,\n        weight: s.weight,\n        signature: s.signature\n      };\n    }\n  }));\n  return {\n    version: 1,\n    payload,\n    subdigest,\n    config: {\n      version: 1,\n      threshold: data.threshold,\n      signers\n    }\n  };\n}\nfunction encodeSigners$1(config, signatures, subdigests, _) {\n  if (subdigests.length !== 0) {\n    throw new Error('Explicit subdigests not supported on v1');\n  }\n  let weight = 0n;\n  const parts = config.signers.map(s => {\n    if (!signatures.has(s.address)) {\n      return s;\n    }\n    const signature = signatures.get(s.address);\n    const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature.signature);\n    weight += BigInt(s.weight);\n    if (signature.isDynamic || bytes.length !== 66) {\n      return _extends({}, s, {\n        isDynamic: true,\n        signature: signature.signature,\n        address: s.address\n      });\n    }\n    return _extends({}, s, {\n      isDynamic: false,\n      signature: signature.signature\n    });\n  });\n  const encoded = encodeSignature$1({\n    version: 1,\n    threshold: config.threshold,\n    signers: parts\n  });\n  return {\n    encoded,\n    weight\n  };\n}\nconst SignatureCoder$1 = {\n  decode: data => {\n    return decodeSignature$1(data);\n  },\n  encode: data => {\n    return encodeSignature$1(data);\n  },\n  trim: async data => {\n    return data;\n  },\n  supportsNoChainId: true,\n  recover: (data, payload, provider) => {\n    return recoverSignature$1(data, payload, provider);\n  },\n  encodeSigners: (config, signatures, subdigests, chainId) => {\n    return encodeSigners$1(config, signatures, subdigests);\n  },\n  hasEnoughSigningPower: (config, signatures) => {\n    const {\n      weight\n    } = SignatureCoder$1.encodeSigners(config, signatures, [], 0);\n    return weight >= BigInt(config.threshold);\n  },\n  chainSignatures: (_main, _suffix) => {\n    throw new Error('Signature chaining not supported on v1');\n  },\n  hashSetImageHash: function (_imageHash) {\n    throw new Error('Image hash not supported on v1');\n  },\n  signaturesOf(config) {\n    return config.signers.filter(s => s.signature !== undefined).map(s => ({\n      address: s.address,\n      signature: s.signature\n    }));\n  },\n  signaturesOfDecoded: function (data) {\n    return data.signers.map(s => s.signature).filter(s => s !== undefined);\n  }\n};\n\nvar signature$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SignaturePartType: SignaturePartType$1,\n  isAddressMember: isAddressMember,\n  isUnrecoveredSignatureMember: isUnrecoveredSignatureMember,\n  isUnrecoveredSignature: isUnrecoveredSignature$1,\n  decodeSignature: decodeSignature$1,\n  encodeSignature: encodeSignature$1,\n  recoverSignature: recoverSignature$1,\n  encodeSigners: encodeSigners$1,\n  SignatureCoder: SignatureCoder$1\n});\n\nconst ConfigCoder$1 = {\n  isWalletConfig: config => {\n    return config.version === 1 && config.threshold !== undefined && config.signers !== undefined;\n  },\n  imageHashOf: config => {\n    return config.signers.reduce((imageHash, signer) => ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().encode(['bytes32', 'uint8', 'address'], [imageHash, signer.weight, signer.address])), ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint256'], [config.threshold]));\n  },\n  hasSubdigest: (_walletConfig, _subdigest) => {\n    // v1 does not support explicit subdigests\n    return false;\n  },\n  isComplete: _config => {\n    // v1 does not support incomplete configs\n    return true;\n  },\n  checkpointOf: _config => {\n    return 0n;\n  },\n  signersOf: config => {\n    return config.signers.map(s => ({\n      address: s.address,\n      weight: Number(s.weight)\n    }));\n  },\n  fromSimple: config => {\n    if (BigInt(config.checkpoint) !== 0n) {\n      throw new Error('v1 wallet config does not support checkpoint');\n    }\n    if (config.subdigests && config.subdigests.length > 0) {\n      throw new Error('v1 wallet config does not support subdigests');\n    }\n    return {\n      version: 1,\n      threshold: config.threshold,\n      signers: config.signers\n    };\n  },\n  update: {\n    isKindUsed: true,\n    buildTransaction: (wallet, config, context, kind) => {\n      const module = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface([..._0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModule.abi, ..._0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModuleUpgradable.abi]);\n      const transactions = [];\n      if (!kind || kind === 'first') {\n        transactions.push({\n          to: wallet,\n          data: module.encodeFunctionData(module.getFunction('updateImplementation'), [context.mainModuleUpgradable]),\n          gasLimit: 0,\n          delegateCall: false,\n          revertOnError: true,\n          value: 0\n        });\n      }\n      transactions.push({\n        to: wallet,\n        data: module.encodeFunctionData(module.getFunction('updateImageHash'), [ConfigCoder$1.imageHashOf(config)]),\n        gasLimit: 0,\n        delegateCall: false,\n        revertOnError: true,\n        value: 0\n      });\n      return {\n        entrypoint: wallet,\n        transactions\n      };\n    },\n    decodeTransaction: function (tx) {\n      throw new Error('Function not implemented.');\n    }\n  },\n  toJSON: function (config) {\n    const plainMembers = config.signers.map(signer => {\n      return {\n        weight: BigInt(signer.weight).toString(),\n        address: signer.address\n      };\n    });\n    return JSON.stringify({\n      version: config.version,\n      threshold: BigInt(config.threshold).toString(),\n      signers: plainMembers\n    });\n  },\n  fromJSON: function (json) {\n    const parsed = JSON.parse(json);\n    const signers = parsed.signers.map(signer => {\n      return {\n        weight: BigInt(signer.weight),\n        address: signer.address\n      };\n    });\n    return {\n      version: parsed.version,\n      threshold: BigInt(parsed.threshold),\n      signers\n    };\n  },\n  editConfig: function (config, action) {\n    var _action$threshold;\n    const newSigners = config.signers.slice();\n    if (action.checkpoint && BigInt(action.checkpoint) !== 0n) {\n      throw new Error('v1 wallet config does not support checkpoint');\n    }\n    if (action.add) {\n      for (const signer of action.add) {\n        if (newSigners.find(s => s.address === signer.address)) {\n          continue;\n        }\n        newSigners.push({\n          weight: signer.weight,\n          address: signer.address\n        });\n      }\n    }\n    if (action.remove) {\n      for (const address of action.remove) {\n        const index = newSigners.findIndex(signer => signer.address === address);\n        if (index >= 0) {\n          newSigners.splice(index, 1);\n        }\n      }\n    }\n    return {\n      version: config.version,\n      threshold: (_action$threshold = action.threshold) != null ? _action$threshold : config.threshold,\n      signers: newSigners\n    };\n  },\n  buildStubSignature: function (config, overrides) {\n    const parts = new Map();\n    for (const [signer, signature] of overrides.entries()) {\n      parts.set(signer, {\n        signature,\n        isDynamic: true\n      });\n      const {\n        encoded,\n        weight\n      } = encodeSigners$1(config, parts, []);\n      if (weight >= BigInt(config.threshold)) {\n        return encoded;\n      }\n    }\n    const signers = config.signers;\n    for (const {\n      address\n    } of signers.sort(({\n      weight: a\n    }, {\n      weight: b\n    }) => Number(a) - Number(b))) {\n      const signature = '0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02';\n      parts.set(address, {\n        signature,\n        isDynamic: false\n      });\n      const {\n        encoded,\n        weight\n      } = encodeSigners$1(config, parts, []);\n      if (weight >= BigInt(config.threshold)) {\n        return encoded;\n      }\n    }\n    return encodeSigners$1(config, parts, []).encoded;\n  }\n};\n\nvar config$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ConfigCoder: ConfigCoder$1\n});\n\nvar context$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nconst version$1 = 1;\nconst DeployedWalletContext$1 = {\n  version: version$1,\n  factory: '0xf9D09D634Fb818b05149329C1dcCFAeA53639d96',\n  guestModule: '0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7',\n  mainModule: '0xd01F11855bCcb95f88D7A48492F66410d4637313',\n  mainModuleUpgradable: '0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118',\n  walletCreationCode: '0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3'\n};\n\nvar v1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  config: config$2,\n  context: context$2,\n  signature: signature$1,\n  version: version$1,\n  DeployedWalletContext: DeployedWalletContext$1\n});\n\n//                              = keccak256(\"SetImageHash(bytes32 imageHash)\")\nconst SetImageHashPrefix = '0x8713a7c4465f6fbee2b6e9d6646d1d9f83fec929edfc4baf661f3c865bdd04d1';\nfunction hashSetImageHash(imageHash) {\n  return ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(messageSetImageHash(imageHash));\n}\nfunction messageSetImageHash(imageHash) {\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes32', 'bytes32'], [SetImageHashPrefix, imageHash]);\n}\nfunction decodeMessageSetImageHash(message) {\n  const arr = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(message);\n  if (arr.length !== 64) {\n    return undefined;\n  }\n  if (ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(0, 32)) !== SetImageHashPrefix) {\n    return undefined;\n  }\n  return ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(32, 64));\n}\nfunction isMessageSetImageHash(message) {\n  return decodeMessageSetImageHash(message) !== undefined;\n}\n\nvar chained = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SetImageHashPrefix: SetImageHashPrefix,\n  hashSetImageHash: hashSetImageHash,\n  messageSetImageHash: messageSetImageHash,\n  decodeMessageSetImageHash: decodeMessageSetImageHash,\n  isMessageSetImageHash: isMessageSetImageHash\n});\n\nlet SignatureType = /*#__PURE__*/function (SignatureType) {\n  SignatureType[SignatureType[\"Legacy\"] = 0] = \"Legacy\";\n  SignatureType[SignatureType[\"Dynamic\"] = 1] = \"Dynamic\";\n  SignatureType[SignatureType[\"NoChainIdDynamic\"] = 2] = \"NoChainIdDynamic\";\n  SignatureType[SignatureType[\"Chained\"] = 3] = \"Chained\";\n  return SignatureType;\n}({});\nlet SignaturePartType = /*#__PURE__*/function (SignaturePartType) {\n  SignaturePartType[SignaturePartType[\"Signature\"] = 0] = \"Signature\";\n  SignaturePartType[SignaturePartType[\"Address\"] = 1] = \"Address\";\n  SignaturePartType[SignaturePartType[\"DynamicSignature\"] = 2] = \"DynamicSignature\";\n  SignaturePartType[SignaturePartType[\"Node\"] = 3] = \"Node\";\n  SignaturePartType[SignaturePartType[\"Branch\"] = 4] = \"Branch\";\n  SignaturePartType[SignaturePartType[\"Subdigest\"] = 5] = \"Subdigest\";\n  SignaturePartType[SignaturePartType[\"Nested\"] = 6] = \"Nested\";\n  return SignaturePartType;\n}({});\nconst SignaturePartTypeLength = 66;\nfunction isUnrecoveredNode(node) {\n  return node.left !== undefined && node.right !== undefined;\n}\nfunction isUnrecoveredNestedLeaf(leaf) {\n  return leaf.tree !== undefined;\n}\nfunction isUnrecoveredSignatureLeaf(leaf) {\n  return leaf.unrecovered && leaf.signature !== undefined && leaf.isDynamic !== undefined;\n}\nfunction decodeSignatureTree(body) {\n  let arr = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(body);\n  let pointer;\n  const append = (prevPointer, node) => {\n    if (!prevPointer) {\n      return {\n        left: node\n      };\n    }\n    if (!prevPointer.right) {\n      return {\n        left: prevPointer.left,\n        right: node\n      };\n    }\n    return {\n      left: prevPointer,\n      right: node\n    };\n  };\n  while (arr.length > 0) {\n    const type = arr[0];\n    arr = arr.slice(1);\n    switch (type) {\n      case SignaturePartType.Signature:\n        {\n          const weight = arr[0];\n          const signature = ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(1, SignaturePartTypeLength + 1));\n          pointer = append(pointer, {\n            signature,\n            weight,\n            unrecovered: true,\n            isDynamic: false\n          });\n          arr = arr.slice(SignaturePartTypeLength + 1);\n        }\n        break;\n      case SignaturePartType.Address:\n        {\n          const weight = arr[0];\n          const address = ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(1, 21)));\n          pointer = append(pointer, {\n            address,\n            weight\n          });\n          arr = arr.slice(21);\n        }\n        break;\n      case SignaturePartType.DynamicSignature:\n        {\n          const weight = arr[0];\n          const address = ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(1, 21)));\n          const size = arr[21] << 16 | arr[22] << 8 | arr[23];\n          const signature = ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(24, 24 + size));\n          pointer = append(pointer, {\n            address,\n            signature,\n            weight,\n            unrecovered: true,\n            isDynamic: true\n          });\n          arr = arr.slice(24 + size);\n        }\n        break;\n      case SignaturePartType.Node:\n        {\n          const nodeHash = ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(0, 32));\n          pointer = append(pointer, {\n            nodeHash\n          });\n          arr = arr.slice(32);\n        }\n        break;\n      case SignaturePartType.Branch:\n        {\n          const size = arr[0] << 16 | arr[1] << 8 | arr[2];\n          const branch = decodeSignatureTree(arr.slice(3, 3 + size));\n          pointer = append(pointer, branch);\n          arr = arr.slice(3 + size);\n        }\n        break;\n      case SignaturePartType.Subdigest:\n        {\n          const subdigest = ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(0, 32));\n          pointer = append(pointer, {\n            subdigest\n          });\n          arr = arr.slice(32);\n        }\n        break;\n      case SignaturePartType.Nested:\n        {\n          const weight = arr[0];\n          const threshold = arr[1] << 8 | arr[2];\n          const size = arr[3] << 16 | arr[4] << 8 | arr[5];\n          const tree = decodeSignatureTree(arr.slice(6, 6 + size));\n          pointer = append(pointer, {\n            weight,\n            threshold,\n            tree\n          });\n          arr = arr.slice(6 + size);\n        }\n        break;\n      default:\n        throw new Error(`Unknown signature part type: ${type}: ${ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr)}`);\n    }\n  }\n  if (!pointer) {\n    throw new Error('Empty signature tree');\n  }\n  if (pointer.right) {\n    return pointer;\n  }\n  return pointer.left;\n}\nclass InvalidSignatureLeafError extends Error {\n  constructor(leaf) {\n    super(`Invalid signature leaf: ${JSON.stringify(leaf)}`);\n    this.leaf = leaf;\n  }\n}\nasync function recoverTopology(unrecovered, subdigest, provider) {\n  if (isUnrecoveredNode(unrecovered)) {\n    const [left, right] = await Promise.all([recoverTopology(unrecovered.left, subdigest, provider), recoverTopology(unrecovered.right, subdigest, provider)]);\n    return {\n      left,\n      right\n    };\n  }\n  if (isUnrecoveredNestedLeaf(unrecovered)) {\n    return {\n      weight: unrecovered.weight,\n      threshold: unrecovered.threshold,\n      tree: await recoverTopology(unrecovered.tree, subdigest, provider)\n    };\n  }\n  if (isUnrecoveredSignatureLeaf(unrecovered)) {\n    if (unrecovered.isDynamic) {\n      if (!unrecovered.address) {\n        throw new Error('Dynamic signature leaf without address');\n      }\n      const isValid = await isValidSignature(unrecovered.address, subdigest, unrecovered.signature, provider);\n      if (!isValid) {\n        throw new InvalidSignatureLeafError(unrecovered);\n      }\n      return {\n        weight: unrecovered.weight,\n        address: unrecovered.address,\n        signature: unrecovered.signature,\n        subdigest\n      };\n    } else {\n      return {\n        weight: unrecovered.weight,\n        address: recoverSigner(subdigest, unrecovered.signature),\n        signature: unrecovered.signature,\n        subdigest\n      };\n    }\n  }\n  return unrecovered;\n}\n\n// TODO: It should be possible to re-use encodeSignatureTree\n// and avoid duplicating this logic\nconst partEncoder = {\n  concat: (a, b) => {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes', 'bytes'], [a, b]);\n  },\n  node: nodeHash => {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Node, nodeHash]);\n  },\n  branch: tree => {\n    const arr = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(tree);\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint24', 'bytes'], [SignaturePartType.Branch, arr.length, arr]);\n  },\n  nested: (weight, threshold, tree) => {\n    const arr = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(tree);\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'uint16', 'uint24', 'bytes'], [SignaturePartType.Nested, weight, threshold, arr.length, arr]);\n  },\n  subdigest: subdigest => {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Subdigest, subdigest]);\n  },\n  signature: (weight, signature) => {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'bytes'], [SignaturePartType.Signature, weight, signature]);\n  },\n  dynamicSignature: (weight, address, signature) => {\n    const arrSignature = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'address', 'uint24', 'bytes'], [SignaturePartType.DynamicSignature, weight, address, arrSignature.length, arrSignature]);\n  },\n  address: (weight, address) => {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'address'], [SignaturePartType.Address, weight, address]);\n  }\n};\nfunction encodeSigners(config, parts, subdigests, chainId, options = {}) {\n  const tree = encodeTree(config.tree, parts, subdigests, options);\n  if (BigInt(chainId) === 0n) {\n    return {\n      encoded: ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint16', 'uint32', 'bytes'], [SignatureType.NoChainIdDynamic, config.threshold, config.checkpoint, tree.encoded]),\n      weight: tree.weight\n    };\n  }\n  if (BigInt(config.threshold) > 255n) {\n    return {\n      encoded: ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint16', 'uint32', 'bytes'], [SignatureType.Dynamic, config.threshold, config.checkpoint, tree.encoded]),\n      weight: tree.weight\n    };\n  }\n  return {\n    encoded: ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'uint32', 'bytes'], [SignatureType.Legacy, config.threshold, config.checkpoint, tree.encoded]),\n    weight: tree.weight\n  };\n}\nfunction encodeTree(topology, parts, subdigests, options = {}) {\n  const trim = !options.disableTrim;\n  if (isNode(topology)) {\n    const left = encodeTree(topology.left, parts, subdigests);\n    const right = encodeTree(topology.right, parts, subdigests);\n    const isLeftSigner = isSignerLeaf(topology.left);\n    const isRightSigner = isSignerLeaf(topology.right);\n    if (trim && left.weight === 0n && right.weight === 0n && !isLeftSigner && !isRightSigner) {\n      return {\n        // We don't need to include anything for this node\n        // just the hash will be enough\n        encoded: partEncoder.node(hashNode(topology)),\n        weight: 0n\n      };\n    }\n    if (trim && right.weight === 0n && !isRightSigner) {\n      return {\n        // The right node doesn't have any weight\n        // but we still need to include the left node encoded\n        encoded: partEncoder.concat(left.encoded, partEncoder.node(hashNode(topology.right))),\n        weight: left.weight\n      };\n    }\n    if (trim && left.weight === 0n && !isLeftSigner) {\n      return {\n        // The left node doesn't have any weight\n        // we can just append its hash, but for the right node\n        // we need to create a new \"branch\"\n        encoded: partEncoder.concat(partEncoder.node(hashNode(topology.left)), partEncoder.branch(right.encoded)),\n        weight: right.weight\n      };\n    }\n    return {\n      // Both nodes have weight, we need to include both\n      // the right one must be a branch\n      encoded: partEncoder.concat(left.encoded, partEncoder.branch(right.encoded)),\n      weight: left.weight + right.weight\n    };\n  }\n  if (isNestedLeaf(topology)) {\n    const tree = encodeTree(topology.tree, parts, subdigests);\n    if (trim && tree.weight === 0n) {\n      return {\n        encoded: partEncoder.node(hashNode(topology)),\n        weight: 0n\n      };\n    }\n    return {\n      encoded: partEncoder.nested(topology.weight, topology.threshold, tree.encoded),\n      weight: tree.weight\n    };\n  }\n  if (isNodeLeaf(topology)) {\n    return {\n      encoded: partEncoder.node(hashNode(topology)),\n      weight: 0n\n    };\n  }\n  if (isSubdigestLeaf(topology)) {\n    const include = subdigests.includes(topology.subdigest);\n    return {\n      encoded: partEncoder.subdigest(topology.subdigest),\n      weight: include ? _0xsequence_utils__WEBPACK_IMPORTED_MODULE_1__.MAX_UINT_256 : 0n\n    };\n  }\n  if (isSignerLeaf(topology)) {\n    const include = parts.has(topology.address);\n    if (include) {\n      const part = parts.get(topology.address);\n      const signature = part.signature;\n      if (options.forceDynamicEncoding || part.isDynamic) {\n        return {\n          encoded: partEncoder.dynamicSignature(topology.weight, topology.address, signature),\n          weight: BigInt(topology.weight)\n        };\n      } else {\n        return {\n          encoded: partEncoder.signature(topology.weight, signature),\n          weight: BigInt(topology.weight)\n        };\n      }\n    } else {\n      return {\n        encoded: partEncoder.address(topology.weight, topology.address),\n        weight: 0n\n      };\n    }\n  }\n  throw new Error(`Invalid topology - unknown error: ${JSON.stringify(topology)}`);\n}\nfunction deepestConfigOfSignature(signature) {\n  return isChainedSignature(signature) ? deepestConfigOfSignature(signature.suffix[signature.suffix.length - 1]) : signature.config;\n}\nfunction isUnrecoveredSignature(sig) {\n  return sig.type !== undefined && sig.decoded !== undefined && sig.version !== undefined && sig.version === 2;\n}\nfunction isUnrecoveredChainedSignature(sig) {\n  return sig.suffix !== undefined && Array.isArray(sig.suffix) && sig.suffix.every(isUnrecoveredSignature);\n}\nfunction isSignature(sig) {\n  return sig.type !== undefined && sig.config !== undefined && sig.digest !== undefined && sig.version !== undefined && sig.version === 2;\n}\nfunction isChainedSignature(sig) {\n  return sig.chain !== undefined && Array.isArray(sig.chain) && sig.chain.every(isSignature);\n}\nfunction decodeSignature(signature) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  const type = bytes[0];\n  switch (type) {\n    case SignatureType.Legacy:\n      return {\n        version: 2,\n        type: SignatureType.Legacy,\n        decoded: decodeSignatureBody(bytes)\n      };\n    case SignatureType.Dynamic:\n      return {\n        version: 2,\n        type: SignatureType.Dynamic,\n        decoded: decodeSignatureBody(bytes.slice(1))\n      };\n    case SignatureType.NoChainIdDynamic:\n      return {\n        version: 2,\n        type: SignatureType.NoChainIdDynamic,\n        decoded: decodeSignatureBody(bytes.slice(1))\n      };\n    case SignatureType.Chained:\n      return decodeChainedSignature(bytes);\n    default:\n      throw new Error(`Invalid signature type: ${type}`);\n  }\n}\nfunction decodeSignatureBody(signature) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  const threshold = bytes[0] << 8 | bytes[1];\n  const checkpoint = bytes[2] << 24 | bytes[3] << 16 | bytes[4] << 8 | bytes[5];\n  const tree = decodeSignatureTree(bytes.slice(6));\n  return {\n    threshold,\n    checkpoint,\n    tree\n  };\n}\nfunction decodeChainedSignature(signature) {\n  const arr = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  const type = arr[0];\n  if (type !== SignatureType.Chained) {\n    throw new Error(`Expected chained signature type: ${type}`);\n  }\n  const chain = [];\n  let index = 1;\n  while (index < arr.length) {\n    const size = arr[index] << 16 | arr[index + 1] << 8 | arr[index + 2];\n    index += 3;\n    const sig = decodeSignature(arr.slice(index, index + size));\n    chain.push(sig);\n    index += size;\n  }\n  const main = chain[0];\n  if (isUnrecoveredChainedSignature(main)) {\n    throw new Error(`Expected first link of chained signature to be a simple signature (not chained)`);\n  }\n  const suffix = chain.slice(1);\n  return _extends({}, main, {\n    suffix\n  });\n}\nfunction setImageHashStruct(imageHash) {\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes32', 'bytes32'], [ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['string'], ['SetImageHash(bytes32 imageHash)']), imageHash]);\n}\nasync function recoverSignature(signature, payload, provider) {\n  const signedPayload = payload.subdigest === undefined ? payload : undefined;\n  const isNoChainId = signature.type === SignatureType.NoChainIdDynamic;\n  if (isNoChainId && signedPayload) {\n    signedPayload.chainId = 0;\n  }\n  const subdigest = signedPayload ? subdigestOf(signedPayload) : payload.subdigest;\n  if (!isUnrecoveredChainedSignature(signature)) {\n    const tree = await recoverTopology(signature.decoded.tree, subdigest, provider);\n    return {\n      version: 2,\n      type: signature.type,\n      subdigest,\n      config: _extends({\n        version: 2\n      }, signature.decoded, {\n        tree\n      })\n    };\n  }\n  if (!isSignedPayload(signedPayload)) {\n    throw new Error(`Chained signature recovery requires detailed signed payload, subdigest is not enough`);\n  }\n  const result = [];\n  let mutatedPayload = signedPayload;\n\n  // Recover the chain of signatures\n  // NOTICE: Remove the suffix from the \"first\" siganture\n  // otherwise we recurse infinitely\n  for (const sig of [_extends({}, signature, {\n    suffix: undefined\n  }), ...signature.suffix]) {\n    const recovered = await recoverSignature(sig, mutatedPayload, provider);\n    result.unshift(recovered);\n    const nextMessage = setImageHashStruct(imageHash(deepestConfigOfSignature(recovered)));\n    mutatedPayload = _extends({}, mutatedPayload, {\n      message: nextMessage,\n      digest: ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(nextMessage)\n    });\n  }\n  const main = result[0];\n  const suffix = result.slice(1);\n  return _extends({}, main, {\n    suffix\n  });\n}\nfunction encodeChain(main, suffix) {\n  const allSignatures = [main, ...(suffix || [])];\n  const encodedMap = allSignatures.map(s => ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(encodeSignature(s)));\n  const body = ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(encodedMap.map(() => ['uint24', 'bytes']).flat(), encodedMap.map(s => [s.length, s]).flat());\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'bytes'], [SignatureType.Chained, body]);\n}\nfunction encodeSignature(decoded) {\n  if (ethers__WEBPACK_IMPORTED_MODULE_4__.isBytesLike(decoded)) return ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(decoded);\n  if (isUnrecoveredChainedSignature(decoded) || isChainedSignature(decoded)) {\n    return encodeChain(encodeSignature(decoded), (decoded.suffix || []).map(encodeSignature));\n  }\n  const body = isUnrecoveredSignature(decoded) ? decoded.decoded : decoded.config;\n  switch (decoded.type) {\n    case SignatureType.Legacy:\n      if (BigInt(body.threshold) > 255n) {\n        throw new Error(`Legacy signature threshold is too large: ${body.threshold} (max 255)`);\n      }\n      return encodeSignatureBody(body);\n    case SignatureType.NoChainIdDynamic:\n    case SignatureType.Dynamic:\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'bytes'], [decoded.type, encodeSignatureBody(body)]);\n    case SignatureType.Chained:\n      throw new Error(`Unreachable code: Chained signature should be handled above`);\n    default:\n      throw new Error(`Invalid signature type: ${decoded.type}`);\n  }\n}\nfunction encodeSignatureBody(decoded) {\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint16', 'uint32', 'bytes'], [decoded.threshold, decoded.checkpoint, encodeSignatureTree(decoded.tree)]);\n}\nfunction encodeSignatureTree(tree) {\n  if (isNode(tree) || isUnrecoveredNode(tree)) {\n    const encodedRight = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(encodeSignatureTree(tree.right));\n    const encodedLeft = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(encodeSignatureTree(tree.left));\n    const isBranching = isNode(tree.right) || isUnrecoveredNode(tree.right);\n    if (isBranching) {\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes', 'uint8', 'uint24', 'bytes'], [encodedLeft, SignaturePartType.Branch, encodedRight.length, encodedRight]);\n    } else {\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes', 'bytes'], [encodedLeft, encodedRight]);\n    }\n  }\n  if (isNestedLeaf(tree) || isUnrecoveredNestedLeaf(tree)) {\n    const nested = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(encodeSignatureTree(tree.tree));\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'uint16', 'uint24', 'bytes'], [SignaturePartType.Nested, tree.weight, tree.threshold, nested.length, nested]);\n  }\n  if (isUnrecoveredSignatureLeaf(tree) || isSignerLeaf(tree) && tree.signature !== undefined) {\n    const signature = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(tree.signature);\n    if (tree.isDynamic || signature.length !== SignaturePartTypeLength) {\n      if (!tree.address) throw new Error(`Dynamic signature leaf must have address`);\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'address', 'uint24', 'bytes'], [SignaturePartType.DynamicSignature, tree.weight, tree.address, signature.length, signature]);\n    } else {\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'bytes'], [SignaturePartType.Signature, tree.weight, signature]);\n    }\n  }\n  if (isSignerLeaf(tree)) {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'address'], [SignaturePartType.Address, tree.weight, tree.address]);\n  }\n  if (isNodeLeaf(tree)) {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Node, tree.nodeHash]);\n  }\n  if (isSubdigestLeaf(tree)) {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Subdigest, tree.subdigest]);\n  }\n  throw new Error(`Unknown signature tree type: ${tree}`);\n}\nfunction signaturesOf(topology) {\n  if (isNode(topology)) {\n    return [...signaturesOf(topology.left), ...signaturesOf(topology.right)];\n  }\n  if (isNestedLeaf(topology)) {\n    return signaturesOf(topology.tree);\n  }\n  if (isSignerLeaf(topology) && topology.signature) {\n    return [{\n      address: topology.address,\n      signature: topology.signature\n    }];\n  }\n  return [];\n}\nfunction signaturesOfDecoded(utopology) {\n  if (isUnrecoveredNode(utopology)) {\n    return [...signaturesOfDecoded(utopology.left), ...signaturesOfDecoded(utopology.right)];\n  }\n  if (isUnrecoveredNestedLeaf(utopology)) {\n    return signaturesOfDecoded(utopology.tree);\n  }\n  if (isUnrecoveredSignatureLeaf(utopology)) {\n    return [utopology.signature];\n  }\n  return [];\n}\nfunction subdigestsOfDecoded(utopology) {\n  if (isUnrecoveredNode(utopology)) {\n    return [...subdigestsOfDecoded(utopology.left), ...subdigestsOfDecoded(utopology.right)];\n  }\n  if (isUnrecoveredNestedLeaf(utopology)) {\n    return subdigestsOfDecoded(utopology.tree);\n  }\n  if (isSubdigestLeaf(utopology)) {\n    return [utopology.subdigest];\n  }\n  return [];\n}\nasync function trimSignature(signature) {\n  const decoded = typeof signature === 'string' ? decodeSignature(signature) : signature;\n  if (isUnrecoveredChainedSignature(decoded)) {\n    // We need to trim every suffix AND the main signature\n    const _trimmed = await Promise.all([trimSignature(_extends({}, decoded, {\n      suffix: undefined\n    })), ...decoded.suffix.map(s => trimSignature(s))]);\n    return encodeChain(_trimmed[0], _trimmed.slice(1));\n  }\n  const {\n    trimmed\n  } = await trimUnrecoveredTree(decoded.decoded.tree);\n  return encodeSignature(_extends({}, decoded, {\n    decoded: _extends({}, decoded.decoded, {\n      tree: trimmed\n    })\n  }));\n}\nasync function trimUnrecoveredTree(tree, trimStaticDigest = true) {\n  if (isUnrecoveredNode(tree)) {\n    const [left, right] = await Promise.all([trimUnrecoveredTree(tree.left), trimUnrecoveredTree(tree.right)]);\n    if (left.weight === 0 && right.weight === 0) {\n      try {\n        // If both weights are 0 then it means we don't have any signatures yet\n        // because of that, we should be able to \"recover\" the tree with any subdigest\n        // and still get the valid node hash (there shouldn't be any signatures to verify)\n        const recovered = await recoverTopology(tree, ethers__WEBPACK_IMPORTED_MODULE_11__.ZeroHash, undefined);\n        return {\n          weight: 0,\n          trimmed: {\n            nodeHash: hashNode(recovered)\n          }\n        };\n      } catch (_unused) {\n        // If something fails it's more likely because some signatures have sneaked in\n        // in that case we should keep this node\n      }\n    } else {\n      return {\n        weight: left.weight + right.weight,\n        trimmed: {\n          left: left.trimmed,\n          right: right.trimmed\n        }\n      };\n    }\n  }\n  if (isUnrecoveredNestedLeaf(tree)) {\n    const trimmed = await trimUnrecoveredTree(tree.tree);\n    if (trimmed.weight === 0) {\n      try {\n        // If the nested leaf is empty, we can recover it with any subdigest\n        // and still get the valid node hash (there shouldn't be any signatures to verify)\n        const recovered = await recoverTopology(tree, ethers__WEBPACK_IMPORTED_MODULE_11__.ZeroHash, undefined);\n        return {\n          weight: 0,\n          trimmed: {\n            nodeHash: hashNode(recovered)\n          }\n        };\n      } catch (_unused2) {\n        // If something fails it's more likely because some signatures have sneaked in\n        // in that case we should keep this node\n      }\n    }\n    return {\n      weight: trimmed.weight,\n      trimmed: {\n        weight: tree.weight,\n        threshold: tree.threshold,\n        tree: trimmed.trimmed\n      }\n    };\n  }\n\n  // Hash nodes can be encoded as signer leaves if they have a weight below\n  // 256, most likely the are signer leaves wrongly encoded\n  if (isNodeLeaf(tree) && isEncodedSignerLeaf(tree.nodeHash)) {\n    return {\n      weight: 0,\n      trimmed: _extends({}, decodeSignerLeaf(tree.nodeHash))\n    };\n  }\n  if (isUnrecoveredSignatureLeaf(tree) || isSignerLeaf(tree) && tree.signature !== undefined) {\n    return {\n      weight: Number(tree.weight),\n      trimmed: tree\n    };\n  }\n  if (!trimStaticDigest && isSubdigestLeaf(tree)) {\n    return {\n      weight: +Infinity,\n      trimmed: tree\n    };\n  }\n  return {\n    weight: 0,\n    trimmed: tree\n  };\n}\nconst SignatureCoder = {\n  decode: data => {\n    return decodeSignature(data);\n  },\n  encode: data => {\n    return encodeSignature(data);\n  },\n  trim: data => {\n    return trimSignature(data);\n  },\n  supportsNoChainId: true,\n  recover: (data, payload, provider) => {\n    return recoverSignature(data, payload, provider);\n  },\n  encodeSigners: (config, signatures, subdigests, chainId) => {\n    return encodeSigners(config, signatures, subdigests, chainId);\n  },\n  hasEnoughSigningPower: (config, signatures) => {\n    const {\n      weight\n    } = SignatureCoder.encodeSigners(config, signatures, [], 0);\n    return weight >= BigInt(config.threshold);\n  },\n  chainSignatures: (main, suffix) => {\n    // Notice: v2 expects suffix to be reversed\n    // that being: from signed to current imageHash\n    const reversed = suffix.reverse();\n    const mraw = ethers__WEBPACK_IMPORTED_MODULE_4__.isBytesLike(main) ? main : encodeSignature(main);\n    const sraw = reversed.map(s => ethers__WEBPACK_IMPORTED_MODULE_4__.isBytesLike(s) ? s : encodeSignature(s));\n    return encodeChain(mraw, sraw);\n  },\n  hashSetImageHash: function (imageHash) {\n    return hashSetImageHash(imageHash);\n  },\n  signaturesOf(config) {\n    return signaturesOf(config.tree);\n  },\n  signaturesOfDecoded: function (data) {\n    return signaturesOfDecoded(data.decoded.tree);\n  }\n};\n\nvar signature = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SignatureType: SignatureType,\n  SignaturePartType: SignaturePartType,\n  SignaturePartTypeLength: SignaturePartTypeLength,\n  isUnrecoveredNode: isUnrecoveredNode,\n  isUnrecoveredNestedLeaf: isUnrecoveredNestedLeaf,\n  isUnrecoveredSignatureLeaf: isUnrecoveredSignatureLeaf,\n  decodeSignatureTree: decodeSignatureTree,\n  InvalidSignatureLeafError: InvalidSignatureLeafError,\n  recoverTopology: recoverTopology,\n  partEncoder: partEncoder,\n  encodeSigners: encodeSigners,\n  encodeTree: encodeTree,\n  deepestConfigOfSignature: deepestConfigOfSignature,\n  isUnrecoveredSignature: isUnrecoveredSignature,\n  isUnrecoveredChainedSignature: isUnrecoveredChainedSignature,\n  isSignature: isSignature,\n  isChainedSignature: isChainedSignature,\n  decodeSignature: decodeSignature,\n  decodeSignatureBody: decodeSignatureBody,\n  decodeChainedSignature: decodeChainedSignature,\n  setImageHashStruct: setImageHashStruct,\n  recoverSignature: recoverSignature,\n  encodeChain: encodeChain,\n  encodeSignature: encodeSignature,\n  encodeSignatureBody: encodeSignatureBody,\n  encodeSignatureTree: encodeSignatureTree,\n  signaturesOf: signaturesOf,\n  signaturesOfDecoded: signaturesOfDecoded,\n  subdigestsOfDecoded: subdigestsOfDecoded,\n  trimSignature: trimSignature,\n  trimUnrecoveredTree: trimUnrecoveredTree,\n  SignatureCoder: SignatureCoder\n});\n\n//\n// Tree typings - leaves\n//\n\n// This is an unknown node\n// it means the tree has a branch\n// but we don't know what the content\n\nfunction isSignerLeaf(leaf) {\n  return leaf.address !== undefined && leaf.weight !== undefined;\n}\nfunction isSubdigestLeaf(leaf) {\n  return leaf.subdigest !== undefined && leaf.address === undefined;\n}\nfunction topologyToJSON(tree) {\n  if (isNode(tree)) {\n    return JSON.stringify({\n      left: topologyToJSON(tree.left),\n      right: topologyToJSON(tree.right)\n    });\n  }\n  if (isNestedLeaf(tree)) {\n    return JSON.stringify({\n      weight: BigInt(tree.weight).toString(),\n      threshold: BigInt(tree.threshold).toString(),\n      tree: topologyToJSON(tree.tree)\n    });\n  }\n  if (isSignerLeaf(tree)) {\n    return JSON.stringify({\n      address: tree.address,\n      weight: BigInt(tree.weight).toString()\n    });\n  }\n  return JSON.stringify(tree);\n}\nfunction topologyFromJSON(json) {\n  const parsed = typeof json === 'string' ? JSON.parse(json) : json;\n  if (parsed.left !== undefined && parsed.right !== undefined) {\n    return {\n      left: topologyFromJSON(parsed.left),\n      right: topologyFromJSON(parsed.right)\n    };\n  }\n  if (parsed.weight !== undefined && parsed.threshold !== undefined && parsed.tree !== undefined) {\n    return {\n      weight: BigInt(parsed.weight),\n      threshold: BigInt(parsed.threshold),\n      tree: topologyFromJSON(parsed.tree)\n    };\n  }\n  if (parsed.address !== undefined && parsed.weight !== undefined) {\n    return {\n      address: parsed.address,\n      weight: BigInt(parsed.weight)\n    };\n  }\n  return parsed;\n}\nfunction isNestedLeaf(leaf) {\n  return leaf.tree !== undefined && leaf.weight !== undefined && leaf.threshold !== undefined;\n}\nfunction isNodeLeaf(leaf) {\n  return leaf.nodeHash !== undefined;\n}\nfunction isLeaf(leaf) {\n  return isSignerLeaf(leaf) || isSubdigestLeaf(leaf) || isNestedLeaf(leaf) || isNodeLeaf(leaf);\n}\n\n//\n// Tree typings - nodes\n//\n\nfunction isNode(node) {\n  return node.left !== undefined && node.right !== undefined;\n}\nfunction isTopology(topology) {\n  return isNode(topology) || isLeaf(topology);\n}\nfunction encodeSignerLeaf(leaf) {\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint96', 'address'], [leaf.weight, leaf.address]);\n}\nfunction decodeSignerLeaf(encoded) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(encoded);\n  if (bytes.length !== 32) {\n    throw new Error('Invalid encoded string length');\n  }\n  const weight = BigInt(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(0, 12)));\n  const address = ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(12)));\n  return {\n    weight,\n    address\n  };\n}\nfunction isEncodedSignerLeaf(encoded) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(encoded);\n  if (bytes.length !== 32) {\n    return false;\n  }\n  const prefix = bytes.slice(0, 11);\n  return prefix.every(byte => byte === 0);\n}\nfunction hashNode(node) {\n  if (isSignerLeaf(node)) {\n    return encodeSignerLeaf(node);\n  }\n  if (isSubdigestLeaf(node)) {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['string', 'bytes32'], ['Sequence static digest:\\n', node.subdigest]);\n  }\n  if (isNestedLeaf(node)) {\n    const nested = hashNode(node.tree);\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['string', 'bytes32', 'uint256', 'uint256'], ['Sequence nested config:\\n', nested, node.threshold, node.weight]);\n  }\n  if (isNodeLeaf(node)) {\n    return node.nodeHash;\n  }\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['bytes32', 'bytes32'], [hashNode(node.left), hashNode(node.right)]);\n}\nfunction leftFace(topology) {\n  const stack = [];\n  let prev = topology;\n  while (!isLeaf(prev)) {\n    stack.unshift(prev.right);\n    prev = prev.left;\n  }\n  stack.unshift(prev);\n  return stack;\n}\n\n//\n// Wallet config types\n//\n\nfunction isWalletConfig(config) {\n  return config.threshold !== undefined && config.checkpoint !== undefined && config.tree !== undefined && config.version !== undefined && config.version === 2;\n}\nfunction imageHash(config) {\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['bytes32', 'uint256'], [ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['bytes32', 'uint256'], [hashNode(config.tree), config.threshold]), config.checkpoint]);\n}\n\n//\n// Simple wallet config types\n// (used for building and reading merkle configs)\n//\n// dev: `members` is a flat representation of the tree\n//      it keeps relevant structure like 'nested trees' but\n//      it ignores the tree structure\n//\n//\n\nfunction isSimpleNestedMember(member) {\n  return member.threshold !== undefined && member.weight !== undefined && member.members !== undefined;\n}\nfunction topologyToMembers(tree) {\n  if (isSignerLeaf(tree) || isSubdigestLeaf(tree)) {\n    return [tree];\n  }\n  if (isNestedLeaf(tree)) {\n    return [{\n      threshold: tree.threshold,\n      weight: tree.weight,\n      members: topologyToMembers(tree.tree)\n    }];\n  }\n  if (isNodeLeaf(tree)) {\n    // we don't know the content of this node\n    // so we omit it\n    return [];\n  }\n  return [...topologyToMembers(tree.left), ...topologyToMembers(tree.right)];\n}\nfunction hasUnknownNodes(tree) {\n  if (isNodeLeaf(tree)) {\n    return true;\n  }\n  if (isNode(tree)) {\n    return hasUnknownNodes(tree.left) || hasUnknownNodes(tree.right);\n  }\n  return false;\n}\nfunction toSimpleWalletConfig(config) {\n  return {\n    threshold: config.threshold,\n    checkpoint: config.checkpoint,\n    members: topologyToMembers(config.tree)\n  };\n}\nconst membersAsTopologies = (members, builder) => {\n  return members.map(member => {\n    if (isSimpleNestedMember(member)) {\n      return {\n        tree: builder(member.members),\n        threshold: member.threshold,\n        weight: member.weight\n      };\n    }\n    return member;\n  });\n};\nfunction legacyTopologyBuilder(members) {\n  if (members.length === 0) {\n    throw new Error('Empty members array');\n  }\n  const asTopologies = membersAsTopologies(members, legacyTopologyBuilder);\n  return asTopologies.reduce((acc, member) => {\n    return {\n      left: acc,\n      right: member\n    };\n  });\n}\nfunction merkleTopologyBuilder(members) {\n  if (members.length === 0) {\n    throw new Error('Empty members array');\n  }\n  const leaves = membersAsTopologies(members, merkleTopologyBuilder);\n  for (let s = leaves.length; s > 1; s = s / 2) {\n    for (let i = 0; i < s / 2; i++) {\n      const j1 = i * 2;\n      const j2 = j1 + 1;\n      if (j2 >= s) {\n        leaves[i] = leaves[j1];\n      } else {\n        leaves[i] = {\n          left: leaves[j1],\n          right: leaves[j2]\n        };\n      }\n    }\n  }\n  return leaves[0];\n}\nfunction optimized2SignersTopologyBuilder(members) {\n  if (members.length > 8) {\n    return merkleTopologyBuilder(members);\n  }\n  return legacyTopologyBuilder(members);\n}\nfunction toWalletConfig(simpleWalletConfig, builder = optimized2SignersTopologyBuilder) {\n  return {\n    version: 2,\n    threshold: simpleWalletConfig.threshold,\n    checkpoint: simpleWalletConfig.checkpoint,\n    tree: builder(simpleWalletConfig.members)\n  };\n}\nfunction hasSubdigest(tree, subdigest) {\n  if (isSubdigestLeaf(tree)) {\n    return tree.subdigest === subdigest;\n  }\n  if (isNode(tree)) {\n    return hasSubdigest(tree.left, subdigest) || hasSubdigest(tree.right, subdigest);\n  }\n  return false;\n}\nfunction signersOf(tree) {\n  const stack = [tree];\n  const signers = new Set();\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (isNestedLeaf(node)) {\n      stack.push(node.tree);\n    } else if (isNode(node)) {\n      stack.push(node.left);\n      stack.push(node.right);\n    } else if (isSignerLeaf(node)) {\n      signers.add({\n        address: node.address,\n        weight: Number(node.weight)\n      });\n    }\n  }\n  return Array.from(signers);\n}\nfunction isComplete(tree) {\n  if (isNode(tree)) {\n    return isComplete(tree.left) && isComplete(tree.right);\n  }\n  return !isNodeLeaf(tree);\n}\nconst ConfigCoder = {\n  isWalletConfig: config => {\n    return config.version === 2 && config.threshold !== undefined && config.tree !== undefined;\n  },\n  imageHashOf: config => {\n    return imageHash(config);\n  },\n  hasSubdigest: (config, subdigest) => {\n    return hasSubdigest(config.tree, subdigest);\n  },\n  checkpointOf: config => {\n    return BigInt(config.checkpoint);\n  },\n  signersOf: config => {\n    return signersOf(config.tree);\n  },\n  fromSimple: config => {\n    var _config$subdigests;\n    return toWalletConfig(_extends({}, config, {\n      members: [...config.signers, ...((_config$subdigests = config.subdigests) != null ? _config$subdigests : []).map(subdigest => ({\n        subdigest\n      }))]\n    }));\n  },\n  isComplete: config => {\n    return isComplete(config.tree);\n  },\n  // isValid = (config: WalletConfig): boolean {}\n  /**\n   *\n   * Notice: context and kind are ignored because v2\n   * doesn't need to manually update the implementation before\n   * a configuration update, it's automatically done by the contract.\n   *\n   */\n  update: {\n    isKindUsed: true,\n    buildTransaction: (wallet, config, _context, _kind) => {\n      const module = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(_0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModuleUpgradable.abi);\n      return {\n        entrypoint: wallet,\n        transactions: [{\n          to: wallet,\n          data: module.encodeFunctionData(module.getFunction('updateImageHash'), [ConfigCoder.imageHashOf(config)]),\n          gasLimit: 0,\n          delegateCall: false,\n          revertOnError: true,\n          value: 0\n        }]\n      };\n    },\n    decodeTransaction: function (tx) {\n      var _tx$transactions$0$va, _tx$transactions$, _tx$transactions$0$ga, _tx$transactions$2;\n      const module = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(_0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModuleUpgradable.abi);\n      if (tx.transactions.length !== 1) {\n        throw new Error('Invalid transaction bundle, expected 1 transaction');\n      }\n      const data = tx.transactions[0].data;\n      if (!data) {\n        throw new Error('Invalid transaction bundle, expected data');\n      }\n      const decoded = module.decodeFunctionData(module.getFunction('updateImageHash'), data);\n      if (!decoded) {\n        throw new Error('Invalid transaction bundle, expected valid data');\n      }\n      if (tx.transactions[0].to !== tx.entrypoint) {\n        throw new Error('Invalid transaction bundle, expected to be sent to entrypoint');\n      }\n      if (tx.transactions[0].delegateCall) {\n        throw new Error('Invalid transaction bundle, expected not to be a delegateCall');\n      }\n      if (!tx.transactions[0].revertOnError) {\n        throw new Error('Invalid transaction bundle, expected revertOnError');\n      }\n      if (BigInt((_tx$transactions$0$va = (_tx$transactions$ = tx.transactions[0]) == null ? void 0 : _tx$transactions$.value) != null ? _tx$transactions$0$va : 0) !== 0n) {\n        throw new Error('Invalid transaction bundle, expected value to be 0');\n      }\n      if (BigInt((_tx$transactions$0$ga = (_tx$transactions$2 = tx.transactions[0]) == null ? void 0 : _tx$transactions$2.gasLimit) != null ? _tx$transactions$0$ga : 0) !== 0n) {\n        throw new Error('Invalid transaction bundle, expected value to be 0');\n      }\n      return {\n        address: tx.entrypoint,\n        newImageHash: decoded[0],\n        kind: undefined\n      };\n    }\n  },\n  toJSON: function (config) {\n    return JSON.stringify({\n      version: config.version,\n      threshold: BigInt(config.threshold).toString(),\n      checkpoint: BigInt(config.checkpoint).toString(),\n      tree: topologyToJSON(config.tree)\n    });\n  },\n  fromJSON: function (json) {\n    const config = JSON.parse(json);\n    return {\n      version: config.version,\n      threshold: BigInt(config.threshold),\n      checkpoint: BigInt(config.checkpoint),\n      tree: topologyFromJSON(config.tree)\n    };\n  },\n  editConfig: function (config, action) {\n    var _action$threshold, _action$checkpoint;\n    const members = topologyToMembers(config.tree);\n    if (action.add) {\n      for (const signer of action.add) {\n        if (members.find(s => isSignerLeaf(s) && s.address === signer.address)) {\n          continue;\n        }\n        members.push({\n          address: signer.address,\n          weight: signer.weight\n        });\n      }\n    }\n    if (action.remove) {\n      for (const address of action.remove) {\n        const index = members.findIndex(s => isSignerLeaf(s) && s.address === address);\n        if (index >= 0) {\n          members.splice(index, 1);\n        }\n      }\n    }\n    return {\n      version: config.version,\n      threshold: (_action$threshold = action.threshold) != null ? _action$threshold : config.threshold,\n      checkpoint: (_action$checkpoint = action.checkpoint) != null ? _action$checkpoint : config.checkpoint,\n      tree: optimized2SignersTopologyBuilder(members)\n    };\n  },\n  buildStubSignature: function (config, overrides) {\n    const parts = new Map();\n    for (const [signer, signature] of overrides.entries()) {\n      parts.set(signer, {\n        signature,\n        isDynamic: true\n      });\n      const {\n        encoded,\n        weight\n      } = encodeSigners(config, parts, [], 0);\n      if (weight >= BigInt(config.threshold)) {\n        return encoded;\n      }\n    }\n    const signers = signersOf(config.tree);\n    for (const {\n      address\n    } of signers.sort(({\n      weight: a\n    }, {\n      weight: b\n    }) => a - b)) {\n      const signature = '0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02';\n      parts.set(address, {\n        signature,\n        isDynamic: false\n      });\n      const {\n        encoded,\n        weight\n      } = encodeSigners(config, parts, [], 0);\n      if (weight >= BigInt(config.threshold)) {\n        return encoded;\n      }\n    }\n    return encodeSigners(config, parts, [], 0).encoded;\n  }\n};\n\nvar config$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  isSignerLeaf: isSignerLeaf,\n  isSubdigestLeaf: isSubdigestLeaf,\n  topologyToJSON: topologyToJSON,\n  topologyFromJSON: topologyFromJSON,\n  isNestedLeaf: isNestedLeaf,\n  isNodeLeaf: isNodeLeaf,\n  isLeaf: isLeaf,\n  isNode: isNode,\n  isTopology: isTopology,\n  encodeSignerLeaf: encodeSignerLeaf,\n  decodeSignerLeaf: decodeSignerLeaf,\n  isEncodedSignerLeaf: isEncodedSignerLeaf,\n  hashNode: hashNode,\n  leftFace: leftFace,\n  isWalletConfig: isWalletConfig,\n  imageHash: imageHash,\n  isSimpleNestedMember: isSimpleNestedMember,\n  topologyToMembers: topologyToMembers,\n  hasUnknownNodes: hasUnknownNodes,\n  toSimpleWalletConfig: toSimpleWalletConfig,\n  legacyTopologyBuilder: legacyTopologyBuilder,\n  merkleTopologyBuilder: merkleTopologyBuilder,\n  optimized2SignersTopologyBuilder: optimized2SignersTopologyBuilder,\n  toWalletConfig: toWalletConfig,\n  hasSubdigest: hasSubdigest,\n  signersOf: signersOf,\n  isComplete: isComplete,\n  ConfigCoder: ConfigCoder\n});\n\nvar context$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nconst coders = {\n  config: ConfigCoder,\n  signature: SignatureCoder\n};\nconst version = 2;\nconst DeployedWalletContext = {\n  version: version,\n  factory: '0xFaA5c0b14d1bED5C888Ca655B9a8A5911F78eF4A',\n  guestModule: '0xfea230Ee243f88BC698dD8f1aE93F8301B6cdfaE',\n  mainModule: '0xfBf8f1A5E00034762D928f46d438B947f5d4065d',\n  mainModuleUpgradable: '0x4222dcA3974E39A8b41c411FeDDE9b09Ae14b911',\n  walletCreationCode: '0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3',\n  proxyImplementationHook: '0x1f56dbAD5e8319F0DE9a323E24A31b5077dEB1a4'\n};\n\nvar v2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  config: config$1,\n  signature: signature,\n  context: context$1,\n  chained: chained,\n  coders: coders,\n  version: version,\n  DeployedWalletContext: DeployedWalletContext\n});\n\nvar config = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nfunction addressOf(context, imageHash) {\n  const codeHash = ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes', 'bytes32'], [context.walletCreationCode, ethers__WEBPACK_IMPORTED_MODULE_4__.zeroPadValue(context.mainModule, 32)]));\n  const hash = ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes1', 'address', 'bytes32', 'bytes32'], ['0xff', context.factory, imageHash, codeHash]));\n  return ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.dataSlice(hash, 12));\n}\nasync function isValidCounterfactual(wallet, digest, signature, chainId, provider, contexts) {\n  // We don't know the version of the signature\n  // so we need to try all of them\n  const res = await Promise.all(allVersions.map(async version => {\n    try {\n      const decoded = version.signature.SignatureCoder.decode(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(signature));\n      const recovered1 = await version.signature.SignatureCoder.recover(decoded, {\n        address: wallet,\n        digest: ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(digest),\n        chainId\n      }, provider);\n      const imageHash = version.config.ConfigCoder.imageHashOf(recovered1.config);\n      const counterfactualAddress = addressOf(contexts[version.version], imageHash);\n      if (counterfactualAddress.toLowerCase() === wallet.toLowerCase()) {\n        return true;\n      }\n\n      // chainId=0 means no chainId, so the signature is valid for all chains\n      // we need to check that case too\n      const recovered2 = await version.signature.SignatureCoder.recover(decoded, {\n        address: wallet,\n        digest: ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(digest),\n        chainId\n      }, provider);\n      const imageHash2 = version.config.ConfigCoder.imageHashOf(recovered2.config);\n      const counterfactualAddress2 = addressOf(contexts[version.version], imageHash2);\n      return counterfactualAddress2.toLowerCase() === wallet.toLowerCase();\n    } catch (_unused) {}\n\n    // We most likely failed to decode the signature\n    return false;\n  }));\n  return res.some(r => r);\n}\nfunction isValidVersionedContext(contexts) {\n  // number of keys is the number of versions\n  const versions = Object.keys(contexts).length;\n\n  // check that all versions exist and are valid\n  for (let i = 1; i <= versions; i++) {\n    const context = contexts[i];\n    if (!context || context.version !== i) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction latestContext(contexts) {\n  const versions = Object.keys(contexts).length;\n  return contexts[versions];\n}\nconst defaultContexts = {\n  1: DeployedWalletContext$1,\n  2: DeployedWalletContext\n};\n\nvar context = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  addressOf: addressOf,\n  isValidCounterfactual: isValidCounterfactual,\n  isValidVersionedContext: isValidVersionedContext,\n  latestContext: latestContext,\n  defaultContexts: defaultContexts\n});\n\nconst MetaTransactionsType = `tuple(\n  bool delegateCall,\n  bool revertOnError,\n  uint256 gasLimit,\n  address target,\n  uint256 value,\n  bytes data\n)[]`;\nfunction intendTransactionBundle(bundle, wallet, chainId, id) {\n  return _extends({}, bundle, {\n    chainId,\n    intent: {\n      id: id,\n      wallet\n    }\n  });\n}\nfunction intendedTransactionID(bundle) {\n  return ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().encode(['address', 'uint256', 'bytes32'], [bundle.intent.wallet, bundle.chainId, bundle.intent.id]));\n}\nfunction unpackMetaTransactionsData(data) {\n  const res = ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().decode(['uint256', MetaTransactionsType], data);\n  if (res.length !== 2 || !res[0] || !res[1]) throw new Error('Invalid meta transaction data');\n  return [res[0], res[1]];\n}\nfunction packMetaTransactionsData(nonce, txs) {\n  return ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().encode(['uint256', MetaTransactionsType], [nonce, sequenceTxAbiEncode(txs)]);\n}\nfunction digestOfTransactions(nonce, txs) {\n  return ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(packMetaTransactionsData(nonce, txs));\n}\nfunction subdigestOfTransactions(address, chainId, nonce, txs) {\n  return subdigestOf({\n    address,\n    chainId,\n    digest: digestOfTransactions(nonce, txs)\n  });\n}\nfunction subdigestOfGuestModuleTransactions(guestModule, chainId, txs) {\n  return subdigestOf({\n    address: guestModule,\n    chainId,\n    digest: ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().encode(['string', MetaTransactionsType], ['guest:', sequenceTxAbiEncode(txs)]))\n  });\n}\nfunction toSequenceTransactions(wallet, txs) {\n  return txs.map(tx => toSequenceTransaction(wallet, tx));\n}\nfunction toSequenceTransaction(wallet, tx) {\n  if (tx.to && tx.to !== ethers__WEBPACK_IMPORTED_MODULE_12__.ZeroAddress) {\n    return {\n      nonce: !isNullish(tx.nonce) ? BigInt(tx.nonce) : undefined,\n      transaction: {\n        delegateCall: false,\n        revertOnError: false,\n        gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : undefined,\n        // XXX: `tx.to` could also be ethers Addressable type which returns a getAddress promise\n        // Keeping this as is for now so we don't have to change everything to async\n        to: tx.to,\n        value: BigInt(tx.value || 0),\n        data: tx.data || '0x'\n      }\n    };\n  } else {\n    const walletInterface = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(_0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModule.abi);\n    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('createContract'), [tx.data]);\n    return {\n      nonce: typeof tx.nonce === 'number' ? BigInt(tx.nonce) : undefined,\n      transaction: {\n        delegateCall: false,\n        revertOnError: false,\n        gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : undefined,\n        to: wallet,\n        value: BigInt(tx.value || 0),\n        data\n      }\n    };\n  }\n}\nfunction isSequenceTransaction(tx) {\n  return tx.delegateCall !== undefined || tx.revertOnError !== undefined;\n}\nfunction hasSequenceTransactions(txs) {\n  return txs.every(isSequenceTransaction);\n}\n\n// TODO: We may be able to remove this if we make Transaction === TransactionEncoded\nfunction sequenceTxAbiEncode(txs) {\n  return txs.map(tx => {\n    var _tx$to;\n    return {\n      delegateCall: tx.delegateCall === true,\n      revertOnError: tx.revertOnError === true,\n      gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : 0n,\n      target: (_tx$to = tx.to) != null ? _tx$to : ethers__WEBPACK_IMPORTED_MODULE_12__.ZeroAddress,\n      value: !isNullish(tx.value) ? tx.value : 0n,\n      data: tx.data || '0x'\n    };\n  });\n}\nfunction fromTxAbiEncode(txs) {\n  return txs.map(tx => ({\n    delegateCall: tx.delegateCall,\n    revertOnError: tx.revertOnError,\n    gasLimit: tx.gasLimit,\n    to: tx.target,\n    value: tx.value,\n    data: tx.data\n  }));\n}\n\n// export function appendNonce(txs: Transaction[], nonce: ethers.BigNumberish): Transaction[] {\n//   return txs.map((t: Transaction) => ({ ...t, nonce }))\n// }\n\nfunction encodeNonce(space, nonce) {\n  const bspace = BigInt(space);\n  const bnonce = BigInt(nonce);\n  const shl = 2n ** 96n;\n  if (bnonce / shl !== 0n) {\n    throw new Error('Space already encoded');\n  }\n  return bnonce + bspace * shl;\n}\nfunction decodeNonce(nonce) {\n  const bnonce = BigInt(nonce);\n  const shr = 2n ** 96n;\n  return [bnonce / shr, bnonce % shr];\n}\nfunction fromTransactionish(wallet, transaction) {\n  if (Array.isArray(transaction)) {\n    if (hasSequenceTransactions(transaction)) {\n      return transaction;\n    } else {\n      const stx = toSequenceTransactions(wallet, transaction);\n      return stx.map(t => t.transaction);\n    }\n  } else if (isSequenceTransaction(transaction)) {\n    return [transaction];\n  } else {\n    return [toSequenceTransaction(wallet, transaction).transaction];\n  }\n}\nfunction isTransactionBundle(cand) {\n  return cand !== undefined && cand.entrypoint !== undefined && cand.chainId !== undefined && cand.transactions !== undefined && cand.nonce !== undefined && cand.intent !== undefined && cand.intent.id !== undefined && cand.intent.wallet !== undefined && Array.isArray(cand.transactions) && cand.transactions.reduce((p, c) => p && isSequenceTransaction(c), true);\n}\nfunction isSignedTransactionBundle(cand) {\n  return cand !== undefined && cand.signature !== undefined && cand.signature !== '' && isTransactionBundle(cand);\n}\nfunction encodeBundleExecData(bundle) {\n  const walletInterface = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(_0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModule.abi);\n  return walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), isSignedTransactionBundle(bundle) ? [\n  // Signed transaction bundle has all 3 parameters\n  sequenceTxAbiEncode(bundle.transactions), bundle.nonce, bundle.signature] : [\n  // Unsigned bundle may be a GuestModule call, so signature and nonce are missing\n  sequenceTxAbiEncode(bundle.transactions), 0, new Uint8Array([])]);\n}\n\n// TODO: Use Sequence ABI package\nconst selfExecuteSelector = '0x61c2926c';\nconst selfExecuteAbi = `tuple(\n  bool delegateCall,\n  bool revertOnError,\n  uint256 gasLimit,\n  address target,\n  uint256 value,\n  bytes data\n)[]`;\n\n// Splits Sequence batch transactions into individual parts\nconst unwind = (wallet, transactions) => {\n  const unwound = [];\n  const walletInterface = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(_0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModule.abi);\n  for (const tx of transactions) {\n    const txData = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(tx.data || '0x');\n    if (tx.to === wallet && ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(txData.slice(0, 4)) === selfExecuteSelector) {\n      // Decode as selfExecute call\n      const data = txData.slice(4);\n      const decoded = ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().decode([selfExecuteAbi], data)[0];\n      unwound.push(...unwind(tx.to, decoded.map(d => _extends({}, d, {\n        to: d.target\n      }))));\n    } else {\n      try {\n        const innerTransactions = walletInterface.decodeFunctionData('execute', txData)[0];\n        const unwoundTransactions = unwind(wallet, innerTransactions.map(tx => _extends({}, tx.toObject(), {\n          to: tx.target\n        })));\n        unwound.push(...unwoundTransactions);\n      } catch (_unused) {\n        unwound.push(tx);\n      }\n    }\n  }\n  return unwound;\n};\nconst isNullish = value => value === null || value === void 0;\n\nvar transaction = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MetaTransactionsType: MetaTransactionsType,\n  intendTransactionBundle: intendTransactionBundle,\n  intendedTransactionID: intendedTransactionID,\n  unpackMetaTransactionsData: unpackMetaTransactionsData,\n  packMetaTransactionsData: packMetaTransactionsData,\n  digestOfTransactions: digestOfTransactions,\n  subdigestOfTransactions: subdigestOfTransactions,\n  subdigestOfGuestModuleTransactions: subdigestOfGuestModuleTransactions,\n  toSequenceTransactions: toSequenceTransactions,\n  toSequenceTransaction: toSequenceTransaction,\n  isSequenceTransaction: isSequenceTransaction,\n  hasSequenceTransactions: hasSequenceTransactions,\n  sequenceTxAbiEncode: sequenceTxAbiEncode,\n  fromTxAbiEncode: fromTxAbiEncode,\n  encodeNonce: encodeNonce,\n  decodeNonce: decodeNonce,\n  fromTransactionish: fromTransactionish,\n  isTransactionBundle: isTransactionBundle,\n  isSignedTransactionBundle: isSignedTransactionBundle,\n  encodeBundleExecData: encodeBundleExecData,\n  selfExecuteSelector: selfExecuteSelector,\n  selfExecuteAbi: selfExecuteAbi,\n  unwind: unwind\n});\n\n/* Source of Offchain EIP-6492 validation:\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\n\n// As per ERC-1271\ninterface IERC1271Wallet {\n  function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\n}\n\nerror ERC1271Revert(bytes error);\nerror ERC6492DeployFailed(bytes error);\n\ncontract UniversalSigValidator {\n  bytes32 private constant ERC6492_DETECTION_SUFFIX = 0x6492649264926492649264926492649264926492649264926492649264926492;\n  bytes4 private constant ERC1271_SUCCESS = 0x1626ba7e;\n\n  function isValidSigImpl(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature,\n    bool allowSideEffects,\n    bool deployAlreadyDeployed\n  ) public returns (bool) {\n    uint contractCodeLen = address(_signer).code.length;\n    bytes memory sigToValidate;\n    // The order here is striclty defined in https://eips.ethereum.org/EIPS/eip-6492\n    // - ERC-6492 suffix check and verification first, while being permissive in case the contract is already deployed; if the contract is deployed we will check the sig against the deployed version, this allows 6492 signatures to still be validated while taking into account potential key rotation\n    // - ERC-1271 verification if there's contract code\n    // - finally, ecrecover\n    bool isCounterfactual = bytes32(_signature[_signature.length-32:_signature.length]) == ERC6492_DETECTION_SUFFIX;\n    if (isCounterfactual) {\n      address create2Factory;\n      bytes memory factoryCalldata;\n      (create2Factory, factoryCalldata, sigToValidate) = abi.decode(_signature[0:_signature.length-32], (address, bytes, bytes));\n\n      if (contractCodeLen == 0 || deployAlreadyDeployed) {\n        (bool success, bytes memory err) = create2Factory.call(factoryCalldata);\n        if (!success) revert ERC6492DeployFailed(err);\n      }\n    } else {\n      sigToValidate = _signature;\n    }\n\n    // Try ERC-1271 verification\n    if (isCounterfactual || contractCodeLen > 0) {\n      try IERC1271Wallet(_signer).isValidSignature(_hash, sigToValidate) returns (bytes4 magicValue) {\n        bool isValid = magicValue == ERC1271_SUCCESS;\n\n        // EXPERIMENTAL: This is not part of the EIP-6492 spec *yet*\n        // but it may be useful to retry the call making the factory call\n        // even if the wallet is already deployed, in case the wallet\n        // needs to perform some sort of migration or onchain key rotation\n        if (!isValid && !deployAlreadyDeployed && contractCodeLen > 0) {\n          return isValidSigImpl(_signer, _hash, _signature, allowSideEffects, true);\n        }\n\n        if (contractCodeLen == 0 && isCounterfactual && !allowSideEffects) {\n          // if the call had side effects we need to return the\n          // result using a `revert` (to undo the state changes)\n          assembly {\n            mstore(0, isValid)\n            revert(31, 1)\n          }\n        }\n\n        return isValid;\n      } catch (bytes memory err) {\n        // EXPERIMENTAL: This is not part of the EIP-6492 spec *yet*\n        // but it may be useful to retry the call making the factory call\n        // even if the wallet is already deployed, in case the wallet\n        // needs to perform some sort of migration or onchain key rotation\n        if (!deployAlreadyDeployed && contractCodeLen > 0) {\n          return isValidSigImpl(_signer, _hash, _signature, allowSideEffects, true);\n        }\n\n        revert ERC1271Revert(err);\n      }\n    }\n\n    // ecrecover verification\n    require(_signature.length == 65, 'SignatureValidator#recoverSigner: invalid signature length');\n    bytes32 r = bytes32(_signature[0:32]);\n    bytes32 s = bytes32(_signature[32:64]);\n    uint8 v = uint8(_signature[64]);\n\n    if (v != 27 && v != 28) {\n      revert('SignatureValidator: invalid signature v value');\n    }\n\n    return ecrecover(_hash, v, r, s) == _signer;\n  }\n\n  function isValidSigWithSideEffects(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature\n  ) external returns (bool) {\n    return this.isValidSigImpl(_signer, _hash, _signature, true, false);\n  }\n\n  function isValidSig(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature\n  ) external returns (bool) {\n    try this.isValidSigImpl(_signer, _hash, _signature, false, false) returns (bool isValid) {\n      return isValid;\n    } catch (bytes memory error) {\n      // in order to avoid side effects from the contract getting deployed, the entire call will revert with a single byte result\n      uint len = error.length;\n      if (len == 1) {\n        return error[0] == 0x01;\n        // all other errors are simply forwarded, but in custom formats so that nothing else can revert with a single byte in the call\n      } else {\n        assembly { revert(error, len) }\n      }\n    }\n  }\n\n  // NOTICE: These functions aren't part of the standard\n  // they are helpers that behave like the above functions\n  // but they don't revert on failure, instead they return false\n\n  function isValidSigNoThrow(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature\n  ) external returns (bool) {\n    try this.isValidSigImpl(_signer, _hash, _signature, false, false) returns (bool isValid) {\n      return isValid;\n    } catch (bytes memory error) {\n      // in order to avoid side effects from the contract getting deployed, the entire call will revert with a single byte result\n      uint len = error.length;\n      if (len == 1) {\n        return error[0] == 0x01;\n        // all other errors are simply forwarded, but in custom formats so that nothing else can revert with a single byte in the call\n      } else {\n        // Ignore all other errors and return false\n        return false;\n      }\n    }\n  }\n\n  function isValidSigWithSideEffectsNoThrow(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature\n  ) external returns (bool) {\n    try this.isValidSigImpl(_signer, _hash, _signature, true, false) returns (bool isValid) {\n      return isValid;\n    } catch (bytes memory error) {\n      // Ignore all errors and return false\n      return false;\n    }\n  }\n}\n\n// this is a helper so we can perform validation in a single eth_call without pre-deploying a singleton\ncontract ValidateSigOffchain {\n  constructor (address _signer, bytes32 _hash, bytes memory _signature) {\n    UniversalSigValidator validator = new UniversalSigValidator();\n    bool isValidSig = validator.isValidSigWithSideEffects(_signer, _hash, _signature);\n    assembly {\n      mstore(0, isValidSig)\n      return(31, 1)\n    }\n  }\n}\n*/\n\nconst EIP_6492_OFFCHAIN_DEPLOY_CODE = '0x608060405234801561001057600080fd5b5060405161124a38038061124a83398101604081905261002f91610124565b600060405161003d906100dd565b604051809103906000f080158015610059573d6000803e3d6000fd5b5090506000816001600160a01b0316638f0684308686866040518463ffffffff1660e01b815260040161008e939291906101fb565b6020604051808303816000875af11580156100ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100d19190610244565b9050806000526001601ff35b610fdc8061026e83390190565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561011b578181015183820152602001610103565b50506000910152565b60008060006060848603121561013957600080fd5b83516001600160a01b038116811461015057600080fd5b6020850151604086015191945092506001600160401b038082111561017457600080fd5b818601915086601f83011261018857600080fd5b81518181111561019a5761019a6100ea565b604051601f8201601f19908116603f011681019083821181831017156101c2576101c26100ea565b816040528281528960208487010111156101db57600080fd5b6101ec836020830160208801610100565b80955050505050509250925092565b60018060a01b0384168152826020820152606060408201526000825180606084015261022e816080850160208701610100565b601f01601f191691909101608001949350505050565b60006020828403121561025657600080fd5b8151801515811461026657600080fd5b939250505056fe608060405234801561001057600080fd5b50610fbc806100206000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c806376be4cea1161005057806376be4cea146100a65780638f068430146100b957806398ef1ed8146100cc57600080fd5b80631c6453271461006c5780633d787b6314610093575b600080fd5b61007f61007a366004610ad4565b6100df565b604051901515815260200160405180910390f35b61007f6100a1366004610ad4565b61023d565b61007f6100b4366004610b3e565b61031e565b61007f6100c7366004610ad4565b6108e1565b61007f6100da366004610ad4565b61096e565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061012890889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610181575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261017e91810190610c45565b60015b610232573d8080156101af576040519150601f19603f3d011682016040523d82523d6000602084013e6101b4565b606091505b508051600181900361022757816000815181106101d3576101d3610c69565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f0100000000000000000000000000000000000000000000000000000000000000149250610235915050565b600092505050610235565b90505b949350505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906102879088908890889088906001908990600401610bc3565b6020604051808303816000875af19250505080156102e0575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526102dd91810190610c45565b60015b610232573d80801561030e576040519150601f19603f3d011682016040523d82523d6000602084013e610313565b606091505b506000915050610235565b600073ffffffffffffffffffffffffffffffffffffffff87163b6060827f64926492649264926492649264926492649264926492649264926492649264928888610369602082610c98565b610375928b9290610cd8565b61037e91610d02565b1490508015610484576000606089828a610399602082610c98565b926103a693929190610cd8565b8101906103b39190610e18565b955090925090508415806103c45750865b1561047d576000808373ffffffffffffffffffffffffffffffffffffffff16836040516103f19190610eb2565b6000604051808303816000865af19150503d806000811461042e576040519150601f19603f3d011682016040523d82523d6000602084013e610433565b606091505b50915091508161047a57806040517f9d0d6e2d0000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b60405180910390fd5b50505b50506104be565b87878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294505050505b80806104ca5750600083115b156106bb576040517f1626ba7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b1690631626ba7e90610523908c908690600401610f2b565b602060405180830381865afa92505050801561057a575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261057791810190610f44565b60015b61060f573d8080156105a8576040519150601f19603f3d011682016040523d82523d6000602084013e6105ad565b606091505b50851580156105bc5750600084115b156105db576105d08b8b8b8b8b600161031e565b9450505050506108d7565b806040517f6f2a95990000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b7fffffffff0000000000000000000000000000000000000000000000000000000081167f1626ba7e000000000000000000000000000000000000000000000000000000001480158161065f575086155b801561066b5750600085115b1561068b5761067f8c8c8c8c8c600161031e565b955050505050506108d7565b841580156106965750825b80156106a0575087155b156106af57806000526001601ffd5b94506108d79350505050565b6041871461074b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f5369676e617475726556616c696461746f72237265636f7665725369676e657260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610471565b600061075a6020828a8c610cd8565b61076391610d02565b90506000610775604060208b8d610cd8565b61077e91610d02565b905060008a8a604081811061079557610795610c69565b919091013560f81c915050601b81148015906107b557508060ff16601c14155b15610842576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f5369676e617475726556616c696461746f723a20696e76616c6964207369676e60448201527f617475726520762076616c7565000000000000000000000000000000000000006064820152608401610471565b6040805160008152602081018083528e905260ff831691810191909152606081018490526080810183905273ffffffffffffffffffffffffffffffffffffffff8e169060019060a0016020604051602081039080840390855afa1580156108ad573d6000803e3d6000fd5b5050506020604051035173ffffffffffffffffffffffffffffffffffffffff161496505050505050505b9695505050505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061092b9088908890889088906001908990600401610bc3565b6020604051808303816000875af115801561094a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102329190610c45565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906109b790889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610a10575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610a0d91810190610c45565b60015b610232573d808015610a3e576040519150601f19603f3d011682016040523d82523d6000602084013e610a43565b606091505b5080516001819003610a6257816000815181106101d3576101d3610c69565b8082fd5b73ffffffffffffffffffffffffffffffffffffffff81168114610a8857600080fd5b50565b60008083601f840112610a9d57600080fd5b50813567ffffffffffffffff811115610ab557600080fd5b602083019150836020828501011115610acd57600080fd5b9250929050565b60008060008060608587031215610aea57600080fd5b8435610af581610a66565b935060208501359250604085013567ffffffffffffffff811115610b1857600080fd5b610b2487828801610a8b565b95989497509550505050565b8015158114610a8857600080fd5b60008060008060008060a08789031215610b5757600080fd5b8635610b6281610a66565b955060208701359450604087013567ffffffffffffffff811115610b8557600080fd5b610b9189828a01610a8b565b9095509350506060870135610ba581610b30565b91506080870135610bb581610b30565b809150509295509295509295565b73ffffffffffffffffffffffffffffffffffffffff8716815285602082015260a060408201528360a0820152838560c0830137600060c085830181019190915292151560608201529015156080820152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016909101019392505050565b600060208284031215610c5757600080fd5b8151610c6281610b30565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b81810381811115610cd2577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b92915050565b60008085851115610ce857600080fd5b83861115610cf557600080fd5b5050820193919092039150565b80356020831015610cd2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602084900360031b1b1692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610d7e57600080fd5b813567ffffffffffffffff80821115610d9957610d99610d3e565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610ddf57610ddf610d3e565b81604052838152866020858801011115610df857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215610e2d57600080fd5b8335610e3881610a66565b9250602084013567ffffffffffffffff80821115610e5557600080fd5b610e6187838801610d6d565b93506040860135915080821115610e7757600080fd5b50610e8486828701610d6d565b9150509250925092565b60005b83811015610ea9578181015183820152602001610e91565b50506000910152565b60008251610ec4818460208701610e8e565b9190910192915050565b60008151808452610ee6816020860160208601610e8e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000610c626020830184610ece565b8281526040602082015260006102356040830184610ece565b600060208284031215610f5657600080fd5b81517fffffffff0000000000000000000000000000000000000000000000000000000081168114610c6257600080fdfea26469706673582212201a72aed4b15ffb05b6502997a9bb655992e06590bd26b336dfbb153d7ff6f34b64736f6c63430008120033';\nconst EIP_6492_SUFFIX = '0x6492649264926492649264926492649264926492649264926492649264926492';\n\n// TODO: This is a length payload, we can lower the load by deploying\n// the contract on some of the popular chains, and calling the contract\n// if the provider is one of those chains\nasync function validateEIP6492Offchain(provider, signer, hash, signature) {\n  try {\n    const result = await provider.call({\n      data: ethers__WEBPACK_IMPORTED_MODULE_4__.concat([EIP_6492_OFFCHAIN_DEPLOY_CODE, ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().encode(['address', 'bytes32', 'bytes'], [signer, hash, signature])])\n    });\n    return result === '0x01';\n  } catch (err) {\n    return false;\n  }\n}\n\nvar validateEIP6492 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  EIP_6492_OFFCHAIN_DEPLOY_CODE: EIP_6492_OFFCHAIN_DEPLOY_CODE,\n  EIP_6492_SUFFIX: EIP_6492_SUFFIX,\n  validateEIP6492Offchain: validateEIP6492Offchain\n});\n\n/**\n * Provides stateful information about the wallet.\n */\n\n/**\n * The OnChainReader class fetches on-chain data from a wallet.\n * It is used to understand the \"real\" state of the wallet contract on-chain.\n */\nclass OnChainReader {\n  constructor(provider) {\n    this.provider = provider;\n    // Simple cache to avoid re-fetching the same data\n    this.isDeployedCache = new Set();\n  }\n  module(address) {\n    return new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(address, [..._0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModuleUpgradable.abi, ..._0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModule.abi, ..._0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.erc1271.abi], this.provider);\n  }\n  async isDeployed(wallet) {\n    // This is safe to cache because the wallet cannot be undeployed once deployed\n    if (this.isDeployedCache.has(wallet)) {\n      return true;\n    }\n    const code = await this.provider.getCode(wallet).then(c => ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(c));\n    const isDeployed = code.length !== 0;\n    if (isDeployed) {\n      this.isDeployedCache.add(wallet);\n    }\n    return isDeployed;\n  }\n  async implementation(wallet) {\n    const position = ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().encode(['address'], [wallet]);\n    const val = await this.provider.getStorage(wallet, position).then(c => ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(c));\n    if (val.length === 20) {\n      return ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(val));\n    }\n    if (val.length === 32) {\n      return ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().decode(['address'], val)[0];\n    }\n    return undefined;\n  }\n  async imageHash(wallet) {\n    try {\n      const imageHash = await this.module(wallet).imageHash();\n      return imageHash;\n    } catch (_unused) {}\n    return undefined;\n  }\n  async nonce(wallet, space = 0) {\n    try {\n      const nonce = await this.module(wallet).readNonce(space);\n      return nonce;\n    } catch (e) {\n      if (!(await this.isDeployed(wallet))) {\n        return 0;\n      }\n      throw e;\n    }\n  }\n\n  // We use the EIP-6492 validator contract to check the signature\n  // this means that if the wallet is not deployed, then the signature\n  // must be prefixed with a transaction that deploys the wallet\n  async isValidSignature(wallet, digest, signature) {\n    return validateEIP6492Offchain(this.provider, wallet, digest, signature);\n  }\n}\n\nvar reader = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  OnChainReader: OnChainReader\n});\n\n/**\n * Request metadata, used by the wallet to pass additional information through the orchestrator.\n */\n\nfunction isWalletSignRequestMetadata(obj) {\n  return obj && obj.address && obj.digest && obj.chainId !== undefined && obj.config;\n}\n\n/**\n * Request metadata, used by the wallet to pass additional information through the orchestrator.\n */\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  config: config,\n  signature: signature$2,\n  context: context,\n  signer: signer,\n  EIP1271: validateEIP1271,\n  transaction: transaction,\n  reader: reader,\n  EIP6492: validateEIP6492,\n  isWalletSignRequestMetadata: isWalletSignRequestMetadata\n});\n\nconst ALL_CODERS = [{\n  config: ConfigCoder$1,\n  signature: SignatureCoder$1\n}, {\n  config: ConfigCoder,\n  signature: SignatureCoder\n}];\nfunction coderFor(version) {\n  const index = version - 1;\n  if (index < 0 || index >= ALL_CODERS.length) {\n    throw new Error(`No coder for version: ${version}`);\n  }\n  return ALL_CODERS[index];\n}\n\n/**\n *  Same as `coderFor` but returns `generic` coders without versioned types.\n */\nfunction genericCoderFor(version) {\n  return coderFor(version);\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ALL_CODERS: ALL_CODERS,\n  coderFor: coderFor,\n  genericCoderFor: genericCoderFor\n});\n\nconst VERSION = '2.2.13';\n\nconst allVersions = [v1, v2];\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0AweHNlcXVlbmNlK2NvcmVAMi4yLjEzX2V0aGVyc0A2LjEzLjVfYnVmZmVydXRpbEA0LjAuOF91dGYtOC12YWxpZGF0ZUA1LjAuMTBfL25vZGVfbW9kdWxlcy9AMHhzZXF1ZW5jZS9jb3JlL2Rpc3QvMHhzZXF1ZW5jZS1jb3JlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ2tCO0FBQ0Q7O0FBRWpEO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxTQUFTLDJEQUE4QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsNENBQWU7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKO0FBQ0EsZ0JBQWdCLDRDQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFlO0FBQy9CLHNCQUFzQiw0Q0FBZTs7QUFFckM7QUFDQTs7QUFFQTtBQUNBLFlBQVksMkNBQWM7QUFDMUIsWUFBWSwyQ0FBYztBQUMxQixtQkFBbUIsMkNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrREFBcUI7QUFDaEM7QUFDQTtBQUNBLFdBQVcsa0RBQXFCLENBQUMsK0NBQWtCO0FBQ25EO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBZTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJDQUFjO0FBQzFEO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFlO0FBQy9CO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJDQUFjO0FBQ25DO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOENBQWlCLENBQUMsMkNBQWM7QUFDbkQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBaUIsQ0FBQywyQ0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQWM7QUFDbkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtDQUFrQjtBQUN4QixXQUFXLDJDQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxhQUFhLGtEQUFxQjtBQUNsQztBQUNBO0FBQ0Esb0JBQW9CLDRDQUFlO0FBQ25DLGFBQWEsa0RBQXFCO0FBQ2xDO0FBQ0EsV0FBVyxrREFBcUI7QUFDaEMsR0FBRztBQUNILFNBQVMsa0RBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFVBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBZTtBQUNqQztBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3REFBd0QsNkNBQWdCLENBQUMsNENBQWUseUdBQXlHLGtEQUFxQjtBQUN0TixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhDQUFnQixLQUFLLDREQUFlLG9CQUFvQiw0REFBZTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZDQUFnQjtBQUN6QjtBQUNBO0FBQ0EsU0FBUyxrREFBcUI7QUFDOUI7QUFDQTtBQUNBLGNBQWMsNENBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyQ0FBYztBQUNwQjtBQUNBO0FBQ0EsU0FBUywyQ0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQWlCLENBQUMsMkNBQWM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBaUIsQ0FBQywyQ0FBYztBQUMxRDtBQUNBLDRCQUE0QiwyQ0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQ0FBYztBQUN6QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJDQUFjO0FBQzFDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSyxJQUFJLDJDQUFjLE1BQU07QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFxQjtBQUNoQyxHQUFHO0FBQ0g7QUFDQSxXQUFXLGtEQUFxQjtBQUNoQyxHQUFHO0FBQ0g7QUFDQSxnQkFBZ0IsNENBQWU7QUFDL0IsV0FBVyxrREFBcUI7QUFDaEMsR0FBRztBQUNIO0FBQ0EsZ0JBQWdCLDRDQUFlO0FBQy9CLFdBQVcsa0RBQXFCO0FBQ2hDLEdBQUc7QUFDSDtBQUNBLFdBQVcsa0RBQXFCO0FBQ2hDLEdBQUc7QUFDSDtBQUNBLFdBQVcsa0RBQXFCO0FBQ2hDLEdBQUc7QUFDSDtBQUNBLHlCQUF5Qiw0Q0FBZTtBQUN4QyxXQUFXLGtEQUFxQjtBQUNoQyxHQUFHO0FBQ0g7QUFDQSxXQUFXLGtEQUFxQjtBQUNoQztBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0RBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQseUJBQXlCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNENBQWU7QUFDN0I7QUFDQTtBQUNBLHdEQUF3RCxLQUFLO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsU0FBUyxrREFBcUIsMEJBQTBCLDJEQUE4QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsY0FBYyw2Q0FBZ0I7QUFDOUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNENBQWU7QUFDM0QsZUFBZSxrREFBcUI7QUFDcEMsU0FBUyxrREFBcUI7QUFDOUI7QUFDQTtBQUNBLE1BQU0sK0NBQWtCLGtCQUFrQiwyQ0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxnQkFBZ0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtEQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtEQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQWU7QUFDeEMsd0JBQXdCLDRDQUFlO0FBQ3ZDO0FBQ0E7QUFDQSxhQUFhLGtEQUFxQjtBQUNsQyxNQUFNO0FBQ04sYUFBYSxrREFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUFlO0FBQ2xDLFdBQVcsa0RBQXFCO0FBQ2hDO0FBQ0E7QUFDQSxzQkFBc0IsNENBQWU7QUFDckM7QUFDQTtBQUNBLGFBQWEsa0RBQXFCO0FBQ2xDLE1BQU07QUFDTixhQUFhLGtEQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFxQjtBQUNoQztBQUNBO0FBQ0EsV0FBVyxrREFBcUI7QUFDaEM7QUFDQTtBQUNBLFdBQVcsa0RBQXFCO0FBQ2hDO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9DQUFvQztBQUNwQyx3QkFBd0I7QUFDeEI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw2Q0FBZTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw2Q0FBZTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFrQjtBQUNuQyxtQ0FBbUMsK0NBQWtCO0FBQ3JEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrREFBcUI7QUFDOUI7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkNBQWM7QUFDdEMsa0JBQWtCLDhDQUFpQixDQUFDLDJDQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBOEI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBOEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJEQUE4QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkRBQThCLDBCQUEwQiwyREFBOEI7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4Q0FBZ0IsQ0FBQyw0REFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5Qiw4Q0FBZ0IsQ0FBQyw0REFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsbUJBQW1CLDZDQUFnQixDQUFDLGtEQUFxQixvREFBb0QsZ0RBQW1CO0FBQ2hJLGVBQWUsNkNBQWdCLENBQUMsa0RBQXFCO0FBQ3JELFNBQVMsOENBQWlCLENBQUMsNkNBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwyQ0FBYztBQUM1RTtBQUNBO0FBQ0EsZ0JBQWdCLDJDQUFjO0FBQzlCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkNBQWM7QUFDOUI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxTQUFTLDZDQUFnQixDQUFDLDRDQUFlO0FBQ3pDO0FBQ0E7QUFDQSxjQUFjLDRDQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBZTtBQUN4QjtBQUNBO0FBQ0EsU0FBUyw2Q0FBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFnQixDQUFDLDRDQUFlO0FBQzVDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdEQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixnQ0FBZ0MsOENBQWdCLENBQUMsNERBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdEQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBZ0IsQ0FBQyw0REFBZTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUFnQixDQUFDLDREQUFlO0FBQzlEO0FBQ0EsbUJBQW1CLDRDQUFlO0FBQ2xDLDRCQUE0QiwyQ0FBYztBQUMxQztBQUNBO0FBQ0Esc0JBQXNCLDRDQUFlO0FBQ3JDLGdFQUFnRTtBQUNoRTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SEFBd0g7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBYSxpQ0FBaUMsNENBQWU7QUFDekUsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQWUsY0FBYyw0REFBZSw4QkFBOEIsNERBQWUsb0JBQW9CLDREQUFlO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw0Q0FBZTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0Q0FBZTtBQUNwQywyRUFBMkUsNENBQWU7QUFDMUY7QUFDQSxhQUFhLDhDQUFpQixDQUFDLDJDQUFjO0FBQzdDO0FBQ0E7QUFDQSxhQUFhLDRDQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVnRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BleGFtcGxlcy9sb2dpbi13aXRoLXBhc3Nwb3J0LXNpbGVudC8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQDB4c2VxdWVuY2UrY29yZUAyLjIuMTNfZXRoZXJzQDYuMTMuNV9idWZmZXJ1dGlsQDQuMC44X3V0Zi04LXZhbGlkYXRlQDUuMC4xMF8vbm9kZV9tb2R1bGVzL0AweHNlcXVlbmNlL2NvcmUvZGlzdC8weHNlcXVlbmNlLWNvcmUuZXNtLmpzPzM0NjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IHdhbGxldENvbnRyYWN0cyB9IGZyb20gJ0AweHNlcXVlbmNlL2FiaSc7XG5pbXBvcnQgeyBNQVhfVUlOVF8yNTYgfSBmcm9tICdAMHhzZXF1ZW5jZS91dGlscyc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICByZXR1cm4gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAobikge1xuICAgIGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50c1tlXTtcbiAgICAgIGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9LCBfZXh0ZW5kcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBzdWJkaWdlc3RPZihwYXlsb2FkKSB7XG4gIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWRLZWNjYWsyNTYoWydieXRlcycsICd1aW50MjU2JywgJ2FkZHJlc3MnLCAnYnl0ZXMzMiddLCBbJzB4MTkwMScsIHBheWxvYWQuY2hhaW5JZCwgcGF5bG9hZC5hZGRyZXNzLCBwYXlsb2FkLmRpZ2VzdF0pO1xufVxuZnVuY3Rpb24gaXNTaWduZWRQYXlsb2FkKHBheWxvYWQpIHtcbiAgcmV0dXJuIHBheWxvYWQuZGlnZXN0ICE9PSB1bmRlZmluZWQgJiYgcGF5bG9hZC5jaGFpbklkICE9PSB1bmRlZmluZWQgJiYgcGF5bG9hZC5hZGRyZXNzICE9PSB1bmRlZmluZWQ7XG59XG5cbnZhciBzaWduYXR1cmUkMiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBzdWJkaWdlc3RPZjogc3ViZGlnZXN0T2YsXG4gIGlzU2lnbmVkUGF5bG9hZDogaXNTaWduZWRQYXlsb2FkXG59KTtcblxuY29uc3QgRUlQMTI3MV9NQUdJQ19WQUxVRSA9ICcweDE2MjZiYTdlJztcbmNvbnN0IEVJUDEyNzFfQUJJID0gW3tcbiAgaW5wdXRzOiBbe1xuICAgIGludGVybmFsVHlwZTogJ2J5dGVzMzInLFxuICAgIHR5cGU6ICdieXRlczMyJ1xuICB9LCB7XG4gICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMnLFxuICAgIHR5cGU6ICdieXRlcydcbiAgfV0sXG4gIG5hbWU6ICdpc1ZhbGlkU2lnbmF0dXJlJyxcbiAgb3V0cHV0czogW3tcbiAgICBpbnRlcm5hbFR5cGU6ICdieXRlczQnLFxuICAgIHR5cGU6ICdieXRlczQnXG4gIH1dLFxuICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgdHlwZTogJ2Z1bmN0aW9uJ1xufV07XG5hc3luYyBmdW5jdGlvbiBpc1ZhbGlkRUlQMTI3MVNpZ25hdHVyZShhZGRyZXNzLCBkaWdlc3QsIHNpZ25hdHVyZSwgcHJvdmlkZXIpIHtcbiAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGFkZHJlc3MsIEVJUDEyNzFfQUJJLCBwcm92aWRlcik7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRyYWN0LmlzVmFsaWRTaWduYXR1cmUoZGlnZXN0LCBzaWduYXR1cmUpO1xuICByZXR1cm4gcmVzdWx0ID09PSBFSVAxMjcxX01BR0lDX1ZBTFVFO1xufVxuXG52YXIgdmFsaWRhdGVFSVAxMjcxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGlzVmFsaWRFSVAxMjcxU2lnbmF0dXJlOiBpc1ZhbGlkRUlQMTI3MVNpZ25hdHVyZVxufSk7XG5cbmxldCBTaWdUeXBlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChTaWdUeXBlKSB7XG4gIFNpZ1R5cGVbU2lnVHlwZVtcIkVJUDcxMlwiXSA9IDFdID0gXCJFSVA3MTJcIjtcbiAgU2lnVHlwZVtTaWdUeXBlW1wiRVRIX1NJR05cIl0gPSAyXSA9IFwiRVRIX1NJR05cIjtcbiAgU2lnVHlwZVtTaWdUeXBlW1wiV0FMTEVUX0JZVEVTMzJcIl0gPSAzXSA9IFwiV0FMTEVUX0JZVEVTMzJcIjtcbiAgcmV0dXJuIFNpZ1R5cGU7XG59KHt9KTtcbmZ1bmN0aW9uIGNhblJlY292ZXIoc2lnbmF0dXJlKSB7XG4gIGNvbnN0IGJ5dGVzID0gZXRoZXJzLmdldEJ5dGVzKHNpZ25hdHVyZSk7XG4gIGNvbnN0IHR5cGUgPSBieXRlc1tieXRlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHR5cGUgPT09IFNpZ1R5cGUuRUlQNzEyIHx8IHR5cGUgPT09IFNpZ1R5cGUuRVRIX1NJR047XG59XG5mdW5jdGlvbiByZWNvdmVyU2lnbmVyKGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gIGNvbnN0IGJ5dGVzID0gZXRoZXJzLmdldEJ5dGVzKHNpZ25hdHVyZSk7XG4gIGNvbnN0IGRpZ2VzdEJ5dGVzID0gZXRoZXJzLmdldEJ5dGVzKGRpZ2VzdCk7XG5cbiAgLy8gdHlwZSBpcyBsYXN0IGJ5dGVcbiAgY29uc3QgdHlwZSA9IGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdO1xuXG4gIC8vIFNwbGl0IHI6czp2XG4gIGNvbnN0IHIgPSBldGhlcnMuaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICBjb25zdCBzID0gZXRoZXJzLmhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsIDY0KSk7XG4gIGNvbnN0IHYgPSBOdW1iZXIoZXRoZXJzLmhleGxpZnkoYnl0ZXMuc2xpY2UoNjQsIDY1KSkpO1xuICBjb25zdCBzcGxpdFNpZ25hdHVyZSA9IHtcbiAgICByLFxuICAgIHMsXG4gICAgdlxuICB9O1xuICBpZiAodHlwZSA9PT0gU2lnVHlwZS5FSVA3MTIpIHtcbiAgICByZXR1cm4gZXRoZXJzLnJlY292ZXJBZGRyZXNzKGRpZ2VzdEJ5dGVzLCBzcGxpdFNpZ25hdHVyZSk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFNpZ1R5cGUuRVRIX1NJR04pIHtcbiAgICByZXR1cm4gZXRoZXJzLnJlY292ZXJBZGRyZXNzKGV0aGVycy5oYXNoTWVzc2FnZShkaWdlc3RCeXRlcyksIHNwbGl0U2lnbmF0dXJlKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNpZ25hdHVyZSB0eXBlOiAke3R5cGV9YCk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkU2lnbmF0dXJlKGFkZHJlc3MsIGRpZ2VzdCwgc2lnbmF0dXJlLCBwcm92aWRlcikge1xuICBjb25zdCBieXRlcyA9IGV0aGVycy5nZXRCeXRlcyhzaWduYXR1cmUpO1xuXG4gIC8vIHR5cGUgaXMgbGFzdCBieXRlXG4gIGNvbnN0IHR5cGUgPSBieXRlc1tieXRlcy5sZW5ndGggLSAxXTtcbiAgaWYgKHR5cGUgPT09IFNpZ1R5cGUuRUlQNzEyIHx8IHR5cGUgPT09IFNpZ1R5cGUuRVRIX1NJR04pIHtcbiAgICByZXR1cm4gYWRkcmVzcyA9PT0gcmVjb3ZlclNpZ25lcihkaWdlc3QsIHNpZ25hdHVyZSk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFNpZ1R5cGUuV0FMTEVUX0JZVEVTMzIpIHtcbiAgICByZXR1cm4gaXNWYWxpZEVJUDEyNzFTaWduYXR1cmUoYWRkcmVzcywgZXRoZXJzLmhleGxpZnkoZGlnZXN0KSwgYnl0ZXMuc2xpY2UoMCwgLTEpLCBwcm92aWRlcik7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZTogJHt0eXBlfWApO1xufVxuZnVuY3Rpb24gdHJ5UmVjb3ZlclNpZ25lcihkaWdlc3QsIHNpZ25hdHVyZSkge1xuICBjb25zdCBieXRlcyA9IGV0aGVycy5nZXRCeXRlcyhzaWduYXR1cmUpO1xuICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA2NikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVjb3ZlclNpZ25lcihkaWdlc3QsIGJ5dGVzKTtcbiAgfSBjYXRjaCAoX3VudXNlZCkge31cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxudmFyIHNpZ25lciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBTaWdUeXBlOiBTaWdUeXBlLFxuICBjYW5SZWNvdmVyOiBjYW5SZWNvdmVyLFxuICByZWNvdmVyU2lnbmVyOiByZWNvdmVyU2lnbmVyLFxuICBpc1ZhbGlkU2lnbmF0dXJlOiBpc1ZhbGlkU2lnbmF0dXJlLFxuICB0cnlSZWNvdmVyU2lnbmVyOiB0cnlSZWNvdmVyU2lnbmVyXG59KTtcblxubGV0IFNpZ25hdHVyZVBhcnRUeXBlJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFNpZ25hdHVyZVBhcnRUeXBlKSB7XG4gIFNpZ25hdHVyZVBhcnRUeXBlW1NpZ25hdHVyZVBhcnRUeXBlW1wiRU9BU2lnbmF0dXJlXCJdID0gMF0gPSBcIkVPQVNpZ25hdHVyZVwiO1xuICBTaWduYXR1cmVQYXJ0VHlwZVtTaWduYXR1cmVQYXJ0VHlwZVtcIkFkZHJlc3NcIl0gPSAxXSA9IFwiQWRkcmVzc1wiO1xuICBTaWduYXR1cmVQYXJ0VHlwZVtTaWduYXR1cmVQYXJ0VHlwZVtcIkR5bmFtaWNTaWduYXR1cmVcIl0gPSAyXSA9IFwiRHluYW1pY1NpZ25hdHVyZVwiO1xuICByZXR1cm4gU2lnbmF0dXJlUGFydFR5cGU7XG59KHt9KTtcbmZ1bmN0aW9uIGlzQWRkcmVzc01lbWJlcihtZW1iZXIpIHtcbiAgcmV0dXJuIG1lbWJlci5hZGRyZXNzICE9PSB1bmRlZmluZWQgJiYgIWlzVW5yZWNvdmVyZWRTaWduYXR1cmVNZW1iZXIobWVtYmVyKTtcbn1cbmZ1bmN0aW9uIGlzVW5yZWNvdmVyZWRTaWduYXR1cmVNZW1iZXIobWVtYmVyKSB7XG4gIHJldHVybiBtZW1iZXIuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiYgbWVtYmVyLndlaWdodCAhPT0gdW5kZWZpbmVkICYmIG1lbWJlci5pc0R5bmFtaWMgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzVW5yZWNvdmVyZWRTaWduYXR1cmUkMShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIHNpZ25hdHVyZS50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCAmJiBzaWduYXR1cmUuc2lnbmVycyAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZGVjb2RlU2lnbmF0dXJlJDEoc2lnbmF0dXJlKSB7XG4gIGNvbnN0IGJ5dGVzID0gZXRoZXJzLmdldEJ5dGVzKHNpZ25hdHVyZSk7XG4gIGNvbnN0IHRocmVzaG9sZCA9IGJ5dGVzWzBdIDw8IDggfCBieXRlc1sxXTtcbiAgY29uc3Qgc2lnbmVycyA9IFtdO1xuICBmb3IgKGxldCBpID0gMjsgaSA8IGJ5dGVzLmxlbmd0aDspIHtcbiAgICBjb25zdCB0eXBlID0gYnl0ZXNbaSsrXTtcbiAgICBjb25zdCB3ZWlnaHQgPSBieXRlc1tpKytdO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBTaWduYXR1cmVQYXJ0VHlwZSQxLkVPQVNpZ25hdHVyZTpcbiAgICAgICAgc2lnbmVycy5wdXNoKHtcbiAgICAgICAgICB1bnJlY292ZXJlZDogdHJ1ZSxcbiAgICAgICAgICB3ZWlnaHQsXG4gICAgICAgICAgc2lnbmF0dXJlOiBldGhlcnMuaGV4bGlmeShieXRlcy5zbGljZShpLCBpICsgNjYpKSxcbiAgICAgICAgICBpc0R5bmFtaWM6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBpICs9IDY2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2lnbmF0dXJlUGFydFR5cGUkMS5BZGRyZXNzOlxuICAgICAgICBzaWduZXJzLnB1c2goe1xuICAgICAgICAgIHdlaWdodCxcbiAgICAgICAgICBhZGRyZXNzOiBldGhlcnMuZ2V0QWRkcmVzcyhldGhlcnMuaGV4bGlmeShieXRlcy5zbGljZShpLCBpICsgMjApKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGkgKz0gMjA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTaWduYXR1cmVQYXJ0VHlwZSQxLkR5bmFtaWNTaWduYXR1cmU6XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhldGhlcnMuaGV4bGlmeShieXRlcy5zbGljZShpLCBpICsgMjApKSk7XG4gICAgICAgIGkgKz0gMjA7XG4gICAgICAgIGNvbnN0IHNpemUgPSBieXRlc1tpXSA8PCA4IHwgYnl0ZXNbaSArIDFdO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIHNpZ25lcnMucHVzaCh7XG4gICAgICAgICAgdW5yZWNvdmVyZWQ6IHRydWUsXG4gICAgICAgICAgd2VpZ2h0LFxuICAgICAgICAgIHNpZ25hdHVyZTogZXRoZXJzLmhleGxpZnkoYnl0ZXMuc2xpY2UoaSwgaSArIHNpemUpKSxcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIGlzRHluYW1pYzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaSArPSBzaXplO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzaWduYXR1cmUgcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogMSxcbiAgICB0aHJlc2hvbGQsXG4gICAgc2lnbmVyc1xuICB9O1xufVxuZnVuY3Rpb24gZW5jb2RlU2lnbmF0dXJlJDEoc2lnbmF0dXJlKSB7XG4gIGlmIChldGhlcnMuaXNCeXRlc0xpa2Uoc2lnbmF0dXJlKSkge1xuICAgIHJldHVybiBldGhlcnMuaGV4bGlmeShzaWduYXR1cmUpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBzaWduZXJzLFxuICAgIHRocmVzaG9sZFxuICB9ID0gaXNVbnJlY292ZXJlZFNpZ25hdHVyZSQxKHNpZ25hdHVyZSkgPyBzaWduYXR1cmUgOiBzaWduYXR1cmUuY29uZmlnO1xuICBjb25zdCBlbmNvZGVkU2lnbmVycyA9IHNpZ25lcnMubWFwKHMgPT4ge1xuICAgIGlmIChpc0FkZHJlc3NNZW1iZXIocykpIHtcbiAgICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICd1aW50OCcsICdhZGRyZXNzJ10sIFtTaWduYXR1cmVQYXJ0VHlwZSQxLkFkZHJlc3MsIHMud2VpZ2h0LCBzLmFkZHJlc3NdKTtcbiAgICB9XG4gICAgaWYgKHMuaXNEeW5hbWljKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGV0aGVycy5nZXRCeXRlcyhzLnNpZ25hdHVyZSk7XG4gICAgICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDgnLCAndWludDgnLCAnYWRkcmVzcycsICd1aW50MTYnLCAnYnl0ZXMnXSwgW1NpZ25hdHVyZVBhcnRUeXBlJDEuRHluYW1pY1NpZ25hdHVyZSwgcy53ZWlnaHQsIHMuYWRkcmVzcywgYnl0ZXMubGVuZ3RoLCBieXRlc10pO1xuICAgIH1cbiAgICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDgnLCAndWludDgnLCAnYnl0ZXMnXSwgW1NpZ25hdHVyZVBhcnRUeXBlJDEuRU9BU2lnbmF0dXJlLCBzLndlaWdodCwgcy5zaWduYXR1cmVdKTtcbiAgfSk7XG4gIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50MTYnLCAuLi5uZXcgQXJyYXkoZW5jb2RlZFNpZ25lcnMubGVuZ3RoKS5maWxsKCdieXRlcycpXSwgW3RocmVzaG9sZCwgLi4uZW5jb2RlZFNpZ25lcnNdKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlY292ZXJTaWduYXR1cmUkMShkYXRhLCBwYXlsb2FkLCBwcm92aWRlcikge1xuICBjb25zdCBzdWJkaWdlc3QgPSBzdWJkaWdlc3RPZihwYXlsb2FkKTtcbiAgY29uc3Qgc2lnbmVycyA9IGF3YWl0IFByb21pc2UuYWxsKGRhdGEuc2lnbmVycy5tYXAoYXN5bmMgcyA9PiB7XG4gICAgaWYgKGlzQWRkcmVzc01lbWJlcihzKSkge1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGlmIChzLmlzRHluYW1pYykge1xuICAgICAgaWYgKCFzLmFkZHJlc3MpIHRocm93IG5ldyBFcnJvcignRHluYW1pYyBzaWduYXR1cmUgcGFydCBtdXN0IGhhdmUgYWRkcmVzcycpO1xuICAgICAgaWYgKCFpc1ZhbGlkU2lnbmF0dXJlKHMuYWRkcmVzcywgc3ViZGlnZXN0LCBzLnNpZ25hdHVyZSwgcHJvdmlkZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkeW5hbWljIHNpZ25hdHVyZSBwYXJ0ICR7cy5hZGRyZXNzfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogcy5hZGRyZXNzLFxuICAgICAgICB3ZWlnaHQ6IHMud2VpZ2h0LFxuICAgICAgICBzaWduYXR1cmU6IHMuc2lnbmF0dXJlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gcmVjb3ZlclNpZ25lcihzdWJkaWdlc3QsIHMuc2lnbmF0dXJlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIHdlaWdodDogcy53ZWlnaHQsXG4gICAgICAgIHNpZ25hdHVyZTogcy5zaWduYXR1cmVcbiAgICAgIH07XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogMSxcbiAgICBwYXlsb2FkLFxuICAgIHN1YmRpZ2VzdCxcbiAgICBjb25maWc6IHtcbiAgICAgIHZlcnNpb246IDEsXG4gICAgICB0aHJlc2hvbGQ6IGRhdGEudGhyZXNob2xkLFxuICAgICAgc2lnbmVyc1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGVuY29kZVNpZ25lcnMkMShjb25maWcsIHNpZ25hdHVyZXMsIHN1YmRpZ2VzdHMsIF8pIHtcbiAgaWYgKHN1YmRpZ2VzdHMubGVuZ3RoICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBsaWNpdCBzdWJkaWdlc3RzIG5vdCBzdXBwb3J0ZWQgb24gdjEnKTtcbiAgfVxuICBsZXQgd2VpZ2h0ID0gMG47XG4gIGNvbnN0IHBhcnRzID0gY29uZmlnLnNpZ25lcnMubWFwKHMgPT4ge1xuICAgIGlmICghc2lnbmF0dXJlcy5oYXMocy5hZGRyZXNzKSkge1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25hdHVyZXMuZ2V0KHMuYWRkcmVzcyk7XG4gICAgY29uc3QgYnl0ZXMgPSBldGhlcnMuZ2V0Qnl0ZXMoc2lnbmF0dXJlLnNpZ25hdHVyZSk7XG4gICAgd2VpZ2h0ICs9IEJpZ0ludChzLndlaWdodCk7XG4gICAgaWYgKHNpZ25hdHVyZS5pc0R5bmFtaWMgfHwgYnl0ZXMubGVuZ3RoICE9PSA2Nikge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzLCB7XG4gICAgICAgIGlzRHluYW1pYzogdHJ1ZSxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUuc2lnbmF0dXJlLFxuICAgICAgICBhZGRyZXNzOiBzLmFkZHJlc3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHMsIHtcbiAgICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZS5zaWduYXR1cmVcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVTaWduYXR1cmUkMSh7XG4gICAgdmVyc2lvbjogMSxcbiAgICB0aHJlc2hvbGQ6IGNvbmZpZy50aHJlc2hvbGQsXG4gICAgc2lnbmVyczogcGFydHNcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZW5jb2RlZCxcbiAgICB3ZWlnaHRcbiAgfTtcbn1cbmNvbnN0IFNpZ25hdHVyZUNvZGVyJDEgPSB7XG4gIGRlY29kZTogZGF0YSA9PiB7XG4gICAgcmV0dXJuIGRlY29kZVNpZ25hdHVyZSQxKGRhdGEpO1xuICB9LFxuICBlbmNvZGU6IGRhdGEgPT4ge1xuICAgIHJldHVybiBlbmNvZGVTaWduYXR1cmUkMShkYXRhKTtcbiAgfSxcbiAgdHJpbTogYXN5bmMgZGF0YSA9PiB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG4gIHN1cHBvcnRzTm9DaGFpbklkOiB0cnVlLFxuICByZWNvdmVyOiAoZGF0YSwgcGF5bG9hZCwgcHJvdmlkZXIpID0+IHtcbiAgICByZXR1cm4gcmVjb3ZlclNpZ25hdHVyZSQxKGRhdGEsIHBheWxvYWQsIHByb3ZpZGVyKTtcbiAgfSxcbiAgZW5jb2RlU2lnbmVyczogKGNvbmZpZywgc2lnbmF0dXJlcywgc3ViZGlnZXN0cywgY2hhaW5JZCkgPT4ge1xuICAgIHJldHVybiBlbmNvZGVTaWduZXJzJDEoY29uZmlnLCBzaWduYXR1cmVzLCBzdWJkaWdlc3RzKTtcbiAgfSxcbiAgaGFzRW5vdWdoU2lnbmluZ1Bvd2VyOiAoY29uZmlnLCBzaWduYXR1cmVzKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgd2VpZ2h0XG4gICAgfSA9IFNpZ25hdHVyZUNvZGVyJDEuZW5jb2RlU2lnbmVycyhjb25maWcsIHNpZ25hdHVyZXMsIFtdLCAwKTtcbiAgICByZXR1cm4gd2VpZ2h0ID49IEJpZ0ludChjb25maWcudGhyZXNob2xkKTtcbiAgfSxcbiAgY2hhaW5TaWduYXR1cmVzOiAoX21haW4sIF9zdWZmaXgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25hdHVyZSBjaGFpbmluZyBub3Qgc3VwcG9ydGVkIG9uIHYxJyk7XG4gIH0sXG4gIGhhc2hTZXRJbWFnZUhhc2g6IGZ1bmN0aW9uIChfaW1hZ2VIYXNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBoYXNoIG5vdCBzdXBwb3J0ZWQgb24gdjEnKTtcbiAgfSxcbiAgc2lnbmF0dXJlc09mKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcuc2lnbmVycy5maWx0ZXIocyA9PiBzLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKS5tYXAocyA9PiAoe1xuICAgICAgYWRkcmVzczogcy5hZGRyZXNzLFxuICAgICAgc2lnbmF0dXJlOiBzLnNpZ25hdHVyZVxuICAgIH0pKTtcbiAgfSxcbiAgc2lnbmF0dXJlc09mRGVjb2RlZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5zaWduZXJzLm1hcChzID0+IHMuc2lnbmF0dXJlKS5maWx0ZXIocyA9PiBzICE9PSB1bmRlZmluZWQpO1xuICB9XG59O1xuXG52YXIgc2lnbmF0dXJlJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgU2lnbmF0dXJlUGFydFR5cGU6IFNpZ25hdHVyZVBhcnRUeXBlJDEsXG4gIGlzQWRkcmVzc01lbWJlcjogaXNBZGRyZXNzTWVtYmVyLFxuICBpc1VucmVjb3ZlcmVkU2lnbmF0dXJlTWVtYmVyOiBpc1VucmVjb3ZlcmVkU2lnbmF0dXJlTWVtYmVyLFxuICBpc1VucmVjb3ZlcmVkU2lnbmF0dXJlOiBpc1VucmVjb3ZlcmVkU2lnbmF0dXJlJDEsXG4gIGRlY29kZVNpZ25hdHVyZTogZGVjb2RlU2lnbmF0dXJlJDEsXG4gIGVuY29kZVNpZ25hdHVyZTogZW5jb2RlU2lnbmF0dXJlJDEsXG4gIHJlY292ZXJTaWduYXR1cmU6IHJlY292ZXJTaWduYXR1cmUkMSxcbiAgZW5jb2RlU2lnbmVyczogZW5jb2RlU2lnbmVycyQxLFxuICBTaWduYXR1cmVDb2RlcjogU2lnbmF0dXJlQ29kZXIkMVxufSk7XG5cbmNvbnN0IENvbmZpZ0NvZGVyJDEgPSB7XG4gIGlzV2FsbGV0Q29uZmlnOiBjb25maWcgPT4ge1xuICAgIHJldHVybiBjb25maWcudmVyc2lvbiA9PT0gMSAmJiBjb25maWcudGhyZXNob2xkICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLnNpZ25lcnMgIT09IHVuZGVmaW5lZDtcbiAgfSxcbiAgaW1hZ2VIYXNoT2Y6IGNvbmZpZyA9PiB7XG4gICAgcmV0dXJuIGNvbmZpZy5zaWduZXJzLnJlZHVjZSgoaW1hZ2VIYXNoLCBzaWduZXIpID0+IGV0aGVycy5rZWNjYWsyNTYoZXRoZXJzLkFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpLmVuY29kZShbJ2J5dGVzMzInLCAndWludDgnLCAnYWRkcmVzcyddLCBbaW1hZ2VIYXNoLCBzaWduZXIud2VpZ2h0LCBzaWduZXIuYWRkcmVzc10pKSwgZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDI1NiddLCBbY29uZmlnLnRocmVzaG9sZF0pKTtcbiAgfSxcbiAgaGFzU3ViZGlnZXN0OiAoX3dhbGxldENvbmZpZywgX3N1YmRpZ2VzdCkgPT4ge1xuICAgIC8vIHYxIGRvZXMgbm90IHN1cHBvcnQgZXhwbGljaXQgc3ViZGlnZXN0c1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgaXNDb21wbGV0ZTogX2NvbmZpZyA9PiB7XG4gICAgLy8gdjEgZG9lcyBub3Qgc3VwcG9ydCBpbmNvbXBsZXRlIGNvbmZpZ3NcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgY2hlY2twb2ludE9mOiBfY29uZmlnID0+IHtcbiAgICByZXR1cm4gMG47XG4gIH0sXG4gIHNpZ25lcnNPZjogY29uZmlnID0+IHtcbiAgICByZXR1cm4gY29uZmlnLnNpZ25lcnMubWFwKHMgPT4gKHtcbiAgICAgIGFkZHJlc3M6IHMuYWRkcmVzcyxcbiAgICAgIHdlaWdodDogTnVtYmVyKHMud2VpZ2h0KVxuICAgIH0pKTtcbiAgfSxcbiAgZnJvbVNpbXBsZTogY29uZmlnID0+IHtcbiAgICBpZiAoQmlnSW50KGNvbmZpZy5jaGVja3BvaW50KSAhPT0gMG4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndjEgd2FsbGV0IGNvbmZpZyBkb2VzIG5vdCBzdXBwb3J0IGNoZWNrcG9pbnQnKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5zdWJkaWdlc3RzICYmIGNvbmZpZy5zdWJkaWdlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndjEgd2FsbGV0IGNvbmZpZyBkb2VzIG5vdCBzdXBwb3J0IHN1YmRpZ2VzdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb246IDEsXG4gICAgICB0aHJlc2hvbGQ6IGNvbmZpZy50aHJlc2hvbGQsXG4gICAgICBzaWduZXJzOiBjb25maWcuc2lnbmVyc1xuICAgIH07XG4gIH0sXG4gIHVwZGF0ZToge1xuICAgIGlzS2luZFVzZWQ6IHRydWUsXG4gICAgYnVpbGRUcmFuc2FjdGlvbjogKHdhbGxldCwgY29uZmlnLCBjb250ZXh0LCBraW5kKSA9PiB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBuZXcgZXRoZXJzLkludGVyZmFjZShbLi4ud2FsbGV0Q29udHJhY3RzLm1haW5Nb2R1bGUuYWJpLCAuLi53YWxsZXRDb250cmFjdHMubWFpbk1vZHVsZVVwZ3JhZGFibGUuYWJpXSk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBbXTtcbiAgICAgIGlmICgha2luZCB8fCBraW5kID09PSAnZmlyc3QnKSB7XG4gICAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICB0bzogd2FsbGV0LFxuICAgICAgICAgIGRhdGE6IG1vZHVsZS5lbmNvZGVGdW5jdGlvbkRhdGEobW9kdWxlLmdldEZ1bmN0aW9uKCd1cGRhdGVJbXBsZW1lbnRhdGlvbicpLCBbY29udGV4dC5tYWluTW9kdWxlVXBncmFkYWJsZV0pLFxuICAgICAgICAgIGdhc0xpbWl0OiAwLFxuICAgICAgICAgIGRlbGVnYXRlQ2FsbDogZmFsc2UsXG4gICAgICAgICAgcmV2ZXJ0T25FcnJvcjogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgdG86IHdhbGxldCxcbiAgICAgICAgZGF0YTogbW9kdWxlLmVuY29kZUZ1bmN0aW9uRGF0YShtb2R1bGUuZ2V0RnVuY3Rpb24oJ3VwZGF0ZUltYWdlSGFzaCcpLCBbQ29uZmlnQ29kZXIkMS5pbWFnZUhhc2hPZihjb25maWcpXSksXG4gICAgICAgIGdhc0xpbWl0OiAwLFxuICAgICAgICBkZWxlZ2F0ZUNhbGw6IGZhbHNlLFxuICAgICAgICByZXZlcnRPbkVycm9yOiB0cnVlLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbnRyeXBvaW50OiB3YWxsZXQsXG4gICAgICAgIHRyYW5zYWN0aW9uc1xuICAgICAgfTtcbiAgICB9LFxuICAgIGRlY29kZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAodHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgfSxcbiAgdG9KU09OOiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgY29uc3QgcGxhaW5NZW1iZXJzID0gY29uZmlnLnNpZ25lcnMubWFwKHNpZ25lciA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3ZWlnaHQ6IEJpZ0ludChzaWduZXIud2VpZ2h0KS50b1N0cmluZygpLFxuICAgICAgICBhZGRyZXNzOiBzaWduZXIuYWRkcmVzc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdmVyc2lvbjogY29uZmlnLnZlcnNpb24sXG4gICAgICB0aHJlc2hvbGQ6IEJpZ0ludChjb25maWcudGhyZXNob2xkKS50b1N0cmluZygpLFxuICAgICAgc2lnbmVyczogcGxhaW5NZW1iZXJzXG4gICAgfSk7XG4gIH0sXG4gIGZyb21KU09OOiBmdW5jdGlvbiAoanNvbikge1xuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgY29uc3Qgc2lnbmVycyA9IHBhcnNlZC5zaWduZXJzLm1hcChzaWduZXIgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2VpZ2h0OiBCaWdJbnQoc2lnbmVyLndlaWdodCksXG4gICAgICAgIGFkZHJlc3M6IHNpZ25lci5hZGRyZXNzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiBwYXJzZWQudmVyc2lvbixcbiAgICAgIHRocmVzaG9sZDogQmlnSW50KHBhcnNlZC50aHJlc2hvbGQpLFxuICAgICAgc2lnbmVyc1xuICAgIH07XG4gIH0sXG4gIGVkaXRDb25maWc6IGZ1bmN0aW9uIChjb25maWcsIGFjdGlvbikge1xuICAgIHZhciBfYWN0aW9uJHRocmVzaG9sZDtcbiAgICBjb25zdCBuZXdTaWduZXJzID0gY29uZmlnLnNpZ25lcnMuc2xpY2UoKTtcbiAgICBpZiAoYWN0aW9uLmNoZWNrcG9pbnQgJiYgQmlnSW50KGFjdGlvbi5jaGVja3BvaW50KSAhPT0gMG4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndjEgd2FsbGV0IGNvbmZpZyBkb2VzIG5vdCBzdXBwb3J0IGNoZWNrcG9pbnQnKTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbi5hZGQpIHtcbiAgICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIGFjdGlvbi5hZGQpIHtcbiAgICAgICAgaWYgKG5ld1NpZ25lcnMuZmluZChzID0+IHMuYWRkcmVzcyA9PT0gc2lnbmVyLmFkZHJlc3MpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbmV3U2lnbmVycy5wdXNoKHtcbiAgICAgICAgICB3ZWlnaHQ6IHNpZ25lci53ZWlnaHQsXG4gICAgICAgICAgYWRkcmVzczogc2lnbmVyLmFkZHJlc3NcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhY3Rpb24ucmVtb3ZlKSB7XG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgYWN0aW9uLnJlbW92ZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IG5ld1NpZ25lcnMuZmluZEluZGV4KHNpZ25lciA9PiBzaWduZXIuYWRkcmVzcyA9PT0gYWRkcmVzcyk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgbmV3U2lnbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiBjb25maWcudmVyc2lvbixcbiAgICAgIHRocmVzaG9sZDogKF9hY3Rpb24kdGhyZXNob2xkID0gYWN0aW9uLnRocmVzaG9sZCkgIT0gbnVsbCA/IF9hY3Rpb24kdGhyZXNob2xkIDogY29uZmlnLnRocmVzaG9sZCxcbiAgICAgIHNpZ25lcnM6IG5ld1NpZ25lcnNcbiAgICB9O1xuICB9LFxuICBidWlsZFN0dWJTaWduYXR1cmU6IGZ1bmN0aW9uIChjb25maWcsIG92ZXJyaWRlcykge1xuICAgIGNvbnN0IHBhcnRzID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW3NpZ25lciwgc2lnbmF0dXJlXSBvZiBvdmVycmlkZXMuZW50cmllcygpKSB7XG4gICAgICBwYXJ0cy5zZXQoc2lnbmVyLCB7XG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgaXNEeW5hbWljOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5jb2RlZCxcbiAgICAgICAgd2VpZ2h0XG4gICAgICB9ID0gZW5jb2RlU2lnbmVycyQxKGNvbmZpZywgcGFydHMsIFtdKTtcbiAgICAgIGlmICh3ZWlnaHQgPj0gQmlnSW50KGNvbmZpZy50aHJlc2hvbGQpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVkO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaWduZXJzID0gY29uZmlnLnNpZ25lcnM7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBhZGRyZXNzXG4gICAgfSBvZiBzaWduZXJzLnNvcnQoKHtcbiAgICAgIHdlaWdodDogYVxuICAgIH0sIHtcbiAgICAgIHdlaWdodDogYlxuICAgIH0pID0+IE51bWJlcihhKSAtIE51bWJlcihiKSkpIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9ICcweDRlODJmMDJmMzg4YTEyYjVmOWQyOWVhZjI0NTJkZDA0MGMwZWU1ODA0YjRlNTA0YjRkZDY0ZTM5NmM2Yzc4MWYyYzc2MjQxOTVhY2JhMjQyZGQ4MjViZmQyNWEyOTA5MTJlM2MyMzA4NDFmZDU1YzlhNzM0YzRkZThkOTg5OTQ1MWIwMic7XG4gICAgICBwYXJ0cy5zZXQoYWRkcmVzcywge1xuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIGlzRHluYW1pYzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmNvZGVkLFxuICAgICAgICB3ZWlnaHRcbiAgICAgIH0gPSBlbmNvZGVTaWduZXJzJDEoY29uZmlnLCBwYXJ0cywgW10pO1xuICAgICAgaWYgKHdlaWdodCA+PSBCaWdJbnQoY29uZmlnLnRocmVzaG9sZCkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVTaWduZXJzJDEoY29uZmlnLCBwYXJ0cywgW10pLmVuY29kZWQ7XG4gIH1cbn07XG5cbnZhciBjb25maWckMiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBDb25maWdDb2RlcjogQ29uZmlnQ29kZXIkMVxufSk7XG5cbnZhciBjb250ZXh0JDIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbmNvbnN0IHZlcnNpb24kMSA9IDE7XG5jb25zdCBEZXBsb3llZFdhbGxldENvbnRleHQkMSA9IHtcbiAgdmVyc2lvbjogdmVyc2lvbiQxLFxuICBmYWN0b3J5OiAnMHhmOUQwOUQ2MzRGYjgxOGIwNTE0OTMyOUMxZGNDRkFlQTUzNjM5ZDk2JyxcbiAgZ3Vlc3RNb2R1bGU6ICcweDAyMzkwRjNFNkU1RkQxQzY3ODZDQjc4RkQzMDI3QzExN2E5OTU1QTcnLFxuICBtYWluTW9kdWxlOiAnMHhkMDFGMTE4NTViQ2NiOTVmODhEN0E0ODQ5MkY2NjQxMGQ0NjM3MzEzJyxcbiAgbWFpbk1vZHVsZVVwZ3JhZGFibGU6ICcweDdFRkU2Y0U0MTU5NTZjNWY4MEM2NTMwY0M2Y2M4MWI0ODA4RjYxMTgnLFxuICB3YWxsZXRDcmVhdGlvbkNvZGU6ICcweDYwM2E2MDBlM2QzOTYwMWE4MDUxMzA1NTNkZjMzNjNkM2QzNzNkM2QzZDM2M2QzMDU0NWFmNDNkODI4MDNlOTAzZDkxNjAxODU3ZmQ1YmYzJ1xufTtcblxudmFyIHYxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGNvbmZpZzogY29uZmlnJDIsXG4gIGNvbnRleHQ6IGNvbnRleHQkMixcbiAgc2lnbmF0dXJlOiBzaWduYXR1cmUkMSxcbiAgdmVyc2lvbjogdmVyc2lvbiQxLFxuICBEZXBsb3llZFdhbGxldENvbnRleHQ6IERlcGxveWVkV2FsbGV0Q29udGV4dCQxXG59KTtcblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IGtlY2NhazI1NihcIlNldEltYWdlSGFzaChieXRlczMyIGltYWdlSGFzaClcIilcbmNvbnN0IFNldEltYWdlSGFzaFByZWZpeCA9ICcweDg3MTNhN2M0NDY1ZjZmYmVlMmI2ZTlkNjY0NmQxZDlmODNmZWM5MjllZGZjNGJhZjY2MWYzYzg2NWJkZDA0ZDEnO1xuZnVuY3Rpb24gaGFzaFNldEltYWdlSGFzaChpbWFnZUhhc2gpIHtcbiAgcmV0dXJuIGV0aGVycy5rZWNjYWsyNTYobWVzc2FnZVNldEltYWdlSGFzaChpbWFnZUhhc2gpKTtcbn1cbmZ1bmN0aW9uIG1lc3NhZ2VTZXRJbWFnZUhhc2goaW1hZ2VIYXNoKSB7XG4gIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWydieXRlczMyJywgJ2J5dGVzMzInXSwgW1NldEltYWdlSGFzaFByZWZpeCwgaW1hZ2VIYXNoXSk7XG59XG5mdW5jdGlvbiBkZWNvZGVNZXNzYWdlU2V0SW1hZ2VIYXNoKG1lc3NhZ2UpIHtcbiAgY29uc3QgYXJyID0gZXRoZXJzLmdldEJ5dGVzKG1lc3NhZ2UpO1xuICBpZiAoYXJyLmxlbmd0aCAhPT0gNjQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChldGhlcnMuaGV4bGlmeShhcnIuc2xpY2UoMCwgMzIpKSAhPT0gU2V0SW1hZ2VIYXNoUHJlZml4KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZXRoZXJzLmhleGxpZnkoYXJyLnNsaWNlKDMyLCA2NCkpO1xufVxuZnVuY3Rpb24gaXNNZXNzYWdlU2V0SW1hZ2VIYXNoKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGRlY29kZU1lc3NhZ2VTZXRJbWFnZUhhc2gobWVzc2FnZSkgIT09IHVuZGVmaW5lZDtcbn1cblxudmFyIGNoYWluZWQgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgU2V0SW1hZ2VIYXNoUHJlZml4OiBTZXRJbWFnZUhhc2hQcmVmaXgsXG4gIGhhc2hTZXRJbWFnZUhhc2g6IGhhc2hTZXRJbWFnZUhhc2gsXG4gIG1lc3NhZ2VTZXRJbWFnZUhhc2g6IG1lc3NhZ2VTZXRJbWFnZUhhc2gsXG4gIGRlY29kZU1lc3NhZ2VTZXRJbWFnZUhhc2g6IGRlY29kZU1lc3NhZ2VTZXRJbWFnZUhhc2gsXG4gIGlzTWVzc2FnZVNldEltYWdlSGFzaDogaXNNZXNzYWdlU2V0SW1hZ2VIYXNoXG59KTtcblxubGV0IFNpZ25hdHVyZVR5cGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFNpZ25hdHVyZVR5cGUpIHtcbiAgU2lnbmF0dXJlVHlwZVtTaWduYXR1cmVUeXBlW1wiTGVnYWN5XCJdID0gMF0gPSBcIkxlZ2FjeVwiO1xuICBTaWduYXR1cmVUeXBlW1NpZ25hdHVyZVR5cGVbXCJEeW5hbWljXCJdID0gMV0gPSBcIkR5bmFtaWNcIjtcbiAgU2lnbmF0dXJlVHlwZVtTaWduYXR1cmVUeXBlW1wiTm9DaGFpbklkRHluYW1pY1wiXSA9IDJdID0gXCJOb0NoYWluSWREeW5hbWljXCI7XG4gIFNpZ25hdHVyZVR5cGVbU2lnbmF0dXJlVHlwZVtcIkNoYWluZWRcIl0gPSAzXSA9IFwiQ2hhaW5lZFwiO1xuICByZXR1cm4gU2lnbmF0dXJlVHlwZTtcbn0oe30pO1xubGV0IFNpZ25hdHVyZVBhcnRUeXBlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChTaWduYXR1cmVQYXJ0VHlwZSkge1xuICBTaWduYXR1cmVQYXJ0VHlwZVtTaWduYXR1cmVQYXJ0VHlwZVtcIlNpZ25hdHVyZVwiXSA9IDBdID0gXCJTaWduYXR1cmVcIjtcbiAgU2lnbmF0dXJlUGFydFR5cGVbU2lnbmF0dXJlUGFydFR5cGVbXCJBZGRyZXNzXCJdID0gMV0gPSBcIkFkZHJlc3NcIjtcbiAgU2lnbmF0dXJlUGFydFR5cGVbU2lnbmF0dXJlUGFydFR5cGVbXCJEeW5hbWljU2lnbmF0dXJlXCJdID0gMl0gPSBcIkR5bmFtaWNTaWduYXR1cmVcIjtcbiAgU2lnbmF0dXJlUGFydFR5cGVbU2lnbmF0dXJlUGFydFR5cGVbXCJOb2RlXCJdID0gM10gPSBcIk5vZGVcIjtcbiAgU2lnbmF0dXJlUGFydFR5cGVbU2lnbmF0dXJlUGFydFR5cGVbXCJCcmFuY2hcIl0gPSA0XSA9IFwiQnJhbmNoXCI7XG4gIFNpZ25hdHVyZVBhcnRUeXBlW1NpZ25hdHVyZVBhcnRUeXBlW1wiU3ViZGlnZXN0XCJdID0gNV0gPSBcIlN1YmRpZ2VzdFwiO1xuICBTaWduYXR1cmVQYXJ0VHlwZVtTaWduYXR1cmVQYXJ0VHlwZVtcIk5lc3RlZFwiXSA9IDZdID0gXCJOZXN0ZWRcIjtcbiAgcmV0dXJuIFNpZ25hdHVyZVBhcnRUeXBlO1xufSh7fSk7XG5jb25zdCBTaWduYXR1cmVQYXJ0VHlwZUxlbmd0aCA9IDY2O1xuZnVuY3Rpb24gaXNVbnJlY292ZXJlZE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgbm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNVbnJlY292ZXJlZE5lc3RlZExlYWYobGVhZikge1xuICByZXR1cm4gbGVhZi50cmVlICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1VucmVjb3ZlcmVkU2lnbmF0dXJlTGVhZihsZWFmKSB7XG4gIHJldHVybiBsZWFmLnVucmVjb3ZlcmVkICYmIGxlYWYuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiYgbGVhZi5pc0R5bmFtaWMgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGRlY29kZVNpZ25hdHVyZVRyZWUoYm9keSkge1xuICBsZXQgYXJyID0gZXRoZXJzLmdldEJ5dGVzKGJvZHkpO1xuICBsZXQgcG9pbnRlcjtcbiAgY29uc3QgYXBwZW5kID0gKHByZXZQb2ludGVyLCBub2RlKSA9PiB7XG4gICAgaWYgKCFwcmV2UG9pbnRlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbm9kZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFwcmV2UG9pbnRlci5yaWdodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcHJldlBvaW50ZXIubGVmdCxcbiAgICAgICAgcmlnaHQ6IG5vZGVcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBwcmV2UG9pbnRlcixcbiAgICAgIHJpZ2h0OiBub2RlXG4gICAgfTtcbiAgfTtcbiAgd2hpbGUgKGFyci5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgdHlwZSA9IGFyclswXTtcbiAgICBhcnIgPSBhcnIuc2xpY2UoMSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFNpZ25hdHVyZVBhcnRUeXBlLlNpZ25hdHVyZTpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHdlaWdodCA9IGFyclswXTtcbiAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBldGhlcnMuaGV4bGlmeShhcnIuc2xpY2UoMSwgU2lnbmF0dXJlUGFydFR5cGVMZW5ndGggKyAxKSk7XG4gICAgICAgICAgcG9pbnRlciA9IGFwcGVuZChwb2ludGVyLCB7XG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICB3ZWlnaHQsXG4gICAgICAgICAgICB1bnJlY292ZXJlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlzRHluYW1pYzogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhcnIgPSBhcnIuc2xpY2UoU2lnbmF0dXJlUGFydFR5cGVMZW5ndGggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2lnbmF0dXJlUGFydFR5cGUuQWRkcmVzczpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHdlaWdodCA9IGFyclswXTtcbiAgICAgICAgICBjb25zdCBhZGRyZXNzID0gZXRoZXJzLmdldEFkZHJlc3MoZXRoZXJzLmhleGxpZnkoYXJyLnNsaWNlKDEsIDIxKSkpO1xuICAgICAgICAgIHBvaW50ZXIgPSBhcHBlbmQocG9pbnRlciwge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIHdlaWdodFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFyciA9IGFyci5zbGljZSgyMSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNpZ25hdHVyZVBhcnRUeXBlLkR5bmFtaWNTaWduYXR1cmU6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB3ZWlnaHQgPSBhcnJbMF07XG4gICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGV0aGVycy5nZXRBZGRyZXNzKGV0aGVycy5oZXhsaWZ5KGFyci5zbGljZSgxLCAyMSkpKTtcbiAgICAgICAgICBjb25zdCBzaXplID0gYXJyWzIxXSA8PCAxNiB8IGFyclsyMl0gPDwgOCB8IGFyclsyM107XG4gICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZXRoZXJzLmhleGxpZnkoYXJyLnNsaWNlKDI0LCAyNCArIHNpemUpKTtcbiAgICAgICAgICBwb2ludGVyID0gYXBwZW5kKHBvaW50ZXIsIHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICB3ZWlnaHQsXG4gICAgICAgICAgICB1bnJlY292ZXJlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlzRHluYW1pYzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFyciA9IGFyci5zbGljZSgyNCArIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTaWduYXR1cmVQYXJ0VHlwZS5Ob2RlOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgbm9kZUhhc2ggPSBldGhlcnMuaGV4bGlmeShhcnIuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICBwb2ludGVyID0gYXBwZW5kKHBvaW50ZXIsIHtcbiAgICAgICAgICAgIG5vZGVIYXNoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXJyID0gYXJyLnNsaWNlKDMyKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2lnbmF0dXJlUGFydFR5cGUuQnJhbmNoOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgc2l6ZSA9IGFyclswXSA8PCAxNiB8IGFyclsxXSA8PCA4IHwgYXJyWzJdO1xuICAgICAgICAgIGNvbnN0IGJyYW5jaCA9IGRlY29kZVNpZ25hdHVyZVRyZWUoYXJyLnNsaWNlKDMsIDMgKyBzaXplKSk7XG4gICAgICAgICAgcG9pbnRlciA9IGFwcGVuZChwb2ludGVyLCBicmFuY2gpO1xuICAgICAgICAgIGFyciA9IGFyci5zbGljZSgzICsgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNpZ25hdHVyZVBhcnRUeXBlLlN1YmRpZ2VzdDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHN1YmRpZ2VzdCA9IGV0aGVycy5oZXhsaWZ5KGFyci5zbGljZSgwLCAzMikpO1xuICAgICAgICAgIHBvaW50ZXIgPSBhcHBlbmQocG9pbnRlciwge1xuICAgICAgICAgICAgc3ViZGlnZXN0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXJyID0gYXJyLnNsaWNlKDMyKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2lnbmF0dXJlUGFydFR5cGUuTmVzdGVkOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gYXJyWzBdO1xuICAgICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IGFyclsxXSA8PCA4IHwgYXJyWzJdO1xuICAgICAgICAgIGNvbnN0IHNpemUgPSBhcnJbM10gPDwgMTYgfCBhcnJbNF0gPDwgOCB8IGFycls1XTtcbiAgICAgICAgICBjb25zdCB0cmVlID0gZGVjb2RlU2lnbmF0dXJlVHJlZShhcnIuc2xpY2UoNiwgNiArIHNpemUpKTtcbiAgICAgICAgICBwb2ludGVyID0gYXBwZW5kKHBvaW50ZXIsIHtcbiAgICAgICAgICAgIHdlaWdodCxcbiAgICAgICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgICAgIHRyZWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhcnIgPSBhcnIuc2xpY2UoNiArIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNpZ25hdHVyZSBwYXJ0IHR5cGU6ICR7dHlwZX06ICR7ZXRoZXJzLmhleGxpZnkoYXJyKX1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFwb2ludGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBzaWduYXR1cmUgdHJlZScpO1xuICB9XG4gIGlmIChwb2ludGVyLnJpZ2h0KSB7XG4gICAgcmV0dXJuIHBvaW50ZXI7XG4gIH1cbiAgcmV0dXJuIHBvaW50ZXIubGVmdDtcbn1cbmNsYXNzIEludmFsaWRTaWduYXR1cmVMZWFmRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGxlYWYpIHtcbiAgICBzdXBlcihgSW52YWxpZCBzaWduYXR1cmUgbGVhZjogJHtKU09OLnN0cmluZ2lmeShsZWFmKX1gKTtcbiAgICB0aGlzLmxlYWYgPSBsZWFmO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZWNvdmVyVG9wb2xvZ3kodW5yZWNvdmVyZWQsIHN1YmRpZ2VzdCwgcHJvdmlkZXIpIHtcbiAgaWYgKGlzVW5yZWNvdmVyZWROb2RlKHVucmVjb3ZlcmVkKSkge1xuICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSBhd2FpdCBQcm9taXNlLmFsbChbcmVjb3ZlclRvcG9sb2d5KHVucmVjb3ZlcmVkLmxlZnQsIHN1YmRpZ2VzdCwgcHJvdmlkZXIpLCByZWNvdmVyVG9wb2xvZ3kodW5yZWNvdmVyZWQucmlnaHQsIHN1YmRpZ2VzdCwgcHJvdmlkZXIpXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH1cbiAgaWYgKGlzVW5yZWNvdmVyZWROZXN0ZWRMZWFmKHVucmVjb3ZlcmVkKSkge1xuICAgIHJldHVybiB7XG4gICAgICB3ZWlnaHQ6IHVucmVjb3ZlcmVkLndlaWdodCxcbiAgICAgIHRocmVzaG9sZDogdW5yZWNvdmVyZWQudGhyZXNob2xkLFxuICAgICAgdHJlZTogYXdhaXQgcmVjb3ZlclRvcG9sb2d5KHVucmVjb3ZlcmVkLnRyZWUsIHN1YmRpZ2VzdCwgcHJvdmlkZXIpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNVbnJlY292ZXJlZFNpZ25hdHVyZUxlYWYodW5yZWNvdmVyZWQpKSB7XG4gICAgaWYgKHVucmVjb3ZlcmVkLmlzRHluYW1pYykge1xuICAgICAgaWYgKCF1bnJlY292ZXJlZC5hZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRHluYW1pYyBzaWduYXR1cmUgbGVhZiB3aXRob3V0IGFkZHJlc3MnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBpc1ZhbGlkU2lnbmF0dXJlKHVucmVjb3ZlcmVkLmFkZHJlc3MsIHN1YmRpZ2VzdCwgdW5yZWNvdmVyZWQuc2lnbmF0dXJlLCBwcm92aWRlcik7XG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTaWduYXR1cmVMZWFmRXJyb3IodW5yZWNvdmVyZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2VpZ2h0OiB1bnJlY292ZXJlZC53ZWlnaHQsXG4gICAgICAgIGFkZHJlc3M6IHVucmVjb3ZlcmVkLmFkZHJlc3MsXG4gICAgICAgIHNpZ25hdHVyZTogdW5yZWNvdmVyZWQuc2lnbmF0dXJlLFxuICAgICAgICBzdWJkaWdlc3RcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdlaWdodDogdW5yZWNvdmVyZWQud2VpZ2h0LFxuICAgICAgICBhZGRyZXNzOiByZWNvdmVyU2lnbmVyKHN1YmRpZ2VzdCwgdW5yZWNvdmVyZWQuc2lnbmF0dXJlKSxcbiAgICAgICAgc2lnbmF0dXJlOiB1bnJlY292ZXJlZC5zaWduYXR1cmUsXG4gICAgICAgIHN1YmRpZ2VzdFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVucmVjb3ZlcmVkO1xufVxuXG4vLyBUT0RPOiBJdCBzaG91bGQgYmUgcG9zc2libGUgdG8gcmUtdXNlIGVuY29kZVNpZ25hdHVyZVRyZWVcbi8vIGFuZCBhdm9pZCBkdXBsaWNhdGluZyB0aGlzIGxvZ2ljXG5jb25zdCBwYXJ0RW5jb2RlciA9IHtcbiAgY29uY2F0OiAoYSwgYikgPT4ge1xuICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWydieXRlcycsICdieXRlcyddLCBbYSwgYl0pO1xuICB9LFxuICBub2RlOiBub2RlSGFzaCA9PiB7XG4gICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ2J5dGVzMzInXSwgW1NpZ25hdHVyZVBhcnRUeXBlLk5vZGUsIG5vZGVIYXNoXSk7XG4gIH0sXG4gIGJyYW5jaDogdHJlZSA9PiB7XG4gICAgY29uc3QgYXJyID0gZXRoZXJzLmdldEJ5dGVzKHRyZWUpO1xuICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICd1aW50MjQnLCAnYnl0ZXMnXSwgW1NpZ25hdHVyZVBhcnRUeXBlLkJyYW5jaCwgYXJyLmxlbmd0aCwgYXJyXSk7XG4gIH0sXG4gIG5lc3RlZDogKHdlaWdodCwgdGhyZXNob2xkLCB0cmVlKSA9PiB7XG4gICAgY29uc3QgYXJyID0gZXRoZXJzLmdldEJ5dGVzKHRyZWUpO1xuICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICd1aW50OCcsICd1aW50MTYnLCAndWludDI0JywgJ2J5dGVzJ10sIFtTaWduYXR1cmVQYXJ0VHlwZS5OZXN0ZWQsIHdlaWdodCwgdGhyZXNob2xkLCBhcnIubGVuZ3RoLCBhcnJdKTtcbiAgfSxcbiAgc3ViZGlnZXN0OiBzdWJkaWdlc3QgPT4ge1xuICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICdieXRlczMyJ10sIFtTaWduYXR1cmVQYXJ0VHlwZS5TdWJkaWdlc3QsIHN1YmRpZ2VzdF0pO1xuICB9LFxuICBzaWduYXR1cmU6ICh3ZWlnaHQsIHNpZ25hdHVyZSkgPT4ge1xuICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICd1aW50OCcsICdieXRlcyddLCBbU2lnbmF0dXJlUGFydFR5cGUuU2lnbmF0dXJlLCB3ZWlnaHQsIHNpZ25hdHVyZV0pO1xuICB9LFxuICBkeW5hbWljU2lnbmF0dXJlOiAod2VpZ2h0LCBhZGRyZXNzLCBzaWduYXR1cmUpID0+IHtcbiAgICBjb25zdCBhcnJTaWduYXR1cmUgPSBldGhlcnMuZ2V0Qnl0ZXMoc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDgnLCAndWludDgnLCAnYWRkcmVzcycsICd1aW50MjQnLCAnYnl0ZXMnXSwgW1NpZ25hdHVyZVBhcnRUeXBlLkR5bmFtaWNTaWduYXR1cmUsIHdlaWdodCwgYWRkcmVzcywgYXJyU2lnbmF0dXJlLmxlbmd0aCwgYXJyU2lnbmF0dXJlXSk7XG4gIH0sXG4gIGFkZHJlc3M6ICh3ZWlnaHQsIGFkZHJlc3MpID0+IHtcbiAgICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDgnLCAndWludDgnLCAnYWRkcmVzcyddLCBbU2lnbmF0dXJlUGFydFR5cGUuQWRkcmVzcywgd2VpZ2h0LCBhZGRyZXNzXSk7XG4gIH1cbn07XG5mdW5jdGlvbiBlbmNvZGVTaWduZXJzKGNvbmZpZywgcGFydHMsIHN1YmRpZ2VzdHMsIGNoYWluSWQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB0cmVlID0gZW5jb2RlVHJlZShjb25maWcudHJlZSwgcGFydHMsIHN1YmRpZ2VzdHMsIG9wdGlvbnMpO1xuICBpZiAoQmlnSW50KGNoYWluSWQpID09PSAwbikge1xuICAgIHJldHVybiB7XG4gICAgICBlbmNvZGVkOiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICd1aW50MTYnLCAndWludDMyJywgJ2J5dGVzJ10sIFtTaWduYXR1cmVUeXBlLk5vQ2hhaW5JZER5bmFtaWMsIGNvbmZpZy50aHJlc2hvbGQsIGNvbmZpZy5jaGVja3BvaW50LCB0cmVlLmVuY29kZWRdKSxcbiAgICAgIHdlaWdodDogdHJlZS53ZWlnaHRcbiAgICB9O1xuICB9XG4gIGlmIChCaWdJbnQoY29uZmlnLnRocmVzaG9sZCkgPiAyNTVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY29kZWQ6IGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ3VpbnQxNicsICd1aW50MzInLCAnYnl0ZXMnXSwgW1NpZ25hdHVyZVR5cGUuRHluYW1pYywgY29uZmlnLnRocmVzaG9sZCwgY29uZmlnLmNoZWNrcG9pbnQsIHRyZWUuZW5jb2RlZF0pLFxuICAgICAgd2VpZ2h0OiB0cmVlLndlaWdodFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGVkOiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICd1aW50OCcsICd1aW50MzInLCAnYnl0ZXMnXSwgW1NpZ25hdHVyZVR5cGUuTGVnYWN5LCBjb25maWcudGhyZXNob2xkLCBjb25maWcuY2hlY2twb2ludCwgdHJlZS5lbmNvZGVkXSksXG4gICAgd2VpZ2h0OiB0cmVlLndlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gZW5jb2RlVHJlZSh0b3BvbG9neSwgcGFydHMsIHN1YmRpZ2VzdHMsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB0cmltID0gIW9wdGlvbnMuZGlzYWJsZVRyaW07XG4gIGlmIChpc05vZGUodG9wb2xvZ3kpKSB7XG4gICAgY29uc3QgbGVmdCA9IGVuY29kZVRyZWUodG9wb2xvZ3kubGVmdCwgcGFydHMsIHN1YmRpZ2VzdHMpO1xuICAgIGNvbnN0IHJpZ2h0ID0gZW5jb2RlVHJlZSh0b3BvbG9neS5yaWdodCwgcGFydHMsIHN1YmRpZ2VzdHMpO1xuICAgIGNvbnN0IGlzTGVmdFNpZ25lciA9IGlzU2lnbmVyTGVhZih0b3BvbG9neS5sZWZ0KTtcbiAgICBjb25zdCBpc1JpZ2h0U2lnbmVyID0gaXNTaWduZXJMZWFmKHRvcG9sb2d5LnJpZ2h0KTtcbiAgICBpZiAodHJpbSAmJiBsZWZ0LndlaWdodCA9PT0gMG4gJiYgcmlnaHQud2VpZ2h0ID09PSAwbiAmJiAhaXNMZWZ0U2lnbmVyICYmICFpc1JpZ2h0U2lnbmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGluY2x1ZGUgYW55dGhpbmcgZm9yIHRoaXMgbm9kZVxuICAgICAgICAvLyBqdXN0IHRoZSBoYXNoIHdpbGwgYmUgZW5vdWdoXG4gICAgICAgIGVuY29kZWQ6IHBhcnRFbmNvZGVyLm5vZGUoaGFzaE5vZGUodG9wb2xvZ3kpKSxcbiAgICAgICAgd2VpZ2h0OiAwblxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRyaW0gJiYgcmlnaHQud2VpZ2h0ID09PSAwbiAmJiAhaXNSaWdodFNpZ25lcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gVGhlIHJpZ2h0IG5vZGUgZG9lc24ndCBoYXZlIGFueSB3ZWlnaHRcbiAgICAgICAgLy8gYnV0IHdlIHN0aWxsIG5lZWQgdG8gaW5jbHVkZSB0aGUgbGVmdCBub2RlIGVuY29kZWRcbiAgICAgICAgZW5jb2RlZDogcGFydEVuY29kZXIuY29uY2F0KGxlZnQuZW5jb2RlZCwgcGFydEVuY29kZXIubm9kZShoYXNoTm9kZSh0b3BvbG9neS5yaWdodCkpKSxcbiAgICAgICAgd2VpZ2h0OiBsZWZ0LndlaWdodFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRyaW0gJiYgbGVmdC53ZWlnaHQgPT09IDBuICYmICFpc0xlZnRTaWduZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIFRoZSBsZWZ0IG5vZGUgZG9lc24ndCBoYXZlIGFueSB3ZWlnaHRcbiAgICAgICAgLy8gd2UgY2FuIGp1c3QgYXBwZW5kIGl0cyBoYXNoLCBidXQgZm9yIHRoZSByaWdodCBub2RlXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IFwiYnJhbmNoXCJcbiAgICAgICAgZW5jb2RlZDogcGFydEVuY29kZXIuY29uY2F0KHBhcnRFbmNvZGVyLm5vZGUoaGFzaE5vZGUodG9wb2xvZ3kubGVmdCkpLCBwYXJ0RW5jb2Rlci5icmFuY2gocmlnaHQuZW5jb2RlZCkpLFxuICAgICAgICB3ZWlnaHQ6IHJpZ2h0LndlaWdodFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIEJvdGggbm9kZXMgaGF2ZSB3ZWlnaHQsIHdlIG5lZWQgdG8gaW5jbHVkZSBib3RoXG4gICAgICAvLyB0aGUgcmlnaHQgb25lIG11c3QgYmUgYSBicmFuY2hcbiAgICAgIGVuY29kZWQ6IHBhcnRFbmNvZGVyLmNvbmNhdChsZWZ0LmVuY29kZWQsIHBhcnRFbmNvZGVyLmJyYW5jaChyaWdodC5lbmNvZGVkKSksXG4gICAgICB3ZWlnaHQ6IGxlZnQud2VpZ2h0ICsgcmlnaHQud2VpZ2h0XG4gICAgfTtcbiAgfVxuICBpZiAoaXNOZXN0ZWRMZWFmKHRvcG9sb2d5KSkge1xuICAgIGNvbnN0IHRyZWUgPSBlbmNvZGVUcmVlKHRvcG9sb2d5LnRyZWUsIHBhcnRzLCBzdWJkaWdlc3RzKTtcbiAgICBpZiAodHJpbSAmJiB0cmVlLndlaWdodCA9PT0gMG4pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZWQ6IHBhcnRFbmNvZGVyLm5vZGUoaGFzaE5vZGUodG9wb2xvZ3kpKSxcbiAgICAgICAgd2VpZ2h0OiAwblxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY29kZWQ6IHBhcnRFbmNvZGVyLm5lc3RlZCh0b3BvbG9neS53ZWlnaHQsIHRvcG9sb2d5LnRocmVzaG9sZCwgdHJlZS5lbmNvZGVkKSxcbiAgICAgIHdlaWdodDogdHJlZS53ZWlnaHRcbiAgICB9O1xuICB9XG4gIGlmIChpc05vZGVMZWFmKHRvcG9sb2d5KSkge1xuICAgIHJldHVybiB7XG4gICAgICBlbmNvZGVkOiBwYXJ0RW5jb2Rlci5ub2RlKGhhc2hOb2RlKHRvcG9sb2d5KSksXG4gICAgICB3ZWlnaHQ6IDBuXG4gICAgfTtcbiAgfVxuICBpZiAoaXNTdWJkaWdlc3RMZWFmKHRvcG9sb2d5KSkge1xuICAgIGNvbnN0IGluY2x1ZGUgPSBzdWJkaWdlc3RzLmluY2x1ZGVzKHRvcG9sb2d5LnN1YmRpZ2VzdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY29kZWQ6IHBhcnRFbmNvZGVyLnN1YmRpZ2VzdCh0b3BvbG9neS5zdWJkaWdlc3QpLFxuICAgICAgd2VpZ2h0OiBpbmNsdWRlID8gTUFYX1VJTlRfMjU2IDogMG5cbiAgICB9O1xuICB9XG4gIGlmIChpc1NpZ25lckxlYWYodG9wb2xvZ3kpKSB7XG4gICAgY29uc3QgaW5jbHVkZSA9IHBhcnRzLmhhcyh0b3BvbG9neS5hZGRyZXNzKTtcbiAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRzLmdldCh0b3BvbG9neS5hZGRyZXNzKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHBhcnQuc2lnbmF0dXJlO1xuICAgICAgaWYgKG9wdGlvbnMuZm9yY2VEeW5hbWljRW5jb2RpbmcgfHwgcGFydC5pc0R5bmFtaWMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbmNvZGVkOiBwYXJ0RW5jb2Rlci5keW5hbWljU2lnbmF0dXJlKHRvcG9sb2d5LndlaWdodCwgdG9wb2xvZ3kuYWRkcmVzcywgc2lnbmF0dXJlKSxcbiAgICAgICAgICB3ZWlnaHQ6IEJpZ0ludCh0b3BvbG9neS53ZWlnaHQpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVuY29kZWQ6IHBhcnRFbmNvZGVyLnNpZ25hdHVyZSh0b3BvbG9neS53ZWlnaHQsIHNpZ25hdHVyZSksXG4gICAgICAgICAgd2VpZ2h0OiBCaWdJbnQodG9wb2xvZ3kud2VpZ2h0KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGVkOiBwYXJ0RW5jb2Rlci5hZGRyZXNzKHRvcG9sb2d5LndlaWdodCwgdG9wb2xvZ3kuYWRkcmVzcyksXG4gICAgICAgIHdlaWdodDogMG5cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0b3BvbG9neSAtIHVua25vd24gZXJyb3I6ICR7SlNPTi5zdHJpbmdpZnkodG9wb2xvZ3kpfWApO1xufVxuZnVuY3Rpb24gZGVlcGVzdENvbmZpZ09mU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICByZXR1cm4gaXNDaGFpbmVkU2lnbmF0dXJlKHNpZ25hdHVyZSkgPyBkZWVwZXN0Q29uZmlnT2ZTaWduYXR1cmUoc2lnbmF0dXJlLnN1ZmZpeFtzaWduYXR1cmUuc3VmZml4Lmxlbmd0aCAtIDFdKSA6IHNpZ25hdHVyZS5jb25maWc7XG59XG5mdW5jdGlvbiBpc1VucmVjb3ZlcmVkU2lnbmF0dXJlKHNpZykge1xuICByZXR1cm4gc2lnLnR5cGUgIT09IHVuZGVmaW5lZCAmJiBzaWcuZGVjb2RlZCAhPT0gdW5kZWZpbmVkICYmIHNpZy52ZXJzaW9uICE9PSB1bmRlZmluZWQgJiYgc2lnLnZlcnNpb24gPT09IDI7XG59XG5mdW5jdGlvbiBpc1VucmVjb3ZlcmVkQ2hhaW5lZFNpZ25hdHVyZShzaWcpIHtcbiAgcmV0dXJuIHNpZy5zdWZmaXggIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KHNpZy5zdWZmaXgpICYmIHNpZy5zdWZmaXguZXZlcnkoaXNVbnJlY292ZXJlZFNpZ25hdHVyZSk7XG59XG5mdW5jdGlvbiBpc1NpZ25hdHVyZShzaWcpIHtcbiAgcmV0dXJuIHNpZy50eXBlICE9PSB1bmRlZmluZWQgJiYgc2lnLmNvbmZpZyAhPT0gdW5kZWZpbmVkICYmIHNpZy5kaWdlc3QgIT09IHVuZGVmaW5lZCAmJiBzaWcudmVyc2lvbiAhPT0gdW5kZWZpbmVkICYmIHNpZy52ZXJzaW9uID09PSAyO1xufVxuZnVuY3Rpb24gaXNDaGFpbmVkU2lnbmF0dXJlKHNpZykge1xuICByZXR1cm4gc2lnLmNoYWluICE9PSB1bmRlZmluZWQgJiYgQXJyYXkuaXNBcnJheShzaWcuY2hhaW4pICYmIHNpZy5jaGFpbi5ldmVyeShpc1NpZ25hdHVyZSk7XG59XG5mdW5jdGlvbiBkZWNvZGVTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIGNvbnN0IGJ5dGVzID0gZXRoZXJzLmdldEJ5dGVzKHNpZ25hdHVyZSk7XG4gIGNvbnN0IHR5cGUgPSBieXRlc1swXTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTaWduYXR1cmVUeXBlLkxlZ2FjeTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IDIsXG4gICAgICAgIHR5cGU6IFNpZ25hdHVyZVR5cGUuTGVnYWN5LFxuICAgICAgICBkZWNvZGVkOiBkZWNvZGVTaWduYXR1cmVCb2R5KGJ5dGVzKVxuICAgICAgfTtcbiAgICBjYXNlIFNpZ25hdHVyZVR5cGUuRHluYW1pYzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IDIsXG4gICAgICAgIHR5cGU6IFNpZ25hdHVyZVR5cGUuRHluYW1pYyxcbiAgICAgICAgZGVjb2RlZDogZGVjb2RlU2lnbmF0dXJlQm9keShieXRlcy5zbGljZSgxKSlcbiAgICAgIH07XG4gICAgY2FzZSBTaWduYXR1cmVUeXBlLk5vQ2hhaW5JZER5bmFtaWM6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uOiAyLFxuICAgICAgICB0eXBlOiBTaWduYXR1cmVUeXBlLk5vQ2hhaW5JZER5bmFtaWMsXG4gICAgICAgIGRlY29kZWQ6IGRlY29kZVNpZ25hdHVyZUJvZHkoYnl0ZXMuc2xpY2UoMSkpXG4gICAgICB9O1xuICAgIGNhc2UgU2lnbmF0dXJlVHlwZS5DaGFpbmVkOlxuICAgICAgcmV0dXJuIGRlY29kZUNoYWluZWRTaWduYXR1cmUoYnl0ZXMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlIHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjb2RlU2lnbmF0dXJlQm9keShzaWduYXR1cmUpIHtcbiAgY29uc3QgYnl0ZXMgPSBldGhlcnMuZ2V0Qnl0ZXMoc2lnbmF0dXJlKTtcbiAgY29uc3QgdGhyZXNob2xkID0gYnl0ZXNbMF0gPDwgOCB8IGJ5dGVzWzFdO1xuICBjb25zdCBjaGVja3BvaW50ID0gYnl0ZXNbMl0gPDwgMjQgfCBieXRlc1szXSA8PCAxNiB8IGJ5dGVzWzRdIDw8IDggfCBieXRlc1s1XTtcbiAgY29uc3QgdHJlZSA9IGRlY29kZVNpZ25hdHVyZVRyZWUoYnl0ZXMuc2xpY2UoNikpO1xuICByZXR1cm4ge1xuICAgIHRocmVzaG9sZCxcbiAgICBjaGVja3BvaW50LFxuICAgIHRyZWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlY29kZUNoYWluZWRTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIGNvbnN0IGFyciA9IGV0aGVycy5nZXRCeXRlcyhzaWduYXR1cmUpO1xuICBjb25zdCB0eXBlID0gYXJyWzBdO1xuICBpZiAodHlwZSAhPT0gU2lnbmF0dXJlVHlwZS5DaGFpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBjaGFpbmVkIHNpZ25hdHVyZSB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbiAgY29uc3QgY2hhaW4gPSBbXTtcbiAgbGV0IGluZGV4ID0gMTtcbiAgd2hpbGUgKGluZGV4IDwgYXJyLmxlbmd0aCkge1xuICAgIGNvbnN0IHNpemUgPSBhcnJbaW5kZXhdIDw8IDE2IHwgYXJyW2luZGV4ICsgMV0gPDwgOCB8IGFycltpbmRleCArIDJdO1xuICAgIGluZGV4ICs9IDM7XG4gICAgY29uc3Qgc2lnID0gZGVjb2RlU2lnbmF0dXJlKGFyci5zbGljZShpbmRleCwgaW5kZXggKyBzaXplKSk7XG4gICAgY2hhaW4ucHVzaChzaWcpO1xuICAgIGluZGV4ICs9IHNpemU7XG4gIH1cbiAgY29uc3QgbWFpbiA9IGNoYWluWzBdO1xuICBpZiAoaXNVbnJlY292ZXJlZENoYWluZWRTaWduYXR1cmUobWFpbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGZpcnN0IGxpbmsgb2YgY2hhaW5lZCBzaWduYXR1cmUgdG8gYmUgYSBzaW1wbGUgc2lnbmF0dXJlIChub3QgY2hhaW5lZClgKTtcbiAgfVxuICBjb25zdCBzdWZmaXggPSBjaGFpbi5zbGljZSgxKTtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBtYWluLCB7XG4gICAgc3VmZml4XG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0SW1hZ2VIYXNoU3RydWN0KGltYWdlSGFzaCkge1xuICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsnYnl0ZXMzMicsICdieXRlczMyJ10sIFtldGhlcnMuc29saWRpdHlQYWNrZWRLZWNjYWsyNTYoWydzdHJpbmcnXSwgWydTZXRJbWFnZUhhc2goYnl0ZXMzMiBpbWFnZUhhc2gpJ10pLCBpbWFnZUhhc2hdKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlY292ZXJTaWduYXR1cmUoc2lnbmF0dXJlLCBwYXlsb2FkLCBwcm92aWRlcikge1xuICBjb25zdCBzaWduZWRQYXlsb2FkID0gcGF5bG9hZC5zdWJkaWdlc3QgPT09IHVuZGVmaW5lZCA/IHBheWxvYWQgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGlzTm9DaGFpbklkID0gc2lnbmF0dXJlLnR5cGUgPT09IFNpZ25hdHVyZVR5cGUuTm9DaGFpbklkRHluYW1pYztcbiAgaWYgKGlzTm9DaGFpbklkICYmIHNpZ25lZFBheWxvYWQpIHtcbiAgICBzaWduZWRQYXlsb2FkLmNoYWluSWQgPSAwO1xuICB9XG4gIGNvbnN0IHN1YmRpZ2VzdCA9IHNpZ25lZFBheWxvYWQgPyBzdWJkaWdlc3RPZihzaWduZWRQYXlsb2FkKSA6IHBheWxvYWQuc3ViZGlnZXN0O1xuICBpZiAoIWlzVW5yZWNvdmVyZWRDaGFpbmVkU2lnbmF0dXJlKHNpZ25hdHVyZSkpIHtcbiAgICBjb25zdCB0cmVlID0gYXdhaXQgcmVjb3ZlclRvcG9sb2d5KHNpZ25hdHVyZS5kZWNvZGVkLnRyZWUsIHN1YmRpZ2VzdCwgcHJvdmlkZXIpO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiAyLFxuICAgICAgdHlwZTogc2lnbmF0dXJlLnR5cGUsXG4gICAgICBzdWJkaWdlc3QsXG4gICAgICBjb25maWc6IF9leHRlbmRzKHtcbiAgICAgICAgdmVyc2lvbjogMlxuICAgICAgfSwgc2lnbmF0dXJlLmRlY29kZWQsIHtcbiAgICAgICAgdHJlZVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIGlmICghaXNTaWduZWRQYXlsb2FkKHNpZ25lZFBheWxvYWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDaGFpbmVkIHNpZ25hdHVyZSByZWNvdmVyeSByZXF1aXJlcyBkZXRhaWxlZCBzaWduZWQgcGF5bG9hZCwgc3ViZGlnZXN0IGlzIG5vdCBlbm91Z2hgKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IG11dGF0ZWRQYXlsb2FkID0gc2lnbmVkUGF5bG9hZDtcblxuICAvLyBSZWNvdmVyIHRoZSBjaGFpbiBvZiBzaWduYXR1cmVzXG4gIC8vIE5PVElDRTogUmVtb3ZlIHRoZSBzdWZmaXggZnJvbSB0aGUgXCJmaXJzdFwiIHNpZ2FudHVyZVxuICAvLyBvdGhlcndpc2Ugd2UgcmVjdXJzZSBpbmZpbml0ZWx5XG4gIGZvciAoY29uc3Qgc2lnIG9mIFtfZXh0ZW5kcyh7fSwgc2lnbmF0dXJlLCB7XG4gICAgc3VmZml4OiB1bmRlZmluZWRcbiAgfSksIC4uLnNpZ25hdHVyZS5zdWZmaXhdKSB7XG4gICAgY29uc3QgcmVjb3ZlcmVkID0gYXdhaXQgcmVjb3ZlclNpZ25hdHVyZShzaWcsIG11dGF0ZWRQYXlsb2FkLCBwcm92aWRlcik7XG4gICAgcmVzdWx0LnVuc2hpZnQocmVjb3ZlcmVkKTtcbiAgICBjb25zdCBuZXh0TWVzc2FnZSA9IHNldEltYWdlSGFzaFN0cnVjdChpbWFnZUhhc2goZGVlcGVzdENvbmZpZ09mU2lnbmF0dXJlKHJlY292ZXJlZCkpKTtcbiAgICBtdXRhdGVkUGF5bG9hZCA9IF9leHRlbmRzKHt9LCBtdXRhdGVkUGF5bG9hZCwge1xuICAgICAgbWVzc2FnZTogbmV4dE1lc3NhZ2UsXG4gICAgICBkaWdlc3Q6IGV0aGVycy5rZWNjYWsyNTYobmV4dE1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWFpbiA9IHJlc3VsdFswXTtcbiAgY29uc3Qgc3VmZml4ID0gcmVzdWx0LnNsaWNlKDEpO1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG1haW4sIHtcbiAgICBzdWZmaXhcbiAgfSk7XG59XG5mdW5jdGlvbiBlbmNvZGVDaGFpbihtYWluLCBzdWZmaXgpIHtcbiAgY29uc3QgYWxsU2lnbmF0dXJlcyA9IFttYWluLCAuLi4oc3VmZml4IHx8IFtdKV07XG4gIGNvbnN0IGVuY29kZWRNYXAgPSBhbGxTaWduYXR1cmVzLm1hcChzID0+IGV0aGVycy5nZXRCeXRlcyhlbmNvZGVTaWduYXR1cmUocykpKTtcbiAgY29uc3QgYm9keSA9IGV0aGVycy5zb2xpZGl0eVBhY2tlZChlbmNvZGVkTWFwLm1hcCgoKSA9PiBbJ3VpbnQyNCcsICdieXRlcyddKS5mbGF0KCksIGVuY29kZWRNYXAubWFwKHMgPT4gW3MubGVuZ3RoLCBzXSkuZmxhdCgpKTtcbiAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ2J5dGVzJ10sIFtTaWduYXR1cmVUeXBlLkNoYWluZWQsIGJvZHldKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVNpZ25hdHVyZShkZWNvZGVkKSB7XG4gIGlmIChldGhlcnMuaXNCeXRlc0xpa2UoZGVjb2RlZCkpIHJldHVybiBldGhlcnMuaGV4bGlmeShkZWNvZGVkKTtcbiAgaWYgKGlzVW5yZWNvdmVyZWRDaGFpbmVkU2lnbmF0dXJlKGRlY29kZWQpIHx8IGlzQ2hhaW5lZFNpZ25hdHVyZShkZWNvZGVkKSkge1xuICAgIHJldHVybiBlbmNvZGVDaGFpbihlbmNvZGVTaWduYXR1cmUoZGVjb2RlZCksIChkZWNvZGVkLnN1ZmZpeCB8fCBbXSkubWFwKGVuY29kZVNpZ25hdHVyZSkpO1xuICB9XG4gIGNvbnN0IGJvZHkgPSBpc1VucmVjb3ZlcmVkU2lnbmF0dXJlKGRlY29kZWQpID8gZGVjb2RlZC5kZWNvZGVkIDogZGVjb2RlZC5jb25maWc7XG4gIHN3aXRjaCAoZGVjb2RlZC50eXBlKSB7XG4gICAgY2FzZSBTaWduYXR1cmVUeXBlLkxlZ2FjeTpcbiAgICAgIGlmIChCaWdJbnQoYm9keS50aHJlc2hvbGQpID4gMjU1bikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExlZ2FjeSBzaWduYXR1cmUgdGhyZXNob2xkIGlzIHRvbyBsYXJnZTogJHtib2R5LnRocmVzaG9sZH0gKG1heCAyNTUpYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2RlU2lnbmF0dXJlQm9keShib2R5KTtcbiAgICBjYXNlIFNpZ25hdHVyZVR5cGUuTm9DaGFpbklkRHluYW1pYzpcbiAgICBjYXNlIFNpZ25hdHVyZVR5cGUuRHluYW1pYzpcbiAgICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICdieXRlcyddLCBbZGVjb2RlZC50eXBlLCBlbmNvZGVTaWduYXR1cmVCb2R5KGJvZHkpXSk7XG4gICAgY2FzZSBTaWduYXR1cmVUeXBlLkNoYWluZWQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVhY2hhYmxlIGNvZGU6IENoYWluZWQgc2lnbmF0dXJlIHNob3VsZCBiZSBoYW5kbGVkIGFib3ZlYCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduYXR1cmUgdHlwZTogJHtkZWNvZGVkLnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZVNpZ25hdHVyZUJvZHkoZGVjb2RlZCkge1xuICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDE2JywgJ3VpbnQzMicsICdieXRlcyddLCBbZGVjb2RlZC50aHJlc2hvbGQsIGRlY29kZWQuY2hlY2twb2ludCwgZW5jb2RlU2lnbmF0dXJlVHJlZShkZWNvZGVkLnRyZWUpXSk7XG59XG5mdW5jdGlvbiBlbmNvZGVTaWduYXR1cmVUcmVlKHRyZWUpIHtcbiAgaWYgKGlzTm9kZSh0cmVlKSB8fCBpc1VucmVjb3ZlcmVkTm9kZSh0cmVlKSkge1xuICAgIGNvbnN0IGVuY29kZWRSaWdodCA9IGV0aGVycy5nZXRCeXRlcyhlbmNvZGVTaWduYXR1cmVUcmVlKHRyZWUucmlnaHQpKTtcbiAgICBjb25zdCBlbmNvZGVkTGVmdCA9IGV0aGVycy5nZXRCeXRlcyhlbmNvZGVTaWduYXR1cmVUcmVlKHRyZWUubGVmdCkpO1xuICAgIGNvbnN0IGlzQnJhbmNoaW5nID0gaXNOb2RlKHRyZWUucmlnaHQpIHx8IGlzVW5yZWNvdmVyZWROb2RlKHRyZWUucmlnaHQpO1xuICAgIGlmIChpc0JyYW5jaGluZykge1xuICAgICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ2J5dGVzJywgJ3VpbnQ4JywgJ3VpbnQyNCcsICdieXRlcyddLCBbZW5jb2RlZExlZnQsIFNpZ25hdHVyZVBhcnRUeXBlLkJyYW5jaCwgZW5jb2RlZFJpZ2h0Lmxlbmd0aCwgZW5jb2RlZFJpZ2h0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWydieXRlcycsICdieXRlcyddLCBbZW5jb2RlZExlZnQsIGVuY29kZWRSaWdodF0pO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOZXN0ZWRMZWFmKHRyZWUpIHx8IGlzVW5yZWNvdmVyZWROZXN0ZWRMZWFmKHRyZWUpKSB7XG4gICAgY29uc3QgbmVzdGVkID0gZXRoZXJzLmdldEJ5dGVzKGVuY29kZVNpZ25hdHVyZVRyZWUodHJlZS50cmVlKSk7XG4gICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ3VpbnQ4JywgJ3VpbnQxNicsICd1aW50MjQnLCAnYnl0ZXMnXSwgW1NpZ25hdHVyZVBhcnRUeXBlLk5lc3RlZCwgdHJlZS53ZWlnaHQsIHRyZWUudGhyZXNob2xkLCBuZXN0ZWQubGVuZ3RoLCBuZXN0ZWRdKTtcbiAgfVxuICBpZiAoaXNVbnJlY292ZXJlZFNpZ25hdHVyZUxlYWYodHJlZSkgfHwgaXNTaWduZXJMZWFmKHRyZWUpICYmIHRyZWUuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBldGhlcnMuZ2V0Qnl0ZXModHJlZS5zaWduYXR1cmUpO1xuICAgIGlmICh0cmVlLmlzRHluYW1pYyB8fCBzaWduYXR1cmUubGVuZ3RoICE9PSBTaWduYXR1cmVQYXJ0VHlwZUxlbmd0aCkge1xuICAgICAgaWYgKCF0cmVlLmFkZHJlc3MpIHRocm93IG5ldyBFcnJvcihgRHluYW1pYyBzaWduYXR1cmUgbGVhZiBtdXN0IGhhdmUgYWRkcmVzc2ApO1xuICAgICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ3VpbnQ4JywgJ2FkZHJlc3MnLCAndWludDI0JywgJ2J5dGVzJ10sIFtTaWduYXR1cmVQYXJ0VHlwZS5EeW5hbWljU2lnbmF0dXJlLCB0cmVlLndlaWdodCwgdHJlZS5hZGRyZXNzLCBzaWduYXR1cmUubGVuZ3RoLCBzaWduYXR1cmVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ3VpbnQ4JywgJ2J5dGVzJ10sIFtTaWduYXR1cmVQYXJ0VHlwZS5TaWduYXR1cmUsIHRyZWUud2VpZ2h0LCBzaWduYXR1cmVdKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzU2lnbmVyTGVhZih0cmVlKSkge1xuICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICd1aW50OCcsICdhZGRyZXNzJ10sIFtTaWduYXR1cmVQYXJ0VHlwZS5BZGRyZXNzLCB0cmVlLndlaWdodCwgdHJlZS5hZGRyZXNzXSk7XG4gIH1cbiAgaWYgKGlzTm9kZUxlYWYodHJlZSkpIHtcbiAgICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDgnLCAnYnl0ZXMzMiddLCBbU2lnbmF0dXJlUGFydFR5cGUuTm9kZSwgdHJlZS5ub2RlSGFzaF0pO1xuICB9XG4gIGlmIChpc1N1YmRpZ2VzdExlYWYodHJlZSkpIHtcbiAgICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDgnLCAnYnl0ZXMzMiddLCBbU2lnbmF0dXJlUGFydFR5cGUuU3ViZGlnZXN0LCB0cmVlLnN1YmRpZ2VzdF0pO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzaWduYXR1cmUgdHJlZSB0eXBlOiAke3RyZWV9YCk7XG59XG5mdW5jdGlvbiBzaWduYXR1cmVzT2YodG9wb2xvZ3kpIHtcbiAgaWYgKGlzTm9kZSh0b3BvbG9neSkpIHtcbiAgICByZXR1cm4gWy4uLnNpZ25hdHVyZXNPZih0b3BvbG9neS5sZWZ0KSwgLi4uc2lnbmF0dXJlc09mKHRvcG9sb2d5LnJpZ2h0KV07XG4gIH1cbiAgaWYgKGlzTmVzdGVkTGVhZih0b3BvbG9neSkpIHtcbiAgICByZXR1cm4gc2lnbmF0dXJlc09mKHRvcG9sb2d5LnRyZWUpO1xuICB9XG4gIGlmIChpc1NpZ25lckxlYWYodG9wb2xvZ3kpICYmIHRvcG9sb2d5LnNpZ25hdHVyZSkge1xuICAgIHJldHVybiBbe1xuICAgICAgYWRkcmVzczogdG9wb2xvZ3kuYWRkcmVzcyxcbiAgICAgIHNpZ25hdHVyZTogdG9wb2xvZ3kuc2lnbmF0dXJlXG4gICAgfV07XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gc2lnbmF0dXJlc09mRGVjb2RlZCh1dG9wb2xvZ3kpIHtcbiAgaWYgKGlzVW5yZWNvdmVyZWROb2RlKHV0b3BvbG9neSkpIHtcbiAgICByZXR1cm4gWy4uLnNpZ25hdHVyZXNPZkRlY29kZWQodXRvcG9sb2d5LmxlZnQpLCAuLi5zaWduYXR1cmVzT2ZEZWNvZGVkKHV0b3BvbG9neS5yaWdodCldO1xuICB9XG4gIGlmIChpc1VucmVjb3ZlcmVkTmVzdGVkTGVhZih1dG9wb2xvZ3kpKSB7XG4gICAgcmV0dXJuIHNpZ25hdHVyZXNPZkRlY29kZWQodXRvcG9sb2d5LnRyZWUpO1xuICB9XG4gIGlmIChpc1VucmVjb3ZlcmVkU2lnbmF0dXJlTGVhZih1dG9wb2xvZ3kpKSB7XG4gICAgcmV0dXJuIFt1dG9wb2xvZ3kuc2lnbmF0dXJlXTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBzdWJkaWdlc3RzT2ZEZWNvZGVkKHV0b3BvbG9neSkge1xuICBpZiAoaXNVbnJlY292ZXJlZE5vZGUodXRvcG9sb2d5KSkge1xuICAgIHJldHVybiBbLi4uc3ViZGlnZXN0c09mRGVjb2RlZCh1dG9wb2xvZ3kubGVmdCksIC4uLnN1YmRpZ2VzdHNPZkRlY29kZWQodXRvcG9sb2d5LnJpZ2h0KV07XG4gIH1cbiAgaWYgKGlzVW5yZWNvdmVyZWROZXN0ZWRMZWFmKHV0b3BvbG9neSkpIHtcbiAgICByZXR1cm4gc3ViZGlnZXN0c09mRGVjb2RlZCh1dG9wb2xvZ3kudHJlZSk7XG4gIH1cbiAgaWYgKGlzU3ViZGlnZXN0TGVhZih1dG9wb2xvZ3kpKSB7XG4gICAgcmV0dXJuIFt1dG9wb2xvZ3kuc3ViZGlnZXN0XTtcbiAgfVxuICByZXR1cm4gW107XG59XG5hc3luYyBmdW5jdGlvbiB0cmltU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICBjb25zdCBkZWNvZGVkID0gdHlwZW9mIHNpZ25hdHVyZSA9PT0gJ3N0cmluZycgPyBkZWNvZGVTaWduYXR1cmUoc2lnbmF0dXJlKSA6IHNpZ25hdHVyZTtcbiAgaWYgKGlzVW5yZWNvdmVyZWRDaGFpbmVkU2lnbmF0dXJlKGRlY29kZWQpKSB7XG4gICAgLy8gV2UgbmVlZCB0byB0cmltIGV2ZXJ5IHN1ZmZpeCBBTkQgdGhlIG1haW4gc2lnbmF0dXJlXG4gICAgY29uc3QgX3RyaW1tZWQgPSBhd2FpdCBQcm9taXNlLmFsbChbdHJpbVNpZ25hdHVyZShfZXh0ZW5kcyh7fSwgZGVjb2RlZCwge1xuICAgICAgc3VmZml4OiB1bmRlZmluZWRcbiAgICB9KSksIC4uLmRlY29kZWQuc3VmZml4Lm1hcChzID0+IHRyaW1TaWduYXR1cmUocykpXSk7XG4gICAgcmV0dXJuIGVuY29kZUNoYWluKF90cmltbWVkWzBdLCBfdHJpbW1lZC5zbGljZSgxKSk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHRyaW1tZWRcbiAgfSA9IGF3YWl0IHRyaW1VbnJlY292ZXJlZFRyZWUoZGVjb2RlZC5kZWNvZGVkLnRyZWUpO1xuICByZXR1cm4gZW5jb2RlU2lnbmF0dXJlKF9leHRlbmRzKHt9LCBkZWNvZGVkLCB7XG4gICAgZGVjb2RlZDogX2V4dGVuZHMoe30sIGRlY29kZWQuZGVjb2RlZCwge1xuICAgICAgdHJlZTogdHJpbW1lZFxuICAgIH0pXG4gIH0pKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRyaW1VbnJlY292ZXJlZFRyZWUodHJlZSwgdHJpbVN0YXRpY0RpZ2VzdCA9IHRydWUpIHtcbiAgaWYgKGlzVW5yZWNvdmVyZWROb2RlKHRyZWUpKSB7XG4gICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGF3YWl0IFByb21pc2UuYWxsKFt0cmltVW5yZWNvdmVyZWRUcmVlKHRyZWUubGVmdCksIHRyaW1VbnJlY292ZXJlZFRyZWUodHJlZS5yaWdodCldKTtcbiAgICBpZiAobGVmdC53ZWlnaHQgPT09IDAgJiYgcmlnaHQud2VpZ2h0ID09PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBJZiBib3RoIHdlaWdodHMgYXJlIDAgdGhlbiBpdCBtZWFucyB3ZSBkb24ndCBoYXZlIGFueSBzaWduYXR1cmVzIHlldFxuICAgICAgICAvLyBiZWNhdXNlIG9mIHRoYXQsIHdlIHNob3VsZCBiZSBhYmxlIHRvIFwicmVjb3ZlclwiIHRoZSB0cmVlIHdpdGggYW55IHN1YmRpZ2VzdFxuICAgICAgICAvLyBhbmQgc3RpbGwgZ2V0IHRoZSB2YWxpZCBub2RlIGhhc2ggKHRoZXJlIHNob3VsZG4ndCBiZSBhbnkgc2lnbmF0dXJlcyB0byB2ZXJpZnkpXG4gICAgICAgIGNvbnN0IHJlY292ZXJlZCA9IGF3YWl0IHJlY292ZXJUb3BvbG9neSh0cmVlLCBldGhlcnMuWmVyb0hhc2gsIHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2VpZ2h0OiAwLFxuICAgICAgICAgIHRyaW1tZWQ6IHtcbiAgICAgICAgICAgIG5vZGVIYXNoOiBoYXNoTm9kZShyZWNvdmVyZWQpXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgZmFpbHMgaXQncyBtb3JlIGxpa2VseSBiZWNhdXNlIHNvbWUgc2lnbmF0dXJlcyBoYXZlIHNuZWFrZWQgaW5cbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIHNob3VsZCBrZWVwIHRoaXMgbm9kZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3ZWlnaHQ6IGxlZnQud2VpZ2h0ICsgcmlnaHQud2VpZ2h0LFxuICAgICAgICB0cmltbWVkOiB7XG4gICAgICAgICAgbGVmdDogbGVmdC50cmltbWVkLFxuICAgICAgICAgIHJpZ2h0OiByaWdodC50cmltbWVkXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlmIChpc1VucmVjb3ZlcmVkTmVzdGVkTGVhZih0cmVlKSkge1xuICAgIGNvbnN0IHRyaW1tZWQgPSBhd2FpdCB0cmltVW5yZWNvdmVyZWRUcmVlKHRyZWUudHJlZSk7XG4gICAgaWYgKHRyaW1tZWQud2VpZ2h0ID09PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBJZiB0aGUgbmVzdGVkIGxlYWYgaXMgZW1wdHksIHdlIGNhbiByZWNvdmVyIGl0IHdpdGggYW55IHN1YmRpZ2VzdFxuICAgICAgICAvLyBhbmQgc3RpbGwgZ2V0IHRoZSB2YWxpZCBub2RlIGhhc2ggKHRoZXJlIHNob3VsZG4ndCBiZSBhbnkgc2lnbmF0dXJlcyB0byB2ZXJpZnkpXG4gICAgICAgIGNvbnN0IHJlY292ZXJlZCA9IGF3YWl0IHJlY292ZXJUb3BvbG9neSh0cmVlLCBldGhlcnMuWmVyb0hhc2gsIHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2VpZ2h0OiAwLFxuICAgICAgICAgIHRyaW1tZWQ6IHtcbiAgICAgICAgICAgIG5vZGVIYXNoOiBoYXNoTm9kZShyZWNvdmVyZWQpXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoX3VudXNlZDIpIHtcbiAgICAgICAgLy8gSWYgc29tZXRoaW5nIGZhaWxzIGl0J3MgbW9yZSBsaWtlbHkgYmVjYXVzZSBzb21lIHNpZ25hdHVyZXMgaGF2ZSBzbmVha2VkIGluXG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBzaG91bGQga2VlcCB0aGlzIG5vZGVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdlaWdodDogdHJpbW1lZC53ZWlnaHQsXG4gICAgICB0cmltbWVkOiB7XG4gICAgICAgIHdlaWdodDogdHJlZS53ZWlnaHQsXG4gICAgICAgIHRocmVzaG9sZDogdHJlZS50aHJlc2hvbGQsXG4gICAgICAgIHRyZWU6IHRyaW1tZWQudHJpbW1lZFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBIYXNoIG5vZGVzIGNhbiBiZSBlbmNvZGVkIGFzIHNpZ25lciBsZWF2ZXMgaWYgdGhleSBoYXZlIGEgd2VpZ2h0IGJlbG93XG4gIC8vIDI1NiwgbW9zdCBsaWtlbHkgdGhlIGFyZSBzaWduZXIgbGVhdmVzIHdyb25nbHkgZW5jb2RlZFxuICBpZiAoaXNOb2RlTGVhZih0cmVlKSAmJiBpc0VuY29kZWRTaWduZXJMZWFmKHRyZWUubm9kZUhhc2gpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdlaWdodDogMCxcbiAgICAgIHRyaW1tZWQ6IF9leHRlbmRzKHt9LCBkZWNvZGVTaWduZXJMZWFmKHRyZWUubm9kZUhhc2gpKVxuICAgIH07XG4gIH1cbiAgaWYgKGlzVW5yZWNvdmVyZWRTaWduYXR1cmVMZWFmKHRyZWUpIHx8IGlzU2lnbmVyTGVhZih0cmVlKSAmJiB0cmVlLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdlaWdodDogTnVtYmVyKHRyZWUud2VpZ2h0KSxcbiAgICAgIHRyaW1tZWQ6IHRyZWVcbiAgICB9O1xuICB9XG4gIGlmICghdHJpbVN0YXRpY0RpZ2VzdCAmJiBpc1N1YmRpZ2VzdExlYWYodHJlZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2VpZ2h0OiArSW5maW5pdHksXG4gICAgICB0cmltbWVkOiB0cmVlXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdlaWdodDogMCxcbiAgICB0cmltbWVkOiB0cmVlXG4gIH07XG59XG5jb25zdCBTaWduYXR1cmVDb2RlciA9IHtcbiAgZGVjb2RlOiBkYXRhID0+IHtcbiAgICByZXR1cm4gZGVjb2RlU2lnbmF0dXJlKGRhdGEpO1xuICB9LFxuICBlbmNvZGU6IGRhdGEgPT4ge1xuICAgIHJldHVybiBlbmNvZGVTaWduYXR1cmUoZGF0YSk7XG4gIH0sXG4gIHRyaW06IGRhdGEgPT4ge1xuICAgIHJldHVybiB0cmltU2lnbmF0dXJlKGRhdGEpO1xuICB9LFxuICBzdXBwb3J0c05vQ2hhaW5JZDogdHJ1ZSxcbiAgcmVjb3ZlcjogKGRhdGEsIHBheWxvYWQsIHByb3ZpZGVyKSA9PiB7XG4gICAgcmV0dXJuIHJlY292ZXJTaWduYXR1cmUoZGF0YSwgcGF5bG9hZCwgcHJvdmlkZXIpO1xuICB9LFxuICBlbmNvZGVTaWduZXJzOiAoY29uZmlnLCBzaWduYXR1cmVzLCBzdWJkaWdlc3RzLCBjaGFpbklkKSA9PiB7XG4gICAgcmV0dXJuIGVuY29kZVNpZ25lcnMoY29uZmlnLCBzaWduYXR1cmVzLCBzdWJkaWdlc3RzLCBjaGFpbklkKTtcbiAgfSxcbiAgaGFzRW5vdWdoU2lnbmluZ1Bvd2VyOiAoY29uZmlnLCBzaWduYXR1cmVzKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgd2VpZ2h0XG4gICAgfSA9IFNpZ25hdHVyZUNvZGVyLmVuY29kZVNpZ25lcnMoY29uZmlnLCBzaWduYXR1cmVzLCBbXSwgMCk7XG4gICAgcmV0dXJuIHdlaWdodCA+PSBCaWdJbnQoY29uZmlnLnRocmVzaG9sZCk7XG4gIH0sXG4gIGNoYWluU2lnbmF0dXJlczogKG1haW4sIHN1ZmZpeCkgPT4ge1xuICAgIC8vIE5vdGljZTogdjIgZXhwZWN0cyBzdWZmaXggdG8gYmUgcmV2ZXJzZWRcbiAgICAvLyB0aGF0IGJlaW5nOiBmcm9tIHNpZ25lZCB0byBjdXJyZW50IGltYWdlSGFzaFxuICAgIGNvbnN0IHJldmVyc2VkID0gc3VmZml4LnJldmVyc2UoKTtcbiAgICBjb25zdCBtcmF3ID0gZXRoZXJzLmlzQnl0ZXNMaWtlKG1haW4pID8gbWFpbiA6IGVuY29kZVNpZ25hdHVyZShtYWluKTtcbiAgICBjb25zdCBzcmF3ID0gcmV2ZXJzZWQubWFwKHMgPT4gZXRoZXJzLmlzQnl0ZXNMaWtlKHMpID8gcyA6IGVuY29kZVNpZ25hdHVyZShzKSk7XG4gICAgcmV0dXJuIGVuY29kZUNoYWluKG1yYXcsIHNyYXcpO1xuICB9LFxuICBoYXNoU2V0SW1hZ2VIYXNoOiBmdW5jdGlvbiAoaW1hZ2VIYXNoKSB7XG4gICAgcmV0dXJuIGhhc2hTZXRJbWFnZUhhc2goaW1hZ2VIYXNoKTtcbiAgfSxcbiAgc2lnbmF0dXJlc09mKGNvbmZpZykge1xuICAgIHJldHVybiBzaWduYXR1cmVzT2YoY29uZmlnLnRyZWUpO1xuICB9LFxuICBzaWduYXR1cmVzT2ZEZWNvZGVkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBzaWduYXR1cmVzT2ZEZWNvZGVkKGRhdGEuZGVjb2RlZC50cmVlKTtcbiAgfVxufTtcblxudmFyIHNpZ25hdHVyZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBTaWduYXR1cmVUeXBlOiBTaWduYXR1cmVUeXBlLFxuICBTaWduYXR1cmVQYXJ0VHlwZTogU2lnbmF0dXJlUGFydFR5cGUsXG4gIFNpZ25hdHVyZVBhcnRUeXBlTGVuZ3RoOiBTaWduYXR1cmVQYXJ0VHlwZUxlbmd0aCxcbiAgaXNVbnJlY292ZXJlZE5vZGU6IGlzVW5yZWNvdmVyZWROb2RlLFxuICBpc1VucmVjb3ZlcmVkTmVzdGVkTGVhZjogaXNVbnJlY292ZXJlZE5lc3RlZExlYWYsXG4gIGlzVW5yZWNvdmVyZWRTaWduYXR1cmVMZWFmOiBpc1VucmVjb3ZlcmVkU2lnbmF0dXJlTGVhZixcbiAgZGVjb2RlU2lnbmF0dXJlVHJlZTogZGVjb2RlU2lnbmF0dXJlVHJlZSxcbiAgSW52YWxpZFNpZ25hdHVyZUxlYWZFcnJvcjogSW52YWxpZFNpZ25hdHVyZUxlYWZFcnJvcixcbiAgcmVjb3ZlclRvcG9sb2d5OiByZWNvdmVyVG9wb2xvZ3ksXG4gIHBhcnRFbmNvZGVyOiBwYXJ0RW5jb2RlcixcbiAgZW5jb2RlU2lnbmVyczogZW5jb2RlU2lnbmVycyxcbiAgZW5jb2RlVHJlZTogZW5jb2RlVHJlZSxcbiAgZGVlcGVzdENvbmZpZ09mU2lnbmF0dXJlOiBkZWVwZXN0Q29uZmlnT2ZTaWduYXR1cmUsXG4gIGlzVW5yZWNvdmVyZWRTaWduYXR1cmU6IGlzVW5yZWNvdmVyZWRTaWduYXR1cmUsXG4gIGlzVW5yZWNvdmVyZWRDaGFpbmVkU2lnbmF0dXJlOiBpc1VucmVjb3ZlcmVkQ2hhaW5lZFNpZ25hdHVyZSxcbiAgaXNTaWduYXR1cmU6IGlzU2lnbmF0dXJlLFxuICBpc0NoYWluZWRTaWduYXR1cmU6IGlzQ2hhaW5lZFNpZ25hdHVyZSxcbiAgZGVjb2RlU2lnbmF0dXJlOiBkZWNvZGVTaWduYXR1cmUsXG4gIGRlY29kZVNpZ25hdHVyZUJvZHk6IGRlY29kZVNpZ25hdHVyZUJvZHksXG4gIGRlY29kZUNoYWluZWRTaWduYXR1cmU6IGRlY29kZUNoYWluZWRTaWduYXR1cmUsXG4gIHNldEltYWdlSGFzaFN0cnVjdDogc2V0SW1hZ2VIYXNoU3RydWN0LFxuICByZWNvdmVyU2lnbmF0dXJlOiByZWNvdmVyU2lnbmF0dXJlLFxuICBlbmNvZGVDaGFpbjogZW5jb2RlQ2hhaW4sXG4gIGVuY29kZVNpZ25hdHVyZTogZW5jb2RlU2lnbmF0dXJlLFxuICBlbmNvZGVTaWduYXR1cmVCb2R5OiBlbmNvZGVTaWduYXR1cmVCb2R5LFxuICBlbmNvZGVTaWduYXR1cmVUcmVlOiBlbmNvZGVTaWduYXR1cmVUcmVlLFxuICBzaWduYXR1cmVzT2Y6IHNpZ25hdHVyZXNPZixcbiAgc2lnbmF0dXJlc09mRGVjb2RlZDogc2lnbmF0dXJlc09mRGVjb2RlZCxcbiAgc3ViZGlnZXN0c09mRGVjb2RlZDogc3ViZGlnZXN0c09mRGVjb2RlZCxcbiAgdHJpbVNpZ25hdHVyZTogdHJpbVNpZ25hdHVyZSxcbiAgdHJpbVVucmVjb3ZlcmVkVHJlZTogdHJpbVVucmVjb3ZlcmVkVHJlZSxcbiAgU2lnbmF0dXJlQ29kZXI6IFNpZ25hdHVyZUNvZGVyXG59KTtcblxuLy9cbi8vIFRyZWUgdHlwaW5ncyAtIGxlYXZlc1xuLy9cblxuLy8gVGhpcyBpcyBhbiB1bmtub3duIG5vZGVcbi8vIGl0IG1lYW5zIHRoZSB0cmVlIGhhcyBhIGJyYW5jaFxuLy8gYnV0IHdlIGRvbid0IGtub3cgd2hhdCB0aGUgY29udGVudFxuXG5mdW5jdGlvbiBpc1NpZ25lckxlYWYobGVhZikge1xuICByZXR1cm4gbGVhZi5hZGRyZXNzICE9PSB1bmRlZmluZWQgJiYgbGVhZi53ZWlnaHQgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzU3ViZGlnZXN0TGVhZihsZWFmKSB7XG4gIHJldHVybiBsZWFmLnN1YmRpZ2VzdCAhPT0gdW5kZWZpbmVkICYmIGxlYWYuYWRkcmVzcyA9PT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gdG9wb2xvZ3lUb0pTT04odHJlZSkge1xuICBpZiAoaXNOb2RlKHRyZWUpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGxlZnQ6IHRvcG9sb2d5VG9KU09OKHRyZWUubGVmdCksXG4gICAgICByaWdodDogdG9wb2xvZ3lUb0pTT04odHJlZS5yaWdodClcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNOZXN0ZWRMZWFmKHRyZWUpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHdlaWdodDogQmlnSW50KHRyZWUud2VpZ2h0KS50b1N0cmluZygpLFxuICAgICAgdGhyZXNob2xkOiBCaWdJbnQodHJlZS50aHJlc2hvbGQpLnRvU3RyaW5nKCksXG4gICAgICB0cmVlOiB0b3BvbG9neVRvSlNPTih0cmVlLnRyZWUpXG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzU2lnbmVyTGVhZih0cmVlKSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBhZGRyZXNzOiB0cmVlLmFkZHJlc3MsXG4gICAgICB3ZWlnaHQ6IEJpZ0ludCh0cmVlLndlaWdodCkudG9TdHJpbmcoKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0cmVlKTtcbn1cbmZ1bmN0aW9uIHRvcG9sb2d5RnJvbUpTT04oanNvbikge1xuICBjb25zdCBwYXJzZWQgPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcbiAgaWYgKHBhcnNlZC5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgcGFyc2VkLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdG9wb2xvZ3lGcm9tSlNPTihwYXJzZWQubGVmdCksXG4gICAgICByaWdodDogdG9wb2xvZ3lGcm9tSlNPTihwYXJzZWQucmlnaHQpXG4gICAgfTtcbiAgfVxuICBpZiAocGFyc2VkLndlaWdodCAhPT0gdW5kZWZpbmVkICYmIHBhcnNlZC50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCAmJiBwYXJzZWQudHJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdlaWdodDogQmlnSW50KHBhcnNlZC53ZWlnaHQpLFxuICAgICAgdGhyZXNob2xkOiBCaWdJbnQocGFyc2VkLnRocmVzaG9sZCksXG4gICAgICB0cmVlOiB0b3BvbG9neUZyb21KU09OKHBhcnNlZC50cmVlKVxuICAgIH07XG4gIH1cbiAgaWYgKHBhcnNlZC5hZGRyZXNzICE9PSB1bmRlZmluZWQgJiYgcGFyc2VkLndlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHJlc3M6IHBhcnNlZC5hZGRyZXNzLFxuICAgICAgd2VpZ2h0OiBCaWdJbnQocGFyc2VkLndlaWdodClcbiAgICB9O1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5mdW5jdGlvbiBpc05lc3RlZExlYWYobGVhZikge1xuICByZXR1cm4gbGVhZi50cmVlICE9PSB1bmRlZmluZWQgJiYgbGVhZi53ZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBsZWFmLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNOb2RlTGVhZihsZWFmKSB7XG4gIHJldHVybiBsZWFmLm5vZGVIYXNoICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0xlYWYobGVhZikge1xuICByZXR1cm4gaXNTaWduZXJMZWFmKGxlYWYpIHx8IGlzU3ViZGlnZXN0TGVhZihsZWFmKSB8fCBpc05lc3RlZExlYWYobGVhZikgfHwgaXNOb2RlTGVhZihsZWFmKTtcbn1cblxuLy9cbi8vIFRyZWUgdHlwaW5ncyAtIG5vZGVzXG4vL1xuXG5mdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgbm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNUb3BvbG9neSh0b3BvbG9neSkge1xuICByZXR1cm4gaXNOb2RlKHRvcG9sb2d5KSB8fCBpc0xlYWYodG9wb2xvZ3kpO1xufVxuZnVuY3Rpb24gZW5jb2RlU2lnbmVyTGVhZihsZWFmKSB7XG4gIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OTYnLCAnYWRkcmVzcyddLCBbbGVhZi53ZWlnaHQsIGxlYWYuYWRkcmVzc10pO1xufVxuZnVuY3Rpb24gZGVjb2RlU2lnbmVyTGVhZihlbmNvZGVkKSB7XG4gIGNvbnN0IGJ5dGVzID0gZXRoZXJzLmdldEJ5dGVzKGVuY29kZWQpO1xuICBpZiAoYnl0ZXMubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGVkIHN0cmluZyBsZW5ndGgnKTtcbiAgfVxuICBjb25zdCB3ZWlnaHQgPSBCaWdJbnQoZXRoZXJzLmhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMTIpKSk7XG4gIGNvbnN0IGFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhldGhlcnMuaGV4bGlmeShieXRlcy5zbGljZSgxMikpKTtcbiAgcmV0dXJuIHtcbiAgICB3ZWlnaHQsXG4gICAgYWRkcmVzc1xuICB9O1xufVxuZnVuY3Rpb24gaXNFbmNvZGVkU2lnbmVyTGVhZihlbmNvZGVkKSB7XG4gIGNvbnN0IGJ5dGVzID0gZXRoZXJzLmdldEJ5dGVzKGVuY29kZWQpO1xuICBpZiAoYnl0ZXMubGVuZ3RoICE9PSAzMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBieXRlcy5zbGljZSgwLCAxMSk7XG4gIHJldHVybiBwcmVmaXguZXZlcnkoYnl0ZSA9PiBieXRlID09PSAwKTtcbn1cbmZ1bmN0aW9uIGhhc2hOb2RlKG5vZGUpIHtcbiAgaWYgKGlzU2lnbmVyTGVhZihub2RlKSkge1xuICAgIHJldHVybiBlbmNvZGVTaWduZXJMZWFmKG5vZGUpO1xuICB9XG4gIGlmIChpc1N1YmRpZ2VzdExlYWYobm9kZSkpIHtcbiAgICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkS2VjY2FrMjU2KFsnc3RyaW5nJywgJ2J5dGVzMzInXSwgWydTZXF1ZW5jZSBzdGF0aWMgZGlnZXN0OlxcbicsIG5vZGUuc3ViZGlnZXN0XSk7XG4gIH1cbiAgaWYgKGlzTmVzdGVkTGVhZihub2RlKSkge1xuICAgIGNvbnN0IG5lc3RlZCA9IGhhc2hOb2RlKG5vZGUudHJlZSk7XG4gICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZEtlY2NhazI1NihbJ3N0cmluZycsICdieXRlczMyJywgJ3VpbnQyNTYnLCAndWludDI1NiddLCBbJ1NlcXVlbmNlIG5lc3RlZCBjb25maWc6XFxuJywgbmVzdGVkLCBub2RlLnRocmVzaG9sZCwgbm9kZS53ZWlnaHRdKTtcbiAgfVxuICBpZiAoaXNOb2RlTGVhZihub2RlKSkge1xuICAgIHJldHVybiBub2RlLm5vZGVIYXNoO1xuICB9XG4gIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWRLZWNjYWsyNTYoWydieXRlczMyJywgJ2J5dGVzMzInXSwgW2hhc2hOb2RlKG5vZGUubGVmdCksIGhhc2hOb2RlKG5vZGUucmlnaHQpXSk7XG59XG5mdW5jdGlvbiBsZWZ0RmFjZSh0b3BvbG9neSkge1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBsZXQgcHJldiA9IHRvcG9sb2d5O1xuICB3aGlsZSAoIWlzTGVhZihwcmV2KSkge1xuICAgIHN0YWNrLnVuc2hpZnQocHJldi5yaWdodCk7XG4gICAgcHJldiA9IHByZXYubGVmdDtcbiAgfVxuICBzdGFjay51bnNoaWZ0KHByZXYpO1xuICByZXR1cm4gc3RhY2s7XG59XG5cbi8vXG4vLyBXYWxsZXQgY29uZmlnIHR5cGVzXG4vL1xuXG5mdW5jdGlvbiBpc1dhbGxldENvbmZpZyhjb25maWcpIHtcbiAgcmV0dXJuIGNvbmZpZy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCAmJiBjb25maWcuY2hlY2twb2ludCAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy50cmVlICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLnZlcnNpb24gIT09IHVuZGVmaW5lZCAmJiBjb25maWcudmVyc2lvbiA9PT0gMjtcbn1cbmZ1bmN0aW9uIGltYWdlSGFzaChjb25maWcpIHtcbiAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZEtlY2NhazI1NihbJ2J5dGVzMzInLCAndWludDI1NiddLCBbZXRoZXJzLnNvbGlkaXR5UGFja2VkS2VjY2FrMjU2KFsnYnl0ZXMzMicsICd1aW50MjU2J10sIFtoYXNoTm9kZShjb25maWcudHJlZSksIGNvbmZpZy50aHJlc2hvbGRdKSwgY29uZmlnLmNoZWNrcG9pbnRdKTtcbn1cblxuLy9cbi8vIFNpbXBsZSB3YWxsZXQgY29uZmlnIHR5cGVzXG4vLyAodXNlZCBmb3IgYnVpbGRpbmcgYW5kIHJlYWRpbmcgbWVya2xlIGNvbmZpZ3MpXG4vL1xuLy8gZGV2OiBgbWVtYmVyc2AgaXMgYSBmbGF0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmVlXG4vLyAgICAgIGl0IGtlZXBzIHJlbGV2YW50IHN0cnVjdHVyZSBsaWtlICduZXN0ZWQgdHJlZXMnIGJ1dFxuLy8gICAgICBpdCBpZ25vcmVzIHRoZSB0cmVlIHN0cnVjdHVyZVxuLy9cbi8vXG5cbmZ1bmN0aW9uIGlzU2ltcGxlTmVzdGVkTWVtYmVyKG1lbWJlcikge1xuICByZXR1cm4gbWVtYmVyLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkICYmIG1lbWJlci53ZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBtZW1iZXIubWVtYmVycyAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gdG9wb2xvZ3lUb01lbWJlcnModHJlZSkge1xuICBpZiAoaXNTaWduZXJMZWFmKHRyZWUpIHx8IGlzU3ViZGlnZXN0TGVhZih0cmVlKSkge1xuICAgIHJldHVybiBbdHJlZV07XG4gIH1cbiAgaWYgKGlzTmVzdGVkTGVhZih0cmVlKSkge1xuICAgIHJldHVybiBbe1xuICAgICAgdGhyZXNob2xkOiB0cmVlLnRocmVzaG9sZCxcbiAgICAgIHdlaWdodDogdHJlZS53ZWlnaHQsXG4gICAgICBtZW1iZXJzOiB0b3BvbG9neVRvTWVtYmVycyh0cmVlLnRyZWUpXG4gICAgfV07XG4gIH1cbiAgaWYgKGlzTm9kZUxlYWYodHJlZSkpIHtcbiAgICAvLyB3ZSBkb24ndCBrbm93IHRoZSBjb250ZW50IG9mIHRoaXMgbm9kZVxuICAgIC8vIHNvIHdlIG9taXQgaXRcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFsuLi50b3BvbG9neVRvTWVtYmVycyh0cmVlLmxlZnQpLCAuLi50b3BvbG9neVRvTWVtYmVycyh0cmVlLnJpZ2h0KV07XG59XG5mdW5jdGlvbiBoYXNVbmtub3duTm9kZXModHJlZSkge1xuICBpZiAoaXNOb2RlTGVhZih0cmVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc05vZGUodHJlZSkpIHtcbiAgICByZXR1cm4gaGFzVW5rbm93bk5vZGVzKHRyZWUubGVmdCkgfHwgaGFzVW5rbm93bk5vZGVzKHRyZWUucmlnaHQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHRvU2ltcGxlV2FsbGV0Q29uZmlnKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIHRocmVzaG9sZDogY29uZmlnLnRocmVzaG9sZCxcbiAgICBjaGVja3BvaW50OiBjb25maWcuY2hlY2twb2ludCxcbiAgICBtZW1iZXJzOiB0b3BvbG9neVRvTWVtYmVycyhjb25maWcudHJlZSlcbiAgfTtcbn1cbmNvbnN0IG1lbWJlcnNBc1RvcG9sb2dpZXMgPSAobWVtYmVycywgYnVpbGRlcikgPT4ge1xuICByZXR1cm4gbWVtYmVycy5tYXAobWVtYmVyID0+IHtcbiAgICBpZiAoaXNTaW1wbGVOZXN0ZWRNZW1iZXIobWVtYmVyKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJlZTogYnVpbGRlcihtZW1iZXIubWVtYmVycyksXG4gICAgICAgIHRocmVzaG9sZDogbWVtYmVyLnRocmVzaG9sZCxcbiAgICAgICAgd2VpZ2h0OiBtZW1iZXIud2VpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbWVtYmVyO1xuICB9KTtcbn07XG5mdW5jdGlvbiBsZWdhY3lUb3BvbG9neUJ1aWxkZXIobWVtYmVycykge1xuICBpZiAobWVtYmVycy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IG1lbWJlcnMgYXJyYXknKTtcbiAgfVxuICBjb25zdCBhc1RvcG9sb2dpZXMgPSBtZW1iZXJzQXNUb3BvbG9naWVzKG1lbWJlcnMsIGxlZ2FjeVRvcG9sb2d5QnVpbGRlcik7XG4gIHJldHVybiBhc1RvcG9sb2dpZXMucmVkdWNlKChhY2MsIG1lbWJlcikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBhY2MsXG4gICAgICByaWdodDogbWVtYmVyXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBtZXJrbGVUb3BvbG9neUJ1aWxkZXIobWVtYmVycykge1xuICBpZiAobWVtYmVycy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IG1lbWJlcnMgYXJyYXknKTtcbiAgfVxuICBjb25zdCBsZWF2ZXMgPSBtZW1iZXJzQXNUb3BvbG9naWVzKG1lbWJlcnMsIG1lcmtsZVRvcG9sb2d5QnVpbGRlcik7XG4gIGZvciAobGV0IHMgPSBsZWF2ZXMubGVuZ3RoOyBzID4gMTsgcyA9IHMgLyAyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzIC8gMjsgaSsrKSB7XG4gICAgICBjb25zdCBqMSA9IGkgKiAyO1xuICAgICAgY29uc3QgajIgPSBqMSArIDE7XG4gICAgICBpZiAoajIgPj0gcykge1xuICAgICAgICBsZWF2ZXNbaV0gPSBsZWF2ZXNbajFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmVzW2ldID0ge1xuICAgICAgICAgIGxlZnQ6IGxlYXZlc1tqMV0sXG4gICAgICAgICAgcmlnaHQ6IGxlYXZlc1tqMl1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlYXZlc1swXTtcbn1cbmZ1bmN0aW9uIG9wdGltaXplZDJTaWduZXJzVG9wb2xvZ3lCdWlsZGVyKG1lbWJlcnMpIHtcbiAgaWYgKG1lbWJlcnMubGVuZ3RoID4gOCkge1xuICAgIHJldHVybiBtZXJrbGVUb3BvbG9neUJ1aWxkZXIobWVtYmVycyk7XG4gIH1cbiAgcmV0dXJuIGxlZ2FjeVRvcG9sb2d5QnVpbGRlcihtZW1iZXJzKTtcbn1cbmZ1bmN0aW9uIHRvV2FsbGV0Q29uZmlnKHNpbXBsZVdhbGxldENvbmZpZywgYnVpbGRlciA9IG9wdGltaXplZDJTaWduZXJzVG9wb2xvZ3lCdWlsZGVyKSB7XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogMixcbiAgICB0aHJlc2hvbGQ6IHNpbXBsZVdhbGxldENvbmZpZy50aHJlc2hvbGQsXG4gICAgY2hlY2twb2ludDogc2ltcGxlV2FsbGV0Q29uZmlnLmNoZWNrcG9pbnQsXG4gICAgdHJlZTogYnVpbGRlcihzaW1wbGVXYWxsZXRDb25maWcubWVtYmVycylcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhc1N1YmRpZ2VzdCh0cmVlLCBzdWJkaWdlc3QpIHtcbiAgaWYgKGlzU3ViZGlnZXN0TGVhZih0cmVlKSkge1xuICAgIHJldHVybiB0cmVlLnN1YmRpZ2VzdCA9PT0gc3ViZGlnZXN0O1xuICB9XG4gIGlmIChpc05vZGUodHJlZSkpIHtcbiAgICByZXR1cm4gaGFzU3ViZGlnZXN0KHRyZWUubGVmdCwgc3ViZGlnZXN0KSB8fCBoYXNTdWJkaWdlc3QodHJlZS5yaWdodCwgc3ViZGlnZXN0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaWduZXJzT2YodHJlZSkge1xuICBjb25zdCBzdGFjayA9IFt0cmVlXTtcbiAgY29uc3Qgc2lnbmVycyA9IG5ldyBTZXQoKTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBub2RlID0gc3RhY2sucG9wKCk7XG4gICAgaWYgKGlzTmVzdGVkTGVhZihub2RlKSkge1xuICAgICAgc3RhY2sucHVzaChub2RlLnRyZWUpO1xuICAgIH0gZWxzZSBpZiAoaXNOb2RlKG5vZGUpKSB7XG4gICAgICBzdGFjay5wdXNoKG5vZGUubGVmdCk7XG4gICAgICBzdGFjay5wdXNoKG5vZGUucmlnaHQpO1xuICAgIH0gZWxzZSBpZiAoaXNTaWduZXJMZWFmKG5vZGUpKSB7XG4gICAgICBzaWduZXJzLmFkZCh7XG4gICAgICAgIGFkZHJlc3M6IG5vZGUuYWRkcmVzcyxcbiAgICAgICAgd2VpZ2h0OiBOdW1iZXIobm9kZS53ZWlnaHQpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2lnbmVycyk7XG59XG5mdW5jdGlvbiBpc0NvbXBsZXRlKHRyZWUpIHtcbiAgaWYgKGlzTm9kZSh0cmVlKSkge1xuICAgIHJldHVybiBpc0NvbXBsZXRlKHRyZWUubGVmdCkgJiYgaXNDb21wbGV0ZSh0cmVlLnJpZ2h0KTtcbiAgfVxuICByZXR1cm4gIWlzTm9kZUxlYWYodHJlZSk7XG59XG5jb25zdCBDb25maWdDb2RlciA9IHtcbiAgaXNXYWxsZXRDb25maWc6IGNvbmZpZyA9PiB7XG4gICAgcmV0dXJuIGNvbmZpZy52ZXJzaW9uID09PSAyICYmIGNvbmZpZy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCAmJiBjb25maWcudHJlZSAhPT0gdW5kZWZpbmVkO1xuICB9LFxuICBpbWFnZUhhc2hPZjogY29uZmlnID0+IHtcbiAgICByZXR1cm4gaW1hZ2VIYXNoKGNvbmZpZyk7XG4gIH0sXG4gIGhhc1N1YmRpZ2VzdDogKGNvbmZpZywgc3ViZGlnZXN0KSA9PiB7XG4gICAgcmV0dXJuIGhhc1N1YmRpZ2VzdChjb25maWcudHJlZSwgc3ViZGlnZXN0KTtcbiAgfSxcbiAgY2hlY2twb2ludE9mOiBjb25maWcgPT4ge1xuICAgIHJldHVybiBCaWdJbnQoY29uZmlnLmNoZWNrcG9pbnQpO1xuICB9LFxuICBzaWduZXJzT2Y6IGNvbmZpZyA9PiB7XG4gICAgcmV0dXJuIHNpZ25lcnNPZihjb25maWcudHJlZSk7XG4gIH0sXG4gIGZyb21TaW1wbGU6IGNvbmZpZyA9PiB7XG4gICAgdmFyIF9jb25maWckc3ViZGlnZXN0cztcbiAgICByZXR1cm4gdG9XYWxsZXRDb25maWcoX2V4dGVuZHMoe30sIGNvbmZpZywge1xuICAgICAgbWVtYmVyczogWy4uLmNvbmZpZy5zaWduZXJzLCAuLi4oKF9jb25maWckc3ViZGlnZXN0cyA9IGNvbmZpZy5zdWJkaWdlc3RzKSAhPSBudWxsID8gX2NvbmZpZyRzdWJkaWdlc3RzIDogW10pLm1hcChzdWJkaWdlc3QgPT4gKHtcbiAgICAgICAgc3ViZGlnZXN0XG4gICAgICB9KSldXG4gICAgfSkpO1xuICB9LFxuICBpc0NvbXBsZXRlOiBjb25maWcgPT4ge1xuICAgIHJldHVybiBpc0NvbXBsZXRlKGNvbmZpZy50cmVlKTtcbiAgfSxcbiAgLy8gaXNWYWxpZCA9IChjb25maWc6IFdhbGxldENvbmZpZyk6IGJvb2xlYW4ge31cbiAgLyoqXG4gICAqXG4gICAqIE5vdGljZTogY29udGV4dCBhbmQga2luZCBhcmUgaWdub3JlZCBiZWNhdXNlIHYyXG4gICAqIGRvZXNuJ3QgbmVlZCB0byBtYW51YWxseSB1cGRhdGUgdGhlIGltcGxlbWVudGF0aW9uIGJlZm9yZVxuICAgKiBhIGNvbmZpZ3VyYXRpb24gdXBkYXRlLCBpdCdzIGF1dG9tYXRpY2FsbHkgZG9uZSBieSB0aGUgY29udHJhY3QuXG4gICAqXG4gICAqL1xuICB1cGRhdGU6IHtcbiAgICBpc0tpbmRVc2VkOiB0cnVlLFxuICAgIGJ1aWxkVHJhbnNhY3Rpb246ICh3YWxsZXQsIGNvbmZpZywgX2NvbnRleHQsIF9raW5kKSA9PiB7XG4gICAgICBjb25zdCBtb2R1bGUgPSBuZXcgZXRoZXJzLkludGVyZmFjZSh3YWxsZXRDb250cmFjdHMubWFpbk1vZHVsZVVwZ3JhZGFibGUuYWJpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudHJ5cG9pbnQ6IHdhbGxldCxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBbe1xuICAgICAgICAgIHRvOiB3YWxsZXQsXG4gICAgICAgICAgZGF0YTogbW9kdWxlLmVuY29kZUZ1bmN0aW9uRGF0YShtb2R1bGUuZ2V0RnVuY3Rpb24oJ3VwZGF0ZUltYWdlSGFzaCcpLCBbQ29uZmlnQ29kZXIuaW1hZ2VIYXNoT2YoY29uZmlnKV0pLFxuICAgICAgICAgIGdhc0xpbWl0OiAwLFxuICAgICAgICAgIGRlbGVnYXRlQ2FsbDogZmFsc2UsXG4gICAgICAgICAgcmV2ZXJ0T25FcnJvcjogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9XVxuICAgICAgfTtcbiAgICB9LFxuICAgIGRlY29kZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAodHgpIHtcbiAgICAgIHZhciBfdHgkdHJhbnNhY3Rpb25zJDAkdmEsIF90eCR0cmFuc2FjdGlvbnMkLCBfdHgkdHJhbnNhY3Rpb25zJDAkZ2EsIF90eCR0cmFuc2FjdGlvbnMkMjtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKHdhbGxldENvbnRyYWN0cy5tYWluTW9kdWxlVXBncmFkYWJsZS5hYmkpO1xuICAgICAgaWYgKHR4LnRyYW5zYWN0aW9ucy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uIGJ1bmRsZSwgZXhwZWN0ZWQgMSB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IHR4LnRyYW5zYWN0aW9uc1swXS5kYXRhO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbiBidW5kbGUsIGV4cGVjdGVkIGRhdGEnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlY29kZWQgPSBtb2R1bGUuZGVjb2RlRnVuY3Rpb25EYXRhKG1vZHVsZS5nZXRGdW5jdGlvbigndXBkYXRlSW1hZ2VIYXNoJyksIGRhdGEpO1xuICAgICAgaWYgKCFkZWNvZGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbiBidW5kbGUsIGV4cGVjdGVkIHZhbGlkIGRhdGEnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eC50cmFuc2FjdGlvbnNbMF0udG8gIT09IHR4LmVudHJ5cG9pbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uIGJ1bmRsZSwgZXhwZWN0ZWQgdG8gYmUgc2VudCB0byBlbnRyeXBvaW50Jyk7XG4gICAgICB9XG4gICAgICBpZiAodHgudHJhbnNhY3Rpb25zWzBdLmRlbGVnYXRlQ2FsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24gYnVuZGxlLCBleHBlY3RlZCBub3QgdG8gYmUgYSBkZWxlZ2F0ZUNhbGwnKTtcbiAgICAgIH1cbiAgICAgIGlmICghdHgudHJhbnNhY3Rpb25zWzBdLnJldmVydE9uRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uIGJ1bmRsZSwgZXhwZWN0ZWQgcmV2ZXJ0T25FcnJvcicpO1xuICAgICAgfVxuICAgICAgaWYgKEJpZ0ludCgoX3R4JHRyYW5zYWN0aW9ucyQwJHZhID0gKF90eCR0cmFuc2FjdGlvbnMkID0gdHgudHJhbnNhY3Rpb25zWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3R4JHRyYW5zYWN0aW9ucyQudmFsdWUpICE9IG51bGwgPyBfdHgkdHJhbnNhY3Rpb25zJDAkdmEgOiAwKSAhPT0gMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uIGJ1bmRsZSwgZXhwZWN0ZWQgdmFsdWUgdG8gYmUgMCcpO1xuICAgICAgfVxuICAgICAgaWYgKEJpZ0ludCgoX3R4JHRyYW5zYWN0aW9ucyQwJGdhID0gKF90eCR0cmFuc2FjdGlvbnMkMiA9IHR4LnRyYW5zYWN0aW9uc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90eCR0cmFuc2FjdGlvbnMkMi5nYXNMaW1pdCkgIT0gbnVsbCA/IF90eCR0cmFuc2FjdGlvbnMkMCRnYSA6IDApICE9PSAwbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24gYnVuZGxlLCBleHBlY3RlZCB2YWx1ZSB0byBiZSAwJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiB0eC5lbnRyeXBvaW50LFxuICAgICAgICBuZXdJbWFnZUhhc2g6IGRlY29kZWRbMF0sXG4gICAgICAgIGtpbmQ6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIHRvSlNPTjogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB2ZXJzaW9uOiBjb25maWcudmVyc2lvbixcbiAgICAgIHRocmVzaG9sZDogQmlnSW50KGNvbmZpZy50aHJlc2hvbGQpLnRvU3RyaW5nKCksXG4gICAgICBjaGVja3BvaW50OiBCaWdJbnQoY29uZmlnLmNoZWNrcG9pbnQpLnRvU3RyaW5nKCksXG4gICAgICB0cmVlOiB0b3BvbG9neVRvSlNPTihjb25maWcudHJlZSlcbiAgICB9KTtcbiAgfSxcbiAgZnJvbUpTT046IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgY29uc3QgY29uZmlnID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbjogY29uZmlnLnZlcnNpb24sXG4gICAgICB0aHJlc2hvbGQ6IEJpZ0ludChjb25maWcudGhyZXNob2xkKSxcbiAgICAgIGNoZWNrcG9pbnQ6IEJpZ0ludChjb25maWcuY2hlY2twb2ludCksXG4gICAgICB0cmVlOiB0b3BvbG9neUZyb21KU09OKGNvbmZpZy50cmVlKVxuICAgIH07XG4gIH0sXG4gIGVkaXRDb25maWc6IGZ1bmN0aW9uIChjb25maWcsIGFjdGlvbikge1xuICAgIHZhciBfYWN0aW9uJHRocmVzaG9sZCwgX2FjdGlvbiRjaGVja3BvaW50O1xuICAgIGNvbnN0IG1lbWJlcnMgPSB0b3BvbG9neVRvTWVtYmVycyhjb25maWcudHJlZSk7XG4gICAgaWYgKGFjdGlvbi5hZGQpIHtcbiAgICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIGFjdGlvbi5hZGQpIHtcbiAgICAgICAgaWYgKG1lbWJlcnMuZmluZChzID0+IGlzU2lnbmVyTGVhZihzKSAmJiBzLmFkZHJlc3MgPT09IHNpZ25lci5hZGRyZXNzKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1lbWJlcnMucHVzaCh7XG4gICAgICAgICAgYWRkcmVzczogc2lnbmVyLmFkZHJlc3MsXG4gICAgICAgICAgd2VpZ2h0OiBzaWduZXIud2VpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWN0aW9uLnJlbW92ZSkge1xuICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIGFjdGlvbi5yZW1vdmUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBtZW1iZXJzLmZpbmRJbmRleChzID0+IGlzU2lnbmVyTGVhZihzKSAmJiBzLmFkZHJlc3MgPT09IGFkZHJlc3MpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIG1lbWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbjogY29uZmlnLnZlcnNpb24sXG4gICAgICB0aHJlc2hvbGQ6IChfYWN0aW9uJHRocmVzaG9sZCA9IGFjdGlvbi50aHJlc2hvbGQpICE9IG51bGwgPyBfYWN0aW9uJHRocmVzaG9sZCA6IGNvbmZpZy50aHJlc2hvbGQsXG4gICAgICBjaGVja3BvaW50OiAoX2FjdGlvbiRjaGVja3BvaW50ID0gYWN0aW9uLmNoZWNrcG9pbnQpICE9IG51bGwgPyBfYWN0aW9uJGNoZWNrcG9pbnQgOiBjb25maWcuY2hlY2twb2ludCxcbiAgICAgIHRyZWU6IG9wdGltaXplZDJTaWduZXJzVG9wb2xvZ3lCdWlsZGVyKG1lbWJlcnMpXG4gICAgfTtcbiAgfSxcbiAgYnVpbGRTdHViU2lnbmF0dXJlOiBmdW5jdGlvbiAoY29uZmlnLCBvdmVycmlkZXMpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtzaWduZXIsIHNpZ25hdHVyZV0gb2Ygb3ZlcnJpZGVzLmVudHJpZXMoKSkge1xuICAgICAgcGFydHMuc2V0KHNpZ25lciwge1xuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIGlzRHluYW1pYzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVuY29kZWQsXG4gICAgICAgIHdlaWdodFxuICAgICAgfSA9IGVuY29kZVNpZ25lcnMoY29uZmlnLCBwYXJ0cywgW10sIDApO1xuICAgICAgaWYgKHdlaWdodCA+PSBCaWdJbnQoY29uZmlnLnRocmVzaG9sZCkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lcnMgPSBzaWduZXJzT2YoY29uZmlnLnRyZWUpO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgYWRkcmVzc1xuICAgIH0gb2Ygc2lnbmVycy5zb3J0KCh7XG4gICAgICB3ZWlnaHQ6IGFcbiAgICB9LCB7XG4gICAgICB3ZWlnaHQ6IGJcbiAgICB9KSA9PiBhIC0gYikpIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9ICcweDRlODJmMDJmMzg4YTEyYjVmOWQyOWVhZjI0NTJkZDA0MGMwZWU1ODA0YjRlNTA0YjRkZDY0ZTM5NmM2Yzc4MWYyYzc2MjQxOTVhY2JhMjQyZGQ4MjViZmQyNWEyOTA5MTJlM2MyMzA4NDFmZDU1YzlhNzM0YzRkZThkOTg5OTQ1MWIwMic7XG4gICAgICBwYXJ0cy5zZXQoYWRkcmVzcywge1xuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIGlzRHluYW1pYzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmNvZGVkLFxuICAgICAgICB3ZWlnaHRcbiAgICAgIH0gPSBlbmNvZGVTaWduZXJzKGNvbmZpZywgcGFydHMsIFtdLCAwKTtcbiAgICAgIGlmICh3ZWlnaHQgPj0gQmlnSW50KGNvbmZpZy50aHJlc2hvbGQpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlU2lnbmVycyhjb25maWcsIHBhcnRzLCBbXSwgMCkuZW5jb2RlZDtcbiAgfVxufTtcblxudmFyIGNvbmZpZyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGlzU2lnbmVyTGVhZjogaXNTaWduZXJMZWFmLFxuICBpc1N1YmRpZ2VzdExlYWY6IGlzU3ViZGlnZXN0TGVhZixcbiAgdG9wb2xvZ3lUb0pTT046IHRvcG9sb2d5VG9KU09OLFxuICB0b3BvbG9neUZyb21KU09OOiB0b3BvbG9neUZyb21KU09OLFxuICBpc05lc3RlZExlYWY6IGlzTmVzdGVkTGVhZixcbiAgaXNOb2RlTGVhZjogaXNOb2RlTGVhZixcbiAgaXNMZWFmOiBpc0xlYWYsXG4gIGlzTm9kZTogaXNOb2RlLFxuICBpc1RvcG9sb2d5OiBpc1RvcG9sb2d5LFxuICBlbmNvZGVTaWduZXJMZWFmOiBlbmNvZGVTaWduZXJMZWFmLFxuICBkZWNvZGVTaWduZXJMZWFmOiBkZWNvZGVTaWduZXJMZWFmLFxuICBpc0VuY29kZWRTaWduZXJMZWFmOiBpc0VuY29kZWRTaWduZXJMZWFmLFxuICBoYXNoTm9kZTogaGFzaE5vZGUsXG4gIGxlZnRGYWNlOiBsZWZ0RmFjZSxcbiAgaXNXYWxsZXRDb25maWc6IGlzV2FsbGV0Q29uZmlnLFxuICBpbWFnZUhhc2g6IGltYWdlSGFzaCxcbiAgaXNTaW1wbGVOZXN0ZWRNZW1iZXI6IGlzU2ltcGxlTmVzdGVkTWVtYmVyLFxuICB0b3BvbG9neVRvTWVtYmVyczogdG9wb2xvZ3lUb01lbWJlcnMsXG4gIGhhc1Vua25vd25Ob2RlczogaGFzVW5rbm93bk5vZGVzLFxuICB0b1NpbXBsZVdhbGxldENvbmZpZzogdG9TaW1wbGVXYWxsZXRDb25maWcsXG4gIGxlZ2FjeVRvcG9sb2d5QnVpbGRlcjogbGVnYWN5VG9wb2xvZ3lCdWlsZGVyLFxuICBtZXJrbGVUb3BvbG9neUJ1aWxkZXI6IG1lcmtsZVRvcG9sb2d5QnVpbGRlcixcbiAgb3B0aW1pemVkMlNpZ25lcnNUb3BvbG9neUJ1aWxkZXI6IG9wdGltaXplZDJTaWduZXJzVG9wb2xvZ3lCdWlsZGVyLFxuICB0b1dhbGxldENvbmZpZzogdG9XYWxsZXRDb25maWcsXG4gIGhhc1N1YmRpZ2VzdDogaGFzU3ViZGlnZXN0LFxuICBzaWduZXJzT2Y6IHNpZ25lcnNPZixcbiAgaXNDb21wbGV0ZTogaXNDb21wbGV0ZSxcbiAgQ29uZmlnQ29kZXI6IENvbmZpZ0NvZGVyXG59KTtcblxudmFyIGNvbnRleHQkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsXG59KTtcblxuY29uc3QgY29kZXJzID0ge1xuICBjb25maWc6IENvbmZpZ0NvZGVyLFxuICBzaWduYXR1cmU6IFNpZ25hdHVyZUNvZGVyXG59O1xuY29uc3QgdmVyc2lvbiA9IDI7XG5jb25zdCBEZXBsb3llZFdhbGxldENvbnRleHQgPSB7XG4gIHZlcnNpb246IHZlcnNpb24sXG4gIGZhY3Rvcnk6ICcweEZhQTVjMGIxNGQxYkVENUM4ODhDYTY1NUI5YThBNTkxMUY3OGVGNEEnLFxuICBndWVzdE1vZHVsZTogJzB4ZmVhMjMwRWUyNDNmODhCQzY5OGREOGYxYUU5M0Y4MzAxQjZjZGZhRScsXG4gIG1haW5Nb2R1bGU6ICcweGZCZjhmMUE1RTAwMDM0NzYyRDkyOGY0NmQ0MzhCOTQ3ZjVkNDA2NWQnLFxuICBtYWluTW9kdWxlVXBncmFkYWJsZTogJzB4NDIyMmRjQTM5NzRFMzlBOGI0MWM0MTFGZURERTliMDlBZTE0YjkxMScsXG4gIHdhbGxldENyZWF0aW9uQ29kZTogJzB4NjAzYTYwMGUzZDM5NjAxYTgwNTEzMDU1M2RmMzM2M2QzZDM3M2QzZDNkMzYzZDMwNTQ1YWY0M2Q4MjgwM2U5MDNkOTE2MDE4NTdmZDViZjMnLFxuICBwcm94eUltcGxlbWVudGF0aW9uSG9vazogJzB4MWY1NmRiQUQ1ZTgzMTlGMERFOWEzMjNFMjRBMzFiNTA3N2RFQjFhNCdcbn07XG5cbnZhciB2MiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjb25maWc6IGNvbmZpZyQxLFxuICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgY29udGV4dDogY29udGV4dCQxLFxuICBjaGFpbmVkOiBjaGFpbmVkLFxuICBjb2RlcnM6IGNvZGVycyxcbiAgdmVyc2lvbjogdmVyc2lvbixcbiAgRGVwbG95ZWRXYWxsZXRDb250ZXh0OiBEZXBsb3llZFdhbGxldENvbnRleHRcbn0pO1xuXG52YXIgY29uZmlnID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG5mdW5jdGlvbiBhZGRyZXNzT2YoY29udGV4dCwgaW1hZ2VIYXNoKSB7XG4gIGNvbnN0IGNvZGVIYXNoID0gZXRoZXJzLmtlY2NhazI1NihldGhlcnMuc29saWRpdHlQYWNrZWQoWydieXRlcycsICdieXRlczMyJ10sIFtjb250ZXh0LndhbGxldENyZWF0aW9uQ29kZSwgZXRoZXJzLnplcm9QYWRWYWx1ZShjb250ZXh0Lm1haW5Nb2R1bGUsIDMyKV0pKTtcbiAgY29uc3QgaGFzaCA9IGV0aGVycy5rZWNjYWsyNTYoZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsnYnl0ZXMxJywgJ2FkZHJlc3MnLCAnYnl0ZXMzMicsICdieXRlczMyJ10sIFsnMHhmZicsIGNvbnRleHQuZmFjdG9yeSwgaW1hZ2VIYXNoLCBjb2RlSGFzaF0pKTtcbiAgcmV0dXJuIGV0aGVycy5nZXRBZGRyZXNzKGV0aGVycy5kYXRhU2xpY2UoaGFzaCwgMTIpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGlzVmFsaWRDb3VudGVyZmFjdHVhbCh3YWxsZXQsIGRpZ2VzdCwgc2lnbmF0dXJlLCBjaGFpbklkLCBwcm92aWRlciwgY29udGV4dHMpIHtcbiAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgdmVyc2lvbiBvZiB0aGUgc2lnbmF0dXJlXG4gIC8vIHNvIHdlIG5lZWQgdG8gdHJ5IGFsbCBvZiB0aGVtXG4gIGNvbnN0IHJlcyA9IGF3YWl0IFByb21pc2UuYWxsKGFsbFZlcnNpb25zLm1hcChhc3luYyB2ZXJzaW9uID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVjb2RlZCA9IHZlcnNpb24uc2lnbmF0dXJlLlNpZ25hdHVyZUNvZGVyLmRlY29kZShldGhlcnMuaGV4bGlmeShzaWduYXR1cmUpKTtcbiAgICAgIGNvbnN0IHJlY292ZXJlZDEgPSBhd2FpdCB2ZXJzaW9uLnNpZ25hdHVyZS5TaWduYXR1cmVDb2Rlci5yZWNvdmVyKGRlY29kZWQsIHtcbiAgICAgICAgYWRkcmVzczogd2FsbGV0LFxuICAgICAgICBkaWdlc3Q6IGV0aGVycy5oZXhsaWZ5KGRpZ2VzdCksXG4gICAgICAgIGNoYWluSWRcbiAgICAgIH0sIHByb3ZpZGVyKTtcbiAgICAgIGNvbnN0IGltYWdlSGFzaCA9IHZlcnNpb24uY29uZmlnLkNvbmZpZ0NvZGVyLmltYWdlSGFzaE9mKHJlY292ZXJlZDEuY29uZmlnKTtcbiAgICAgIGNvbnN0IGNvdW50ZXJmYWN0dWFsQWRkcmVzcyA9IGFkZHJlc3NPZihjb250ZXh0c1t2ZXJzaW9uLnZlcnNpb25dLCBpbWFnZUhhc2gpO1xuICAgICAgaWYgKGNvdW50ZXJmYWN0dWFsQWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSB3YWxsZXQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hhaW5JZD0wIG1lYW5zIG5vIGNoYWluSWQsIHNvIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQgZm9yIGFsbCBjaGFpbnNcbiAgICAgIC8vIHdlIG5lZWQgdG8gY2hlY2sgdGhhdCBjYXNlIHRvb1xuICAgICAgY29uc3QgcmVjb3ZlcmVkMiA9IGF3YWl0IHZlcnNpb24uc2lnbmF0dXJlLlNpZ25hdHVyZUNvZGVyLnJlY292ZXIoZGVjb2RlZCwge1xuICAgICAgICBhZGRyZXNzOiB3YWxsZXQsXG4gICAgICAgIGRpZ2VzdDogZXRoZXJzLmhleGxpZnkoZGlnZXN0KSxcbiAgICAgICAgY2hhaW5JZFxuICAgICAgfSwgcHJvdmlkZXIpO1xuICAgICAgY29uc3QgaW1hZ2VIYXNoMiA9IHZlcnNpb24uY29uZmlnLkNvbmZpZ0NvZGVyLmltYWdlSGFzaE9mKHJlY292ZXJlZDIuY29uZmlnKTtcbiAgICAgIGNvbnN0IGNvdW50ZXJmYWN0dWFsQWRkcmVzczIgPSBhZGRyZXNzT2YoY29udGV4dHNbdmVyc2lvbi52ZXJzaW9uXSwgaW1hZ2VIYXNoMik7XG4gICAgICByZXR1cm4gY291bnRlcmZhY3R1YWxBZGRyZXNzMi50b0xvd2VyQ2FzZSgpID09PSB3YWxsZXQudG9Mb3dlckNhc2UoKTtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7fVxuXG4gICAgLy8gV2UgbW9zdCBsaWtlbHkgZmFpbGVkIHRvIGRlY29kZSB0aGUgc2lnbmF0dXJlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KSk7XG4gIHJldHVybiByZXMuc29tZShyID0+IHIpO1xufVxuZnVuY3Rpb24gaXNWYWxpZFZlcnNpb25lZENvbnRleHQoY29udGV4dHMpIHtcbiAgLy8gbnVtYmVyIG9mIGtleXMgaXMgdGhlIG51bWJlciBvZiB2ZXJzaW9uc1xuICBjb25zdCB2ZXJzaW9ucyA9IE9iamVjdC5rZXlzKGNvbnRleHRzKS5sZW5ndGg7XG5cbiAgLy8gY2hlY2sgdGhhdCBhbGwgdmVyc2lvbnMgZXhpc3QgYW5kIGFyZSB2YWxpZFxuICBmb3IgKGxldCBpID0gMTsgaSA8PSB2ZXJzaW9uczsgaSsrKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNvbnRleHRzW2ldO1xuICAgIGlmICghY29udGV4dCB8fCBjb250ZXh0LnZlcnNpb24gIT09IGkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsYXRlc3RDb250ZXh0KGNvbnRleHRzKSB7XG4gIGNvbnN0IHZlcnNpb25zID0gT2JqZWN0LmtleXMoY29udGV4dHMpLmxlbmd0aDtcbiAgcmV0dXJuIGNvbnRleHRzW3ZlcnNpb25zXTtcbn1cbmNvbnN0IGRlZmF1bHRDb250ZXh0cyA9IHtcbiAgMTogRGVwbG95ZWRXYWxsZXRDb250ZXh0JDEsXG4gIDI6IERlcGxveWVkV2FsbGV0Q29udGV4dFxufTtcblxudmFyIGNvbnRleHQgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYWRkcmVzc09mOiBhZGRyZXNzT2YsXG4gIGlzVmFsaWRDb3VudGVyZmFjdHVhbDogaXNWYWxpZENvdW50ZXJmYWN0dWFsLFxuICBpc1ZhbGlkVmVyc2lvbmVkQ29udGV4dDogaXNWYWxpZFZlcnNpb25lZENvbnRleHQsXG4gIGxhdGVzdENvbnRleHQ6IGxhdGVzdENvbnRleHQsXG4gIGRlZmF1bHRDb250ZXh0czogZGVmYXVsdENvbnRleHRzXG59KTtcblxuY29uc3QgTWV0YVRyYW5zYWN0aW9uc1R5cGUgPSBgdHVwbGUoXG4gIGJvb2wgZGVsZWdhdGVDYWxsLFxuICBib29sIHJldmVydE9uRXJyb3IsXG4gIHVpbnQyNTYgZ2FzTGltaXQsXG4gIGFkZHJlc3MgdGFyZ2V0LFxuICB1aW50MjU2IHZhbHVlLFxuICBieXRlcyBkYXRhXG4pW11gO1xuZnVuY3Rpb24gaW50ZW5kVHJhbnNhY3Rpb25CdW5kbGUoYnVuZGxlLCB3YWxsZXQsIGNoYWluSWQsIGlkKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgYnVuZGxlLCB7XG4gICAgY2hhaW5JZCxcbiAgICBpbnRlbnQ6IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHdhbGxldFxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpbnRlbmRlZFRyYW5zYWN0aW9uSUQoYnVuZGxlKSB7XG4gIHJldHVybiBldGhlcnMua2VjY2FrMjU2KGV0aGVycy5BYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKS5lbmNvZGUoWydhZGRyZXNzJywgJ3VpbnQyNTYnLCAnYnl0ZXMzMiddLCBbYnVuZGxlLmludGVudC53YWxsZXQsIGJ1bmRsZS5jaGFpbklkLCBidW5kbGUuaW50ZW50LmlkXSkpO1xufVxuZnVuY3Rpb24gdW5wYWNrTWV0YVRyYW5zYWN0aW9uc0RhdGEoZGF0YSkge1xuICBjb25zdCByZXMgPSBldGhlcnMuQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCkuZGVjb2RlKFsndWludDI1NicsIE1ldGFUcmFuc2FjdGlvbnNUeXBlXSwgZGF0YSk7XG4gIGlmIChyZXMubGVuZ3RoICE9PSAyIHx8ICFyZXNbMF0gfHwgIXJlc1sxXSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGEgdHJhbnNhY3Rpb24gZGF0YScpO1xuICByZXR1cm4gW3Jlc1swXSwgcmVzWzFdXTtcbn1cbmZ1bmN0aW9uIHBhY2tNZXRhVHJhbnNhY3Rpb25zRGF0YShub25jZSwgdHhzKSB7XG4gIHJldHVybiBldGhlcnMuQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCkuZW5jb2RlKFsndWludDI1NicsIE1ldGFUcmFuc2FjdGlvbnNUeXBlXSwgW25vbmNlLCBzZXF1ZW5jZVR4QWJpRW5jb2RlKHR4cyldKTtcbn1cbmZ1bmN0aW9uIGRpZ2VzdE9mVHJhbnNhY3Rpb25zKG5vbmNlLCB0eHMpIHtcbiAgcmV0dXJuIGV0aGVycy5rZWNjYWsyNTYocGFja01ldGFUcmFuc2FjdGlvbnNEYXRhKG5vbmNlLCB0eHMpKTtcbn1cbmZ1bmN0aW9uIHN1YmRpZ2VzdE9mVHJhbnNhY3Rpb25zKGFkZHJlc3MsIGNoYWluSWQsIG5vbmNlLCB0eHMpIHtcbiAgcmV0dXJuIHN1YmRpZ2VzdE9mKHtcbiAgICBhZGRyZXNzLFxuICAgIGNoYWluSWQsXG4gICAgZGlnZXN0OiBkaWdlc3RPZlRyYW5zYWN0aW9ucyhub25jZSwgdHhzKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHN1YmRpZ2VzdE9mR3Vlc3RNb2R1bGVUcmFuc2FjdGlvbnMoZ3Vlc3RNb2R1bGUsIGNoYWluSWQsIHR4cykge1xuICByZXR1cm4gc3ViZGlnZXN0T2Yoe1xuICAgIGFkZHJlc3M6IGd1ZXN0TW9kdWxlLFxuICAgIGNoYWluSWQsXG4gICAgZGlnZXN0OiBldGhlcnMua2VjY2FrMjU2KGV0aGVycy5BYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKS5lbmNvZGUoWydzdHJpbmcnLCBNZXRhVHJhbnNhY3Rpb25zVHlwZV0sIFsnZ3Vlc3Q6Jywgc2VxdWVuY2VUeEFiaUVuY29kZSh0eHMpXSkpXG4gIH0pO1xufVxuZnVuY3Rpb24gdG9TZXF1ZW5jZVRyYW5zYWN0aW9ucyh3YWxsZXQsIHR4cykge1xuICByZXR1cm4gdHhzLm1hcCh0eCA9PiB0b1NlcXVlbmNlVHJhbnNhY3Rpb24od2FsbGV0LCB0eCkpO1xufVxuZnVuY3Rpb24gdG9TZXF1ZW5jZVRyYW5zYWN0aW9uKHdhbGxldCwgdHgpIHtcbiAgaWYgKHR4LnRvICYmIHR4LnRvICE9PSBldGhlcnMuWmVyb0FkZHJlc3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2U6ICFpc051bGxpc2godHgubm9uY2UpID8gQmlnSW50KHR4Lm5vbmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgIGRlbGVnYXRlQ2FsbDogZmFsc2UsXG4gICAgICAgIHJldmVydE9uRXJyb3I6IGZhbHNlLFxuICAgICAgICBnYXNMaW1pdDogIWlzTnVsbGlzaCh0eC5nYXNMaW1pdCkgPyBCaWdJbnQodHguZ2FzTGltaXQpIDogdW5kZWZpbmVkLFxuICAgICAgICAvLyBYWFg6IGB0eC50b2AgY291bGQgYWxzbyBiZSBldGhlcnMgQWRkcmVzc2FibGUgdHlwZSB3aGljaCByZXR1cm5zIGEgZ2V0QWRkcmVzcyBwcm9taXNlXG4gICAgICAgIC8vIEtlZXBpbmcgdGhpcyBhcyBpcyBmb3Igbm93IHNvIHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIGV2ZXJ5dGhpbmcgdG8gYXN5bmNcbiAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICB2YWx1ZTogQmlnSW50KHR4LnZhbHVlIHx8IDApLFxuICAgICAgICBkYXRhOiB0eC5kYXRhIHx8ICcweCdcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHdhbGxldEludGVyZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKHdhbGxldENvbnRyYWN0cy5tYWluTW9kdWxlLmFiaSk7XG4gICAgY29uc3QgZGF0YSA9IHdhbGxldEludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEod2FsbGV0SW50ZXJmYWNlLmdldEZ1bmN0aW9uKCdjcmVhdGVDb250cmFjdCcpLCBbdHguZGF0YV0pO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZTogdHlwZW9mIHR4Lm5vbmNlID09PSAnbnVtYmVyJyA/IEJpZ0ludCh0eC5ub25jZSkgOiB1bmRlZmluZWQsXG4gICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICBkZWxlZ2F0ZUNhbGw6IGZhbHNlLFxuICAgICAgICByZXZlcnRPbkVycm9yOiBmYWxzZSxcbiAgICAgICAgZ2FzTGltaXQ6ICFpc051bGxpc2godHguZ2FzTGltaXQpID8gQmlnSW50KHR4Lmdhc0xpbWl0KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgdG86IHdhbGxldCxcbiAgICAgICAgdmFsdWU6IEJpZ0ludCh0eC52YWx1ZSB8fCAwKSxcbiAgICAgICAgZGF0YVxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU2VxdWVuY2VUcmFuc2FjdGlvbih0eCkge1xuICByZXR1cm4gdHguZGVsZWdhdGVDYWxsICE9PSB1bmRlZmluZWQgfHwgdHgucmV2ZXJ0T25FcnJvciAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaGFzU2VxdWVuY2VUcmFuc2FjdGlvbnModHhzKSB7XG4gIHJldHVybiB0eHMuZXZlcnkoaXNTZXF1ZW5jZVRyYW5zYWN0aW9uKTtcbn1cblxuLy8gVE9ETzogV2UgbWF5IGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgaWYgd2UgbWFrZSBUcmFuc2FjdGlvbiA9PT0gVHJhbnNhY3Rpb25FbmNvZGVkXG5mdW5jdGlvbiBzZXF1ZW5jZVR4QWJpRW5jb2RlKHR4cykge1xuICByZXR1cm4gdHhzLm1hcCh0eCA9PiB7XG4gICAgdmFyIF90eCR0bztcbiAgICByZXR1cm4ge1xuICAgICAgZGVsZWdhdGVDYWxsOiB0eC5kZWxlZ2F0ZUNhbGwgPT09IHRydWUsXG4gICAgICByZXZlcnRPbkVycm9yOiB0eC5yZXZlcnRPbkVycm9yID09PSB0cnVlLFxuICAgICAgZ2FzTGltaXQ6ICFpc051bGxpc2godHguZ2FzTGltaXQpID8gQmlnSW50KHR4Lmdhc0xpbWl0KSA6IDBuLFxuICAgICAgdGFyZ2V0OiAoX3R4JHRvID0gdHgudG8pICE9IG51bGwgPyBfdHgkdG8gOiBldGhlcnMuWmVyb0FkZHJlc3MsXG4gICAgICB2YWx1ZTogIWlzTnVsbGlzaCh0eC52YWx1ZSkgPyB0eC52YWx1ZSA6IDBuLFxuICAgICAgZGF0YTogdHguZGF0YSB8fCAnMHgnXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmcm9tVHhBYmlFbmNvZGUodHhzKSB7XG4gIHJldHVybiB0eHMubWFwKHR4ID0+ICh7XG4gICAgZGVsZWdhdGVDYWxsOiB0eC5kZWxlZ2F0ZUNhbGwsXG4gICAgcmV2ZXJ0T25FcnJvcjogdHgucmV2ZXJ0T25FcnJvcixcbiAgICBnYXNMaW1pdDogdHguZ2FzTGltaXQsXG4gICAgdG86IHR4LnRhcmdldCxcbiAgICB2YWx1ZTogdHgudmFsdWUsXG4gICAgZGF0YTogdHguZGF0YVxuICB9KSk7XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBhcHBlbmROb25jZSh0eHM6IFRyYW5zYWN0aW9uW10sIG5vbmNlOiBldGhlcnMuQmlnTnVtYmVyaXNoKTogVHJhbnNhY3Rpb25bXSB7XG4vLyAgIHJldHVybiB0eHMubWFwKCh0OiBUcmFuc2FjdGlvbikgPT4gKHsgLi4udCwgbm9uY2UgfSkpXG4vLyB9XG5cbmZ1bmN0aW9uIGVuY29kZU5vbmNlKHNwYWNlLCBub25jZSkge1xuICBjb25zdCBic3BhY2UgPSBCaWdJbnQoc3BhY2UpO1xuICBjb25zdCBibm9uY2UgPSBCaWdJbnQobm9uY2UpO1xuICBjb25zdCBzaGwgPSAybiAqKiA5Nm47XG4gIGlmIChibm9uY2UgLyBzaGwgIT09IDBuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTcGFjZSBhbHJlYWR5IGVuY29kZWQnKTtcbiAgfVxuICByZXR1cm4gYm5vbmNlICsgYnNwYWNlICogc2hsO1xufVxuZnVuY3Rpb24gZGVjb2RlTm9uY2Uobm9uY2UpIHtcbiAgY29uc3QgYm5vbmNlID0gQmlnSW50KG5vbmNlKTtcbiAgY29uc3Qgc2hyID0gMm4gKiogOTZuO1xuICByZXR1cm4gW2Jub25jZSAvIHNociwgYm5vbmNlICUgc2hyXTtcbn1cbmZ1bmN0aW9uIGZyb21UcmFuc2FjdGlvbmlzaCh3YWxsZXQsIHRyYW5zYWN0aW9uKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyYW5zYWN0aW9uKSkge1xuICAgIGlmIChoYXNTZXF1ZW5jZVRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbikpIHtcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3R4ID0gdG9TZXF1ZW5jZVRyYW5zYWN0aW9ucyh3YWxsZXQsIHRyYW5zYWN0aW9uKTtcbiAgICAgIHJldHVybiBzdHgubWFwKHQgPT4gdC50cmFuc2FjdGlvbik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzU2VxdWVuY2VUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpIHtcbiAgICByZXR1cm4gW3RyYW5zYWN0aW9uXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3RvU2VxdWVuY2VUcmFuc2FjdGlvbih3YWxsZXQsIHRyYW5zYWN0aW9uKS50cmFuc2FjdGlvbl07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVHJhbnNhY3Rpb25CdW5kbGUoY2FuZCkge1xuICByZXR1cm4gY2FuZCAhPT0gdW5kZWZpbmVkICYmIGNhbmQuZW50cnlwb2ludCAhPT0gdW5kZWZpbmVkICYmIGNhbmQuY2hhaW5JZCAhPT0gdW5kZWZpbmVkICYmIGNhbmQudHJhbnNhY3Rpb25zICE9PSB1bmRlZmluZWQgJiYgY2FuZC5ub25jZSAhPT0gdW5kZWZpbmVkICYmIGNhbmQuaW50ZW50ICE9PSB1bmRlZmluZWQgJiYgY2FuZC5pbnRlbnQuaWQgIT09IHVuZGVmaW5lZCAmJiBjYW5kLmludGVudC53YWxsZXQgIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KGNhbmQudHJhbnNhY3Rpb25zKSAmJiBjYW5kLnRyYW5zYWN0aW9ucy5yZWR1Y2UoKHAsIGMpID0+IHAgJiYgaXNTZXF1ZW5jZVRyYW5zYWN0aW9uKGMpLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGlzU2lnbmVkVHJhbnNhY3Rpb25CdW5kbGUoY2FuZCkge1xuICByZXR1cm4gY2FuZCAhPT0gdW5kZWZpbmVkICYmIGNhbmQuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiYgY2FuZC5zaWduYXR1cmUgIT09ICcnICYmIGlzVHJhbnNhY3Rpb25CdW5kbGUoY2FuZCk7XG59XG5mdW5jdGlvbiBlbmNvZGVCdW5kbGVFeGVjRGF0YShidW5kbGUpIHtcbiAgY29uc3Qgd2FsbGV0SW50ZXJmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2Uod2FsbGV0Q29udHJhY3RzLm1haW5Nb2R1bGUuYWJpKTtcbiAgcmV0dXJuIHdhbGxldEludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEod2FsbGV0SW50ZXJmYWNlLmdldEZ1bmN0aW9uKCdleGVjdXRlJyksIGlzU2lnbmVkVHJhbnNhY3Rpb25CdW5kbGUoYnVuZGxlKSA/IFtcbiAgLy8gU2lnbmVkIHRyYW5zYWN0aW9uIGJ1bmRsZSBoYXMgYWxsIDMgcGFyYW1ldGVyc1xuICBzZXF1ZW5jZVR4QWJpRW5jb2RlKGJ1bmRsZS50cmFuc2FjdGlvbnMpLCBidW5kbGUubm9uY2UsIGJ1bmRsZS5zaWduYXR1cmVdIDogW1xuICAvLyBVbnNpZ25lZCBidW5kbGUgbWF5IGJlIGEgR3Vlc3RNb2R1bGUgY2FsbCwgc28gc2lnbmF0dXJlIGFuZCBub25jZSBhcmUgbWlzc2luZ1xuICBzZXF1ZW5jZVR4QWJpRW5jb2RlKGJ1bmRsZS50cmFuc2FjdGlvbnMpLCAwLCBuZXcgVWludDhBcnJheShbXSldKTtcbn1cblxuLy8gVE9ETzogVXNlIFNlcXVlbmNlIEFCSSBwYWNrYWdlXG5jb25zdCBzZWxmRXhlY3V0ZVNlbGVjdG9yID0gJzB4NjFjMjkyNmMnO1xuY29uc3Qgc2VsZkV4ZWN1dGVBYmkgPSBgdHVwbGUoXG4gIGJvb2wgZGVsZWdhdGVDYWxsLFxuICBib29sIHJldmVydE9uRXJyb3IsXG4gIHVpbnQyNTYgZ2FzTGltaXQsXG4gIGFkZHJlc3MgdGFyZ2V0LFxuICB1aW50MjU2IHZhbHVlLFxuICBieXRlcyBkYXRhXG4pW11gO1xuXG4vLyBTcGxpdHMgU2VxdWVuY2UgYmF0Y2ggdHJhbnNhY3Rpb25zIGludG8gaW5kaXZpZHVhbCBwYXJ0c1xuY29uc3QgdW53aW5kID0gKHdhbGxldCwgdHJhbnNhY3Rpb25zKSA9PiB7XG4gIGNvbnN0IHVud291bmQgPSBbXTtcbiAgY29uc3Qgd2FsbGV0SW50ZXJmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2Uod2FsbGV0Q29udHJhY3RzLm1haW5Nb2R1bGUuYWJpKTtcbiAgZm9yIChjb25zdCB0eCBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCB0eERhdGEgPSBldGhlcnMuZ2V0Qnl0ZXModHguZGF0YSB8fCAnMHgnKTtcbiAgICBpZiAodHgudG8gPT09IHdhbGxldCAmJiBldGhlcnMuaGV4bGlmeSh0eERhdGEuc2xpY2UoMCwgNCkpID09PSBzZWxmRXhlY3V0ZVNlbGVjdG9yKSB7XG4gICAgICAvLyBEZWNvZGUgYXMgc2VsZkV4ZWN1dGUgY2FsbFxuICAgICAgY29uc3QgZGF0YSA9IHR4RGF0YS5zbGljZSg0KTtcbiAgICAgIGNvbnN0IGRlY29kZWQgPSBldGhlcnMuQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCkuZGVjb2RlKFtzZWxmRXhlY3V0ZUFiaV0sIGRhdGEpWzBdO1xuICAgICAgdW53b3VuZC5wdXNoKC4uLnVud2luZCh0eC50bywgZGVjb2RlZC5tYXAoZCA9PiBfZXh0ZW5kcyh7fSwgZCwge1xuICAgICAgICB0bzogZC50YXJnZXRcbiAgICAgIH0pKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBpbm5lclRyYW5zYWN0aW9ucyA9IHdhbGxldEludGVyZmFjZS5kZWNvZGVGdW5jdGlvbkRhdGEoJ2V4ZWN1dGUnLCB0eERhdGEpWzBdO1xuICAgICAgICBjb25zdCB1bndvdW5kVHJhbnNhY3Rpb25zID0gdW53aW5kKHdhbGxldCwgaW5uZXJUcmFuc2FjdGlvbnMubWFwKHR4ID0+IF9leHRlbmRzKHt9LCB0eC50b09iamVjdCgpLCB7XG4gICAgICAgICAgdG86IHR4LnRhcmdldFxuICAgICAgICB9KSkpO1xuICAgICAgICB1bndvdW5kLnB1c2goLi4udW53b3VuZFRyYW5zYWN0aW9ucyk7XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgIHVud291bmQucHVzaCh0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1bndvdW5kO1xufTtcbmNvbnN0IGlzTnVsbGlzaCA9IHZhbHVlID0+IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDA7XG5cbnZhciB0cmFuc2FjdGlvbiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBNZXRhVHJhbnNhY3Rpb25zVHlwZTogTWV0YVRyYW5zYWN0aW9uc1R5cGUsXG4gIGludGVuZFRyYW5zYWN0aW9uQnVuZGxlOiBpbnRlbmRUcmFuc2FjdGlvbkJ1bmRsZSxcbiAgaW50ZW5kZWRUcmFuc2FjdGlvbklEOiBpbnRlbmRlZFRyYW5zYWN0aW9uSUQsXG4gIHVucGFja01ldGFUcmFuc2FjdGlvbnNEYXRhOiB1bnBhY2tNZXRhVHJhbnNhY3Rpb25zRGF0YSxcbiAgcGFja01ldGFUcmFuc2FjdGlvbnNEYXRhOiBwYWNrTWV0YVRyYW5zYWN0aW9uc0RhdGEsXG4gIGRpZ2VzdE9mVHJhbnNhY3Rpb25zOiBkaWdlc3RPZlRyYW5zYWN0aW9ucyxcbiAgc3ViZGlnZXN0T2ZUcmFuc2FjdGlvbnM6IHN1YmRpZ2VzdE9mVHJhbnNhY3Rpb25zLFxuICBzdWJkaWdlc3RPZkd1ZXN0TW9kdWxlVHJhbnNhY3Rpb25zOiBzdWJkaWdlc3RPZkd1ZXN0TW9kdWxlVHJhbnNhY3Rpb25zLFxuICB0b1NlcXVlbmNlVHJhbnNhY3Rpb25zOiB0b1NlcXVlbmNlVHJhbnNhY3Rpb25zLFxuICB0b1NlcXVlbmNlVHJhbnNhY3Rpb246IHRvU2VxdWVuY2VUcmFuc2FjdGlvbixcbiAgaXNTZXF1ZW5jZVRyYW5zYWN0aW9uOiBpc1NlcXVlbmNlVHJhbnNhY3Rpb24sXG4gIGhhc1NlcXVlbmNlVHJhbnNhY3Rpb25zOiBoYXNTZXF1ZW5jZVRyYW5zYWN0aW9ucyxcbiAgc2VxdWVuY2VUeEFiaUVuY29kZTogc2VxdWVuY2VUeEFiaUVuY29kZSxcbiAgZnJvbVR4QWJpRW5jb2RlOiBmcm9tVHhBYmlFbmNvZGUsXG4gIGVuY29kZU5vbmNlOiBlbmNvZGVOb25jZSxcbiAgZGVjb2RlTm9uY2U6IGRlY29kZU5vbmNlLFxuICBmcm9tVHJhbnNhY3Rpb25pc2g6IGZyb21UcmFuc2FjdGlvbmlzaCxcbiAgaXNUcmFuc2FjdGlvbkJ1bmRsZTogaXNUcmFuc2FjdGlvbkJ1bmRsZSxcbiAgaXNTaWduZWRUcmFuc2FjdGlvbkJ1bmRsZTogaXNTaWduZWRUcmFuc2FjdGlvbkJ1bmRsZSxcbiAgZW5jb2RlQnVuZGxlRXhlY0RhdGE6IGVuY29kZUJ1bmRsZUV4ZWNEYXRhLFxuICBzZWxmRXhlY3V0ZVNlbGVjdG9yOiBzZWxmRXhlY3V0ZVNlbGVjdG9yLFxuICBzZWxmRXhlY3V0ZUFiaTogc2VsZkV4ZWN1dGVBYmksXG4gIHVud2luZDogdW53aW5kXG59KTtcblxuLyogU291cmNlIG9mIE9mZmNoYWluIEVJUC02NDkyIHZhbGlkYXRpb246XG5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5wcmFnbWEgc29saWRpdHkgMC44LjE4O1xuXG5cbi8vIEFzIHBlciBFUkMtMTI3MVxuaW50ZXJmYWNlIElFUkMxMjcxV2FsbGV0IHtcbiAgZnVuY3Rpb24gaXNWYWxpZFNpZ25hdHVyZShieXRlczMyIGhhc2gsIGJ5dGVzIGNhbGxkYXRhIHNpZ25hdHVyZSkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChieXRlczQgbWFnaWNWYWx1ZSk7XG59XG5cbmVycm9yIEVSQzEyNzFSZXZlcnQoYnl0ZXMgZXJyb3IpO1xuZXJyb3IgRVJDNjQ5MkRlcGxveUZhaWxlZChieXRlcyBlcnJvcik7XG5cbmNvbnRyYWN0IFVuaXZlcnNhbFNpZ1ZhbGlkYXRvciB7XG4gIGJ5dGVzMzIgcHJpdmF0ZSBjb25zdGFudCBFUkM2NDkyX0RFVEVDVElPTl9TVUZGSVggPSAweDY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI7XG4gIGJ5dGVzNCBwcml2YXRlIGNvbnN0YW50IEVSQzEyNzFfU1VDQ0VTUyA9IDB4MTYyNmJhN2U7XG5cbiAgZnVuY3Rpb24gaXNWYWxpZFNpZ0ltcGwoXG4gICAgYWRkcmVzcyBfc2lnbmVyLFxuICAgIGJ5dGVzMzIgX2hhc2gsXG4gICAgYnl0ZXMgY2FsbGRhdGEgX3NpZ25hdHVyZSxcbiAgICBib29sIGFsbG93U2lkZUVmZmVjdHMsXG4gICAgYm9vbCBkZXBsb3lBbHJlYWR5RGVwbG95ZWRcbiAgKSBwdWJsaWMgcmV0dXJucyAoYm9vbCkge1xuICAgIHVpbnQgY29udHJhY3RDb2RlTGVuID0gYWRkcmVzcyhfc2lnbmVyKS5jb2RlLmxlbmd0aDtcbiAgICBieXRlcyBtZW1vcnkgc2lnVG9WYWxpZGF0ZTtcbiAgICAvLyBUaGUgb3JkZXIgaGVyZSBpcyBzdHJpY2x0eSBkZWZpbmVkIGluIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNjQ5MlxuICAgIC8vIC0gRVJDLTY0OTIgc3VmZml4IGNoZWNrIGFuZCB2ZXJpZmljYXRpb24gZmlyc3QsIHdoaWxlIGJlaW5nIHBlcm1pc3NpdmUgaW4gY2FzZSB0aGUgY29udHJhY3QgaXMgYWxyZWFkeSBkZXBsb3llZDsgaWYgdGhlIGNvbnRyYWN0IGlzIGRlcGxveWVkIHdlIHdpbGwgY2hlY2sgdGhlIHNpZyBhZ2FpbnN0IHRoZSBkZXBsb3llZCB2ZXJzaW9uLCB0aGlzIGFsbG93cyA2NDkyIHNpZ25hdHVyZXMgdG8gc3RpbGwgYmUgdmFsaWRhdGVkIHdoaWxlIHRha2luZyBpbnRvIGFjY291bnQgcG90ZW50aWFsIGtleSByb3RhdGlvblxuICAgIC8vIC0gRVJDLTEyNzEgdmVyaWZpY2F0aW9uIGlmIHRoZXJlJ3MgY29udHJhY3QgY29kZVxuICAgIC8vIC0gZmluYWxseSwgZWNyZWNvdmVyXG4gICAgYm9vbCBpc0NvdW50ZXJmYWN0dWFsID0gYnl0ZXMzMihfc2lnbmF0dXJlW19zaWduYXR1cmUubGVuZ3RoLTMyOl9zaWduYXR1cmUubGVuZ3RoXSkgPT0gRVJDNjQ5Ml9ERVRFQ1RJT05fU1VGRklYO1xuICAgIGlmIChpc0NvdW50ZXJmYWN0dWFsKSB7XG4gICAgICBhZGRyZXNzIGNyZWF0ZTJGYWN0b3J5O1xuICAgICAgYnl0ZXMgbWVtb3J5IGZhY3RvcnlDYWxsZGF0YTtcbiAgICAgIChjcmVhdGUyRmFjdG9yeSwgZmFjdG9yeUNhbGxkYXRhLCBzaWdUb1ZhbGlkYXRlKSA9IGFiaS5kZWNvZGUoX3NpZ25hdHVyZVswOl9zaWduYXR1cmUubGVuZ3RoLTMyXSwgKGFkZHJlc3MsIGJ5dGVzLCBieXRlcykpO1xuXG4gICAgICBpZiAoY29udHJhY3RDb2RlTGVuID09IDAgfHwgZGVwbG95QWxyZWFkeURlcGxveWVkKSB7XG4gICAgICAgIChib29sIHN1Y2Nlc3MsIGJ5dGVzIG1lbW9yeSBlcnIpID0gY3JlYXRlMkZhY3RvcnkuY2FsbChmYWN0b3J5Q2FsbGRhdGEpO1xuICAgICAgICBpZiAoIXN1Y2Nlc3MpIHJldmVydCBFUkM2NDkyRGVwbG95RmFpbGVkKGVycik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpZ1RvVmFsaWRhdGUgPSBfc2lnbmF0dXJlO1xuICAgIH1cblxuICAgIC8vIFRyeSBFUkMtMTI3MSB2ZXJpZmljYXRpb25cbiAgICBpZiAoaXNDb3VudGVyZmFjdHVhbCB8fCBjb250cmFjdENvZGVMZW4gPiAwKSB7XG4gICAgICB0cnkgSUVSQzEyNzFXYWxsZXQoX3NpZ25lcikuaXNWYWxpZFNpZ25hdHVyZShfaGFzaCwgc2lnVG9WYWxpZGF0ZSkgcmV0dXJucyAoYnl0ZXM0IG1hZ2ljVmFsdWUpIHtcbiAgICAgICAgYm9vbCBpc1ZhbGlkID0gbWFnaWNWYWx1ZSA9PSBFUkMxMjcxX1NVQ0NFU1M7XG5cbiAgICAgICAgLy8gRVhQRVJJTUVOVEFMOiBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBFSVAtNjQ5MiBzcGVjICp5ZXQqXG4gICAgICAgIC8vIGJ1dCBpdCBtYXkgYmUgdXNlZnVsIHRvIHJldHJ5IHRoZSBjYWxsIG1ha2luZyB0aGUgZmFjdG9yeSBjYWxsXG4gICAgICAgIC8vIGV2ZW4gaWYgdGhlIHdhbGxldCBpcyBhbHJlYWR5IGRlcGxveWVkLCBpbiBjYXNlIHRoZSB3YWxsZXRcbiAgICAgICAgLy8gbmVlZHMgdG8gcGVyZm9ybSBzb21lIHNvcnQgb2YgbWlncmF0aW9uIG9yIG9uY2hhaW4ga2V5IHJvdGF0aW9uXG4gICAgICAgIGlmICghaXNWYWxpZCAmJiAhZGVwbG95QWxyZWFkeURlcGxveWVkICYmIGNvbnRyYWN0Q29kZUxlbiA+IDApIHtcbiAgICAgICAgICByZXR1cm4gaXNWYWxpZFNpZ0ltcGwoX3NpZ25lciwgX2hhc2gsIF9zaWduYXR1cmUsIGFsbG93U2lkZUVmZmVjdHMsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRyYWN0Q29kZUxlbiA9PSAwICYmIGlzQ291bnRlcmZhY3R1YWwgJiYgIWFsbG93U2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgY2FsbCBoYWQgc2lkZSBlZmZlY3RzIHdlIG5lZWQgdG8gcmV0dXJuIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCB1c2luZyBhIGByZXZlcnRgICh0byB1bmRvIHRoZSBzdGF0ZSBjaGFuZ2VzKVxuICAgICAgICAgIGFzc2VtYmx5IHtcbiAgICAgICAgICAgIG1zdG9yZSgwLCBpc1ZhbGlkKVxuICAgICAgICAgICAgcmV2ZXJ0KDMxLCAxKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoYnl0ZXMgbWVtb3J5IGVycikge1xuICAgICAgICAvLyBFWFBFUklNRU5UQUw6IFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIEVJUC02NDkyIHNwZWMgKnlldCpcbiAgICAgICAgLy8gYnV0IGl0IG1heSBiZSB1c2VmdWwgdG8gcmV0cnkgdGhlIGNhbGwgbWFraW5nIHRoZSBmYWN0b3J5IGNhbGxcbiAgICAgICAgLy8gZXZlbiBpZiB0aGUgd2FsbGV0IGlzIGFscmVhZHkgZGVwbG95ZWQsIGluIGNhc2UgdGhlIHdhbGxldFxuICAgICAgICAvLyBuZWVkcyB0byBwZXJmb3JtIHNvbWUgc29ydCBvZiBtaWdyYXRpb24gb3Igb25jaGFpbiBrZXkgcm90YXRpb25cbiAgICAgICAgaWYgKCFkZXBsb3lBbHJlYWR5RGVwbG95ZWQgJiYgY29udHJhY3RDb2RlTGVuID4gMCkge1xuICAgICAgICAgIHJldHVybiBpc1ZhbGlkU2lnSW1wbChfc2lnbmVyLCBfaGFzaCwgX3NpZ25hdHVyZSwgYWxsb3dTaWRlRWZmZWN0cywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXZlcnQgRVJDMTI3MVJldmVydChlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVjcmVjb3ZlciB2ZXJpZmljYXRpb25cbiAgICByZXF1aXJlKF9zaWduYXR1cmUubGVuZ3RoID09IDY1LCAnU2lnbmF0dXJlVmFsaWRhdG9yI3JlY292ZXJTaWduZXI6IGludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICAgIGJ5dGVzMzIgciA9IGJ5dGVzMzIoX3NpZ25hdHVyZVswOjMyXSk7XG4gICAgYnl0ZXMzMiBzID0gYnl0ZXMzMihfc2lnbmF0dXJlWzMyOjY0XSk7XG4gICAgdWludDggdiA9IHVpbnQ4KF9zaWduYXR1cmVbNjRdKTtcblxuICAgIGlmICh2ICE9IDI3ICYmIHYgIT0gMjgpIHtcbiAgICAgIHJldmVydCgnU2lnbmF0dXJlVmFsaWRhdG9yOiBpbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVjcmVjb3ZlcihfaGFzaCwgdiwgciwgcykgPT0gX3NpZ25lcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWRTaWdXaXRoU2lkZUVmZmVjdHMoXG4gICAgYWRkcmVzcyBfc2lnbmVyLFxuICAgIGJ5dGVzMzIgX2hhc2gsXG4gICAgYnl0ZXMgY2FsbGRhdGEgX3NpZ25hdHVyZVxuICApIGV4dGVybmFsIHJldHVybnMgKGJvb2wpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkU2lnSW1wbChfc2lnbmVyLCBfaGFzaCwgX3NpZ25hdHVyZSwgdHJ1ZSwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNWYWxpZFNpZyhcbiAgICBhZGRyZXNzIF9zaWduZXIsXG4gICAgYnl0ZXMzMiBfaGFzaCxcbiAgICBieXRlcyBjYWxsZGF0YSBfc2lnbmF0dXJlXG4gICkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCkge1xuICAgIHRyeSB0aGlzLmlzVmFsaWRTaWdJbXBsKF9zaWduZXIsIF9oYXNoLCBfc2lnbmF0dXJlLCBmYWxzZSwgZmFsc2UpIHJldHVybnMgKGJvb2wgaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfSBjYXRjaCAoYnl0ZXMgbWVtb3J5IGVycm9yKSB7XG4gICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBzaWRlIGVmZmVjdHMgZnJvbSB0aGUgY29udHJhY3QgZ2V0dGluZyBkZXBsb3llZCwgdGhlIGVudGlyZSBjYWxsIHdpbGwgcmV2ZXJ0IHdpdGggYSBzaW5nbGUgYnl0ZSByZXN1bHRcbiAgICAgIHVpbnQgbGVuID0gZXJyb3IubGVuZ3RoO1xuICAgICAgaWYgKGxlbiA9PSAxKSB7XG4gICAgICAgIHJldHVybiBlcnJvclswXSA9PSAweDAxO1xuICAgICAgICAvLyBhbGwgb3RoZXIgZXJyb3JzIGFyZSBzaW1wbHkgZm9yd2FyZGVkLCBidXQgaW4gY3VzdG9tIGZvcm1hdHMgc28gdGhhdCBub3RoaW5nIGVsc2UgY2FuIHJldmVydCB3aXRoIGEgc2luZ2xlIGJ5dGUgaW4gdGhlIGNhbGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VtYmx5IHsgcmV2ZXJ0KGVycm9yLCBsZW4pIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOT1RJQ0U6IFRoZXNlIGZ1bmN0aW9ucyBhcmVuJ3QgcGFydCBvZiB0aGUgc3RhbmRhcmRcbiAgLy8gdGhleSBhcmUgaGVscGVycyB0aGF0IGJlaGF2ZSBsaWtlIHRoZSBhYm92ZSBmdW5jdGlvbnNcbiAgLy8gYnV0IHRoZXkgZG9uJ3QgcmV2ZXJ0IG9uIGZhaWx1cmUsIGluc3RlYWQgdGhleSByZXR1cm4gZmFsc2VcblxuICBmdW5jdGlvbiBpc1ZhbGlkU2lnTm9UaHJvdyhcbiAgICBhZGRyZXNzIF9zaWduZXIsXG4gICAgYnl0ZXMzMiBfaGFzaCxcbiAgICBieXRlcyBjYWxsZGF0YSBfc2lnbmF0dXJlXG4gICkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCkge1xuICAgIHRyeSB0aGlzLmlzVmFsaWRTaWdJbXBsKF9zaWduZXIsIF9oYXNoLCBfc2lnbmF0dXJlLCBmYWxzZSwgZmFsc2UpIHJldHVybnMgKGJvb2wgaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfSBjYXRjaCAoYnl0ZXMgbWVtb3J5IGVycm9yKSB7XG4gICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBzaWRlIGVmZmVjdHMgZnJvbSB0aGUgY29udHJhY3QgZ2V0dGluZyBkZXBsb3llZCwgdGhlIGVudGlyZSBjYWxsIHdpbGwgcmV2ZXJ0IHdpdGggYSBzaW5nbGUgYnl0ZSByZXN1bHRcbiAgICAgIHVpbnQgbGVuID0gZXJyb3IubGVuZ3RoO1xuICAgICAgaWYgKGxlbiA9PSAxKSB7XG4gICAgICAgIHJldHVybiBlcnJvclswXSA9PSAweDAxO1xuICAgICAgICAvLyBhbGwgb3RoZXIgZXJyb3JzIGFyZSBzaW1wbHkgZm9yd2FyZGVkLCBidXQgaW4gY3VzdG9tIGZvcm1hdHMgc28gdGhhdCBub3RoaW5nIGVsc2UgY2FuIHJldmVydCB3aXRoIGEgc2luZ2xlIGJ5dGUgaW4gdGhlIGNhbGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElnbm9yZSBhbGwgb3RoZXIgZXJyb3JzIGFuZCByZXR1cm4gZmFsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWRTaWdXaXRoU2lkZUVmZmVjdHNOb1Rocm93KFxuICAgIGFkZHJlc3MgX3NpZ25lcixcbiAgICBieXRlczMyIF9oYXNoLFxuICAgIGJ5dGVzIGNhbGxkYXRhIF9zaWduYXR1cmVcbiAgKSBleHRlcm5hbCByZXR1cm5zIChib29sKSB7XG4gICAgdHJ5IHRoaXMuaXNWYWxpZFNpZ0ltcGwoX3NpZ25lciwgX2hhc2gsIF9zaWduYXR1cmUsIHRydWUsIGZhbHNlKSByZXR1cm5zIChib29sIGlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgIH0gY2F0Y2ggKGJ5dGVzIG1lbW9yeSBlcnJvcikge1xuICAgICAgLy8gSWdub3JlIGFsbCBlcnJvcnMgYW5kIHJldHVybiBmYWxzZVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG4vLyB0aGlzIGlzIGEgaGVscGVyIHNvIHdlIGNhbiBwZXJmb3JtIHZhbGlkYXRpb24gaW4gYSBzaW5nbGUgZXRoX2NhbGwgd2l0aG91dCBwcmUtZGVwbG95aW5nIGEgc2luZ2xldG9uXG5jb250cmFjdCBWYWxpZGF0ZVNpZ09mZmNoYWluIHtcbiAgY29uc3RydWN0b3IgKGFkZHJlc3MgX3NpZ25lciwgYnl0ZXMzMiBfaGFzaCwgYnl0ZXMgbWVtb3J5IF9zaWduYXR1cmUpIHtcbiAgICBVbml2ZXJzYWxTaWdWYWxpZGF0b3IgdmFsaWRhdG9yID0gbmV3IFVuaXZlcnNhbFNpZ1ZhbGlkYXRvcigpO1xuICAgIGJvb2wgaXNWYWxpZFNpZyA9IHZhbGlkYXRvci5pc1ZhbGlkU2lnV2l0aFNpZGVFZmZlY3RzKF9zaWduZXIsIF9oYXNoLCBfc2lnbmF0dXJlKTtcbiAgICBhc3NlbWJseSB7XG4gICAgICBtc3RvcmUoMCwgaXNWYWxpZFNpZylcbiAgICAgIHJldHVybigzMSwgMSlcbiAgICB9XG4gIH1cbn1cbiovXG5cbmNvbnN0IEVJUF82NDkyX09GRkNIQUlOX0RFUExPWV9DT0RFID0gJzB4NjA4MDYwNDA1MjM0ODAxNTYxMDAxMDU3NjAwMDgwZmQ1YjUwNjA0MDUxNjExMjRhMzgwMzgwNjExMjRhODMzOTgxMDE2MDQwODE5MDUyNjEwMDJmOTE2MTAxMjQ1NjViNjAwMDYwNDA1MTYxMDAzZDkwNjEwMGRkNTY1YjYwNDA1MTgwOTEwMzkwNjAwMGYwODAxNTgwMTU2MTAwNTk1NzNkNjAwMDgwM2UzZDYwMDBmZDViNTA5MDUwNjAwMDgxNjAwMTYwMDE2MGEwMWIwMzE2NjM4ZjA2ODQzMDg2ODY4NjYwNDA1MTg0NjNmZmZmZmZmZjE2NjBlMDFiODE1MjYwMDQwMTYxMDA4ZTkzOTI5MTkwNjEwMWZiNTY1YjYwMjA2MDQwNTE4MDgzMDM4MTYwMDA4NzVhZjExNTgwMTU2MTAwYWQ1NzNkNjAwMDgwM2UzZDYwMDBmZDViNTA1MDUwNTA2MDQwNTEzZDYwMWYxOTYwMWY4MjAxMTY4MjAxODA2MDQwNTI1MDgxMDE5MDYxMDBkMTkxOTA2MTAyNDQ1NjViOTA1MDgwNjAwMDUyNjAwMTYwMWZmMzViNjEwZmRjODA2MTAyNmU4MzM5MDE5MDU2NWI2MzRlNDg3YjcxNjBlMDFiNjAwMDUyNjA0MTYwMDQ1MjYwMjQ2MDAwZmQ1YjYwMDA1YjgzODExMDE1NjEwMTFiNTc4MTgxMDE1MTgzODIwMTUyNjAyMDAxNjEwMTAzNTY1YjUwNTA2MDAwOTEwMTUyNTY1YjYwMDA4MDYwMDA2MDYwODQ4NjAzMTIxNTYxMDEzOTU3NjAwMDgwZmQ1YjgzNTE2MDAxNjAwMTYwYTAxYjAzODExNjgxMTQ2MTAxNTA1NzYwMDA4MGZkNWI2MDIwODUwMTUxNjA0MDg2MDE1MTkxOTQ1MDkyNTA2MDAxNjAwMTYwNDAxYjAzODA4MjExMTU2MTAxNzQ1NzYwMDA4MGZkNWI4MTg2MDE5MTUwODY2MDFmODMwMTEyNjEwMTg4NTc2MDAwODBmZDViODE1MTgxODExMTE1NjEwMTlhNTc2MTAxOWE2MTAwZWE1NjViNjA0MDUxNjAxZjgyMDE2MDFmMTk5MDgxMTY2MDNmMDExNjgxMDE5MDgzODIxMTgxODMxMDE3MTU2MTAxYzI1NzYxMDFjMjYxMDBlYTU2NWI4MTYwNDA1MjgyODE1Mjg5NjAyMDg0ODcwMTAxMTExNTYxMDFkYjU3NjAwMDgwZmQ1YjYxMDFlYzgzNjAyMDgzMDE2MDIwODgwMTYxMDEwMDU2NWI4MDk1NTA1MDUwNTA1MDUwOTI1MDkyNTA5MjU2NWI2MDAxODA2MGEwMWIwMzg0MTY4MTUyODI2MDIwODIwMTUyNjA2MDYwNDA4MjAxNTI2MDAwODI1MTgwNjA2MDg0MDE1MjYxMDIyZTgxNjA4MDg1MDE2MDIwODcwMTYxMDEwMDU2NWI2MDFmMDE2MDFmMTkxNjkxOTA5MTAxNjA4MDAxOTQ5MzUwNTA1MDUwNTY1YjYwMDA2MDIwODI4NDAzMTIxNTYxMDI1NjU3NjAwMDgwZmQ1YjgxNTE4MDE1MTU4MTE0NjEwMjY2NTc2MDAwODBmZDViOTM5MjUwNTA1MDU2ZmU2MDgwNjA0MDUyMzQ4MDE1NjEwMDEwNTc2MDAwODBmZDViNTA2MTBmYmM4MDYxMDAyMDYwMDAzOTYwMDBmM2ZlNjA4MDYwNDA1MjM0ODAxNTYxMDAxMDU3NjAwMDgwZmQ1YjUwNjAwNDM2MTA2MTAwNjc1NzYwMDAzNTYwZTAxYzgwNjM3NmJlNGNlYTExNjEwMDUwNTc4MDYzNzZiZTRjZWExNDYxMDBhNjU3ODA2MzhmMDY4NDMwMTQ2MTAwYjk1NzgwNjM5OGVmMWVkODE0NjEwMGNjNTc2MDAwODBmZDViODA2MzFjNjQ1MzI3MTQ2MTAwNmM1NzgwNjMzZDc4N2I2MzE0NjEwMDkzNTc1YjYwMDA4MGZkNWI2MTAwN2Y2MTAwN2EzNjYwMDQ2MTBhZDQ1NjViNjEwMGRmNTY1YjYwNDA1MTkwMTUxNTgxNTI2MDIwMDE2MDQwNTE4MDkxMDM5MGYzNWI2MTAwN2Y2MTAwYTEzNjYwMDQ2MTBhZDQ1NjViNjEwMjNkNTY1YjYxMDA3ZjYxMDBiNDM2NjAwNDYxMGIzZTU2NWI2MTAzMWU1NjViNjEwMDdmNjEwMGM3MzY2MDA0NjEwYWQ0NTY1YjYxMDhlMTU2NWI2MTAwN2Y2MTAwZGEzNjYwMDQ2MTBhZDQ1NjViNjEwOTZlNTY1YjYwNDA1MTdmNzZiZTRjZWEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgxNTI2MDAwOTAzMDkwNjM3NmJlNGNlYTkwNjEwMTI4OTA4ODkwODg5MDg4OTA4ODkwODg5MDgxOTA2MDA0MDE2MTBiYzM1NjViNjAyMDYwNDA1MTgwODMwMzgxNjAwMDg3NWFmMTkyNTA1MDUwODAxNTYxMDE4MTU3NTA2MDQwODA1MTYwMWYzZDkwODEwMTdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlMDE2ODIwMTkwOTI1MjYxMDE3ZTkxODEwMTkwNjEwYzQ1NTY1YjYwMDE1YjYxMDIzMjU3M2Q4MDgwMTU2MTAxYWY1NzYwNDA1MTkxNTA2MDFmMTk2MDNmM2QwMTE2ODIwMTYwNDA1MjNkODI1MjNkNjAwMDYwMjA4NDAxM2U2MTAxYjQ1NjViNjA2MDkxNTA1YjUwODA1MTYwMDE4MTkwMDM2MTAyMjc1NzgxNjAwMDgxNTE4MTEwNjEwMWQzNTc2MTAxZDM2MTBjNjk1NjViNjAyMDkxMDEwMTUxN2ZmZjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTY3ZjAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxNDkyNTA2MTAyMzU5MTUwNTA1NjViNjAwMDkyNTA1MDUwNjEwMjM1NTY1YjkwNTA1Yjk0OTM1MDUwNTA1MDU2NWI2MDQwNTE3Zjc2YmU0Y2VhMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MTUyNjAwMDkwMzA5MDYzNzZiZTRjZWE5MDYxMDI4NzkwODg5MDg4OTA4ODkwODg5MDYwMDE5MDg5OTA2MDA0MDE2MTBiYzM1NjViNjAyMDYwNDA1MTgwODMwMzgxNjAwMDg3NWFmMTkyNTA1MDUwODAxNTYxMDJlMDU3NTA2MDQwODA1MTYwMWYzZDkwODEwMTdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlMDE2ODIwMTkwOTI1MjYxMDJkZDkxODEwMTkwNjEwYzQ1NTY1YjYwMDE1YjYxMDIzMjU3M2Q4MDgwMTU2MTAzMGU1NzYwNDA1MTkxNTA2MDFmMTk2MDNmM2QwMTE2ODIwMTYwNDA1MjNkODI1MjNkNjAwMDYwMjA4NDAxM2U2MTAzMTM1NjViNjA2MDkxNTA1YjUwNjAwMDkxNTA1MDYxMDIzNTU2NWI2MDAwNzNmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmODcxNjNiNjA2MDgyN2Y2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyODg4ODYxMDM2OTYwMjA4MjYxMGM5ODU2NWI2MTAzNzU5MjhiOTI5MDYxMGNkODU2NWI2MTAzN2U5MTYxMGQwMjU2NWIxNDkwNTA4MDE1NjEwNDg0NTc2MDAwNjA2MDg5ODI4YTYxMDM5OTYwMjA4MjYxMGM5ODU2NWI5MjYxMDNhNjkzOTI5MTkwNjEwY2Q4NTY1YjgxMDE5MDYxMDNiMzkxOTA2MTBlMTg1NjViOTU1MDkwOTI1MDkwNTA4NDE1ODA2MTAzYzQ1NzUwODY1YjE1NjEwNDdkNTc2MDAwODA4MzczZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjE2ODM2MDQwNTE2MTAzZjE5MTkwNjEwZWIyNTY1YjYwMDA2MDQwNTE4MDgzMDM4MTYwMDA4NjVhZjE5MTUwNTAzZDgwNjAwMDgxMTQ2MTA0MmU1NzYwNDA1MTkxNTA2MDFmMTk2MDNmM2QwMTE2ODIwMTYwNDA1MjNkODI1MjNkNjAwMDYwMjA4NDAxM2U2MTA0MzM1NjViNjA2MDkxNTA1YjUwOTE1MDkxNTA4MTYxMDQ3YTU3ODA2MDQwNTE3ZjlkMGQ2ZTJkMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MTUyNjAwNDAxNjEwNDcxOTE5MDYxMGYxODU2NWI2MDQwNTE4MDkxMDM5MGZkNWI1MDUwNWI1MDUwNjEwNGJlNTY1Yjg3ODc4MDgwNjAxZjAxNjAyMDgwOTEwNDAyNjAyMDAxNjA0MDUxOTA4MTAxNjA0MDUyODA5MzkyOTE5MDgxODE1MjYwMjAwMTgzODM4MDgyODQzNzYwMDA5MjAxOTE5MDkxNTI1MDkyOTQ1MDUwNTA1MDViODA4MDYxMDRjYTU3NTA2MDAwODMxMTViMTU2MTA2YmI1NzYwNDA1MTdmMTYyNmJhN2UwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgxNTI3M2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY4YjE2OTA2MzE2MjZiYTdlOTA2MTA1MjM5MDhjOTA4NjkwNjAwNDAxNjEwZjJiNTY1YjYwMjA2MDQwNTE4MDgzMDM4MTg2NWFmYTkyNTA1MDUwODAxNTYxMDU3YTU3NTA2MDQwODA1MTYwMWYzZDkwODEwMTdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlMDE2ODIwMTkwOTI1MjYxMDU3NzkxODEwMTkwNjEwZjQ0NTY1YjYwMDE1YjYxMDYwZjU3M2Q4MDgwMTU2MTA1YTg1NzYwNDA1MTkxNTA2MDFmMTk2MDNmM2QwMTE2ODIwMTYwNDA1MjNkODI1MjNkNjAwMDYwMjA4NDAxM2U2MTA1YWQ1NjViNjA2MDkxNTA1YjUwODUxNTgwMTU2MTA1YmM1NzUwNjAwMDg0MTE1YjE1NjEwNWRiNTc2MTA1ZDA4YjhiOGI4YjhiNjAwMTYxMDMxZTU2NWI5NDUwNTA1MDUwNTA2MTA4ZDc1NjViODA2MDQwNTE3ZjZmMmE5NTk5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MTUyNjAwNDAxNjEwNDcxOTE5MDYxMGYxODU2NWI3ZmZmZmZmZmZmMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MTE2N2YxNjI2YmE3ZTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTQ4MDE1ODE2MTA2NWY1NzUwODYxNTViODAxNTYxMDY2YjU3NTA2MDAwODUxMTViMTU2MTA2OGI1NzYxMDY3ZjhjOGM4YzhjOGM2MDAxNjEwMzFlNTY1Yjk1NTA1MDUwNTA1MDUwNjEwOGQ3NTY1Yjg0MTU4MDE1NjEwNjk2NTc1MDgyNWI4MDE1NjEwNmEwNTc1MDg3MTU1YjE1NjEwNmFmNTc4MDYwMDA1MjYwMDE2MDFmZmQ1Yjk0NTA2MTA4ZDc5MzUwNTA1MDUwNTY1YjYwNDE4NzE0NjEwNzRiNTc2MDQwNTE3ZjA4YzM3OWEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MTUyNjAyMDYwMDQ4MjAxNTI2MDNhNjAyNDgyMDE1MjdmNTM2OTY3NmU2MTc0NzU3MjY1NTY2MTZjNjk2NDYxNzQ2ZjcyMjM3MjY1NjM2Zjc2NjU3MjUzNjk2NzZlNjU3MjYwNDQ4MjAxNTI3ZjNhMjA2OTZlNzY2MTZjNjk2NDIwNzM2OTY3NmU2MTc0NzU3MjY1MjA2YzY1NmU2Nzc0NjgwMDAwMDAwMDAwMDA2MDY0ODIwMTUyNjA4NDAxNjEwNDcxNTY1YjYwMDA2MTA3NWE2MDIwODI4YThjNjEwY2Q4NTY1YjYxMDc2MzkxNjEwZDAyNTY1YjkwNTA2MDAwNjEwNzc1NjA0MDYwMjA4YjhkNjEwY2Q4NTY1YjYxMDc3ZTkxNjEwZDAyNTY1YjkwNTA2MDAwOGE4YTYwNDA4MTgxMTA2MTA3OTU1NzYxMDc5NTYxMGM2OTU2NWI5MTkwOTEwMTM1NjBmODFjOTE1MDUwNjAxYjgxMTQ4MDE1OTA2MTA3YjU1NzUwODA2MGZmMTY2MDFjMTQxNTViMTU2MTA4NDI1NzYwNDA1MTdmMDhjMzc5YTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgxNTI2MDIwNjAwNDgyMDE1MjYwMmQ2MDI0ODIwMTUyN2Y1MzY5Njc2ZTYxNzQ3NTcyNjU1NjYxNmM2OTY0NjE3NDZmNzIzYTIwNjk2ZTc2NjE2YzY5NjQyMDczNjk2NzZlNjA0NDgyMDE1MjdmNjE3NDc1NzI2NTIwNzYyMDc2NjE2Yzc1NjUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwNjQ4MjAxNTI2MDg0MDE2MTA0NzE1NjViNjA0MDgwNTE2MDAwODE1MjYwMjA4MTAxODA4MzUyOGU5MDUyNjBmZjgzMTY5MTgxMDE5MTkwOTE1MjYwNjA4MTAxODQ5MDUyNjA4MDgxMDE4MzkwNTI3M2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY4ZTE2OTA2MDAxOTA2MGEwMDE2MDIwNjA0MDUxNjAyMDgxMDM5MDgwODQwMzkwODU1YWZhMTU4MDE1NjEwOGFkNTczZDYwMDA4MDNlM2Q2MDAwZmQ1YjUwNTA1MDYwMjA2MDQwNTEwMzUxNzNmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmMTYxNDk2NTA1MDUwNTA1MDUwNTA1Yjk2OTU1MDUwNTA1MDUwNTA1NjViNjA0MDUxN2Y3NmJlNGNlYTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODE1MjYwMDA5MDMwOTA2Mzc2YmU0Y2VhOTA2MTA5MmI5MDg4OTA4ODkwODg5MDg4OTA2MDAxOTA4OTkwNjAwNDAxNjEwYmMzNTY1YjYwMjA2MDQwNTE4MDgzMDM4MTYwMDA4NzVhZjExNTgwMTU2MTA5NGE1NzNkNjAwMDgwM2UzZDYwMDBmZDViNTA1MDUwNTA2MDQwNTEzZDYwMWYxOTYwMWY4MjAxMTY4MjAxODA2MDQwNTI1MDgxMDE5MDYxMDIzMjkxOTA2MTBjNDU1NjViNjA0MDUxN2Y3NmJlNGNlYTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODE1MjYwMDA5MDMwOTA2Mzc2YmU0Y2VhOTA2MTA5Yjc5MDg4OTA4ODkwODg5MDg4OTA4ODkwODE5MDYwMDQwMTYxMGJjMzU2NWI2MDIwNjA0MDUxODA4MzAzODE2MDAwODc1YWYxOTI1MDUwNTA4MDE1NjEwYTEwNTc1MDYwNDA4MDUxNjAxZjNkOTA4MTAxN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmUwMTY4MjAxOTA5MjUyNjEwYTBkOTE4MTAxOTA2MTBjNDU1NjViNjAwMTViNjEwMjMyNTczZDgwODAxNTYxMGEzZTU3NjA0MDUxOTE1MDYwMWYxOTYwM2YzZDAxMTY4MjAxNjA0MDUyM2Q4MjUyM2Q2MDAwNjAyMDg0MDEzZTYxMGE0MzU2NWI2MDYwOTE1MDViNTA4MDUxNjAwMTgxOTAwMzYxMGE2MjU3ODE2MDAwODE1MTgxMTA2MTAxZDM1NzYxMDFkMzYxMGM2OTU2NWI4MDgyZmQ1YjczZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjgxMTY4MTE0NjEwYTg4NTc2MDAwODBmZDViNTA1NjViNjAwMDgwODM2MDFmODQwMTEyNjEwYTlkNTc2MDAwODBmZDViNTA4MTM1NjdmZmZmZmZmZmZmZmZmZmZmODExMTE1NjEwYWI1NTc2MDAwODBmZDViNjAyMDgzMDE5MTUwODM2MDIwODI4NTAxMDExMTE1NjEwYWNkNTc2MDAwODBmZDViOTI1MDkyOTA1MDU2NWI2MDAwODA2MDAwODA2MDYwODU4NzAzMTIxNTYxMGFlYTU3NjAwMDgwZmQ1Yjg0MzU2MTBhZjU4MTYxMGE2NjU2NWI5MzUwNjAyMDg1MDEzNTkyNTA2MDQwODUwMTM1NjdmZmZmZmZmZmZmZmZmZmZmODExMTE1NjEwYjE4NTc2MDAwODBmZDViNjEwYjI0ODc4Mjg4MDE2MTBhOGI1NjViOTU5ODk0OTc1MDk1NTA1MDUwNTA1NjViODAxNTE1ODExNDYxMGE4ODU3NjAwMDgwZmQ1YjYwMDA4MDYwMDA4MDYwMDA4MDYwYTA4Nzg5MDMxMjE1NjEwYjU3NTc2MDAwODBmZDViODYzNTYxMGI2MjgxNjEwYTY2NTY1Yjk1NTA2MDIwODcwMTM1OTQ1MDYwNDA4NzAxMzU2N2ZmZmZmZmZmZmZmZmZmZmY4MTExMTU2MTBiODU1NzYwMDA4MGZkNWI2MTBiOTE4OTgyOGEwMTYxMGE4YjU2NWI5MDk1NTA5MzUwNTA2MDYwODcwMTM1NjEwYmE1ODE2MTBiMzA1NjViOTE1MDYwODA4NzAxMzU2MTBiYjU4MTYxMGIzMDU2NWI4MDkxNTA1MDkyOTU1MDkyOTU1MDkyOTU1NjViNzNmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmODcxNjgxNTI4NTYwMjA4MjAxNTI2MGEwNjA0MDgyMDE1MjgzNjBhMDgyMDE1MjgzODU2MGMwODMwMTM3NjAwMDYwYzA4NTgzMDE4MTAxOTE5MDkxNTI5MjE1MTU2MDYwODIwMTUyOTAxNTE1NjA4MDgyMDE1MjYwMWY5MDkyMDE3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZTAxNjkwOTEwMTAxOTM5MjUwNTA1MDU2NWI2MDAwNjAyMDgyODQwMzEyMTU2MTBjNTc1NzYwMDA4MGZkNWI4MTUxNjEwYzYyODE2MTBiMzA1NjViOTM5MjUwNTA1MDU2NWI3ZjRlNDg3YjcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwNTI2MDMyNjAwNDUyNjAyNDYwMDBmZDViODE4MTAzODE4MTExMTU2MTBjZDI1NzdmNGU0ODdiNzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDA1MjYwMTE2MDA0NTI2MDI0NjAwMGZkNWI5MjkxNTA1MDU2NWI2MDAwODA4NTg1MTExNTYxMGNlODU3NjAwMDgwZmQ1YjgzODYxMTE1NjEwY2Y1NTc2MDAwODBmZDViNTA1MDgyMDE5MzkxOTA5MjAzOTE1MDU2NWI4MDM1NjAyMDgzMTAxNTYxMGNkMjU3N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmNjAyMDg0OTAwMzYwMDMxYjFiMTY5MjkxNTA1MDU2NWI3ZjRlNDg3YjcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwNTI2MDQxNjAwNDUyNjAyNDYwMDBmZDViNjAwMDgyNjAxZjgzMDExMjYxMGQ3ZTU3NjAwMDgwZmQ1YjgxMzU2N2ZmZmZmZmZmZmZmZmZmZmY4MDgyMTExNTYxMGQ5OTU3NjEwZDk5NjEwZDNlNTY1YjYwNDA1MTYwMWY4MzAxN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmUwOTA4MTE2NjAzZjAxMTY4MTAxOTA4MjgyMTE4MTgzMTAxNzE1NjEwZGRmNTc2MTBkZGY2MTBkM2U1NjViODE2MDQwNTI4MzgxNTI4NjYwMjA4NTg4MDEwMTExMTU2MTBkZjg1NzYwMDA4MGZkNWI4MzYwMjA4NzAxNjAyMDgzMDEzNzYwMDA2MDIwODU4MzAxMDE1MjgwOTQ1MDUwNTA1MDUwOTI5MTUwNTA1NjViNjAwMDgwNjAwMDYwNjA4NDg2MDMxMjE1NjEwZTJkNTc2MDAwODBmZDViODMzNTYxMGUzODgxNjEwYTY2NTY1YjkyNTA2MDIwODQwMTM1NjdmZmZmZmZmZmZmZmZmZmZmODA4MjExMTU2MTBlNTU1NzYwMDA4MGZkNWI2MTBlNjE4NzgzODgwMTYxMGQ2ZDU2NWI5MzUwNjA0MDg2MDEzNTkxNTA4MDgyMTExNTYxMGU3NzU3NjAwMDgwZmQ1YjUwNjEwZTg0ODY4Mjg3MDE2MTBkNmQ1NjViOTE1MDUwOTI1MDkyNTA5MjU2NWI2MDAwNWI4MzgxMTAxNTYxMGVhOTU3ODE4MTAxNTE4MzgyMDE1MjYwMjAwMTYxMGU5MTU2NWI1MDUwNjAwMDkxMDE1MjU2NWI2MDAwODI1MTYxMGVjNDgxODQ2MDIwODcwMTYxMGU4ZTU2NWI5MTkwOTEwMTkyOTE1MDUwNTY1YjYwMDA4MTUxODA4NDUyNjEwZWU2ODE2MDIwODYwMTYwMjA4NjAxNjEwZThlNTY1YjYwMWYwMTdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlMDE2OTI5MDkyMDE2MDIwMDE5MjkxNTA1MDU2NWI2MDIwODE1MjYwMDA2MTBjNjI2MDIwODMwMTg0NjEwZWNlNTY1YjgyODE1MjYwNDA2MDIwODIwMTUyNjAwMDYxMDIzNTYwNDA4MzAxODQ2MTBlY2U1NjViNjAwMDYwMjA4Mjg0MDMxMjE1NjEwZjU2NTc2MDAwODBmZDViODE1MTdmZmZmZmZmZmYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgxMTY4MTE0NjEwYzYyNTc2MDAwODBmZGZlYTI2NDY5NzA2NjczNTgyMjEyMjAxYTcyYWVkNGIxNWZmYjA1YjY1MDI5OTdhOWJiNjU1OTkyZTA2NTkwYmQyNmIzMzZkZmJiMTUzZDdmZjZmMzRiNjQ3MzZmNmM2MzQzMDAwODEyMDAzMyc7XG5jb25zdCBFSVBfNjQ5Ml9TVUZGSVggPSAnMHg2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyJztcblxuLy8gVE9ETzogVGhpcyBpcyBhIGxlbmd0aCBwYXlsb2FkLCB3ZSBjYW4gbG93ZXIgdGhlIGxvYWQgYnkgZGVwbG95aW5nXG4vLyB0aGUgY29udHJhY3Qgb24gc29tZSBvZiB0aGUgcG9wdWxhciBjaGFpbnMsIGFuZCBjYWxsaW5nIHRoZSBjb250cmFjdFxuLy8gaWYgdGhlIHByb3ZpZGVyIGlzIG9uZSBvZiB0aG9zZSBjaGFpbnNcbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlRUlQNjQ5Mk9mZmNoYWluKHByb3ZpZGVyLCBzaWduZXIsIGhhc2gsIHNpZ25hdHVyZSkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmNhbGwoe1xuICAgICAgZGF0YTogZXRoZXJzLmNvbmNhdChbRUlQXzY0OTJfT0ZGQ0hBSU5fREVQTE9ZX0NPREUsIGV0aGVycy5BYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKS5lbmNvZGUoWydhZGRyZXNzJywgJ2J5dGVzMzInLCAnYnl0ZXMnXSwgW3NpZ25lciwgaGFzaCwgc2lnbmF0dXJlXSldKVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQgPT09ICcweDAxJztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbnZhciB2YWxpZGF0ZUVJUDY0OTIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgRUlQXzY0OTJfT0ZGQ0hBSU5fREVQTE9ZX0NPREU6IEVJUF82NDkyX09GRkNIQUlOX0RFUExPWV9DT0RFLFxuICBFSVBfNjQ5Ml9TVUZGSVg6IEVJUF82NDkyX1NVRkZJWCxcbiAgdmFsaWRhdGVFSVA2NDkyT2ZmY2hhaW46IHZhbGlkYXRlRUlQNjQ5Mk9mZmNoYWluXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBzdGF0ZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgd2FsbGV0LlxuICovXG5cbi8qKlxuICogVGhlIE9uQ2hhaW5SZWFkZXIgY2xhc3MgZmV0Y2hlcyBvbi1jaGFpbiBkYXRhIGZyb20gYSB3YWxsZXQuXG4gKiBJdCBpcyB1c2VkIHRvIHVuZGVyc3RhbmQgdGhlIFwicmVhbFwiIHN0YXRlIG9mIHRoZSB3YWxsZXQgY29udHJhY3Qgb24tY2hhaW4uXG4gKi9cbmNsYXNzIE9uQ2hhaW5SZWFkZXIge1xuICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAvLyBTaW1wbGUgY2FjaGUgdG8gYXZvaWQgcmUtZmV0Y2hpbmcgdGhlIHNhbWUgZGF0YVxuICAgIHRoaXMuaXNEZXBsb3llZENhY2hlID0gbmV3IFNldCgpO1xuICB9XG4gIG1vZHVsZShhZGRyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBldGhlcnMuQ29udHJhY3QoYWRkcmVzcywgWy4uLndhbGxldENvbnRyYWN0cy5tYWluTW9kdWxlVXBncmFkYWJsZS5hYmksIC4uLndhbGxldENvbnRyYWN0cy5tYWluTW9kdWxlLmFiaSwgLi4ud2FsbGV0Q29udHJhY3RzLmVyYzEyNzEuYWJpXSwgdGhpcy5wcm92aWRlcik7XG4gIH1cbiAgYXN5bmMgaXNEZXBsb3llZCh3YWxsZXQpIHtcbiAgICAvLyBUaGlzIGlzIHNhZmUgdG8gY2FjaGUgYmVjYXVzZSB0aGUgd2FsbGV0IGNhbm5vdCBiZSB1bmRlcGxveWVkIG9uY2UgZGVwbG95ZWRcbiAgICBpZiAodGhpcy5pc0RlcGxveWVkQ2FjaGUuaGFzKHdhbGxldCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRDb2RlKHdhbGxldCkudGhlbihjID0+IGV0aGVycy5nZXRCeXRlcyhjKSk7XG4gICAgY29uc3QgaXNEZXBsb3llZCA9IGNvZGUubGVuZ3RoICE9PSAwO1xuICAgIGlmIChpc0RlcGxveWVkKSB7XG4gICAgICB0aGlzLmlzRGVwbG95ZWRDYWNoZS5hZGQod2FsbGV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVwbG95ZWQ7XG4gIH1cbiAgYXN5bmMgaW1wbGVtZW50YXRpb24od2FsbGV0KSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBldGhlcnMuQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCkuZW5jb2RlKFsnYWRkcmVzcyddLCBbd2FsbGV0XSk7XG4gICAgY29uc3QgdmFsID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRTdG9yYWdlKHdhbGxldCwgcG9zaXRpb24pLnRoZW4oYyA9PiBldGhlcnMuZ2V0Qnl0ZXMoYykpO1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAyMCkge1xuICAgICAgcmV0dXJuIGV0aGVycy5nZXRBZGRyZXNzKGV0aGVycy5oZXhsaWZ5KHZhbCkpO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgIHJldHVybiBldGhlcnMuQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCkuZGVjb2RlKFsnYWRkcmVzcyddLCB2YWwpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGFzeW5jIGltYWdlSGFzaCh3YWxsZXQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaW1hZ2VIYXNoID0gYXdhaXQgdGhpcy5tb2R1bGUod2FsbGV0KS5pbWFnZUhhc2goKTtcbiAgICAgIHJldHVybiBpbWFnZUhhc2g7XG4gICAgfSBjYXRjaCAoX3VudXNlZCkge31cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGFzeW5jIG5vbmNlKHdhbGxldCwgc3BhY2UgPSAwKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgdGhpcy5tb2R1bGUod2FsbGV0KS5yZWFkTm9uY2Uoc3BhY2UpO1xuICAgICAgcmV0dXJuIG5vbmNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghKGF3YWl0IHRoaXMuaXNEZXBsb3llZCh3YWxsZXQpKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgLy8gV2UgdXNlIHRoZSBFSVAtNjQ5MiB2YWxpZGF0b3IgY29udHJhY3QgdG8gY2hlY2sgdGhlIHNpZ25hdHVyZVxuICAvLyB0aGlzIG1lYW5zIHRoYXQgaWYgdGhlIHdhbGxldCBpcyBub3QgZGVwbG95ZWQsIHRoZW4gdGhlIHNpZ25hdHVyZVxuICAvLyBtdXN0IGJlIHByZWZpeGVkIHdpdGggYSB0cmFuc2FjdGlvbiB0aGF0IGRlcGxveXMgdGhlIHdhbGxldFxuICBhc3luYyBpc1ZhbGlkU2lnbmF0dXJlKHdhbGxldCwgZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVFSVA2NDkyT2ZmY2hhaW4odGhpcy5wcm92aWRlciwgd2FsbGV0LCBkaWdlc3QsIHNpZ25hdHVyZSk7XG4gIH1cbn1cblxudmFyIHJlYWRlciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBPbkNoYWluUmVhZGVyOiBPbkNoYWluUmVhZGVyXG59KTtcblxuLyoqXG4gKiBSZXF1ZXN0IG1ldGFkYXRhLCB1c2VkIGJ5IHRoZSB3YWxsZXQgdG8gcGFzcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRocm91Z2ggdGhlIG9yY2hlc3RyYXRvci5cbiAqL1xuXG5mdW5jdGlvbiBpc1dhbGxldFNpZ25SZXF1ZXN0TWV0YWRhdGEob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLmFkZHJlc3MgJiYgb2JqLmRpZ2VzdCAmJiBvYmouY2hhaW5JZCAhPT0gdW5kZWZpbmVkICYmIG9iai5jb25maWc7XG59XG5cbi8qKlxuICogUmVxdWVzdCBtZXRhZGF0YSwgdXNlZCBieSB0aGUgd2FsbGV0IHRvIHBhc3MgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0aHJvdWdoIHRoZSBvcmNoZXN0cmF0b3IuXG4gKi9cblxudmFyIGluZGV4JDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgY29uZmlnOiBjb25maWcsXG4gIHNpZ25hdHVyZTogc2lnbmF0dXJlJDIsXG4gIGNvbnRleHQ6IGNvbnRleHQsXG4gIHNpZ25lcjogc2lnbmVyLFxuICBFSVAxMjcxOiB2YWxpZGF0ZUVJUDEyNzEsXG4gIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgcmVhZGVyOiByZWFkZXIsXG4gIEVJUDY0OTI6IHZhbGlkYXRlRUlQNjQ5MixcbiAgaXNXYWxsZXRTaWduUmVxdWVzdE1ldGFkYXRhOiBpc1dhbGxldFNpZ25SZXF1ZXN0TWV0YWRhdGFcbn0pO1xuXG5jb25zdCBBTExfQ09ERVJTID0gW3tcbiAgY29uZmlnOiBDb25maWdDb2RlciQxLFxuICBzaWduYXR1cmU6IFNpZ25hdHVyZUNvZGVyJDFcbn0sIHtcbiAgY29uZmlnOiBDb25maWdDb2RlcixcbiAgc2lnbmF0dXJlOiBTaWduYXR1cmVDb2RlclxufV07XG5mdW5jdGlvbiBjb2RlckZvcih2ZXJzaW9uKSB7XG4gIGNvbnN0IGluZGV4ID0gdmVyc2lvbiAtIDE7XG4gIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gQUxMX0NPREVSUy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvZGVyIGZvciB2ZXJzaW9uOiAke3ZlcnNpb259YCk7XG4gIH1cbiAgcmV0dXJuIEFMTF9DT0RFUlNbaW5kZXhdO1xufVxuXG4vKipcbiAqICBTYW1lIGFzIGBjb2RlckZvcmAgYnV0IHJldHVybnMgYGdlbmVyaWNgIGNvZGVycyB3aXRob3V0IHZlcnNpb25lZCB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJpY0NvZGVyRm9yKHZlcnNpb24pIHtcbiAgcmV0dXJuIGNvZGVyRm9yKHZlcnNpb24pO1xufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQUxMX0NPREVSUzogQUxMX0NPREVSUyxcbiAgY29kZXJGb3I6IGNvZGVyRm9yLFxuICBnZW5lcmljQ29kZXJGb3I6IGdlbmVyaWNDb2RlckZvclxufSk7XG5cbmNvbnN0IFZFUlNJT04gPSAnMi4yLjEzJztcblxuY29uc3QgYWxsVmVyc2lvbnMgPSBbdjEsIHYyXTtcblxuZXhwb3J0IHsgVkVSU0lPTiwgYWxsVmVyc2lvbnMsIGluZGV4JDEgYXMgY29tbW9ucywgaW5kZXggYXMgdW5pdmVyc2FsLCB2MSwgdjIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/.pnpm/@0xsequence+core@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/core/dist/0xsequence-core.esm.js\n");

/***/ })

};
;