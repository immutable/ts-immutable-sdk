"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sns-validator@0.3.5";
exports.ids = ["vendor-chunks/sns-validator@0.3.5"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/.pnpm/sns-validator@0.3.5/node_modules/sns-validator/index.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/sns-validator@0.3.5/node_modules/sns-validator/index.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar url = __webpack_require__(/*! url */ \"url\"),\n    https = __webpack_require__(/*! https */ \"https\"),\n    crypto = __webpack_require__(/*! crypto */ \"crypto\"),\n    defaultEncoding = 'utf8',\n    defaultHostPattern = /^sns\\.[a-zA-Z0-9\\-]{3,}\\.amazonaws\\.com(\\.cn)?$/,\n    certCache = {},\n    subscriptionControlKeys = ['SubscribeURL', 'Token'],\n    subscriptionControlMessageTypes = [\n        'SubscriptionConfirmation',\n        'UnsubscribeConfirmation'\n    ],\n    requiredKeys = [\n        'Message',\n        'MessageId',\n        'Timestamp',\n        'TopicArn',\n        'Type',\n        'Signature',\n        'SigningCertURL',\n        'SignatureVersion'\n    ],\n    signableKeysForNotification = [\n        'Message',\n        'MessageId',\n        'Subject',\n        'SubscribeURL',\n        'Timestamp',\n        'TopicArn',\n        'Type'\n    ],\n    signableKeysForSubscription = [\n        'Message',\n        'MessageId',\n        'Subject',\n        'SubscribeURL',\n        'Timestamp',\n        'Token',\n        'TopicArn',\n        'Type'\n    ],\n    lambdaMessageKeys = {\n        'SigningCertUrl': 'SigningCertURL',\n        'UnsubscribeUrl': 'UnsubscribeURL'\n    };\n\nvar hashHasKeys = function (hash, keys) {\n    for (var i = 0; i < keys.length; i++) {\n        if (!(keys[i] in hash)) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\nvar indexOf = function (array, value) {\n    for (var i = 0; i < array.length; i++) {\n        if (value === array[i]) {\n            return i;\n        }\n    }\n\n    return -1;\n};\n\nfunction convertLambdaMessage(message) {\n    for (var key in lambdaMessageKeys) {\n        if (key in message) {\n            message[lambdaMessageKeys[key]] = message[key];\n        }\n    }\n\n    if ('Subject' in message && message.Subject === null) {\n        delete message.Subject;\n    }\n\n    return message;\n}\n\nvar validateMessageStructure = function (message) {\n    var valid = hashHasKeys(message, requiredKeys);\n\n    if (indexOf(subscriptionControlMessageTypes, message['Type']) > -1) {\n        valid = valid && hashHasKeys(message, subscriptionControlKeys);\n    }\n\n    return valid;\n};\n\nvar validateUrl = function (urlToValidate, hostPattern) {\n    var parsed = url.parse(urlToValidate);\n\n    return parsed.protocol === 'https:'\n        && parsed.path.substr(-4) === '.pem'\n        && hostPattern.test(parsed.host);\n};\n\nvar getCertificate = function (certUrl, cb) {\n    if (certCache.hasOwnProperty(certUrl)) {\n        cb(null, certCache[certUrl]);\n        return;\n    }\n\n    https.get(certUrl, function (res) {\n        var chunks = [];\n\n        if(res.statusCode !== 200){\n            return cb(new Error('Certificate could not be retrieved'));\n        }\n\n        res\n            .on('data', function (data) {\n                chunks.push(data.toString());\n            })\n            .on('end', function () {\n                certCache[certUrl] = chunks.join('');\n                cb(null, certCache[certUrl]);\n            });\n    }).on('error', cb)\n};\n\nvar validateSignature = function (message, cb, encoding) {\n    var signatureVersion = message['SignatureVersion'];\n    if (signatureVersion !== '1' && signatureVersion !== '2') {\n        cb(new Error('The signature version '\n            + signatureVersion + ' is not supported.'));\n        return;\n    }\n\n    var signableKeys = [];\n    if (message.Type === 'SubscriptionConfirmation') {\n        signableKeys = signableKeysForSubscription.slice(0);\n    } else {\n        signableKeys = signableKeysForNotification.slice(0);\n    }\n\n    var verifier = (signatureVersion === '1') ? crypto.createVerify('RSA-SHA1') : crypto.createVerify('RSA-SHA256');\n    for (var i = 0; i < signableKeys.length; i++) {\n        if (signableKeys[i] in message) {\n            verifier.update(signableKeys[i] + \"\\n\"\n                + message[signableKeys[i]] + \"\\n\", encoding);\n        }\n    }\n\n    getCertificate(message['SigningCertURL'], function (err, certificate) {\n        if (err) {\n            cb(err);\n            return;\n        }\n        try {\n            if (verifier.verify(certificate, message['Signature'], 'base64')) {\n                cb(null, message);\n            } else {\n                cb(new Error('The message signature is invalid.'));\n            }\n        } catch (e) {\n            cb(e);\n        }\n    });\n};\n\n/**\n * A validator for inbound HTTP(S) SNS messages.\n *\n * @constructor\n * @param {RegExp} [hostPattern=/^sns\\.[a-zA-Z0-9\\-]{3,}\\.amazonaws\\.com(\\.cn)?$/] - A pattern used to validate that a message's certificate originates from a trusted domain.\n * @param {String} [encoding='utf8'] - The encoding of the messages being signed.\n */\nfunction MessageValidator(hostPattern, encoding) {\n    this.hostPattern = hostPattern || defaultHostPattern;\n    this.encoding = encoding || defaultEncoding;\n}\n\n/**\n * A callback to be called by the validator once it has verified a message's\n * signature.\n *\n * @callback validationCallback\n * @param {Error} error - Any error encountered attempting to validate a\n *                          message's signature.\n * @param {Object} message - The validated inbound SNS message.\n */\n\n/**\n * Validates a message's signature and passes it to the provided callback.\n *\n * @param {Object} hash\n * @param {validationCallback} cb\n */\nMessageValidator.prototype.validate = function (hash, cb) {\n    if (typeof hash === 'string') {\n        try {\n            hash = JSON.parse(hash);\n        } catch (err) {\n            cb(err);\n            return;\n        }\n    }\n\n    hash = convertLambdaMessage(hash);\n\n    if (!validateMessageStructure(hash)) {\n        cb(new Error('Message missing required keys.'));\n        return;\n    }\n\n    if (!validateUrl(hash['SigningCertURL'], this.hostPattern)) {\n        cb(new Error('The certificate is located on an invalid domain.'));\n        return;\n    }\n\n    validateSignature(hash, cb, this.encoding);\n};\n\nmodule.exports = MessageValidator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Nucy12YWxpZGF0b3JAMC4zLjUvbm9kZV9tb2R1bGVzL3Nucy12YWxpZGF0b3IvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3ZCLFlBQVksbUJBQU8sQ0FBQyxvQkFBTztBQUMzQixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0I7QUFDQSw4Q0FBOEMsR0FBRztBQUNqRCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVEsa0NBQWtDLEdBQUc7QUFDeEQsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGV4YW1wbGVzL2xvZ2luLXdpdGgtcGFzc3BvcnQtc2lsZW50Ly4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zbnMtdmFsaWRhdG9yQDAuMy41L25vZGVfbW9kdWxlcy9zbnMtdmFsaWRhdG9yL2luZGV4LmpzPzhmOTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKSxcbiAgICBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyksXG4gICAgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyksXG4gICAgZGVmYXVsdEVuY29kaW5nID0gJ3V0ZjgnLFxuICAgIGRlZmF1bHRIb3N0UGF0dGVybiA9IC9ec25zXFwuW2EtekEtWjAtOVxcLV17Myx9XFwuYW1hem9uYXdzXFwuY29tKFxcLmNuKT8kLyxcbiAgICBjZXJ0Q2FjaGUgPSB7fSxcbiAgICBzdWJzY3JpcHRpb25Db250cm9sS2V5cyA9IFsnU3Vic2NyaWJlVVJMJywgJ1Rva2VuJ10sXG4gICAgc3Vic2NyaXB0aW9uQ29udHJvbE1lc3NhZ2VUeXBlcyA9IFtcbiAgICAgICAgJ1N1YnNjcmlwdGlvbkNvbmZpcm1hdGlvbicsXG4gICAgICAgICdVbnN1YnNjcmliZUNvbmZpcm1hdGlvbidcbiAgICBdLFxuICAgIHJlcXVpcmVkS2V5cyA9IFtcbiAgICAgICAgJ01lc3NhZ2UnLFxuICAgICAgICAnTWVzc2FnZUlkJyxcbiAgICAgICAgJ1RpbWVzdGFtcCcsXG4gICAgICAgICdUb3BpY0FybicsXG4gICAgICAgICdUeXBlJyxcbiAgICAgICAgJ1NpZ25hdHVyZScsXG4gICAgICAgICdTaWduaW5nQ2VydFVSTCcsXG4gICAgICAgICdTaWduYXR1cmVWZXJzaW9uJ1xuICAgIF0sXG4gICAgc2lnbmFibGVLZXlzRm9yTm90aWZpY2F0aW9uID0gW1xuICAgICAgICAnTWVzc2FnZScsXG4gICAgICAgICdNZXNzYWdlSWQnLFxuICAgICAgICAnU3ViamVjdCcsXG4gICAgICAgICdTdWJzY3JpYmVVUkwnLFxuICAgICAgICAnVGltZXN0YW1wJyxcbiAgICAgICAgJ1RvcGljQXJuJyxcbiAgICAgICAgJ1R5cGUnXG4gICAgXSxcbiAgICBzaWduYWJsZUtleXNGb3JTdWJzY3JpcHRpb24gPSBbXG4gICAgICAgICdNZXNzYWdlJyxcbiAgICAgICAgJ01lc3NhZ2VJZCcsXG4gICAgICAgICdTdWJqZWN0JyxcbiAgICAgICAgJ1N1YnNjcmliZVVSTCcsXG4gICAgICAgICdUaW1lc3RhbXAnLFxuICAgICAgICAnVG9rZW4nLFxuICAgICAgICAnVG9waWNBcm4nLFxuICAgICAgICAnVHlwZSdcbiAgICBdLFxuICAgIGxhbWJkYU1lc3NhZ2VLZXlzID0ge1xuICAgICAgICAnU2lnbmluZ0NlcnRVcmwnOiAnU2lnbmluZ0NlcnRVUkwnLFxuICAgICAgICAnVW5zdWJzY3JpYmVVcmwnOiAnVW5zdWJzY3JpYmVVUkwnXG4gICAgfTtcblxudmFyIGhhc2hIYXNLZXlzID0gZnVuY3Rpb24gKGhhc2gsIGtleXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCEoa2V5c1tpXSBpbiBoYXNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgdmFsdWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gYXJyYXlbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufTtcblxuZnVuY3Rpb24gY29udmVydExhbWJkYU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGZvciAodmFyIGtleSBpbiBsYW1iZGFNZXNzYWdlS2V5cykge1xuICAgICAgICBpZiAoa2V5IGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VbbGFtYmRhTWVzc2FnZUtleXNba2V5XV0gPSBtZXNzYWdlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ1N1YmplY3QnIGluIG1lc3NhZ2UgJiYgbWVzc2FnZS5TdWJqZWN0ID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBtZXNzYWdlLlN1YmplY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG5cbnZhciB2YWxpZGF0ZU1lc3NhZ2VTdHJ1Y3R1cmUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHZhciB2YWxpZCA9IGhhc2hIYXNLZXlzKG1lc3NhZ2UsIHJlcXVpcmVkS2V5cyk7XG5cbiAgICBpZiAoaW5kZXhPZihzdWJzY3JpcHRpb25Db250cm9sTWVzc2FnZVR5cGVzLCBtZXNzYWdlWydUeXBlJ10pID4gLTEpIHtcbiAgICAgICAgdmFsaWQgPSB2YWxpZCAmJiBoYXNoSGFzS2V5cyhtZXNzYWdlLCBzdWJzY3JpcHRpb25Db250cm9sS2V5cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkO1xufTtcblxudmFyIHZhbGlkYXRlVXJsID0gZnVuY3Rpb24gKHVybFRvVmFsaWRhdGUsIGhvc3RQYXR0ZXJuKSB7XG4gICAgdmFyIHBhcnNlZCA9IHVybC5wYXJzZSh1cmxUb1ZhbGlkYXRlKTtcblxuICAgIHJldHVybiBwYXJzZWQucHJvdG9jb2wgPT09ICdodHRwczonXG4gICAgICAgICYmIHBhcnNlZC5wYXRoLnN1YnN0cigtNCkgPT09ICcucGVtJ1xuICAgICAgICAmJiBob3N0UGF0dGVybi50ZXN0KHBhcnNlZC5ob3N0KTtcbn07XG5cbnZhciBnZXRDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uIChjZXJ0VXJsLCBjYikge1xuICAgIGlmIChjZXJ0Q2FjaGUuaGFzT3duUHJvcGVydHkoY2VydFVybCkpIHtcbiAgICAgICAgY2IobnVsbCwgY2VydENhY2hlW2NlcnRVcmxdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGh0dHBzLmdldChjZXJ0VXJsLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHZhciBjaHVua3MgPSBbXTtcblxuICAgICAgICBpZihyZXMuc3RhdHVzQ29kZSAhPT0gMjAwKXtcbiAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0NlcnRpZmljYXRlIGNvdWxkIG5vdCBiZSByZXRyaWV2ZWQnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNcbiAgICAgICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goZGF0YS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjZXJ0Q2FjaGVbY2VydFVybF0gPSBjaHVua3Muam9pbignJyk7XG4gICAgICAgICAgICAgICAgY2IobnVsbCwgY2VydENhY2hlW2NlcnRVcmxdKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0pLm9uKCdlcnJvcicsIGNiKVxufTtcblxudmFyIHZhbGlkYXRlU2lnbmF0dXJlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGNiLCBlbmNvZGluZykge1xuICAgIHZhciBzaWduYXR1cmVWZXJzaW9uID0gbWVzc2FnZVsnU2lnbmF0dXJlVmVyc2lvbiddO1xuICAgIGlmIChzaWduYXR1cmVWZXJzaW9uICE9PSAnMScgJiYgc2lnbmF0dXJlVmVyc2lvbiAhPT0gJzInKSB7XG4gICAgICAgIGNiKG5ldyBFcnJvcignVGhlIHNpZ25hdHVyZSB2ZXJzaW9uICdcbiAgICAgICAgICAgICsgc2lnbmF0dXJlVmVyc2lvbiArICcgaXMgbm90IHN1cHBvcnRlZC4nKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2lnbmFibGVLZXlzID0gW107XG4gICAgaWYgKG1lc3NhZ2UuVHlwZSA9PT0gJ1N1YnNjcmlwdGlvbkNvbmZpcm1hdGlvbicpIHtcbiAgICAgICAgc2lnbmFibGVLZXlzID0gc2lnbmFibGVLZXlzRm9yU3Vic2NyaXB0aW9uLnNsaWNlKDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZ25hYmxlS2V5cyA9IHNpZ25hYmxlS2V5c0Zvck5vdGlmaWNhdGlvbi5zbGljZSgwKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyaWZpZXIgPSAoc2lnbmF0dXJlVmVyc2lvbiA9PT0gJzEnKSA/IGNyeXB0by5jcmVhdGVWZXJpZnkoJ1JTQS1TSEExJykgOiBjcnlwdG8uY3JlYXRlVmVyaWZ5KCdSU0EtU0hBMjU2Jyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduYWJsZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNpZ25hYmxlS2V5c1tpXSBpbiBtZXNzYWdlKSB7XG4gICAgICAgICAgICB2ZXJpZmllci51cGRhdGUoc2lnbmFibGVLZXlzW2ldICsgXCJcXG5cIlxuICAgICAgICAgICAgICAgICsgbWVzc2FnZVtzaWduYWJsZUtleXNbaV1dICsgXCJcXG5cIiwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q2VydGlmaWNhdGUobWVzc2FnZVsnU2lnbmluZ0NlcnRVUkwnXSwgZnVuY3Rpb24gKGVyciwgY2VydGlmaWNhdGUpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHZlcmlmaWVyLnZlcmlmeShjZXJ0aWZpY2F0ZSwgbWVzc2FnZVsnU2lnbmF0dXJlJ10sICdiYXNlNjQnKSkge1xuICAgICAgICAgICAgICAgIGNiKG51bGwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYihuZXcgRXJyb3IoJ1RoZSBtZXNzYWdlIHNpZ25hdHVyZSBpcyBpbnZhbGlkLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY2IoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQSB2YWxpZGF0b3IgZm9yIGluYm91bmQgSFRUUChTKSBTTlMgbWVzc2FnZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW2hvc3RQYXR0ZXJuPS9ec25zXFwuW2EtekEtWjAtOVxcLV17Myx9XFwuYW1hem9uYXdzXFwuY29tKFxcLmNuKT8kL10gLSBBIHBhdHRlcm4gdXNlZCB0byB2YWxpZGF0ZSB0aGF0IGEgbWVzc2FnZSdzIGNlcnRpZmljYXRlIG9yaWdpbmF0ZXMgZnJvbSBhIHRydXN0ZWQgZG9tYWluLlxuICogQHBhcmFtIHtTdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIC0gVGhlIGVuY29kaW5nIG9mIHRoZSBtZXNzYWdlcyBiZWluZyBzaWduZWQuXG4gKi9cbmZ1bmN0aW9uIE1lc3NhZ2VWYWxpZGF0b3IoaG9zdFBhdHRlcm4sIGVuY29kaW5nKSB7XG4gICAgdGhpcy5ob3N0UGF0dGVybiA9IGhvc3RQYXR0ZXJuIHx8IGRlZmF1bHRIb3N0UGF0dGVybjtcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jb2RpbmcgfHwgZGVmYXVsdEVuY29kaW5nO1xufVxuXG4vKipcbiAqIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGJ5IHRoZSB2YWxpZGF0b3Igb25jZSBpdCBoYXMgdmVyaWZpZWQgYSBtZXNzYWdlJ3NcbiAqIHNpZ25hdHVyZS5cbiAqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGlvbkNhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciAtIEFueSBlcnJvciBlbmNvdW50ZXJlZCBhdHRlbXB0aW5nIHRvIHZhbGlkYXRlIGFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlJ3Mgc2lnbmF0dXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2UgLSBUaGUgdmFsaWRhdGVkIGluYm91bmQgU05TIG1lc3NhZ2UuXG4gKi9cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBtZXNzYWdlJ3Mgc2lnbmF0dXJlIGFuZCBwYXNzZXMgaXQgdG8gdGhlIHByb3ZpZGVkIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoXG4gKiBAcGFyYW0ge3ZhbGlkYXRpb25DYWxsYmFja30gY2JcbiAqL1xuTWVzc2FnZVZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoaGFzaCwgY2IpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoYXNoID0gSlNPTi5wYXJzZShoYXNoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzaCA9IGNvbnZlcnRMYW1iZGFNZXNzYWdlKGhhc2gpO1xuXG4gICAgaWYgKCF2YWxpZGF0ZU1lc3NhZ2VTdHJ1Y3R1cmUoaGFzaCkpIHtcbiAgICAgICAgY2IobmV3IEVycm9yKCdNZXNzYWdlIG1pc3NpbmcgcmVxdWlyZWQga2V5cy4nKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXZhbGlkYXRlVXJsKGhhc2hbJ1NpZ25pbmdDZXJ0VVJMJ10sIHRoaXMuaG9zdFBhdHRlcm4pKSB7XG4gICAgICAgIGNiKG5ldyBFcnJvcignVGhlIGNlcnRpZmljYXRlIGlzIGxvY2F0ZWQgb24gYW4gaW52YWxpZCBkb21haW4uJykpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFsaWRhdGVTaWduYXR1cmUoaGFzaCwgY2IsIHRoaXMuZW5jb2RpbmcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlVmFsaWRhdG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/.pnpm/sns-validator@0.3.5/node_modules/sns-validator/index.js\n");

/***/ })

};
;