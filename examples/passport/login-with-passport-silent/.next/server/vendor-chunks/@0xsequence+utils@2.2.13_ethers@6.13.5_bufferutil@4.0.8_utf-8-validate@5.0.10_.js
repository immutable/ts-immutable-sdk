"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@0xsequence+utils@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_";
exports.ids = ["vendor-chunks/@0xsequence+utils@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/.pnpm/@0xsequence+utils@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/utils/dist/0xsequence-utils.esm.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@0xsequence+utils@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/utils/dist/0xsequence-utils.esm.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   MAX_UINT_256: () => (/* binding */ MAX_UINT_256),\n/* harmony export */   MerkleTreeGenerator: () => (/* binding */ MerkleTreeGenerator),\n/* harmony export */   PromiseCache: () => (/* binding */ PromiseCache),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64DecodeObject: () => (/* binding */ base64DecodeObject),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64EncodeObject: () => (/* binding */ base64EncodeObject),\n/* harmony export */   bigintReplacer: () => (/* binding */ bigintReplacer),\n/* harmony export */   bigintReviver: () => (/* binding */ bigintReviver),\n/* harmony export */   configureLogger: () => (/* binding */ configureLogger),\n/* harmony export */   defineProperties: () => (/* binding */ defineProperties),\n/* harmony export */   encodeMessageDigest: () => (/* binding */ encodeMessageDigest),\n/* harmony export */   encodeTypedDataDigest: () => (/* binding */ encodeTypedDataDigest),\n/* harmony export */   encodeTypedDataHash: () => (/* binding */ encodeTypedDataHash),\n/* harmony export */   extractProjectIdFromAccessKey: () => (/* binding */ extractProjectIdFromAccessKey),\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatUnits: () => (/* binding */ formatUnits),\n/* harmony export */   getFetchRequest: () => (/* binding */ getFetchRequest),\n/* harmony export */   getRandomInt: () => (/* binding */ getRandomInt),\n/* harmony export */   getSaleItemsLeaf: () => (/* binding */ getSaleItemsLeaf),\n/* harmony export */   isBigNumberish: () => (/* binding */ isBigNumberish),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   jwtDecodeClaims: () => (/* binding */ jwtDecodeClaims),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   packMessageData: () => (/* binding */ packMessageData),\n/* harmony export */   parseEther: () => (/* binding */ parseEther),\n/* harmony export */   parseUnits: () => (/* binding */ parseUnits),\n/* harmony export */   promisify: () => (/* binding */ promisify),\n/* harmony export */   queryStringFromObject: () => (/* binding */ queryStringFromObject),\n/* harmony export */   queryStringToObject: () => (/* binding */ queryStringToObject),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties),\n/* harmony export */   sanitizeAlphanumeric: () => (/* binding */ sanitizeAlphanumeric),\n/* harmony export */   sanitizeHost: () => (/* binding */ sanitizeHost),\n/* harmony export */   sanitizeNumberString: () => (/* binding */ sanitizeNumberString),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   subDigestOf: () => (/* binding */ subDigestOf),\n/* harmony export */   toHexString: () => (/* binding */ toHexString),\n/* harmony export */   urlClean: () => (/* binding */ urlClean)\n/* harmony export */ });\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-base64 */ \"(ssr)/../../../node_modules/.pnpm/js-base64@3.7.7/node_modules/js-base64/base64.mjs\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/solidity.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/typed-data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/ethers.js\");\n\n\n\nconst extractProjectIdFromAccessKey = accessKey => {\n  // Convert URL-safe base64 string to standard base64 string\n  const base64String = accessKey.replace(/-/g, '+').replace(/_/g, '/');\n  // Decode the base64 string to a binary string\n  const binaryString = atob(base64String);\n\n  // Convert the binary string to a byte array (Uint8Array)\n  const byteArray = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    byteArray[i] = binaryString.charCodeAt(i);\n  }\n  if (byteArray[0] !== 1) {\n    throw new Error('UnsupportedVersion');\n  }\n\n  // Extract the project ID from bytes 2 to 9 (8 bytes)\n  const projectIdBytes = byteArray.slice(1, 9);\n  const projectId = projectIdBytes[7] | projectIdBytes[6] << 8 | projectIdBytes[5] << 16 | projectIdBytes[4] << 24 | projectIdBytes[3] << 32 | projectIdBytes[2] << 40 | projectIdBytes[1] << 48 | projectIdBytes[0] << 56;\n  return projectId;\n};\n\nconst MAX_UINT_256 = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n\n// ethers implement this method but doesn't exports it\nconst isBigNumberish = value => {\n  return value != null && (typeof value === 'number' && value % 1 === 0 || typeof value === 'string' && !!value.match(/^-?[0-9]+$/) || ethers__WEBPACK_IMPORTED_MODULE_0__.isHexString(value) || typeof value === 'bigint');\n};\n\n// Even length zero-padded hex string with 0x prefix\nconst toHexString = value => {\n  const result = value.toString(16);\n  return `${result.length % 2 === 0 ? '0x' : '0x0'}${result}`;\n};\nconst parseUnits = (value, decimals = 18) => {\n  let [integer, fraction = '0'] = value.split('.');\n  const negative = integer.startsWith('-');\n  if (negative) {\n    integer = integer.slice(1);\n  }\n\n  // trim trailing zeros.\n  fraction = fraction.replace(/(0+)$/, '');\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    integer = `${Math.round(Number(`${integer}.${fraction}`))}`;\n    fraction = '';\n  } else if (fraction.length > decimals) {\n    const [left, unit, right] = [fraction.slice(0, decimals - 1), fraction.slice(decimals - 1, decimals), fraction.slice(decimals)];\n    const rounded = Math.round(Number(`${unit}.${right}`));\n    if (rounded > 9) {\n      fraction = `${BigInt(left) + 1n}0`.padStart(left.length + 1, '0');\n    } else {\n      fraction = `${left}${rounded}`;\n    }\n    if (fraction.length > decimals) {\n      fraction = fraction.slice(1);\n      integer = `${BigInt(integer) + 1n}`;\n    }\n    fraction = fraction.slice(0, decimals);\n  } else {\n    fraction = fraction.padEnd(decimals, '0');\n  }\n  return BigInt(`${negative ? '-' : ''}${integer}${fraction}`);\n};\nconst parseEther = value => parseUnits(value, 18);\nconst formatUnits = (value, decimals = 18) => {\n  let display = value.toString();\n  const negative = display.startsWith('-');\n  if (negative) {\n    display = display.slice(1);\n  }\n  display = display.padStart(decimals, '0');\n  const integer = display.slice(0, display.length - decimals);\n  let fraction = display.slice(display.length - decimals);\n  fraction = fraction.replace(/(0+)$/, '');\n  return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;\n};\nconst formatEther = value => formatUnits(value, 18);\n\n// JSON.stringify doesn't handle BigInts, so we need to replace them with objects\nconst bigintReplacer = (key, value) => {\n  if (typeof value === 'bigint') {\n    return {\n      $bigint: value.toString()\n    };\n  }\n  return value;\n};\n\n// JSON.parse will need to convert our serialized bigints back into BigInt\nconst bigintReviver = (key, value) => {\n  if (value !== null && typeof value === 'object' && '$bigint' in value && typeof value.$bigint === 'string') {\n    return BigInt(value.$bigint);\n  }\n\n  // BigNumber compatibility with older versions of sequence.js with ethers v5\n  if (value !== null && typeof value === 'object' && value.type === 'BigNumber' && ethers__WEBPACK_IMPORTED_MODULE_0__.isHexString(value.hex)) {\n    return BigInt(value.hex);\n  }\n  return value;\n};\n\nconst base64Encode = val => {\n  return js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.encode(val, true);\n};\nconst base64EncodeObject = obj => {\n  return js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.encode(JSON.stringify(obj, bigintReplacer), true);\n};\nconst base64Decode = encodedString => {\n  if (encodedString === null || encodedString === undefined) {\n    return undefined;\n  }\n  return js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.decode(encodedString);\n};\nconst base64DecodeObject = encodedObject => {\n  if (encodedObject === null || encodedObject === undefined) {\n    return undefined;\n  }\n  return JSON.parse(js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.decode(encodedObject), bigintReviver);\n};\n\nconst encodeMessageDigest = message => {\n  if (typeof message === 'string') {\n    return ethers__WEBPACK_IMPORTED_MODULE_0__.getBytes(ethers__WEBPACK_IMPORTED_MODULE_2__.id(message));\n  } else {\n    return ethers__WEBPACK_IMPORTED_MODULE_0__.getBytes(ethers__WEBPACK_IMPORTED_MODULE_3__.keccak256(message));\n  }\n};\n\n// packMessageData encodes the specified data ready for the Sequence Wallet contracts.\nconst packMessageData = (walletAddress, chainId, digest) => {\n  return ethers__WEBPACK_IMPORTED_MODULE_4__.solidityPacked(['string', 'uint256', 'address', 'bytes32'], ['\\x19\\x01', chainId, walletAddress, digest]);\n};\nconst subDigestOf = (address, chainId, digest) => {\n  return ethers__WEBPACK_IMPORTED_MODULE_3__.keccak256(packMessageData(address, chainId, digest));\n};\n\nconst isNode = () => {\n  if (typeof window === 'undefined' && typeof process === 'object') {\n    return true;\n  } else {\n    return false;\n  }\n};\nconst isBrowser = () => !isNode();\n\nconst jwtDecodeClaims = jwt => {\n  const parts = jwt.split('.');\n  if (parts.length !== 3) {\n    throw new Error('invalid jwt');\n  }\n  const claims = JSON.parse(js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.decode(parts[1]));\n  return claims;\n};\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\nvar logLevel = /*#__PURE__*/function (logLevel) {\n  logLevel[logLevel[\"DEBUG\"] = 1] = \"DEBUG\";\n  logLevel[logLevel[\"INFO\"] = 2] = \"INFO\";\n  logLevel[logLevel[\"WARN\"] = 3] = \"WARN\";\n  logLevel[logLevel[\"ERROR\"] = 4] = \"ERROR\";\n  logLevel[logLevel[\"DISABLED\"] = 5] = \"DISABLED\";\n  return logLevel;\n}(logLevel || {});\nclass Logger {\n  constructor(config) {\n    this.config = config;\n    this.logLevel = void 0;\n    this.configure(config);\n  }\n  configure(config) {\n    this.config = _extends({}, this.config, config);\n    switch (this.config.logLevel) {\n      case 'DEBUG':\n        this.logLevel = logLevel.DEBUG;\n        break;\n      case 'INFO':\n        this.logLevel = logLevel.INFO;\n        break;\n      case 'WARN':\n        this.logLevel = logLevel.WARN;\n        break;\n      case 'ERROR':\n        this.logLevel = logLevel.ERROR;\n        break;\n      case 'DISABLED':\n        this.logLevel = logLevel.DISABLED;\n        break;\n      default:\n        this.logLevel = logLevel.INFO;\n        break;\n    }\n\n    // undefined silence value will disable the default silence flag\n    if (this.config.silence === undefined) {\n      this.config.silence = false;\n    }\n  }\n  debug(message, ...optionalParams) {\n    if (this.config.silence === true) return;\n    if (this.logLevel === logLevel.DEBUG) {\n      console.log(message, ...optionalParams);\n    }\n  }\n  info(message, ...optionalParams) {\n    if (this.config.silence === true) return;\n    if (this.logLevel <= logLevel.INFO) {\n      console.log(message, ...optionalParams);\n    }\n  }\n  warn(message, ...optionalParams) {\n    if (this.config.silence === true) return;\n    if (this.logLevel <= logLevel.WARN) {\n      console.warn(message, ...optionalParams);\n      if (this.config.onwarn) {\n        this.config.onwarn(message, optionalParams);\n      }\n    }\n  }\n  error(message, ...optionalParams) {\n    if (this.config.silence === true) return;\n    if (this.logLevel <= logLevel.ERROR) {\n      console.error(message, ...optionalParams);\n      if (this.config.onerror) {\n        this.config.onerror(message, optionalParams);\n      }\n    }\n  }\n}\nconst logger = new Logger({\n  logLevel: 'INFO',\n  // By default we silence the logger. In tests we should call `configureLogger`\n  // below to set silence: false.\n  silence: true\n});\nconst configureLogger = config => logger.configure(config);\n\nclass Base {\n  static bufferIndexOf(array, element, isSorted = false) {\n    if (isSorted) {\n      return Base.binarySearch(array, element, Base.compare);\n    }\n    const eqChecker = (buffer1, buffer2) => {\n      if (buffer1 === buffer2) {\n        return true;\n      }\n      if (buffer1.length !== buffer2.length) {\n        return false;\n      }\n      for (let i = 0; i < buffer1.length; i++) {\n        if (buffer1[i] !== buffer2[i]) {\n          return false;\n        }\n      }\n      return true;\n    };\n    return Base.linearSearch(array, element, eqChecker);\n  }\n  static binarySearch(array, element, compareFunction) {\n    let start = 0;\n    let end = array.length - 1;\n\n    // Iterate while start not meets end\n    while (start <= end) {\n      // Find the mid index\n      const mid = Math.floor((start + end) / 2);\n\n      // Check if the mid value is greater than, equal to, or less than search element.\n      const ordering = compareFunction(array[mid], element);\n\n      // If element is present at mid, start iterating for searching first appearance.\n      if (ordering === 0) {\n        // Linear reverse iteration until the first matching item index is found.\n        for (let i = mid - 1; i >= 0; i--) {\n          if (compareFunction(array[i], element) === 0) continue;\n          return i + 1;\n        }\n        return 0;\n      } /* Else look in left or right half accordingly */else if (ordering < 0) {\n        start = mid + 1;\n      } else {\n        end = mid - 1;\n      }\n    }\n    return -1;\n  }\n  static compare(a, b) {\n    // Determine the minimum length to compare\n    const len = Math.min(a.length, b.length);\n\n    // Compare byte by byte\n    for (let i = 0; i < len; i++) {\n      if (a[i] !== b[i]) {\n        return a[i] - b[i];\n      }\n    }\n\n    // If all compared bytes are equal, compare lengths\n    return a.length - b.length;\n  }\n  static linearSearch(array, element, eqChecker) {\n    for (let i = 0; i < array.length; i++) {\n      if (eqChecker(array[i], element)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  static bufferify(value) {\n    if (typeof value === 'string') {\n      return ethers__WEBPACK_IMPORTED_MODULE_0__.getBytes(value);\n    }\n    return value;\n  }\n  static isHexString(v) {\n    return typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n  }\n  static bufferToHex(value, withPrefix = true) {\n    const prefixed = ethers__WEBPACK_IMPORTED_MODULE_0__.hexlify(value);\n    return withPrefix ? prefixed : prefixed.substring(2);\n  }\n  static bufferifyFn(f) {\n    return value => {\n      return Base.bufferify(f(value));\n    };\n  }\n}\n\nclass MerkleTree extends Base {\n  constructor(leaves, options = {}) {\n    super();\n    this.hashFn = void 0;\n    this.leaves = [];\n    this.layers = [];\n    this.sortLeaves = false;\n    this.sortPairs = false;\n    this.sortLeaves = !!options.sortLeaves;\n    this.sortPairs = !!options.sortPairs;\n    this.hashFn = Base.bufferifyFn(ethers__WEBPACK_IMPORTED_MODULE_3__.keccak256);\n    this.processLeaves(leaves);\n  }\n  getOptions() {\n    return {\n      sortLeaves: this.sortLeaves,\n      sortPairs: this.sortPairs\n    };\n  }\n  processLeaves(leaves) {\n    this.leaves = leaves.map(Base.bufferify);\n    if (this.sortLeaves) {\n      this.leaves = this.leaves.sort(Base.compare);\n    }\n    this.createHashes(this.leaves);\n  }\n  createHashes(nodes) {\n    this.layers = [nodes];\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n      this.layers.push([]);\n      const layerLimit = nodes.length;\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i >= layerLimit) {\n          this.layers[layerIndex].push(...nodes.slice(layerLimit));\n          break;\n        } else if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            // push copy of hash and continue iteration\n            this.layers[layerIndex].push(nodes[i]);\n            continue;\n          }\n        }\n        const left = nodes[i];\n        const right = i + 1 === nodes.length ? left : nodes[i + 1];\n        const combined = [left, right];\n        if (this.sortPairs) {\n          combined.sort(Base.compare);\n        }\n        const hash = this.hashFn(ethers__WEBPACK_IMPORTED_MODULE_0__.concat(combined));\n        this.layers[layerIndex].push(hash);\n      }\n      nodes = this.layers[layerIndex];\n    }\n  }\n  getRoot() {\n    if (this.layers.length === 0) {\n      return Uint8Array.from([]);\n    }\n    return this.layers[this.layers.length - 1][0] || Uint8Array.from([]);\n  }\n  getHexRoot() {\n    return Base.bufferToHex(this.getRoot());\n  }\n  getProof(leaf, index) {\n    if (typeof leaf === 'undefined') {\n      throw new Error('leaf is required');\n    }\n    leaf = Base.bufferify(leaf);\n    const proof = [];\n    if (!Number.isInteger(index)) {\n      index = -1;\n      for (let i = 0; i < this.leaves.length; i++) {\n        if (Base.compare(leaf, this.leaves[i]) === 0) {\n          index = i;\n        }\n      }\n    }\n\n    // Type fix\n    index = index;\n    if (index <= -1) {\n      return [];\n    }\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode ? index - 1 : index + 1;\n      if (pairIndex < layer.length) {\n        proof.push({\n          position: isRightNode ? 'left' : 'right',\n          data: layer[pairIndex]\n        });\n      }\n\n      // set index to parent index\n      index = index / 2 | 0;\n    }\n    return proof;\n  }\n  getHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => Base.bufferToHex(item.data));\n  }\n  verify(proof, targetNode, root) {\n    let hash = Base.bufferify(targetNode);\n    root = Base.bufferify(root);\n    if (!Array.isArray(proof) || !targetNode || !root) {\n      return false;\n    }\n    for (let i = 0; i < proof.length; i++) {\n      const node = proof[i];\n      let data;\n      let isLeftNode;\n      if (typeof node === 'string') {\n        data = Base.bufferify(node);\n        isLeftNode = true;\n      } else if (node instanceof Object) {\n        data = node.data;\n        isLeftNode = node.position === 'left';\n      } else {\n        throw new Error('Expected node to be of type string or object');\n      }\n      const buffers = [];\n      if (this.sortPairs) {\n        if (Base.compare(hash, data) < 0) {\n          buffers.push(hash, data);\n        } else {\n          buffers.push(data, hash);\n        }\n        hash = this.hashFn(ethers__WEBPACK_IMPORTED_MODULE_0__.concat(buffers));\n      } else {\n        buffers.push(hash);\n        buffers[isLeftNode ? 'unshift' : 'push'](data);\n        hash = this.hashFn(ethers__WEBPACK_IMPORTED_MODULE_0__.concat(buffers));\n      }\n    }\n    return Base.compare(hash, root) === 0;\n  }\n}\n\nclass MerkleTreeGenerator {\n  constructor(elements, toLeaf) {\n    this.elements = void 0;\n    this.toLeaf = void 0;\n    this.tree = void 0;\n    this.elements = elements;\n    this.toLeaf = toLeaf;\n  }\n  generateTree() {\n    const hashed = this.elements.map(e => this.toLeaf(e));\n    return new MerkleTree(hashed, {\n      sortPairs: true,\n      sortLeaves: true\n    });\n  }\n  generateRoot() {\n    if (!this.tree) this.tree = this.generateTree();\n    return this.tree.getHexRoot();\n  }\n  generateProof(element) {\n    if (!this.elements.includes(element)) throw new Error('Element not found');\n    if (!this.tree) this.tree = this.generateTree();\n    return this.tree.getHexProof(this.toLeaf(element));\n  }\n  verifyProof(element, proof) {\n    if (!this.elements.includes(element)) throw new Error('Element not found');\n    if (!this.tree) this.tree = this.generateTree();\n    return this.tree.verify(proof, this.toLeaf(element), this.generateRoot());\n  }\n}\nconst getSaleItemsLeaf = element => ethers__WEBPACK_IMPORTED_MODULE_4__.solidityPackedKeccak256(['address', 'uint256'], [element.address.toLowerCase(), element.tokenId]);\n\n// export const getEthersConnectionInfo = (url: string, projectAccessKey?: string, jwt?: string): ConnectionInfo => {\n//   const headers: {\n//     [key: string]: string | number\n//   } = {}\n\n//   if (jwt && jwt.length > 0) {\n//     headers['Authorization'] = `BEARER ${jwt}`\n//   }\n//   if (projectAccessKey && projectAccessKey.length > 0) {\n//     headers['X-Access-Key'] = projectAccessKey\n//   }\n\n//   return {\n//     url,\n//     headers,\n//     skipFetchSetup: true,\n//     fetchOptions: {\n//       mode: 'cors',\n//       cache: 'force-cache',\n//       credentials: 'same-origin',\n//       redirect: 'follow',\n//       referrer: 'client'\n//     }\n//   }\n// }\n\nconst getFetchRequest = (url, projectAccessKey, jwt) => {\n  const req = new ethers__WEBPACK_IMPORTED_MODULE_5__.FetchRequest(url);\n  if (jwt) {\n    req.setHeader('Authorization', `BEARER ${jwt}`);\n  }\n  if (projectAccessKey) {\n    req.setHeader('X-Access-Key', projectAccessKey);\n  }\n  return req;\n};\n\nclass PromiseCache {\n  constructor() {\n    this.cache = void 0;\n    this.cache = new Map();\n  }\n  do(key, validMilliseconds, task, ...args) {\n    key = `${key}:${ethers__WEBPACK_IMPORTED_MODULE_2__.id(JSON.stringify(args, deterministically))}`;\n    let entry = this.cache.get(key);\n    if (entry) {\n      if (entry.expiration) {\n        if (new Date() >= entry.expiration) {\n          entry = undefined;\n          this.cache.delete(key);\n        }\n      }\n    }\n    if (!entry) {\n      const entry_ = {\n        promise: task(...args)\n      };\n      if (validMilliseconds !== undefined) {\n        entry_.promise = entry_.promise.then(result => {\n          entry_.expiration = new Date(Date.now() + validMilliseconds);\n          return result;\n        });\n      }\n      entry = entry_;\n      this.cache.set(key, entry);\n    }\n    return entry.promise;\n  }\n}\nfunction deterministically(_key, value) {\n  if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n    return Object.fromEntries(Object.entries(value).sort());\n  }\n  return value;\n}\n\nfunction promisify(f, thisContext) {\n  return function (...a) {\n    const args = Array.prototype.slice.call(a);\n    return new Promise(async (resolve, reject) => {\n      try {\n        args.push((err, result) => err ? reject(err) : resolve(result));\n        await f.apply(thisContext, args);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n}\n\nfunction queryStringFromObject(name, obj) {\n  const k = encodeURIComponent(name);\n  const v = encodeURIComponent(JSON.stringify(obj));\n  return `${k}=${v}`;\n}\nfunction queryStringToObject(qs) {\n  const p = qs.split('&');\n  const o = {};\n  for (const v of p) {\n    const z = v.split('=');\n    o[decodeURIComponent(z[0])] = JSON.parse(decodeURIComponent(z[1]));\n  }\n  return o;\n}\n\nconst getRandomInt = (min = 0, max = Number.MAX_SAFE_INTEGER) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n// sanitizeNumberString accepts a number string and returns back a clean number string.\n// For example, input '1234.5678' will return '1234.5678' but '12javascript:{}etc' will return '12'\nconst sanitizeNumberString = numString => {\n  if (!numString || typeof numString !== 'string') {\n    return '';\n  }\n  const v = numString.match(/[\\d.]+/);\n  return v && v.length > 0 ? v[0].trim() : '';\n};\n\n// sanitizeAlphanumeric accepts any string and returns alphanumeric contents only\nconst sanitizeAlphanumeric = alphanum => {\n  if (!alphanum || typeof alphanum !== 'string') {\n    return '';\n  }\n  const v = alphanum.match(/[\\w\\s\\d]+/);\n  return v && v.length > 0 ? v[0].trim() : '';\n};\n\n// sanitizeHost accepts any string and returns valid host string\nconst sanitizeHost = host => {\n  if (!host || typeof host !== 'string') {\n    return '';\n  }\n  const v = host.match(/[\\w\\d.\\-:\\/]+/);\n  return v && v.length > 0 ? v[0].trim() : '';\n};\n\nconst sleep = t => {\n  return new Promise(resolve => {\n    const timeout = setTimeout(() => {\n      clearTimeout(timeout);\n      resolve();\n    }, t);\n  });\n};\n\nconst encodeTypedDataHash = typedData => {\n  const types = _extends({}, typedData.types);\n\n  // remove EIP712Domain key from types as ethers will auto-gen it in\n  // the hash encoder below\n  delete types['EIP712Domain'];\n  return ethers__WEBPACK_IMPORTED_MODULE_6__.TypedDataEncoder.hash(typedData.domain, types, typedData.message);\n};\nconst encodeTypedDataDigest = typedData => {\n  return ethers__WEBPACK_IMPORTED_MODULE_0__.getBytes(encodeTypedDataHash(typedData));\n};\n\nconst {\n  defineProperties,\n  resolveProperties\n} = ethers__WEBPACK_IMPORTED_MODULE_7__;\n\n// urlClean removes double slashes from url path\nconst urlClean = url => url.replace(/([^:]\\/)\\/+/g, '$1');\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0AweHNlcXVlbmNlK3V0aWxzQDIuMi4xM19ldGhlcnNANi4xMy41X2J1ZmZlcnV0aWxANC4wLjhfdXRmLTgtdmFsaWRhdGVANS4wLjEwXy9ub2RlX21vZHVsZXMvQDB4c2VxdWVuY2UvdXRpbHMvZGlzdC8weHNlcXVlbmNlLXV0aWxzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDSDs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVJQUF1SSwrQ0FBa0I7QUFDeko7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1Q0FBdUMsRUFBRSxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUIsUUFBUSxHQUFHLFNBQVMsSUFBSTtBQUM5RDtBQUNBLElBQUk7QUFDSjtBQUNBLHlDQUF5QyxLQUFLLEdBQUcsTUFBTTtBQUN2RDtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMsTUFBTTtBQUNOLG9CQUFvQixLQUFLLEVBQUUsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0IsRUFBRSxRQUFRLEVBQUUsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQixFQUFFLGVBQWUsRUFBRSxlQUFlLFNBQVMsT0FBTztBQUNsRjtBQUNBOztBQUVB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QUFDckM7QUFDQSw2Q0FBNkMsSUFBSTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJLEdBQUcsc0NBQVMsMENBQTBDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksRUFBRSxHQUFHLEVBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0RBQXVCO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTLDRDQUFlO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQ0FBTTs7QUFFVjtBQUNBOztBQUV3b0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZXhhbXBsZXMvbG9naW4td2l0aC1wYXNzcG9ydC1zaWxlbnQvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0AweHNlcXVlbmNlK3V0aWxzQDIuMi4xM19ldGhlcnNANi4xMy41X2J1ZmZlcnV0aWxANC4wLjhfdXRmLTgtdmFsaWRhdGVANS4wLjEwXy9ub2RlX21vZHVsZXMvQDB4c2VxdWVuY2UvdXRpbHMvZGlzdC8weHNlcXVlbmNlLXV0aWxzLmVzbS5qcz9hZDhhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2U2NCB9IGZyb20gJ2pzLWJhc2U2NCc7XG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuXG5jb25zdCBleHRyYWN0UHJvamVjdElkRnJvbUFjY2Vzc0tleSA9IGFjY2Vzc0tleSA9PiB7XG4gIC8vIENvbnZlcnQgVVJMLXNhZmUgYmFzZTY0IHN0cmluZyB0byBzdGFuZGFyZCBiYXNlNjQgc3RyaW5nXG4gIGNvbnN0IGJhc2U2NFN0cmluZyA9IGFjY2Vzc0tleS5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpO1xuICAvLyBEZWNvZGUgdGhlIGJhc2U2NCBzdHJpbmcgdG8gYSBiaW5hcnkgc3RyaW5nXG4gIGNvbnN0IGJpbmFyeVN0cmluZyA9IGF0b2IoYmFzZTY0U3RyaW5nKTtcblxuICAvLyBDb252ZXJ0IHRoZSBiaW5hcnkgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheSAoVWludDhBcnJheSlcbiAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZUFycmF5W2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgaWYgKGJ5dGVBcnJheVswXSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWRWZXJzaW9uJyk7XG4gIH1cblxuICAvLyBFeHRyYWN0IHRoZSBwcm9qZWN0IElEIGZyb20gYnl0ZXMgMiB0byA5ICg4IGJ5dGVzKVxuICBjb25zdCBwcm9qZWN0SWRCeXRlcyA9IGJ5dGVBcnJheS5zbGljZSgxLCA5KTtcbiAgY29uc3QgcHJvamVjdElkID0gcHJvamVjdElkQnl0ZXNbN10gfCBwcm9qZWN0SWRCeXRlc1s2XSA8PCA4IHwgcHJvamVjdElkQnl0ZXNbNV0gPDwgMTYgfCBwcm9qZWN0SWRCeXRlc1s0XSA8PCAyNCB8IHByb2plY3RJZEJ5dGVzWzNdIDw8IDMyIHwgcHJvamVjdElkQnl0ZXNbMl0gPDwgNDAgfCBwcm9qZWN0SWRCeXRlc1sxXSA8PCA0OCB8IHByb2plY3RJZEJ5dGVzWzBdIDw8IDU2O1xuICByZXR1cm4gcHJvamVjdElkO1xufTtcblxuY29uc3QgTUFYX1VJTlRfMjU2ID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnKTtcblxuLy8gZXRoZXJzIGltcGxlbWVudCB0aGlzIG1ldGhvZCBidXQgZG9lc24ndCBleHBvcnRzIGl0XG5jb25zdCBpc0JpZ051bWJlcmlzaCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgJSAxID09PSAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgISF2YWx1ZS5tYXRjaCgvXi0/WzAtOV0rJC8pIHx8IGV0aGVycy5pc0hleFN0cmluZyh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jyk7XG59O1xuXG4vLyBFdmVuIGxlbmd0aCB6ZXJvLXBhZGRlZCBoZXggc3RyaW5nIHdpdGggMHggcHJlZml4XG5jb25zdCB0b0hleFN0cmluZyA9IHZhbHVlID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICByZXR1cm4gYCR7cmVzdWx0Lmxlbmd0aCAlIDIgPT09IDAgPyAnMHgnIDogJzB4MCd9JHtyZXN1bHR9YDtcbn07XG5jb25zdCBwYXJzZVVuaXRzID0gKHZhbHVlLCBkZWNpbWFscyA9IDE4KSA9PiB7XG4gIGxldCBbaW50ZWdlciwgZnJhY3Rpb24gPSAnMCddID0gdmFsdWUuc3BsaXQoJy4nKTtcbiAgY29uc3QgbmVnYXRpdmUgPSBpbnRlZ2VyLnN0YXJ0c1dpdGgoJy0nKTtcbiAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgaW50ZWdlciA9IGludGVnZXIuc2xpY2UoMSk7XG4gIH1cblxuICAvLyB0cmltIHRyYWlsaW5nIHplcm9zLlxuICBmcmFjdGlvbiA9IGZyYWN0aW9uLnJlcGxhY2UoLygwKykkLywgJycpO1xuXG4gIC8vIHJvdW5kIG9mZiBpZiB0aGUgZnJhY3Rpb24gaXMgbGFyZ2VyIHRoYW4gdGhlIG51bWJlciBvZiBkZWNpbWFscy5cbiAgaWYgKGRlY2ltYWxzID09PSAwKSB7XG4gICAgaW50ZWdlciA9IGAke01hdGgucm91bmQoTnVtYmVyKGAke2ludGVnZXJ9LiR7ZnJhY3Rpb259YCkpfWA7XG4gICAgZnJhY3Rpb24gPSAnJztcbiAgfSBlbHNlIGlmIChmcmFjdGlvbi5sZW5ndGggPiBkZWNpbWFscykge1xuICAgIGNvbnN0IFtsZWZ0LCB1bml0LCByaWdodF0gPSBbZnJhY3Rpb24uc2xpY2UoMCwgZGVjaW1hbHMgLSAxKSwgZnJhY3Rpb24uc2xpY2UoZGVjaW1hbHMgLSAxLCBkZWNpbWFscyksIGZyYWN0aW9uLnNsaWNlKGRlY2ltYWxzKV07XG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoTnVtYmVyKGAke3VuaXR9LiR7cmlnaHR9YCkpO1xuICAgIGlmIChyb3VuZGVkID4gOSkge1xuICAgICAgZnJhY3Rpb24gPSBgJHtCaWdJbnQobGVmdCkgKyAxbn0wYC5wYWRTdGFydChsZWZ0Lmxlbmd0aCArIDEsICcwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWN0aW9uID0gYCR7bGVmdH0ke3JvdW5kZWR9YDtcbiAgICB9XG4gICAgaWYgKGZyYWN0aW9uLmxlbmd0aCA+IGRlY2ltYWxzKSB7XG4gICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnNsaWNlKDEpO1xuICAgICAgaW50ZWdlciA9IGAke0JpZ0ludChpbnRlZ2VyKSArIDFufWA7XG4gICAgfVxuICAgIGZyYWN0aW9uID0gZnJhY3Rpb24uc2xpY2UoMCwgZGVjaW1hbHMpO1xuICB9IGVsc2Uge1xuICAgIGZyYWN0aW9uID0gZnJhY3Rpb24ucGFkRW5kKGRlY2ltYWxzLCAnMCcpO1xuICB9XG4gIHJldHVybiBCaWdJbnQoYCR7bmVnYXRpdmUgPyAnLScgOiAnJ30ke2ludGVnZXJ9JHtmcmFjdGlvbn1gKTtcbn07XG5jb25zdCBwYXJzZUV0aGVyID0gdmFsdWUgPT4gcGFyc2VVbml0cyh2YWx1ZSwgMTgpO1xuY29uc3QgZm9ybWF0VW5pdHMgPSAodmFsdWUsIGRlY2ltYWxzID0gMTgpID0+IHtcbiAgbGV0IGRpc3BsYXkgPSB2YWx1ZS50b1N0cmluZygpO1xuICBjb25zdCBuZWdhdGl2ZSA9IGRpc3BsYXkuc3RhcnRzV2l0aCgnLScpO1xuICBpZiAobmVnYXRpdmUpIHtcbiAgICBkaXNwbGF5ID0gZGlzcGxheS5zbGljZSgxKTtcbiAgfVxuICBkaXNwbGF5ID0gZGlzcGxheS5wYWRTdGFydChkZWNpbWFscywgJzAnKTtcbiAgY29uc3QgaW50ZWdlciA9IGRpc3BsYXkuc2xpY2UoMCwgZGlzcGxheS5sZW5ndGggLSBkZWNpbWFscyk7XG4gIGxldCBmcmFjdGlvbiA9IGRpc3BsYXkuc2xpY2UoZGlzcGxheS5sZW5ndGggLSBkZWNpbWFscyk7XG4gIGZyYWN0aW9uID0gZnJhY3Rpb24ucmVwbGFjZSgvKDArKSQvLCAnJyk7XG4gIHJldHVybiBgJHtuZWdhdGl2ZSA/ICctJyA6ICcnfSR7aW50ZWdlciB8fCAnMCd9JHtmcmFjdGlvbiA/IGAuJHtmcmFjdGlvbn1gIDogJyd9YDtcbn07XG5jb25zdCBmb3JtYXRFdGhlciA9IHZhbHVlID0+IGZvcm1hdFVuaXRzKHZhbHVlLCAxOCk7XG5cbi8vIEpTT04uc3RyaW5naWZ5IGRvZXNuJ3QgaGFuZGxlIEJpZ0ludHMsIHNvIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGVtIHdpdGggb2JqZWN0c1xuY29uc3QgYmlnaW50UmVwbGFjZXIgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgIHJldHVybiB7XG4gICAgICAkYmlnaW50OiB2YWx1ZS50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBKU09OLnBhcnNlIHdpbGwgbmVlZCB0byBjb252ZXJ0IG91ciBzZXJpYWxpemVkIGJpZ2ludHMgYmFjayBpbnRvIEJpZ0ludFxuY29uc3QgYmlnaW50UmV2aXZlciA9IChrZXksIHZhbHVlKSA9PiB7XG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICckYmlnaW50JyBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuJGJpZ2ludCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gQmlnSW50KHZhbHVlLiRiaWdpbnQpO1xuICB9XG5cbiAgLy8gQmlnTnVtYmVyIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBzZXF1ZW5jZS5qcyB3aXRoIGV0aGVycyB2NVxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS50eXBlID09PSAnQmlnTnVtYmVyJyAmJiBldGhlcnMuaXNIZXhTdHJpbmcodmFsdWUuaGV4KSkge1xuICAgIHJldHVybiBCaWdJbnQodmFsdWUuaGV4KTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5jb25zdCBiYXNlNjRFbmNvZGUgPSB2YWwgPT4ge1xuICByZXR1cm4gQmFzZTY0LmVuY29kZSh2YWwsIHRydWUpO1xufTtcbmNvbnN0IGJhc2U2NEVuY29kZU9iamVjdCA9IG9iaiA9PiB7XG4gIHJldHVybiBCYXNlNjQuZW5jb2RlKEpTT04uc3RyaW5naWZ5KG9iaiwgYmlnaW50UmVwbGFjZXIpLCB0cnVlKTtcbn07XG5jb25zdCBiYXNlNjREZWNvZGUgPSBlbmNvZGVkU3RyaW5nID0+IHtcbiAgaWYgKGVuY29kZWRTdHJpbmcgPT09IG51bGwgfHwgZW5jb2RlZFN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gQmFzZTY0LmRlY29kZShlbmNvZGVkU3RyaW5nKTtcbn07XG5jb25zdCBiYXNlNjREZWNvZGVPYmplY3QgPSBlbmNvZGVkT2JqZWN0ID0+IHtcbiAgaWYgKGVuY29kZWRPYmplY3QgPT09IG51bGwgfHwgZW5jb2RlZE9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gSlNPTi5wYXJzZShCYXNlNjQuZGVjb2RlKGVuY29kZWRPYmplY3QpLCBiaWdpbnRSZXZpdmVyKTtcbn07XG5cbmNvbnN0IGVuY29kZU1lc3NhZ2VEaWdlc3QgPSBtZXNzYWdlID0+IHtcbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBldGhlcnMuZ2V0Qnl0ZXMoZXRoZXJzLmlkKG1lc3NhZ2UpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXRoZXJzLmdldEJ5dGVzKGV0aGVycy5rZWNjYWsyNTYobWVzc2FnZSkpO1xuICB9XG59O1xuXG4vLyBwYWNrTWVzc2FnZURhdGEgZW5jb2RlcyB0aGUgc3BlY2lmaWVkIGRhdGEgcmVhZHkgZm9yIHRoZSBTZXF1ZW5jZSBXYWxsZXQgY29udHJhY3RzLlxuY29uc3QgcGFja01lc3NhZ2VEYXRhID0gKHdhbGxldEFkZHJlc3MsIGNoYWluSWQsIGRpZ2VzdCkgPT4ge1xuICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsnc3RyaW5nJywgJ3VpbnQyNTYnLCAnYWRkcmVzcycsICdieXRlczMyJ10sIFsnXFx4MTlcXHgwMScsIGNoYWluSWQsIHdhbGxldEFkZHJlc3MsIGRpZ2VzdF0pO1xufTtcbmNvbnN0IHN1YkRpZ2VzdE9mID0gKGFkZHJlc3MsIGNoYWluSWQsIGRpZ2VzdCkgPT4ge1xuICByZXR1cm4gZXRoZXJzLmtlY2NhazI1NihwYWNrTWVzc2FnZURhdGEoYWRkcmVzcywgY2hhaW5JZCwgZGlnZXN0KSk7XG59O1xuXG5jb25zdCBpc05vZGUgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5jb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiAhaXNOb2RlKCk7XG5cbmNvbnN0IGp3dERlY29kZUNsYWltcyA9IGp3dCA9PiB7XG4gIGNvbnN0IHBhcnRzID0gand0LnNwbGl0KCcuJyk7XG4gIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgand0Jyk7XG4gIH1cbiAgY29uc3QgY2xhaW1zID0gSlNPTi5wYXJzZShCYXNlNjQuZGVjb2RlKHBhcnRzWzFdKSk7XG4gIHJldHVybiBjbGFpbXM7XG59O1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgcmV0dXJuIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKG4pIHtcbiAgICBmb3IgKHZhciBlID0gMTsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHNbZV07XG4gICAgICBmb3IgKHZhciByIGluIHQpICh7fSkuaGFzT3duUHJvcGVydHkuY2FsbCh0LCByKSAmJiAobltyXSA9IHRbcl0pO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfSwgX2V4dGVuZHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxudmFyIGxvZ0xldmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChsb2dMZXZlbCkge1xuICBsb2dMZXZlbFtsb2dMZXZlbFtcIkRFQlVHXCJdID0gMV0gPSBcIkRFQlVHXCI7XG4gIGxvZ0xldmVsW2xvZ0xldmVsW1wiSU5GT1wiXSA9IDJdID0gXCJJTkZPXCI7XG4gIGxvZ0xldmVsW2xvZ0xldmVsW1wiV0FSTlwiXSA9IDNdID0gXCJXQVJOXCI7XG4gIGxvZ0xldmVsW2xvZ0xldmVsW1wiRVJST1JcIl0gPSA0XSA9IFwiRVJST1JcIjtcbiAgbG9nTGV2ZWxbbG9nTGV2ZWxbXCJESVNBQkxFRFwiXSA9IDVdID0gXCJESVNBQkxFRFwiO1xuICByZXR1cm4gbG9nTGV2ZWw7XG59KGxvZ0xldmVsIHx8IHt9KTtcbmNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMubG9nTGV2ZWwgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWd1cmUoY29uZmlnKTtcbiAgfVxuICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBfZXh0ZW5kcyh7fSwgdGhpcy5jb25maWcsIGNvbmZpZyk7XG4gICAgc3dpdGNoICh0aGlzLmNvbmZpZy5sb2dMZXZlbCkge1xuICAgICAgY2FzZSAnREVCVUcnOlxuICAgICAgICB0aGlzLmxvZ0xldmVsID0gbG9nTGV2ZWwuREVCVUc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSU5GTyc6XG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBsb2dMZXZlbC5JTkZPO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1dBUk4nOlxuICAgICAgICB0aGlzLmxvZ0xldmVsID0gbG9nTGV2ZWwuV0FSTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdFUlJPUic6XG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBsb2dMZXZlbC5FUlJPUjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdESVNBQkxFRCc6XG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBsb2dMZXZlbC5ESVNBQkxFRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmxvZ0xldmVsID0gbG9nTGV2ZWwuSU5GTztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gdW5kZWZpbmVkIHNpbGVuY2UgdmFsdWUgd2lsbCBkaXNhYmxlIHRoZSBkZWZhdWx0IHNpbGVuY2UgZmxhZ1xuICAgIGlmICh0aGlzLmNvbmZpZy5zaWxlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY29uZmlnLnNpbGVuY2UgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZGVidWcobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpIHtcbiAgICBpZiAodGhpcy5jb25maWcuc2lsZW5jZSA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmxvZ0xldmVsID09PSBsb2dMZXZlbC5ERUJVRykge1xuICAgICAgY29uc29sZS5sb2cobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgIH1cbiAgfVxuICBpbmZvKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLnNpbGVuY2UgPT09IHRydWUpIHJldHVybjtcbiAgICBpZiAodGhpcy5sb2dMZXZlbCA8PSBsb2dMZXZlbC5JTkZPKSB7XG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgfVxuICB9XG4gIHdhcm4obWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpIHtcbiAgICBpZiAodGhpcy5jb25maWcuc2lsZW5jZSA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmxvZ0xldmVsIDw9IGxvZ0xldmVsLldBUk4pIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgICBpZiAodGhpcy5jb25maWcub253YXJuKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm9ud2FybihtZXNzYWdlLCBvcHRpb25hbFBhcmFtcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVycm9yKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLnNpbGVuY2UgPT09IHRydWUpIHJldHVybjtcbiAgICBpZiAodGhpcy5sb2dMZXZlbCA8PSBsb2dMZXZlbC5FUlJPUikge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgICBpZiAodGhpcy5jb25maWcub25lcnJvcikge1xuICAgICAgICB0aGlzLmNvbmZpZy5vbmVycm9yKG1lc3NhZ2UsIG9wdGlvbmFsUGFyYW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoe1xuICBsb2dMZXZlbDogJ0lORk8nLFxuICAvLyBCeSBkZWZhdWx0IHdlIHNpbGVuY2UgdGhlIGxvZ2dlci4gSW4gdGVzdHMgd2Ugc2hvdWxkIGNhbGwgYGNvbmZpZ3VyZUxvZ2dlcmBcbiAgLy8gYmVsb3cgdG8gc2V0IHNpbGVuY2U6IGZhbHNlLlxuICBzaWxlbmNlOiB0cnVlXG59KTtcbmNvbnN0IGNvbmZpZ3VyZUxvZ2dlciA9IGNvbmZpZyA9PiBsb2dnZXIuY29uZmlndXJlKGNvbmZpZyk7XG5cbmNsYXNzIEJhc2Uge1xuICBzdGF0aWMgYnVmZmVySW5kZXhPZihhcnJheSwgZWxlbWVudCwgaXNTb3J0ZWQgPSBmYWxzZSkge1xuICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgcmV0dXJuIEJhc2UuYmluYXJ5U2VhcmNoKGFycmF5LCBlbGVtZW50LCBCYXNlLmNvbXBhcmUpO1xuICAgIH1cbiAgICBjb25zdCBlcUNoZWNrZXIgPSAoYnVmZmVyMSwgYnVmZmVyMikgPT4ge1xuICAgICAgaWYgKGJ1ZmZlcjEgPT09IGJ1ZmZlcjIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYnVmZmVyMS5sZW5ndGggIT09IGJ1ZmZlcjIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyMS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYnVmZmVyMVtpXSAhPT0gYnVmZmVyMltpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZS5saW5lYXJTZWFyY2goYXJyYXksIGVsZW1lbnQsIGVxQ2hlY2tlcik7XG4gIH1cbiAgc3RhdGljIGJpbmFyeVNlYXJjaChhcnJheSwgZWxlbWVudCwgY29tcGFyZUZ1bmN0aW9uKSB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gYXJyYXkubGVuZ3RoIC0gMTtcblxuICAgIC8vIEl0ZXJhdGUgd2hpbGUgc3RhcnQgbm90IG1lZXRzIGVuZFxuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgIC8vIEZpbmQgdGhlIG1pZCBpbmRleFxuICAgICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBtaWQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuLCBlcXVhbCB0bywgb3IgbGVzcyB0aGFuIHNlYXJjaCBlbGVtZW50LlxuICAgICAgY29uc3Qgb3JkZXJpbmcgPSBjb21wYXJlRnVuY3Rpb24oYXJyYXlbbWlkXSwgZWxlbWVudCk7XG5cbiAgICAgIC8vIElmIGVsZW1lbnQgaXMgcHJlc2VudCBhdCBtaWQsIHN0YXJ0IGl0ZXJhdGluZyBmb3Igc2VhcmNoaW5nIGZpcnN0IGFwcGVhcmFuY2UuXG4gICAgICBpZiAob3JkZXJpbmcgPT09IDApIHtcbiAgICAgICAgLy8gTGluZWFyIHJldmVyc2UgaXRlcmF0aW9uIHVudGlsIHRoZSBmaXJzdCBtYXRjaGluZyBpdGVtIGluZGV4IGlzIGZvdW5kLlxuICAgICAgICBmb3IgKGxldCBpID0gbWlkIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAoY29tcGFyZUZ1bmN0aW9uKGFycmF5W2ldLCBlbGVtZW50KSA9PT0gMCkgY29udGludWU7XG4gICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSAvKiBFbHNlIGxvb2sgaW4gbGVmdCBvciByaWdodCBoYWxmIGFjY29yZGluZ2x5ICovZWxzZSBpZiAob3JkZXJpbmcgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gbWlkICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IG1pZCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBzdGF0aWMgY29tcGFyZShhLCBiKSB7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBtaW5pbXVtIGxlbmd0aCB0byBjb21wYXJlXG4gICAgY29uc3QgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcblxuICAgIC8vIENvbXBhcmUgYnl0ZSBieSBieXRlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgcmV0dXJuIGFbaV0gLSBiW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGFsbCBjb21wYXJlZCBieXRlcyBhcmUgZXF1YWwsIGNvbXBhcmUgbGVuZ3Roc1xuICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICB9XG4gIHN0YXRpYyBsaW5lYXJTZWFyY2goYXJyYXksIGVsZW1lbnQsIGVxQ2hlY2tlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlcUNoZWNrZXIoYXJyYXlbaV0sIGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgc3RhdGljIGJ1ZmZlcmlmeSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZXRoZXJzLmdldEJ5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHN0YXRpYyBpc0hleFN0cmluZyh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnc3RyaW5nJyAmJiAvXigweCk/WzAtOUEtRmEtZl0qJC8udGVzdCh2KTtcbiAgfVxuICBzdGF0aWMgYnVmZmVyVG9IZXgodmFsdWUsIHdpdGhQcmVmaXggPSB0cnVlKSB7XG4gICAgY29uc3QgcHJlZml4ZWQgPSBldGhlcnMuaGV4bGlmeSh2YWx1ZSk7XG4gICAgcmV0dXJuIHdpdGhQcmVmaXggPyBwcmVmaXhlZCA6IHByZWZpeGVkLnN1YnN0cmluZygyKTtcbiAgfVxuICBzdGF0aWMgYnVmZmVyaWZ5Rm4oZikge1xuICAgIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgICByZXR1cm4gQmFzZS5idWZmZXJpZnkoZih2YWx1ZSkpO1xuICAgIH07XG4gIH1cbn1cblxuY2xhc3MgTWVya2xlVHJlZSBleHRlbmRzIEJhc2Uge1xuICBjb25zdHJ1Y3RvcihsZWF2ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5oYXNoRm4gPSB2b2lkIDA7XG4gICAgdGhpcy5sZWF2ZXMgPSBbXTtcbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIHRoaXMuc29ydExlYXZlcyA9IGZhbHNlO1xuICAgIHRoaXMuc29ydFBhaXJzID0gZmFsc2U7XG4gICAgdGhpcy5zb3J0TGVhdmVzID0gISFvcHRpb25zLnNvcnRMZWF2ZXM7XG4gICAgdGhpcy5zb3J0UGFpcnMgPSAhIW9wdGlvbnMuc29ydFBhaXJzO1xuICAgIHRoaXMuaGFzaEZuID0gQmFzZS5idWZmZXJpZnlGbihldGhlcnMua2VjY2FrMjU2KTtcbiAgICB0aGlzLnByb2Nlc3NMZWF2ZXMobGVhdmVzKTtcbiAgfVxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzb3J0TGVhdmVzOiB0aGlzLnNvcnRMZWF2ZXMsXG4gICAgICBzb3J0UGFpcnM6IHRoaXMuc29ydFBhaXJzXG4gICAgfTtcbiAgfVxuICBwcm9jZXNzTGVhdmVzKGxlYXZlcykge1xuICAgIHRoaXMubGVhdmVzID0gbGVhdmVzLm1hcChCYXNlLmJ1ZmZlcmlmeSk7XG4gICAgaWYgKHRoaXMuc29ydExlYXZlcykge1xuICAgICAgdGhpcy5sZWF2ZXMgPSB0aGlzLmxlYXZlcy5zb3J0KEJhc2UuY29tcGFyZSk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlSGFzaGVzKHRoaXMubGVhdmVzKTtcbiAgfVxuICBjcmVhdGVIYXNoZXMobm9kZXMpIHtcbiAgICB0aGlzLmxheWVycyA9IFtub2Rlc107XG4gICAgd2hpbGUgKG5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IGxheWVySW5kZXggPSB0aGlzLmxheWVycy5sZW5ndGg7XG4gICAgICB0aGlzLmxheWVycy5wdXNoKFtdKTtcbiAgICAgIGNvbnN0IGxheWVyTGltaXQgPSBub2Rlcy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGlmIChpID49IGxheWVyTGltaXQpIHtcbiAgICAgICAgICB0aGlzLmxheWVyc1tsYXllckluZGV4XS5wdXNoKC4uLm5vZGVzLnNsaWNlKGxheWVyTGltaXQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHB1c2ggY29weSBvZiBoYXNoIGFuZCBjb250aW51ZSBpdGVyYXRpb25cbiAgICAgICAgICAgIHRoaXMubGF5ZXJzW2xheWVySW5kZXhdLnB1c2gobm9kZXNbaV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlZnQgPSBub2Rlc1tpXTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBpICsgMSA9PT0gbm9kZXMubGVuZ3RoID8gbGVmdCA6IG5vZGVzW2kgKyAxXTtcbiAgICAgICAgY29uc3QgY29tYmluZWQgPSBbbGVmdCwgcmlnaHRdO1xuICAgICAgICBpZiAodGhpcy5zb3J0UGFpcnMpIHtcbiAgICAgICAgICBjb21iaW5lZC5zb3J0KEJhc2UuY29tcGFyZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuaGFzaEZuKGV0aGVycy5jb25jYXQoY29tYmluZWQpKTtcbiAgICAgICAgdGhpcy5sYXllcnNbbGF5ZXJJbmRleF0ucHVzaChoYXNoKTtcbiAgICAgIH1cbiAgICAgIG5vZGVzID0gdGhpcy5sYXllcnNbbGF5ZXJJbmRleF07XG4gICAgfVxuICB9XG4gIGdldFJvb3QoKSB7XG4gICAgaWYgKHRoaXMubGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxheWVyc1t0aGlzLmxheWVycy5sZW5ndGggLSAxXVswXSB8fCBVaW50OEFycmF5LmZyb20oW10pO1xuICB9XG4gIGdldEhleFJvb3QoKSB7XG4gICAgcmV0dXJuIEJhc2UuYnVmZmVyVG9IZXgodGhpcy5nZXRSb290KCkpO1xuICB9XG4gIGdldFByb29mKGxlYWYsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBsZWFmID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZWFmIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGxlYWYgPSBCYXNlLmJ1ZmZlcmlmeShsZWFmKTtcbiAgICBjb25zdCBwcm9vZiA9IFtdO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbmRleCkpIHtcbiAgICAgIGluZGV4ID0gLTE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVhdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChCYXNlLmNvbXBhcmUobGVhZiwgdGhpcy5sZWF2ZXNbaV0pID09PSAwKSB7XG4gICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHlwZSBmaXhcbiAgICBpbmRleCA9IGluZGV4O1xuICAgIGlmIChpbmRleCA8PSAtMSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzW2ldO1xuICAgICAgY29uc3QgaXNSaWdodE5vZGUgPSBpbmRleCAlIDI7XG4gICAgICBjb25zdCBwYWlySW5kZXggPSBpc1JpZ2h0Tm9kZSA/IGluZGV4IC0gMSA6IGluZGV4ICsgMTtcbiAgICAgIGlmIChwYWlySW5kZXggPCBsYXllci5sZW5ndGgpIHtcbiAgICAgICAgcHJvb2YucHVzaCh7XG4gICAgICAgICAgcG9zaXRpb246IGlzUmlnaHROb2RlID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgICAgICAgICBkYXRhOiBsYXllcltwYWlySW5kZXhdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgaW5kZXggdG8gcGFyZW50IGluZGV4XG4gICAgICBpbmRleCA9IGluZGV4IC8gMiB8IDA7XG4gICAgfVxuICAgIHJldHVybiBwcm9vZjtcbiAgfVxuICBnZXRIZXhQcm9vZihsZWFmLCBpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFByb29mKGxlYWYsIGluZGV4KS5tYXAoaXRlbSA9PiBCYXNlLmJ1ZmZlclRvSGV4KGl0ZW0uZGF0YSkpO1xuICB9XG4gIHZlcmlmeShwcm9vZiwgdGFyZ2V0Tm9kZSwgcm9vdCkge1xuICAgIGxldCBoYXNoID0gQmFzZS5idWZmZXJpZnkodGFyZ2V0Tm9kZSk7XG4gICAgcm9vdCA9IEJhc2UuYnVmZmVyaWZ5KHJvb3QpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9vZikgfHwgIXRhcmdldE5vZGUgfHwgIXJvb3QpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9vZi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHByb29mW2ldO1xuICAgICAgbGV0IGRhdGE7XG4gICAgICBsZXQgaXNMZWZ0Tm9kZTtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IEJhc2UuYnVmZmVyaWZ5KG5vZGUpO1xuICAgICAgICBpc0xlZnROb2RlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICBkYXRhID0gbm9kZS5kYXRhO1xuICAgICAgICBpc0xlZnROb2RlID0gbm9kZS5wb3NpdGlvbiA9PT0gJ2xlZnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBub2RlIHRvIGJlIG9mIHR5cGUgc3RyaW5nIG9yIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgICAgaWYgKHRoaXMuc29ydFBhaXJzKSB7XG4gICAgICAgIGlmIChCYXNlLmNvbXBhcmUoaGFzaCwgZGF0YSkgPCAwKSB7XG4gICAgICAgICAgYnVmZmVycy5wdXNoKGhhc2gsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlcnMucHVzaChkYXRhLCBoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNoID0gdGhpcy5oYXNoRm4oZXRoZXJzLmNvbmNhdChidWZmZXJzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJzLnB1c2goaGFzaCk7XG4gICAgICAgIGJ1ZmZlcnNbaXNMZWZ0Tm9kZSA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10oZGF0YSk7XG4gICAgICAgIGhhc2ggPSB0aGlzLmhhc2hGbihldGhlcnMuY29uY2F0KGJ1ZmZlcnMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEJhc2UuY29tcGFyZShoYXNoLCByb290KSA9PT0gMDtcbiAgfVxufVxuXG5jbGFzcyBNZXJrbGVUcmVlR2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudHMsIHRvTGVhZikge1xuICAgIHRoaXMuZWxlbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy50b0xlYWYgPSB2b2lkIDA7XG4gICAgdGhpcy50cmVlID0gdm9pZCAwO1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB0aGlzLnRvTGVhZiA9IHRvTGVhZjtcbiAgfVxuICBnZW5lcmF0ZVRyZWUoKSB7XG4gICAgY29uc3QgaGFzaGVkID0gdGhpcy5lbGVtZW50cy5tYXAoZSA9PiB0aGlzLnRvTGVhZihlKSk7XG4gICAgcmV0dXJuIG5ldyBNZXJrbGVUcmVlKGhhc2hlZCwge1xuICAgICAgc29ydFBhaXJzOiB0cnVlLFxuICAgICAgc29ydExlYXZlczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGdlbmVyYXRlUm9vdCgpIHtcbiAgICBpZiAoIXRoaXMudHJlZSkgdGhpcy50cmVlID0gdGhpcy5nZW5lcmF0ZVRyZWUoKTtcbiAgICByZXR1cm4gdGhpcy50cmVlLmdldEhleFJvb3QoKTtcbiAgfVxuICBnZW5lcmF0ZVByb29mKGVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuZWxlbWVudHMuaW5jbHVkZXMoZWxlbWVudCkpIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBub3QgZm91bmQnKTtcbiAgICBpZiAoIXRoaXMudHJlZSkgdGhpcy50cmVlID0gdGhpcy5nZW5lcmF0ZVRyZWUoKTtcbiAgICByZXR1cm4gdGhpcy50cmVlLmdldEhleFByb29mKHRoaXMudG9MZWFmKGVsZW1lbnQpKTtcbiAgfVxuICB2ZXJpZnlQcm9vZihlbGVtZW50LCBwcm9vZikge1xuICAgIGlmICghdGhpcy5lbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSkgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IG5vdCBmb3VuZCcpO1xuICAgIGlmICghdGhpcy50cmVlKSB0aGlzLnRyZWUgPSB0aGlzLmdlbmVyYXRlVHJlZSgpO1xuICAgIHJldHVybiB0aGlzLnRyZWUudmVyaWZ5KHByb29mLCB0aGlzLnRvTGVhZihlbGVtZW50KSwgdGhpcy5nZW5lcmF0ZVJvb3QoKSk7XG4gIH1cbn1cbmNvbnN0IGdldFNhbGVJdGVtc0xlYWYgPSBlbGVtZW50ID0+IGV0aGVycy5zb2xpZGl0eVBhY2tlZEtlY2NhazI1NihbJ2FkZHJlc3MnLCAndWludDI1NiddLCBbZWxlbWVudC5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIGVsZW1lbnQudG9rZW5JZF0pO1xuXG4vLyBleHBvcnQgY29uc3QgZ2V0RXRoZXJzQ29ubmVjdGlvbkluZm8gPSAodXJsOiBzdHJpbmcsIHByb2plY3RBY2Nlc3NLZXk/OiBzdHJpbmcsIGp3dD86IHN0cmluZyk6IENvbm5lY3Rpb25JbmZvID0+IHtcbi8vICAgY29uc3QgaGVhZGVyczoge1xuLy8gICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlclxuLy8gICB9ID0ge31cblxuLy8gICBpZiAoand0ICYmIGp3dC5sZW5ndGggPiAwKSB7XG4vLyAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJFQVJFUiAke2p3dH1gXG4vLyAgIH1cbi8vICAgaWYgKHByb2plY3RBY2Nlc3NLZXkgJiYgcHJvamVjdEFjY2Vzc0tleS5sZW5ndGggPiAwKSB7XG4vLyAgICAgaGVhZGVyc1snWC1BY2Nlc3MtS2V5J10gPSBwcm9qZWN0QWNjZXNzS2V5XG4vLyAgIH1cblxuLy8gICByZXR1cm4ge1xuLy8gICAgIHVybCxcbi8vICAgICBoZWFkZXJzLFxuLy8gICAgIHNraXBGZXRjaFNldHVwOiB0cnVlLFxuLy8gICAgIGZldGNoT3B0aW9uczoge1xuLy8gICAgICAgbW9kZTogJ2NvcnMnLFxuLy8gICAgICAgY2FjaGU6ICdmb3JjZS1jYWNoZScsXG4vLyAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbi8vICAgICAgIHJlZGlyZWN0OiAnZm9sbG93Jyxcbi8vICAgICAgIHJlZmVycmVyOiAnY2xpZW50J1xuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuXG5jb25zdCBnZXRGZXRjaFJlcXVlc3QgPSAodXJsLCBwcm9qZWN0QWNjZXNzS2V5LCBqd3QpID0+IHtcbiAgY29uc3QgcmVxID0gbmV3IGV0aGVycy5GZXRjaFJlcXVlc3QodXJsKTtcbiAgaWYgKGp3dCkge1xuICAgIHJlcS5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCBgQkVBUkVSICR7and0fWApO1xuICB9XG4gIGlmIChwcm9qZWN0QWNjZXNzS2V5KSB7XG4gICAgcmVxLnNldEhlYWRlcignWC1BY2Nlc3MtS2V5JywgcHJvamVjdEFjY2Vzc0tleSk7XG4gIH1cbiAgcmV0dXJuIHJlcTtcbn07XG5cbmNsYXNzIFByb21pc2VDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2FjaGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuICBkbyhrZXksIHZhbGlkTWlsbGlzZWNvbmRzLCB0YXNrLCAuLi5hcmdzKSB7XG4gICAga2V5ID0gYCR7a2V5fToke2V0aGVycy5pZChKU09OLnN0cmluZ2lmeShhcmdzLCBkZXRlcm1pbmlzdGljYWxseSkpfWA7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGlmIChlbnRyeS5leHBpcmF0aW9uKSB7XG4gICAgICAgIGlmIChuZXcgRGF0ZSgpID49IGVudHJ5LmV4cGlyYXRpb24pIHtcbiAgICAgICAgICBlbnRyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGNvbnN0IGVudHJ5XyA9IHtcbiAgICAgICAgcHJvbWlzZTogdGFzayguLi5hcmdzKVxuICAgICAgfTtcbiAgICAgIGlmICh2YWxpZE1pbGxpc2Vjb25kcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVudHJ5Xy5wcm9taXNlID0gZW50cnlfLnByb21pc2UudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgIGVudHJ5Xy5leHBpcmF0aW9uID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIHZhbGlkTWlsbGlzZWNvbmRzKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVudHJ5ID0gZW50cnlfO1xuICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCBlbnRyeSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS5wcm9taXNlO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljYWxseShfa2V5LCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHZhbHVlKS5zb3J0KCkpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZ5KGYsIHRoaXNDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoLi4uYSkge1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXJncy5wdXNoKChlcnIsIHJlc3VsdCkgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlc3VsdCkpO1xuICAgICAgICBhd2FpdCBmLmFwcGx5KHRoaXNDb250ZXh0LCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBxdWVyeVN0cmluZ0Zyb21PYmplY3QobmFtZSwgb2JqKSB7XG4gIGNvbnN0IGsgPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSk7XG4gIGNvbnN0IHYgPSBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIHJldHVybiBgJHtrfT0ke3Z9YDtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U3RyaW5nVG9PYmplY3QocXMpIHtcbiAgY29uc3QgcCA9IHFzLnNwbGl0KCcmJyk7XG4gIGNvbnN0IG8gPSB7fTtcbiAgZm9yIChjb25zdCB2IG9mIHApIHtcbiAgICBjb25zdCB6ID0gdi5zcGxpdCgnPScpO1xuICAgIG9bZGVjb2RlVVJJQ29tcG9uZW50KHpbMF0pXSA9IEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KHpbMV0pKTtcbiAgfVxuICByZXR1cm4gbztcbn1cblxuY29uc3QgZ2V0UmFuZG9tSW50ID0gKG1pbiA9IDAsIG1heCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSA9PiB7XG4gIG1pbiA9IE1hdGguY2VpbChtaW4pO1xuICBtYXggPSBNYXRoLmZsb29yKG1heCk7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xufTtcblxuLy8gc2FuaXRpemVOdW1iZXJTdHJpbmcgYWNjZXB0cyBhIG51bWJlciBzdHJpbmcgYW5kIHJldHVybnMgYmFjayBhIGNsZWFuIG51bWJlciBzdHJpbmcuXG4vLyBGb3IgZXhhbXBsZSwgaW5wdXQgJzEyMzQuNTY3OCcgd2lsbCByZXR1cm4gJzEyMzQuNTY3OCcgYnV0ICcxMmphdmFzY3JpcHQ6e31ldGMnIHdpbGwgcmV0dXJuICcxMidcbmNvbnN0IHNhbml0aXplTnVtYmVyU3RyaW5nID0gbnVtU3RyaW5nID0+IHtcbiAgaWYgKCFudW1TdHJpbmcgfHwgdHlwZW9mIG51bVN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgY29uc3QgdiA9IG51bVN0cmluZy5tYXRjaCgvW1xcZC5dKy8pO1xuICByZXR1cm4gdiAmJiB2Lmxlbmd0aCA+IDAgPyB2WzBdLnRyaW0oKSA6ICcnO1xufTtcblxuLy8gc2FuaXRpemVBbHBoYW51bWVyaWMgYWNjZXB0cyBhbnkgc3RyaW5nIGFuZCByZXR1cm5zIGFscGhhbnVtZXJpYyBjb250ZW50cyBvbmx5XG5jb25zdCBzYW5pdGl6ZUFscGhhbnVtZXJpYyA9IGFscGhhbnVtID0+IHtcbiAgaWYgKCFhbHBoYW51bSB8fCB0eXBlb2YgYWxwaGFudW0gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IHYgPSBhbHBoYW51bS5tYXRjaCgvW1xcd1xcc1xcZF0rLyk7XG4gIHJldHVybiB2ICYmIHYubGVuZ3RoID4gMCA/IHZbMF0udHJpbSgpIDogJyc7XG59O1xuXG4vLyBzYW5pdGl6ZUhvc3QgYWNjZXB0cyBhbnkgc3RyaW5nIGFuZCByZXR1cm5zIHZhbGlkIGhvc3Qgc3RyaW5nXG5jb25zdCBzYW5pdGl6ZUhvc3QgPSBob3N0ID0+IHtcbiAgaWYgKCFob3N0IHx8IHR5cGVvZiBob3N0ICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCB2ID0gaG9zdC5tYXRjaCgvW1xcd1xcZC5cXC06XFwvXSsvKTtcbiAgcmV0dXJuIHYgJiYgdi5sZW5ndGggPiAwID8gdlswXS50cmltKCkgOiAnJztcbn07XG5cbmNvbnN0IHNsZWVwID0gdCA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSwgdCk7XG4gIH0pO1xufTtcblxuY29uc3QgZW5jb2RlVHlwZWREYXRhSGFzaCA9IHR5cGVkRGF0YSA9PiB7XG4gIGNvbnN0IHR5cGVzID0gX2V4dGVuZHMoe30sIHR5cGVkRGF0YS50eXBlcyk7XG5cbiAgLy8gcmVtb3ZlIEVJUDcxMkRvbWFpbiBrZXkgZnJvbSB0eXBlcyBhcyBldGhlcnMgd2lsbCBhdXRvLWdlbiBpdCBpblxuICAvLyB0aGUgaGFzaCBlbmNvZGVyIGJlbG93XG4gIGRlbGV0ZSB0eXBlc1snRUlQNzEyRG9tYWluJ107XG4gIHJldHVybiBldGhlcnMuVHlwZWREYXRhRW5jb2Rlci5oYXNoKHR5cGVkRGF0YS5kb21haW4sIHR5cGVzLCB0eXBlZERhdGEubWVzc2FnZSk7XG59O1xuY29uc3QgZW5jb2RlVHlwZWREYXRhRGlnZXN0ID0gdHlwZWREYXRhID0+IHtcbiAgcmV0dXJuIGV0aGVycy5nZXRCeXRlcyhlbmNvZGVUeXBlZERhdGFIYXNoKHR5cGVkRGF0YSkpO1xufTtcblxuY29uc3Qge1xuICBkZWZpbmVQcm9wZXJ0aWVzLFxuICByZXNvbHZlUHJvcGVydGllc1xufSA9IGV0aGVycztcblxuLy8gdXJsQ2xlYW4gcmVtb3ZlcyBkb3VibGUgc2xhc2hlcyBmcm9tIHVybCBwYXRoXG5jb25zdCB1cmxDbGVhbiA9IHVybCA9PiB1cmwucmVwbGFjZSgvKFteOl1cXC8pXFwvKy9nLCAnJDEnKTtcblxuZXhwb3J0IHsgTG9nZ2VyLCBNQVhfVUlOVF8yNTYsIE1lcmtsZVRyZWVHZW5lcmF0b3IsIFByb21pc2VDYWNoZSwgYmFzZTY0RGVjb2RlLCBiYXNlNjREZWNvZGVPYmplY3QsIGJhc2U2NEVuY29kZSwgYmFzZTY0RW5jb2RlT2JqZWN0LCBiaWdpbnRSZXBsYWNlciwgYmlnaW50UmV2aXZlciwgY29uZmlndXJlTG9nZ2VyLCBkZWZpbmVQcm9wZXJ0aWVzLCBlbmNvZGVNZXNzYWdlRGlnZXN0LCBlbmNvZGVUeXBlZERhdGFEaWdlc3QsIGVuY29kZVR5cGVkRGF0YUhhc2gsIGV4dHJhY3RQcm9qZWN0SWRGcm9tQWNjZXNzS2V5LCBmb3JtYXRFdGhlciwgZm9ybWF0VW5pdHMsIGdldEZldGNoUmVxdWVzdCwgZ2V0UmFuZG9tSW50LCBnZXRTYWxlSXRlbXNMZWFmLCBpc0JpZ051bWJlcmlzaCwgaXNCcm93c2VyLCBpc05vZGUsIGp3dERlY29kZUNsYWltcywgbG9nZ2VyLCBwYWNrTWVzc2FnZURhdGEsIHBhcnNlRXRoZXIsIHBhcnNlVW5pdHMsIHByb21pc2lmeSwgcXVlcnlTdHJpbmdGcm9tT2JqZWN0LCBxdWVyeVN0cmluZ1RvT2JqZWN0LCByZXNvbHZlUHJvcGVydGllcywgc2FuaXRpemVBbHBoYW51bWVyaWMsIHNhbml0aXplSG9zdCwgc2FuaXRpemVOdW1iZXJTdHJpbmcsIHNsZWVwLCBzdWJEaWdlc3RPZiwgdG9IZXhTdHJpbmcsIHVybENsZWFuIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/.pnpm/@0xsequence+utils@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/utils/dist/0xsequence-utils.esm.js\n");

/***/ })

};
;