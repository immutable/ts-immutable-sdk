"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@0xsequence+core@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_";
exports.ids = ["vendor-chunks/@0xsequence+core@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/.pnpm/@0xsequence+core@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/core/dist/0xsequence-core.esm.js":
/*!***************************************************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@0xsequence+core@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/core/dist/0xsequence-core.esm.js ***!
  \***************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   allVersions: () => (/* binding */ allVersions),\n/* harmony export */   commons: () => (/* binding */ index$1),\n/* harmony export */   universal: () => (/* binding */ index),\n/* harmony export */   v1: () => (/* binding */ v1),\n/* harmony export */   v2: () => (/* binding */ v2)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/solidity.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/message.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/hashes.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @0xsequence/abi */ \"(ssr)/../../../node_modules/.pnpm/@0xsequence+abi@2.2.13/node_modules/@0xsequence/abi/dist/0xsequence-abi.esm.js\");\n/* harmony import */ var _0xsequence_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @0xsequence/utils */ \"(ssr)/../../../node_modules/.pnpm/@0xsequence+utils@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/utils/dist/0xsequence-utils.esm.js\");\n\n\n\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\nfunction subdigestOf(payload) {\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['bytes', 'uint256', 'address', 'bytes32'], ['0x1901', payload.chainId, payload.address, payload.digest]);\n}\nfunction isSignedPayload(payload) {\n  return payload.digest !== undefined && payload.chainId !== undefined && payload.address !== undefined;\n}\n\nvar signature$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  subdigestOf: subdigestOf,\n  isSignedPayload: isSignedPayload\n});\n\nconst EIP1271_MAGIC_VALUE = '0x1626ba7e';\nconst EIP1271_ABI = [{\n  inputs: [{\n    internalType: 'bytes32',\n    type: 'bytes32'\n  }, {\n    internalType: 'bytes',\n    type: 'bytes'\n  }],\n  name: 'isValidSignature',\n  outputs: [{\n    internalType: 'bytes4',\n    type: 'bytes4'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}];\nasync function isValidEIP1271Signature(address, digest, signature, provider) {\n  const contract = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(address, EIP1271_ABI, provider);\n  const result = await contract.isValidSignature(digest, signature);\n  return result === EIP1271_MAGIC_VALUE;\n}\n\nvar validateEIP1271 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  isValidEIP1271Signature: isValidEIP1271Signature\n});\n\nlet SigType = /*#__PURE__*/function (SigType) {\n  SigType[SigType[\"EIP712\"] = 1] = \"EIP712\";\n  SigType[SigType[\"ETH_SIGN\"] = 2] = \"ETH_SIGN\";\n  SigType[SigType[\"WALLET_BYTES32\"] = 3] = \"WALLET_BYTES32\";\n  return SigType;\n}({});\nfunction canRecover(signature) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  const type = bytes[bytes.length - 1];\n  return type === SigType.EIP712 || type === SigType.ETH_SIGN;\n}\nfunction recoverSigner(digest, signature) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  const digestBytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(digest);\n\n  // type is last byte\n  const type = bytes[bytes.length - 1];\n\n  // Split r:s:v\n  const r = ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(0, 32));\n  const s = ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(32, 64));\n  const v = Number(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(64, 65)));\n  const splitSignature = {\n    r,\n    s,\n    v\n  };\n  if (type === SigType.EIP712) {\n    return ethers__WEBPACK_IMPORTED_MODULE_5__.recoverAddress(digestBytes, splitSignature);\n  }\n  if (type === SigType.ETH_SIGN) {\n    return ethers__WEBPACK_IMPORTED_MODULE_5__.recoverAddress(ethers__WEBPACK_IMPORTED_MODULE_6__.hashMessage(digestBytes), splitSignature);\n  }\n  throw new Error(`Unsupported signature type: ${type}`);\n}\nfunction isValidSignature(address, digest, signature, provider) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n\n  // type is last byte\n  const type = bytes[bytes.length - 1];\n  if (type === SigType.EIP712 || type === SigType.ETH_SIGN) {\n    return address === recoverSigner(digest, signature);\n  }\n  if (type === SigType.WALLET_BYTES32) {\n    return isValidEIP1271Signature(address, ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(digest), bytes.slice(0, -1), provider);\n  }\n  throw new Error(`Unsupported signature type: ${type}`);\n}\nfunction tryRecoverSigner(digest, signature) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  if (bytes.length !== 66) return undefined;\n  try {\n    return recoverSigner(digest, bytes);\n  } catch (_unused) {}\n  return undefined;\n}\n\nvar signer = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SigType: SigType,\n  canRecover: canRecover,\n  recoverSigner: recoverSigner,\n  isValidSignature: isValidSignature,\n  tryRecoverSigner: tryRecoverSigner\n});\n\nlet SignaturePartType$1 = /*#__PURE__*/function (SignaturePartType) {\n  SignaturePartType[SignaturePartType[\"EOASignature\"] = 0] = \"EOASignature\";\n  SignaturePartType[SignaturePartType[\"Address\"] = 1] = \"Address\";\n  SignaturePartType[SignaturePartType[\"DynamicSignature\"] = 2] = \"DynamicSignature\";\n  return SignaturePartType;\n}({});\nfunction isAddressMember(member) {\n  return member.address !== undefined && !isUnrecoveredSignatureMember(member);\n}\nfunction isUnrecoveredSignatureMember(member) {\n  return member.signature !== undefined && member.weight !== undefined && member.isDynamic !== undefined;\n}\nfunction isUnrecoveredSignature$1(signature) {\n  return signature.threshold !== undefined && signature.signers !== undefined;\n}\nfunction decodeSignature$1(signature) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  const threshold = bytes[0] << 8 | bytes[1];\n  const signers = [];\n  for (let i = 2; i < bytes.length;) {\n    const type = bytes[i++];\n    const weight = bytes[i++];\n    switch (type) {\n      case SignaturePartType$1.EOASignature:\n        signers.push({\n          unrecovered: true,\n          weight,\n          signature: ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(i, i + 66)),\n          isDynamic: false\n        });\n        i += 66;\n        break;\n      case SignaturePartType$1.Address:\n        signers.push({\n          weight,\n          address: ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(i, i + 20)))\n        });\n        i += 20;\n        break;\n      case SignaturePartType$1.DynamicSignature:\n        const address = ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(i, i + 20)));\n        i += 20;\n        const size = bytes[i] << 8 | bytes[i + 1];\n        i += 2;\n        signers.push({\n          unrecovered: true,\n          weight,\n          signature: ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(i, i + size)),\n          address,\n          isDynamic: true\n        });\n        i += size;\n        break;\n      default:\n        throw new Error(`Unknown signature part type: ${type}`);\n    }\n  }\n  return {\n    version: 1,\n    threshold,\n    signers\n  };\n}\nfunction encodeSignature$1(signature) {\n  if (ethers__WEBPACK_IMPORTED_MODULE_4__.isBytesLike(signature)) {\n    return ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(signature);\n  }\n  const {\n    signers,\n    threshold\n  } = isUnrecoveredSignature$1(signature) ? signature : signature.config;\n  const encodedSigners = signers.map(s => {\n    if (isAddressMember(s)) {\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'address'], [SignaturePartType$1.Address, s.weight, s.address]);\n    }\n    if (s.isDynamic) {\n      const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(s.signature);\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'address', 'uint16', 'bytes'], [SignaturePartType$1.DynamicSignature, s.weight, s.address, bytes.length, bytes]);\n    }\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'bytes'], [SignaturePartType$1.EOASignature, s.weight, s.signature]);\n  });\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint16', ...new Array(encodedSigners.length).fill('bytes')], [threshold, ...encodedSigners]);\n}\nasync function recoverSignature$1(data, payload, provider) {\n  const subdigest = subdigestOf(payload);\n  const signers = await Promise.all(data.signers.map(async s => {\n    if (isAddressMember(s)) {\n      return s;\n    }\n    if (s.isDynamic) {\n      if (!s.address) throw new Error('Dynamic signature part must have address');\n      if (!isValidSignature(s.address, subdigest, s.signature, provider)) {\n        throw new Error(`Invalid dynamic signature part ${s.address}`);\n      }\n      return {\n        address: s.address,\n        weight: s.weight,\n        signature: s.signature\n      };\n    } else {\n      const address = recoverSigner(subdigest, s.signature);\n      return {\n        address,\n        weight: s.weight,\n        signature: s.signature\n      };\n    }\n  }));\n  return {\n    version: 1,\n    payload,\n    subdigest,\n    config: {\n      version: 1,\n      threshold: data.threshold,\n      signers\n    }\n  };\n}\nfunction encodeSigners$1(config, signatures, subdigests, _) {\n  if (subdigests.length !== 0) {\n    throw new Error('Explicit subdigests not supported on v1');\n  }\n  let weight = 0n;\n  const parts = config.signers.map(s => {\n    if (!signatures.has(s.address)) {\n      return s;\n    }\n    const signature = signatures.get(s.address);\n    const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature.signature);\n    weight += BigInt(s.weight);\n    if (signature.isDynamic || bytes.length !== 66) {\n      return _extends({}, s, {\n        isDynamic: true,\n        signature: signature.signature,\n        address: s.address\n      });\n    }\n    return _extends({}, s, {\n      isDynamic: false,\n      signature: signature.signature\n    });\n  });\n  const encoded = encodeSignature$1({\n    version: 1,\n    threshold: config.threshold,\n    signers: parts\n  });\n  return {\n    encoded,\n    weight\n  };\n}\nconst SignatureCoder$1 = {\n  decode: data => {\n    return decodeSignature$1(data);\n  },\n  encode: data => {\n    return encodeSignature$1(data);\n  },\n  trim: async data => {\n    return data;\n  },\n  supportsNoChainId: true,\n  recover: (data, payload, provider) => {\n    return recoverSignature$1(data, payload, provider);\n  },\n  encodeSigners: (config, signatures, subdigests, chainId) => {\n    return encodeSigners$1(config, signatures, subdigests);\n  },\n  hasEnoughSigningPower: (config, signatures) => {\n    const {\n      weight\n    } = SignatureCoder$1.encodeSigners(config, signatures, [], 0);\n    return weight >= BigInt(config.threshold);\n  },\n  chainSignatures: (_main, _suffix) => {\n    throw new Error('Signature chaining not supported on v1');\n  },\n  hashSetImageHash: function (_imageHash) {\n    throw new Error('Image hash not supported on v1');\n  },\n  signaturesOf(config) {\n    return config.signers.filter(s => s.signature !== undefined).map(s => ({\n      address: s.address,\n      signature: s.signature\n    }));\n  },\n  signaturesOfDecoded: function (data) {\n    return data.signers.map(s => s.signature).filter(s => s !== undefined);\n  }\n};\n\nvar signature$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SignaturePartType: SignaturePartType$1,\n  isAddressMember: isAddressMember,\n  isUnrecoveredSignatureMember: isUnrecoveredSignatureMember,\n  isUnrecoveredSignature: isUnrecoveredSignature$1,\n  decodeSignature: decodeSignature$1,\n  encodeSignature: encodeSignature$1,\n  recoverSignature: recoverSignature$1,\n  encodeSigners: encodeSigners$1,\n  SignatureCoder: SignatureCoder$1\n});\n\nconst ConfigCoder$1 = {\n  isWalletConfig: config => {\n    return config.version === 1 && config.threshold !== undefined && config.signers !== undefined;\n  },\n  imageHashOf: config => {\n    return config.signers.reduce((imageHash, signer) => ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().encode(['bytes32', 'uint8', 'address'], [imageHash, signer.weight, signer.address])), ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint256'], [config.threshold]));\n  },\n  hasSubdigest: (_walletConfig, _subdigest) => {\n    // v1 does not support explicit subdigests\n    return false;\n  },\n  isComplete: _config => {\n    // v1 does not support incomplete configs\n    return true;\n  },\n  checkpointOf: _config => {\n    return 0n;\n  },\n  signersOf: config => {\n    return config.signers.map(s => ({\n      address: s.address,\n      weight: Number(s.weight)\n    }));\n  },\n  fromSimple: config => {\n    if (BigInt(config.checkpoint) !== 0n) {\n      throw new Error('v1 wallet config does not support checkpoint');\n    }\n    if (config.subdigests && config.subdigests.length > 0) {\n      throw new Error('v1 wallet config does not support subdigests');\n    }\n    return {\n      version: 1,\n      threshold: config.threshold,\n      signers: config.signers\n    };\n  },\n  update: {\n    isKindUsed: true,\n    buildTransaction: (wallet, config, context, kind) => {\n      const module = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface([..._0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModule.abi, ..._0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModuleUpgradable.abi]);\n      const transactions = [];\n      if (!kind || kind === 'first') {\n        transactions.push({\n          to: wallet,\n          data: module.encodeFunctionData(module.getFunction('updateImplementation'), [context.mainModuleUpgradable]),\n          gasLimit: 0,\n          delegateCall: false,\n          revertOnError: true,\n          value: 0\n        });\n      }\n      transactions.push({\n        to: wallet,\n        data: module.encodeFunctionData(module.getFunction('updateImageHash'), [ConfigCoder$1.imageHashOf(config)]),\n        gasLimit: 0,\n        delegateCall: false,\n        revertOnError: true,\n        value: 0\n      });\n      return {\n        entrypoint: wallet,\n        transactions\n      };\n    },\n    decodeTransaction: function (tx) {\n      throw new Error('Function not implemented.');\n    }\n  },\n  toJSON: function (config) {\n    const plainMembers = config.signers.map(signer => {\n      return {\n        weight: BigInt(signer.weight).toString(),\n        address: signer.address\n      };\n    });\n    return JSON.stringify({\n      version: config.version,\n      threshold: BigInt(config.threshold).toString(),\n      signers: plainMembers\n    });\n  },\n  fromJSON: function (json) {\n    const parsed = JSON.parse(json);\n    const signers = parsed.signers.map(signer => {\n      return {\n        weight: BigInt(signer.weight),\n        address: signer.address\n      };\n    });\n    return {\n      version: parsed.version,\n      threshold: BigInt(parsed.threshold),\n      signers\n    };\n  },\n  editConfig: function (config, action) {\n    var _action$threshold;\n    const newSigners = config.signers.slice();\n    if (action.checkpoint && BigInt(action.checkpoint) !== 0n) {\n      throw new Error('v1 wallet config does not support checkpoint');\n    }\n    if (action.add) {\n      for (const signer of action.add) {\n        if (newSigners.find(s => s.address === signer.address)) {\n          continue;\n        }\n        newSigners.push({\n          weight: signer.weight,\n          address: signer.address\n        });\n      }\n    }\n    if (action.remove) {\n      for (const address of action.remove) {\n        const index = newSigners.findIndex(signer => signer.address === address);\n        if (index >= 0) {\n          newSigners.splice(index, 1);\n        }\n      }\n    }\n    return {\n      version: config.version,\n      threshold: (_action$threshold = action.threshold) != null ? _action$threshold : config.threshold,\n      signers: newSigners\n    };\n  },\n  buildStubSignature: function (config, overrides) {\n    const parts = new Map();\n    for (const [signer, signature] of overrides.entries()) {\n      parts.set(signer, {\n        signature,\n        isDynamic: true\n      });\n      const {\n        encoded,\n        weight\n      } = encodeSigners$1(config, parts, []);\n      if (weight >= BigInt(config.threshold)) {\n        return encoded;\n      }\n    }\n    const signers = config.signers;\n    for (const {\n      address\n    } of signers.sort(({\n      weight: a\n    }, {\n      weight: b\n    }) => Number(a) - Number(b))) {\n      const signature = '0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02';\n      parts.set(address, {\n        signature,\n        isDynamic: false\n      });\n      const {\n        encoded,\n        weight\n      } = encodeSigners$1(config, parts, []);\n      if (weight >= BigInt(config.threshold)) {\n        return encoded;\n      }\n    }\n    return encodeSigners$1(config, parts, []).encoded;\n  }\n};\n\nvar config$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ConfigCoder: ConfigCoder$1\n});\n\nvar context$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nconst version$1 = 1;\nconst DeployedWalletContext$1 = {\n  version: version$1,\n  factory: '0xf9D09D634Fb818b05149329C1dcCFAeA53639d96',\n  guestModule: '0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7',\n  mainModule: '0xd01F11855bCcb95f88D7A48492F66410d4637313',\n  mainModuleUpgradable: '0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118',\n  walletCreationCode: '0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3'\n};\n\nvar v1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  config: config$2,\n  context: context$2,\n  signature: signature$1,\n  version: version$1,\n  DeployedWalletContext: DeployedWalletContext$1\n});\n\n//                              = keccak256(\"SetImageHash(bytes32 imageHash)\")\nconst SetImageHashPrefix = '0x8713a7c4465f6fbee2b6e9d6646d1d9f83fec929edfc4baf661f3c865bdd04d1';\nfunction hashSetImageHash(imageHash) {\n  return ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(messageSetImageHash(imageHash));\n}\nfunction messageSetImageHash(imageHash) {\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes32', 'bytes32'], [SetImageHashPrefix, imageHash]);\n}\nfunction decodeMessageSetImageHash(message) {\n  const arr = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(message);\n  if (arr.length !== 64) {\n    return undefined;\n  }\n  if (ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(0, 32)) !== SetImageHashPrefix) {\n    return undefined;\n  }\n  return ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(32, 64));\n}\nfunction isMessageSetImageHash(message) {\n  return decodeMessageSetImageHash(message) !== undefined;\n}\n\nvar chained = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SetImageHashPrefix: SetImageHashPrefix,\n  hashSetImageHash: hashSetImageHash,\n  messageSetImageHash: messageSetImageHash,\n  decodeMessageSetImageHash: decodeMessageSetImageHash,\n  isMessageSetImageHash: isMessageSetImageHash\n});\n\nlet SignatureType = /*#__PURE__*/function (SignatureType) {\n  SignatureType[SignatureType[\"Legacy\"] = 0] = \"Legacy\";\n  SignatureType[SignatureType[\"Dynamic\"] = 1] = \"Dynamic\";\n  SignatureType[SignatureType[\"NoChainIdDynamic\"] = 2] = \"NoChainIdDynamic\";\n  SignatureType[SignatureType[\"Chained\"] = 3] = \"Chained\";\n  return SignatureType;\n}({});\nlet SignaturePartType = /*#__PURE__*/function (SignaturePartType) {\n  SignaturePartType[SignaturePartType[\"Signature\"] = 0] = \"Signature\";\n  SignaturePartType[SignaturePartType[\"Address\"] = 1] = \"Address\";\n  SignaturePartType[SignaturePartType[\"DynamicSignature\"] = 2] = \"DynamicSignature\";\n  SignaturePartType[SignaturePartType[\"Node\"] = 3] = \"Node\";\n  SignaturePartType[SignaturePartType[\"Branch\"] = 4] = \"Branch\";\n  SignaturePartType[SignaturePartType[\"Subdigest\"] = 5] = \"Subdigest\";\n  SignaturePartType[SignaturePartType[\"Nested\"] = 6] = \"Nested\";\n  return SignaturePartType;\n}({});\nconst SignaturePartTypeLength = 66;\nfunction isUnrecoveredNode(node) {\n  return node.left !== undefined && node.right !== undefined;\n}\nfunction isUnrecoveredNestedLeaf(leaf) {\n  return leaf.tree !== undefined;\n}\nfunction isUnrecoveredSignatureLeaf(leaf) {\n  return leaf.unrecovered && leaf.signature !== undefined && leaf.isDynamic !== undefined;\n}\nfunction decodeSignatureTree(body) {\n  let arr = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(body);\n  let pointer;\n  const append = (prevPointer, node) => {\n    if (!prevPointer) {\n      return {\n        left: node\n      };\n    }\n    if (!prevPointer.right) {\n      return {\n        left: prevPointer.left,\n        right: node\n      };\n    }\n    return {\n      left: prevPointer,\n      right: node\n    };\n  };\n  while (arr.length > 0) {\n    const type = arr[0];\n    arr = arr.slice(1);\n    switch (type) {\n      case SignaturePartType.Signature:\n        {\n          const weight = arr[0];\n          const signature = ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(1, SignaturePartTypeLength + 1));\n          pointer = append(pointer, {\n            signature,\n            weight,\n            unrecovered: true,\n            isDynamic: false\n          });\n          arr = arr.slice(SignaturePartTypeLength + 1);\n        }\n        break;\n      case SignaturePartType.Address:\n        {\n          const weight = arr[0];\n          const address = ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(1, 21)));\n          pointer = append(pointer, {\n            address,\n            weight\n          });\n          arr = arr.slice(21);\n        }\n        break;\n      case SignaturePartType.DynamicSignature:\n        {\n          const weight = arr[0];\n          const address = ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(1, 21)));\n          const size = arr[21] << 16 | arr[22] << 8 | arr[23];\n          const signature = ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(24, 24 + size));\n          pointer = append(pointer, {\n            address,\n            signature,\n            weight,\n            unrecovered: true,\n            isDynamic: true\n          });\n          arr = arr.slice(24 + size);\n        }\n        break;\n      case SignaturePartType.Node:\n        {\n          const nodeHash = ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(0, 32));\n          pointer = append(pointer, {\n            nodeHash\n          });\n          arr = arr.slice(32);\n        }\n        break;\n      case SignaturePartType.Branch:\n        {\n          const size = arr[0] << 16 | arr[1] << 8 | arr[2];\n          const branch = decodeSignatureTree(arr.slice(3, 3 + size));\n          pointer = append(pointer, branch);\n          arr = arr.slice(3 + size);\n        }\n        break;\n      case SignaturePartType.Subdigest:\n        {\n          const subdigest = ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr.slice(0, 32));\n          pointer = append(pointer, {\n            subdigest\n          });\n          arr = arr.slice(32);\n        }\n        break;\n      case SignaturePartType.Nested:\n        {\n          const weight = arr[0];\n          const threshold = arr[1] << 8 | arr[2];\n          const size = arr[3] << 16 | arr[4] << 8 | arr[5];\n          const tree = decodeSignatureTree(arr.slice(6, 6 + size));\n          pointer = append(pointer, {\n            weight,\n            threshold,\n            tree\n          });\n          arr = arr.slice(6 + size);\n        }\n        break;\n      default:\n        throw new Error(`Unknown signature part type: ${type}: ${ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(arr)}`);\n    }\n  }\n  if (!pointer) {\n    throw new Error('Empty signature tree');\n  }\n  if (pointer.right) {\n    return pointer;\n  }\n  return pointer.left;\n}\nclass InvalidSignatureLeafError extends Error {\n  constructor(leaf) {\n    super(`Invalid signature leaf: ${JSON.stringify(leaf)}`);\n    this.leaf = leaf;\n  }\n}\nasync function recoverTopology(unrecovered, subdigest, provider) {\n  if (isUnrecoveredNode(unrecovered)) {\n    const [left, right] = await Promise.all([recoverTopology(unrecovered.left, subdigest, provider), recoverTopology(unrecovered.right, subdigest, provider)]);\n    return {\n      left,\n      right\n    };\n  }\n  if (isUnrecoveredNestedLeaf(unrecovered)) {\n    return {\n      weight: unrecovered.weight,\n      threshold: unrecovered.threshold,\n      tree: await recoverTopology(unrecovered.tree, subdigest, provider)\n    };\n  }\n  if (isUnrecoveredSignatureLeaf(unrecovered)) {\n    if (unrecovered.isDynamic) {\n      if (!unrecovered.address) {\n        throw new Error('Dynamic signature leaf without address');\n      }\n      const isValid = await isValidSignature(unrecovered.address, subdigest, unrecovered.signature, provider);\n      if (!isValid) {\n        throw new InvalidSignatureLeafError(unrecovered);\n      }\n      return {\n        weight: unrecovered.weight,\n        address: unrecovered.address,\n        signature: unrecovered.signature,\n        subdigest\n      };\n    } else {\n      return {\n        weight: unrecovered.weight,\n        address: recoverSigner(subdigest, unrecovered.signature),\n        signature: unrecovered.signature,\n        subdigest\n      };\n    }\n  }\n  return unrecovered;\n}\n\n// TODO: It should be possible to re-use encodeSignatureTree\n// and avoid duplicating this logic\nconst partEncoder = {\n  concat: (a, b) => {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes', 'bytes'], [a, b]);\n  },\n  node: nodeHash => {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Node, nodeHash]);\n  },\n  branch: tree => {\n    const arr = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(tree);\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint24', 'bytes'], [SignaturePartType.Branch, arr.length, arr]);\n  },\n  nested: (weight, threshold, tree) => {\n    const arr = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(tree);\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'uint16', 'uint24', 'bytes'], [SignaturePartType.Nested, weight, threshold, arr.length, arr]);\n  },\n  subdigest: subdigest => {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Subdigest, subdigest]);\n  },\n  signature: (weight, signature) => {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'bytes'], [SignaturePartType.Signature, weight, signature]);\n  },\n  dynamicSignature: (weight, address, signature) => {\n    const arrSignature = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'address', 'uint24', 'bytes'], [SignaturePartType.DynamicSignature, weight, address, arrSignature.length, arrSignature]);\n  },\n  address: (weight, address) => {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'address'], [SignaturePartType.Address, weight, address]);\n  }\n};\nfunction encodeSigners(config, parts, subdigests, chainId, options = {}) {\n  const tree = encodeTree(config.tree, parts, subdigests, options);\n  if (BigInt(chainId) === 0n) {\n    return {\n      encoded: ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint16', 'uint32', 'bytes'], [SignatureType.NoChainIdDynamic, config.threshold, config.checkpoint, tree.encoded]),\n      weight: tree.weight\n    };\n  }\n  if (BigInt(config.threshold) > 255n) {\n    return {\n      encoded: ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint16', 'uint32', 'bytes'], [SignatureType.Dynamic, config.threshold, config.checkpoint, tree.encoded]),\n      weight: tree.weight\n    };\n  }\n  return {\n    encoded: ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'uint32', 'bytes'], [SignatureType.Legacy, config.threshold, config.checkpoint, tree.encoded]),\n    weight: tree.weight\n  };\n}\nfunction encodeTree(topology, parts, subdigests, options = {}) {\n  const trim = !options.disableTrim;\n  if (isNode(topology)) {\n    const left = encodeTree(topology.left, parts, subdigests);\n    const right = encodeTree(topology.right, parts, subdigests);\n    const isLeftSigner = isSignerLeaf(topology.left);\n    const isRightSigner = isSignerLeaf(topology.right);\n    if (trim && left.weight === 0n && right.weight === 0n && !isLeftSigner && !isRightSigner) {\n      return {\n        // We don't need to include anything for this node\n        // just the hash will be enough\n        encoded: partEncoder.node(hashNode(topology)),\n        weight: 0n\n      };\n    }\n    if (trim && right.weight === 0n && !isRightSigner) {\n      return {\n        // The right node doesn't have any weight\n        // but we still need to include the left node encoded\n        encoded: partEncoder.concat(left.encoded, partEncoder.node(hashNode(topology.right))),\n        weight: left.weight\n      };\n    }\n    if (trim && left.weight === 0n && !isLeftSigner) {\n      return {\n        // The left node doesn't have any weight\n        // we can just append its hash, but for the right node\n        // we need to create a new \"branch\"\n        encoded: partEncoder.concat(partEncoder.node(hashNode(topology.left)), partEncoder.branch(right.encoded)),\n        weight: right.weight\n      };\n    }\n    return {\n      // Both nodes have weight, we need to include both\n      // the right one must be a branch\n      encoded: partEncoder.concat(left.encoded, partEncoder.branch(right.encoded)),\n      weight: left.weight + right.weight\n    };\n  }\n  if (isNestedLeaf(topology)) {\n    const tree = encodeTree(topology.tree, parts, subdigests);\n    if (trim && tree.weight === 0n) {\n      return {\n        encoded: partEncoder.node(hashNode(topology)),\n        weight: 0n\n      };\n    }\n    return {\n      encoded: partEncoder.nested(topology.weight, topology.threshold, tree.encoded),\n      weight: tree.weight\n    };\n  }\n  if (isNodeLeaf(topology)) {\n    return {\n      encoded: partEncoder.node(hashNode(topology)),\n      weight: 0n\n    };\n  }\n  if (isSubdigestLeaf(topology)) {\n    const include = subdigests.includes(topology.subdigest);\n    return {\n      encoded: partEncoder.subdigest(topology.subdigest),\n      weight: include ? _0xsequence_utils__WEBPACK_IMPORTED_MODULE_1__.MAX_UINT_256 : 0n\n    };\n  }\n  if (isSignerLeaf(topology)) {\n    const include = parts.has(topology.address);\n    if (include) {\n      const part = parts.get(topology.address);\n      const signature = part.signature;\n      if (options.forceDynamicEncoding || part.isDynamic) {\n        return {\n          encoded: partEncoder.dynamicSignature(topology.weight, topology.address, signature),\n          weight: BigInt(topology.weight)\n        };\n      } else {\n        return {\n          encoded: partEncoder.signature(topology.weight, signature),\n          weight: BigInt(topology.weight)\n        };\n      }\n    } else {\n      return {\n        encoded: partEncoder.address(topology.weight, topology.address),\n        weight: 0n\n      };\n    }\n  }\n  throw new Error(`Invalid topology - unknown error: ${JSON.stringify(topology)}`);\n}\nfunction deepestConfigOfSignature(signature) {\n  return isChainedSignature(signature) ? deepestConfigOfSignature(signature.suffix[signature.suffix.length - 1]) : signature.config;\n}\nfunction isUnrecoveredSignature(sig) {\n  return sig.type !== undefined && sig.decoded !== undefined && sig.version !== undefined && sig.version === 2;\n}\nfunction isUnrecoveredChainedSignature(sig) {\n  return sig.suffix !== undefined && Array.isArray(sig.suffix) && sig.suffix.every(isUnrecoveredSignature);\n}\nfunction isSignature(sig) {\n  return sig.type !== undefined && sig.config !== undefined && sig.digest !== undefined && sig.version !== undefined && sig.version === 2;\n}\nfunction isChainedSignature(sig) {\n  return sig.chain !== undefined && Array.isArray(sig.chain) && sig.chain.every(isSignature);\n}\nfunction decodeSignature(signature) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  const type = bytes[0];\n  switch (type) {\n    case SignatureType.Legacy:\n      return {\n        version: 2,\n        type: SignatureType.Legacy,\n        decoded: decodeSignatureBody(bytes)\n      };\n    case SignatureType.Dynamic:\n      return {\n        version: 2,\n        type: SignatureType.Dynamic,\n        decoded: decodeSignatureBody(bytes.slice(1))\n      };\n    case SignatureType.NoChainIdDynamic:\n      return {\n        version: 2,\n        type: SignatureType.NoChainIdDynamic,\n        decoded: decodeSignatureBody(bytes.slice(1))\n      };\n    case SignatureType.Chained:\n      return decodeChainedSignature(bytes);\n    default:\n      throw new Error(`Invalid signature type: ${type}`);\n  }\n}\nfunction decodeSignatureBody(signature) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  const threshold = bytes[0] << 8 | bytes[1];\n  const checkpoint = bytes[2] << 24 | bytes[3] << 16 | bytes[4] << 8 | bytes[5];\n  const tree = decodeSignatureTree(bytes.slice(6));\n  return {\n    threshold,\n    checkpoint,\n    tree\n  };\n}\nfunction decodeChainedSignature(signature) {\n  const arr = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(signature);\n  const type = arr[0];\n  if (type !== SignatureType.Chained) {\n    throw new Error(`Expected chained signature type: ${type}`);\n  }\n  const chain = [];\n  let index = 1;\n  while (index < arr.length) {\n    const size = arr[index] << 16 | arr[index + 1] << 8 | arr[index + 2];\n    index += 3;\n    const sig = decodeSignature(arr.slice(index, index + size));\n    chain.push(sig);\n    index += size;\n  }\n  const main = chain[0];\n  if (isUnrecoveredChainedSignature(main)) {\n    throw new Error(`Expected first link of chained signature to be a simple signature (not chained)`);\n  }\n  const suffix = chain.slice(1);\n  return _extends({}, main, {\n    suffix\n  });\n}\nfunction setImageHashStruct(imageHash) {\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes32', 'bytes32'], [ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['string'], ['SetImageHash(bytes32 imageHash)']), imageHash]);\n}\nasync function recoverSignature(signature, payload, provider) {\n  const signedPayload = payload.subdigest === undefined ? payload : undefined;\n  const isNoChainId = signature.type === SignatureType.NoChainIdDynamic;\n  if (isNoChainId && signedPayload) {\n    signedPayload.chainId = 0;\n  }\n  const subdigest = signedPayload ? subdigestOf(signedPayload) : payload.subdigest;\n  if (!isUnrecoveredChainedSignature(signature)) {\n    const tree = await recoverTopology(signature.decoded.tree, subdigest, provider);\n    return {\n      version: 2,\n      type: signature.type,\n      subdigest,\n      config: _extends({\n        version: 2\n      }, signature.decoded, {\n        tree\n      })\n    };\n  }\n  if (!isSignedPayload(signedPayload)) {\n    throw new Error(`Chained signature recovery requires detailed signed payload, subdigest is not enough`);\n  }\n  const result = [];\n  let mutatedPayload = signedPayload;\n\n  // Recover the chain of signatures\n  // NOTICE: Remove the suffix from the \"first\" siganture\n  // otherwise we recurse infinitely\n  for (const sig of [_extends({}, signature, {\n    suffix: undefined\n  }), ...signature.suffix]) {\n    const recovered = await recoverSignature(sig, mutatedPayload, provider);\n    result.unshift(recovered);\n    const nextMessage = setImageHashStruct(imageHash(deepestConfigOfSignature(recovered)));\n    mutatedPayload = _extends({}, mutatedPayload, {\n      message: nextMessage,\n      digest: ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(nextMessage)\n    });\n  }\n  const main = result[0];\n  const suffix = result.slice(1);\n  return _extends({}, main, {\n    suffix\n  });\n}\nfunction encodeChain(main, suffix) {\n  const allSignatures = [main, ...(suffix || [])];\n  const encodedMap = allSignatures.map(s => ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(encodeSignature(s)));\n  const body = ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(encodedMap.map(() => ['uint24', 'bytes']).flat(), encodedMap.map(s => [s.length, s]).flat());\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'bytes'], [SignatureType.Chained, body]);\n}\nfunction encodeSignature(decoded) {\n  if (ethers__WEBPACK_IMPORTED_MODULE_4__.isBytesLike(decoded)) return ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(decoded);\n  if (isUnrecoveredChainedSignature(decoded) || isChainedSignature(decoded)) {\n    return encodeChain(encodeSignature(decoded), (decoded.suffix || []).map(encodeSignature));\n  }\n  const body = isUnrecoveredSignature(decoded) ? decoded.decoded : decoded.config;\n  switch (decoded.type) {\n    case SignatureType.Legacy:\n      if (BigInt(body.threshold) > 255n) {\n        throw new Error(`Legacy signature threshold is too large: ${body.threshold} (max 255)`);\n      }\n      return encodeSignatureBody(body);\n    case SignatureType.NoChainIdDynamic:\n    case SignatureType.Dynamic:\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'bytes'], [decoded.type, encodeSignatureBody(body)]);\n    case SignatureType.Chained:\n      throw new Error(`Unreachable code: Chained signature should be handled above`);\n    default:\n      throw new Error(`Invalid signature type: ${decoded.type}`);\n  }\n}\nfunction encodeSignatureBody(decoded) {\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint16', 'uint32', 'bytes'], [decoded.threshold, decoded.checkpoint, encodeSignatureTree(decoded.tree)]);\n}\nfunction encodeSignatureTree(tree) {\n  if (isNode(tree) || isUnrecoveredNode(tree)) {\n    const encodedRight = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(encodeSignatureTree(tree.right));\n    const encodedLeft = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(encodeSignatureTree(tree.left));\n    const isBranching = isNode(tree.right) || isUnrecoveredNode(tree.right);\n    if (isBranching) {\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes', 'uint8', 'uint24', 'bytes'], [encodedLeft, SignaturePartType.Branch, encodedRight.length, encodedRight]);\n    } else {\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes', 'bytes'], [encodedLeft, encodedRight]);\n    }\n  }\n  if (isNestedLeaf(tree) || isUnrecoveredNestedLeaf(tree)) {\n    const nested = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(encodeSignatureTree(tree.tree));\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'uint16', 'uint24', 'bytes'], [SignaturePartType.Nested, tree.weight, tree.threshold, nested.length, nested]);\n  }\n  if (isUnrecoveredSignatureLeaf(tree) || isSignerLeaf(tree) && tree.signature !== undefined) {\n    const signature = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(tree.signature);\n    if (tree.isDynamic || signature.length !== SignaturePartTypeLength) {\n      if (!tree.address) throw new Error(`Dynamic signature leaf must have address`);\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'address', 'uint24', 'bytes'], [SignaturePartType.DynamicSignature, tree.weight, tree.address, signature.length, signature]);\n    } else {\n      return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'bytes'], [SignaturePartType.Signature, tree.weight, signature]);\n    }\n  }\n  if (isSignerLeaf(tree)) {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'uint8', 'address'], [SignaturePartType.Address, tree.weight, tree.address]);\n  }\n  if (isNodeLeaf(tree)) {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Node, tree.nodeHash]);\n  }\n  if (isSubdigestLeaf(tree)) {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Subdigest, tree.subdigest]);\n  }\n  throw new Error(`Unknown signature tree type: ${tree}`);\n}\nfunction signaturesOf(topology) {\n  if (isNode(topology)) {\n    return [...signaturesOf(topology.left), ...signaturesOf(topology.right)];\n  }\n  if (isNestedLeaf(topology)) {\n    return signaturesOf(topology.tree);\n  }\n  if (isSignerLeaf(topology) && topology.signature) {\n    return [{\n      address: topology.address,\n      signature: topology.signature\n    }];\n  }\n  return [];\n}\nfunction signaturesOfDecoded(utopology) {\n  if (isUnrecoveredNode(utopology)) {\n    return [...signaturesOfDecoded(utopology.left), ...signaturesOfDecoded(utopology.right)];\n  }\n  if (isUnrecoveredNestedLeaf(utopology)) {\n    return signaturesOfDecoded(utopology.tree);\n  }\n  if (isUnrecoveredSignatureLeaf(utopology)) {\n    return [utopology.signature];\n  }\n  return [];\n}\nfunction subdigestsOfDecoded(utopology) {\n  if (isUnrecoveredNode(utopology)) {\n    return [...subdigestsOfDecoded(utopology.left), ...subdigestsOfDecoded(utopology.right)];\n  }\n  if (isUnrecoveredNestedLeaf(utopology)) {\n    return subdigestsOfDecoded(utopology.tree);\n  }\n  if (isSubdigestLeaf(utopology)) {\n    return [utopology.subdigest];\n  }\n  return [];\n}\nasync function trimSignature(signature) {\n  const decoded = typeof signature === 'string' ? decodeSignature(signature) : signature;\n  if (isUnrecoveredChainedSignature(decoded)) {\n    // We need to trim every suffix AND the main signature\n    const _trimmed = await Promise.all([trimSignature(_extends({}, decoded, {\n      suffix: undefined\n    })), ...decoded.suffix.map(s => trimSignature(s))]);\n    return encodeChain(_trimmed[0], _trimmed.slice(1));\n  }\n  const {\n    trimmed\n  } = await trimUnrecoveredTree(decoded.decoded.tree);\n  return encodeSignature(_extends({}, decoded, {\n    decoded: _extends({}, decoded.decoded, {\n      tree: trimmed\n    })\n  }));\n}\nasync function trimUnrecoveredTree(tree, trimStaticDigest = true) {\n  if (isUnrecoveredNode(tree)) {\n    const [left, right] = await Promise.all([trimUnrecoveredTree(tree.left), trimUnrecoveredTree(tree.right)]);\n    if (left.weight === 0 && right.weight === 0) {\n      try {\n        // If both weights are 0 then it means we don't have any signatures yet\n        // because of that, we should be able to \"recover\" the tree with any subdigest\n        // and still get the valid node hash (there shouldn't be any signatures to verify)\n        const recovered = await recoverTopology(tree, ethers__WEBPACK_IMPORTED_MODULE_11__.ZeroHash, undefined);\n        return {\n          weight: 0,\n          trimmed: {\n            nodeHash: hashNode(recovered)\n          }\n        };\n      } catch (_unused) {\n        // If something fails it's more likely because some signatures have sneaked in\n        // in that case we should keep this node\n      }\n    } else {\n      return {\n        weight: left.weight + right.weight,\n        trimmed: {\n          left: left.trimmed,\n          right: right.trimmed\n        }\n      };\n    }\n  }\n  if (isUnrecoveredNestedLeaf(tree)) {\n    const trimmed = await trimUnrecoveredTree(tree.tree);\n    if (trimmed.weight === 0) {\n      try {\n        // If the nested leaf is empty, we can recover it with any subdigest\n        // and still get the valid node hash (there shouldn't be any signatures to verify)\n        const recovered = await recoverTopology(tree, ethers__WEBPACK_IMPORTED_MODULE_11__.ZeroHash, undefined);\n        return {\n          weight: 0,\n          trimmed: {\n            nodeHash: hashNode(recovered)\n          }\n        };\n      } catch (_unused2) {\n        // If something fails it's more likely because some signatures have sneaked in\n        // in that case we should keep this node\n      }\n    }\n    return {\n      weight: trimmed.weight,\n      trimmed: {\n        weight: tree.weight,\n        threshold: tree.threshold,\n        tree: trimmed.trimmed\n      }\n    };\n  }\n\n  // Hash nodes can be encoded as signer leaves if they have a weight below\n  // 256, most likely the are signer leaves wrongly encoded\n  if (isNodeLeaf(tree) && isEncodedSignerLeaf(tree.nodeHash)) {\n    return {\n      weight: 0,\n      trimmed: _extends({}, decodeSignerLeaf(tree.nodeHash))\n    };\n  }\n  if (isUnrecoveredSignatureLeaf(tree) || isSignerLeaf(tree) && tree.signature !== undefined) {\n    return {\n      weight: Number(tree.weight),\n      trimmed: tree\n    };\n  }\n  if (!trimStaticDigest && isSubdigestLeaf(tree)) {\n    return {\n      weight: +Infinity,\n      trimmed: tree\n    };\n  }\n  return {\n    weight: 0,\n    trimmed: tree\n  };\n}\nconst SignatureCoder = {\n  decode: data => {\n    return decodeSignature(data);\n  },\n  encode: data => {\n    return encodeSignature(data);\n  },\n  trim: data => {\n    return trimSignature(data);\n  },\n  supportsNoChainId: true,\n  recover: (data, payload, provider) => {\n    return recoverSignature(data, payload, provider);\n  },\n  encodeSigners: (config, signatures, subdigests, chainId) => {\n    return encodeSigners(config, signatures, subdigests, chainId);\n  },\n  hasEnoughSigningPower: (config, signatures) => {\n    const {\n      weight\n    } = SignatureCoder.encodeSigners(config, signatures, [], 0);\n    return weight >= BigInt(config.threshold);\n  },\n  chainSignatures: (main, suffix) => {\n    // Notice: v2 expects suffix to be reversed\n    // that being: from signed to current imageHash\n    const reversed = suffix.reverse();\n    const mraw = ethers__WEBPACK_IMPORTED_MODULE_4__.isBytesLike(main) ? main : encodeSignature(main);\n    const sraw = reversed.map(s => ethers__WEBPACK_IMPORTED_MODULE_4__.isBytesLike(s) ? s : encodeSignature(s));\n    return encodeChain(mraw, sraw);\n  },\n  hashSetImageHash: function (imageHash) {\n    return hashSetImageHash(imageHash);\n  },\n  signaturesOf(config) {\n    return signaturesOf(config.tree);\n  },\n  signaturesOfDecoded: function (data) {\n    return signaturesOfDecoded(data.decoded.tree);\n  }\n};\n\nvar signature = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SignatureType: SignatureType,\n  SignaturePartType: SignaturePartType,\n  SignaturePartTypeLength: SignaturePartTypeLength,\n  isUnrecoveredNode: isUnrecoveredNode,\n  isUnrecoveredNestedLeaf: isUnrecoveredNestedLeaf,\n  isUnrecoveredSignatureLeaf: isUnrecoveredSignatureLeaf,\n  decodeSignatureTree: decodeSignatureTree,\n  InvalidSignatureLeafError: InvalidSignatureLeafError,\n  recoverTopology: recoverTopology,\n  partEncoder: partEncoder,\n  encodeSigners: encodeSigners,\n  encodeTree: encodeTree,\n  deepestConfigOfSignature: deepestConfigOfSignature,\n  isUnrecoveredSignature: isUnrecoveredSignature,\n  isUnrecoveredChainedSignature: isUnrecoveredChainedSignature,\n  isSignature: isSignature,\n  isChainedSignature: isChainedSignature,\n  decodeSignature: decodeSignature,\n  decodeSignatureBody: decodeSignatureBody,\n  decodeChainedSignature: decodeChainedSignature,\n  setImageHashStruct: setImageHashStruct,\n  recoverSignature: recoverSignature,\n  encodeChain: encodeChain,\n  encodeSignature: encodeSignature,\n  encodeSignatureBody: encodeSignatureBody,\n  encodeSignatureTree: encodeSignatureTree,\n  signaturesOf: signaturesOf,\n  signaturesOfDecoded: signaturesOfDecoded,\n  subdigestsOfDecoded: subdigestsOfDecoded,\n  trimSignature: trimSignature,\n  trimUnrecoveredTree: trimUnrecoveredTree,\n  SignatureCoder: SignatureCoder\n});\n\n//\n// Tree typings - leaves\n//\n\n// This is an unknown node\n// it means the tree has a branch\n// but we don't know what the content\n\nfunction isSignerLeaf(leaf) {\n  return leaf.address !== undefined && leaf.weight !== undefined;\n}\nfunction isSubdigestLeaf(leaf) {\n  return leaf.subdigest !== undefined && leaf.address === undefined;\n}\nfunction topologyToJSON(tree) {\n  if (isNode(tree)) {\n    return JSON.stringify({\n      left: topologyToJSON(tree.left),\n      right: topologyToJSON(tree.right)\n    });\n  }\n  if (isNestedLeaf(tree)) {\n    return JSON.stringify({\n      weight: BigInt(tree.weight).toString(),\n      threshold: BigInt(tree.threshold).toString(),\n      tree: topologyToJSON(tree.tree)\n    });\n  }\n  if (isSignerLeaf(tree)) {\n    return JSON.stringify({\n      address: tree.address,\n      weight: BigInt(tree.weight).toString()\n    });\n  }\n  return JSON.stringify(tree);\n}\nfunction topologyFromJSON(json) {\n  const parsed = typeof json === 'string' ? JSON.parse(json) : json;\n  if (parsed.left !== undefined && parsed.right !== undefined) {\n    return {\n      left: topologyFromJSON(parsed.left),\n      right: topologyFromJSON(parsed.right)\n    };\n  }\n  if (parsed.weight !== undefined && parsed.threshold !== undefined && parsed.tree !== undefined) {\n    return {\n      weight: BigInt(parsed.weight),\n      threshold: BigInt(parsed.threshold),\n      tree: topologyFromJSON(parsed.tree)\n    };\n  }\n  if (parsed.address !== undefined && parsed.weight !== undefined) {\n    return {\n      address: parsed.address,\n      weight: BigInt(parsed.weight)\n    };\n  }\n  return parsed;\n}\nfunction isNestedLeaf(leaf) {\n  return leaf.tree !== undefined && leaf.weight !== undefined && leaf.threshold !== undefined;\n}\nfunction isNodeLeaf(leaf) {\n  return leaf.nodeHash !== undefined;\n}\nfunction isLeaf(leaf) {\n  return isSignerLeaf(leaf) || isSubdigestLeaf(leaf) || isNestedLeaf(leaf) || isNodeLeaf(leaf);\n}\n\n//\n// Tree typings - nodes\n//\n\nfunction isNode(node) {\n  return node.left !== undefined && node.right !== undefined;\n}\nfunction isTopology(topology) {\n  return isNode(topology) || isLeaf(topology);\n}\nfunction encodeSignerLeaf(leaf) {\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['uint96', 'address'], [leaf.weight, leaf.address]);\n}\nfunction decodeSignerLeaf(encoded) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(encoded);\n  if (bytes.length !== 32) {\n    throw new Error('Invalid encoded string length');\n  }\n  const weight = BigInt(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(0, 12)));\n  const address = ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(bytes.slice(12)));\n  return {\n    weight,\n    address\n  };\n}\nfunction isEncodedSignerLeaf(encoded) {\n  const bytes = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(encoded);\n  if (bytes.length !== 32) {\n    return false;\n  }\n  const prefix = bytes.slice(0, 11);\n  return prefix.every(byte => byte === 0);\n}\nfunction hashNode(node) {\n  if (isSignerLeaf(node)) {\n    return encodeSignerLeaf(node);\n  }\n  if (isSubdigestLeaf(node)) {\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['string', 'bytes32'], ['Sequence static digest:\\n', node.subdigest]);\n  }\n  if (isNestedLeaf(node)) {\n    const nested = hashNode(node.tree);\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['string', 'bytes32', 'uint256', 'uint256'], ['Sequence nested config:\\n', nested, node.threshold, node.weight]);\n  }\n  if (isNodeLeaf(node)) {\n    return node.nodeHash;\n  }\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['bytes32', 'bytes32'], [hashNode(node.left), hashNode(node.right)]);\n}\nfunction leftFace(topology) {\n  const stack = [];\n  let prev = topology;\n  while (!isLeaf(prev)) {\n    stack.unshift(prev.right);\n    prev = prev.left;\n  }\n  stack.unshift(prev);\n  return stack;\n}\n\n//\n// Wallet config types\n//\n\nfunction isWalletConfig(config) {\n  return config.threshold !== undefined && config.checkpoint !== undefined && config.tree !== undefined && config.version !== undefined && config.version === 2;\n}\nfunction imageHash(config) {\n  return ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['bytes32', 'uint256'], [ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPackedKeccak256(['bytes32', 'uint256'], [hashNode(config.tree), config.threshold]), config.checkpoint]);\n}\n\n//\n// Simple wallet config types\n// (used for building and reading merkle configs)\n//\n// dev: `members` is a flat representation of the tree\n//      it keeps relevant structure like 'nested trees' but\n//      it ignores the tree structure\n//\n//\n\nfunction isSimpleNestedMember(member) {\n  return member.threshold !== undefined && member.weight !== undefined && member.members !== undefined;\n}\nfunction topologyToMembers(tree) {\n  if (isSignerLeaf(tree) || isSubdigestLeaf(tree)) {\n    return [tree];\n  }\n  if (isNestedLeaf(tree)) {\n    return [{\n      threshold: tree.threshold,\n      weight: tree.weight,\n      members: topologyToMembers(tree.tree)\n    }];\n  }\n  if (isNodeLeaf(tree)) {\n    // we don't know the content of this node\n    // so we omit it\n    return [];\n  }\n  return [...topologyToMembers(tree.left), ...topologyToMembers(tree.right)];\n}\nfunction hasUnknownNodes(tree) {\n  if (isNodeLeaf(tree)) {\n    return true;\n  }\n  if (isNode(tree)) {\n    return hasUnknownNodes(tree.left) || hasUnknownNodes(tree.right);\n  }\n  return false;\n}\nfunction toSimpleWalletConfig(config) {\n  return {\n    threshold: config.threshold,\n    checkpoint: config.checkpoint,\n    members: topologyToMembers(config.tree)\n  };\n}\nconst membersAsTopologies = (members, builder) => {\n  return members.map(member => {\n    if (isSimpleNestedMember(member)) {\n      return {\n        tree: builder(member.members),\n        threshold: member.threshold,\n        weight: member.weight\n      };\n    }\n    return member;\n  });\n};\nfunction legacyTopologyBuilder(members) {\n  if (members.length === 0) {\n    throw new Error('Empty members array');\n  }\n  const asTopologies = membersAsTopologies(members, legacyTopologyBuilder);\n  return asTopologies.reduce((acc, member) => {\n    return {\n      left: acc,\n      right: member\n    };\n  });\n}\nfunction merkleTopologyBuilder(members) {\n  if (members.length === 0) {\n    throw new Error('Empty members array');\n  }\n  const leaves = membersAsTopologies(members, merkleTopologyBuilder);\n  for (let s = leaves.length; s > 1; s = s / 2) {\n    for (let i = 0; i < s / 2; i++) {\n      const j1 = i * 2;\n      const j2 = j1 + 1;\n      if (j2 >= s) {\n        leaves[i] = leaves[j1];\n      } else {\n        leaves[i] = {\n          left: leaves[j1],\n          right: leaves[j2]\n        };\n      }\n    }\n  }\n  return leaves[0];\n}\nfunction optimized2SignersTopologyBuilder(members) {\n  if (members.length > 8) {\n    return merkleTopologyBuilder(members);\n  }\n  return legacyTopologyBuilder(members);\n}\nfunction toWalletConfig(simpleWalletConfig, builder = optimized2SignersTopologyBuilder) {\n  return {\n    version: 2,\n    threshold: simpleWalletConfig.threshold,\n    checkpoint: simpleWalletConfig.checkpoint,\n    tree: builder(simpleWalletConfig.members)\n  };\n}\nfunction hasSubdigest(tree, subdigest) {\n  if (isSubdigestLeaf(tree)) {\n    return tree.subdigest === subdigest;\n  }\n  if (isNode(tree)) {\n    return hasSubdigest(tree.left, subdigest) || hasSubdigest(tree.right, subdigest);\n  }\n  return false;\n}\nfunction signersOf(tree) {\n  const stack = [tree];\n  const signers = new Set();\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (isNestedLeaf(node)) {\n      stack.push(node.tree);\n    } else if (isNode(node)) {\n      stack.push(node.left);\n      stack.push(node.right);\n    } else if (isSignerLeaf(node)) {\n      signers.add({\n        address: node.address,\n        weight: Number(node.weight)\n      });\n    }\n  }\n  return Array.from(signers);\n}\nfunction isComplete(tree) {\n  if (isNode(tree)) {\n    return isComplete(tree.left) && isComplete(tree.right);\n  }\n  return !isNodeLeaf(tree);\n}\nconst ConfigCoder = {\n  isWalletConfig: config => {\n    return config.version === 2 && config.threshold !== undefined && config.tree !== undefined;\n  },\n  imageHashOf: config => {\n    return imageHash(config);\n  },\n  hasSubdigest: (config, subdigest) => {\n    return hasSubdigest(config.tree, subdigest);\n  },\n  checkpointOf: config => {\n    return BigInt(config.checkpoint);\n  },\n  signersOf: config => {\n    return signersOf(config.tree);\n  },\n  fromSimple: config => {\n    var _config$subdigests;\n    return toWalletConfig(_extends({}, config, {\n      members: [...config.signers, ...((_config$subdigests = config.subdigests) != null ? _config$subdigests : []).map(subdigest => ({\n        subdigest\n      }))]\n    }));\n  },\n  isComplete: config => {\n    return isComplete(config.tree);\n  },\n  // isValid = (config: WalletConfig): boolean {}\n  /**\n   *\n   * Notice: context and kind are ignored because v2\n   * doesn't need to manually update the implementation before\n   * a configuration update, it's automatically done by the contract.\n   *\n   */\n  update: {\n    isKindUsed: true,\n    buildTransaction: (wallet, config, _context, _kind) => {\n      const module = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(_0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModuleUpgradable.abi);\n      return {\n        entrypoint: wallet,\n        transactions: [{\n          to: wallet,\n          data: module.encodeFunctionData(module.getFunction('updateImageHash'), [ConfigCoder.imageHashOf(config)]),\n          gasLimit: 0,\n          delegateCall: false,\n          revertOnError: true,\n          value: 0\n        }]\n      };\n    },\n    decodeTransaction: function (tx) {\n      var _tx$transactions$0$va, _tx$transactions$, _tx$transactions$0$ga, _tx$transactions$2;\n      const module = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(_0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModuleUpgradable.abi);\n      if (tx.transactions.length !== 1) {\n        throw new Error('Invalid transaction bundle, expected 1 transaction');\n      }\n      const data = tx.transactions[0].data;\n      if (!data) {\n        throw new Error('Invalid transaction bundle, expected data');\n      }\n      const decoded = module.decodeFunctionData(module.getFunction('updateImageHash'), data);\n      if (!decoded) {\n        throw new Error('Invalid transaction bundle, expected valid data');\n      }\n      if (tx.transactions[0].to !== tx.entrypoint) {\n        throw new Error('Invalid transaction bundle, expected to be sent to entrypoint');\n      }\n      if (tx.transactions[0].delegateCall) {\n        throw new Error('Invalid transaction bundle, expected not to be a delegateCall');\n      }\n      if (!tx.transactions[0].revertOnError) {\n        throw new Error('Invalid transaction bundle, expected revertOnError');\n      }\n      if (BigInt((_tx$transactions$0$va = (_tx$transactions$ = tx.transactions[0]) == null ? void 0 : _tx$transactions$.value) != null ? _tx$transactions$0$va : 0) !== 0n) {\n        throw new Error('Invalid transaction bundle, expected value to be 0');\n      }\n      if (BigInt((_tx$transactions$0$ga = (_tx$transactions$2 = tx.transactions[0]) == null ? void 0 : _tx$transactions$2.gasLimit) != null ? _tx$transactions$0$ga : 0) !== 0n) {\n        throw new Error('Invalid transaction bundle, expected value to be 0');\n      }\n      return {\n        address: tx.entrypoint,\n        newImageHash: decoded[0],\n        kind: undefined\n      };\n    }\n  },\n  toJSON: function (config) {\n    return JSON.stringify({\n      version: config.version,\n      threshold: BigInt(config.threshold).toString(),\n      checkpoint: BigInt(config.checkpoint).toString(),\n      tree: topologyToJSON(config.tree)\n    });\n  },\n  fromJSON: function (json) {\n    const config = JSON.parse(json);\n    return {\n      version: config.version,\n      threshold: BigInt(config.threshold),\n      checkpoint: BigInt(config.checkpoint),\n      tree: topologyFromJSON(config.tree)\n    };\n  },\n  editConfig: function (config, action) {\n    var _action$threshold, _action$checkpoint;\n    const members = topologyToMembers(config.tree);\n    if (action.add) {\n      for (const signer of action.add) {\n        if (members.find(s => isSignerLeaf(s) && s.address === signer.address)) {\n          continue;\n        }\n        members.push({\n          address: signer.address,\n          weight: signer.weight\n        });\n      }\n    }\n    if (action.remove) {\n      for (const address of action.remove) {\n        const index = members.findIndex(s => isSignerLeaf(s) && s.address === address);\n        if (index >= 0) {\n          members.splice(index, 1);\n        }\n      }\n    }\n    return {\n      version: config.version,\n      threshold: (_action$threshold = action.threshold) != null ? _action$threshold : config.threshold,\n      checkpoint: (_action$checkpoint = action.checkpoint) != null ? _action$checkpoint : config.checkpoint,\n      tree: optimized2SignersTopologyBuilder(members)\n    };\n  },\n  buildStubSignature: function (config, overrides) {\n    const parts = new Map();\n    for (const [signer, signature] of overrides.entries()) {\n      parts.set(signer, {\n        signature,\n        isDynamic: true\n      });\n      const {\n        encoded,\n        weight\n      } = encodeSigners(config, parts, [], 0);\n      if (weight >= BigInt(config.threshold)) {\n        return encoded;\n      }\n    }\n    const signers = signersOf(config.tree);\n    for (const {\n      address\n    } of signers.sort(({\n      weight: a\n    }, {\n      weight: b\n    }) => a - b)) {\n      const signature = '0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02';\n      parts.set(address, {\n        signature,\n        isDynamic: false\n      });\n      const {\n        encoded,\n        weight\n      } = encodeSigners(config, parts, [], 0);\n      if (weight >= BigInt(config.threshold)) {\n        return encoded;\n      }\n    }\n    return encodeSigners(config, parts, [], 0).encoded;\n  }\n};\n\nvar config$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  isSignerLeaf: isSignerLeaf,\n  isSubdigestLeaf: isSubdigestLeaf,\n  topologyToJSON: topologyToJSON,\n  topologyFromJSON: topologyFromJSON,\n  isNestedLeaf: isNestedLeaf,\n  isNodeLeaf: isNodeLeaf,\n  isLeaf: isLeaf,\n  isNode: isNode,\n  isTopology: isTopology,\n  encodeSignerLeaf: encodeSignerLeaf,\n  decodeSignerLeaf: decodeSignerLeaf,\n  isEncodedSignerLeaf: isEncodedSignerLeaf,\n  hashNode: hashNode,\n  leftFace: leftFace,\n  isWalletConfig: isWalletConfig,\n  imageHash: imageHash,\n  isSimpleNestedMember: isSimpleNestedMember,\n  topologyToMembers: topologyToMembers,\n  hasUnknownNodes: hasUnknownNodes,\n  toSimpleWalletConfig: toSimpleWalletConfig,\n  legacyTopologyBuilder: legacyTopologyBuilder,\n  merkleTopologyBuilder: merkleTopologyBuilder,\n  optimized2SignersTopologyBuilder: optimized2SignersTopologyBuilder,\n  toWalletConfig: toWalletConfig,\n  hasSubdigest: hasSubdigest,\n  signersOf: signersOf,\n  isComplete: isComplete,\n  ConfigCoder: ConfigCoder\n});\n\nvar context$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nconst coders = {\n  config: ConfigCoder,\n  signature: SignatureCoder\n};\nconst version = 2;\nconst DeployedWalletContext = {\n  version: version,\n  factory: '0xFaA5c0b14d1bED5C888Ca655B9a8A5911F78eF4A',\n  guestModule: '0xfea230Ee243f88BC698dD8f1aE93F8301B6cdfaE',\n  mainModule: '0xfBf8f1A5E00034762D928f46d438B947f5d4065d',\n  mainModuleUpgradable: '0x4222dcA3974E39A8b41c411FeDDE9b09Ae14b911',\n  walletCreationCode: '0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3',\n  proxyImplementationHook: '0x1f56dbAD5e8319F0DE9a323E24A31b5077dEB1a4'\n};\n\nvar v2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  config: config$1,\n  signature: signature,\n  context: context$1,\n  chained: chained,\n  coders: coders,\n  version: version,\n  DeployedWalletContext: DeployedWalletContext\n});\n\nvar config = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nfunction addressOf(context, imageHash) {\n  const codeHash = ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes', 'bytes32'], [context.walletCreationCode, ethers__WEBPACK_IMPORTED_MODULE_4__.zeroPadValue(context.mainModule, 32)]));\n  const hash = ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_2__.solidityPacked(['bytes1', 'address', 'bytes32', 'bytes32'], ['0xff', context.factory, imageHash, codeHash]));\n  return ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.dataSlice(hash, 12));\n}\nasync function isValidCounterfactual(wallet, digest, signature, chainId, provider, contexts) {\n  // We don't know the version of the signature\n  // so we need to try all of them\n  const res = await Promise.all(allVersions.map(async version => {\n    try {\n      const decoded = version.signature.SignatureCoder.decode(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(signature));\n      const recovered1 = await version.signature.SignatureCoder.recover(decoded, {\n        address: wallet,\n        digest: ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(digest),\n        chainId\n      }, provider);\n      const imageHash = version.config.ConfigCoder.imageHashOf(recovered1.config);\n      const counterfactualAddress = addressOf(contexts[version.version], imageHash);\n      if (counterfactualAddress.toLowerCase() === wallet.toLowerCase()) {\n        return true;\n      }\n\n      // chainId=0 means no chainId, so the signature is valid for all chains\n      // we need to check that case too\n      const recovered2 = await version.signature.SignatureCoder.recover(decoded, {\n        address: wallet,\n        digest: ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(digest),\n        chainId\n      }, provider);\n      const imageHash2 = version.config.ConfigCoder.imageHashOf(recovered2.config);\n      const counterfactualAddress2 = addressOf(contexts[version.version], imageHash2);\n      return counterfactualAddress2.toLowerCase() === wallet.toLowerCase();\n    } catch (_unused) {}\n\n    // We most likely failed to decode the signature\n    return false;\n  }));\n  return res.some(r => r);\n}\nfunction isValidVersionedContext(contexts) {\n  // number of keys is the number of versions\n  const versions = Object.keys(contexts).length;\n\n  // check that all versions exist and are valid\n  for (let i = 1; i <= versions; i++) {\n    const context = contexts[i];\n    if (!context || context.version !== i) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction latestContext(contexts) {\n  const versions = Object.keys(contexts).length;\n  return contexts[versions];\n}\nconst defaultContexts = {\n  1: DeployedWalletContext$1,\n  2: DeployedWalletContext\n};\n\nvar context = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  addressOf: addressOf,\n  isValidCounterfactual: isValidCounterfactual,\n  isValidVersionedContext: isValidVersionedContext,\n  latestContext: latestContext,\n  defaultContexts: defaultContexts\n});\n\nconst MetaTransactionsType = `tuple(\n  bool delegateCall,\n  bool revertOnError,\n  uint256 gasLimit,\n  address target,\n  uint256 value,\n  bytes data\n)[]`;\nfunction intendTransactionBundle(bundle, wallet, chainId, id) {\n  return _extends({}, bundle, {\n    chainId,\n    intent: {\n      id: id,\n      wallet\n    }\n  });\n}\nfunction intendedTransactionID(bundle) {\n  return ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().encode(['address', 'uint256', 'bytes32'], [bundle.intent.wallet, bundle.chainId, bundle.intent.id]));\n}\nfunction unpackMetaTransactionsData(data) {\n  const res = ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().decode(['uint256', MetaTransactionsType], data);\n  if (res.length !== 2 || !res[0] || !res[1]) throw new Error('Invalid meta transaction data');\n  return [res[0], res[1]];\n}\nfunction packMetaTransactionsData(nonce, txs) {\n  return ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().encode(['uint256', MetaTransactionsType], [nonce, sequenceTxAbiEncode(txs)]);\n}\nfunction digestOfTransactions(nonce, txs) {\n  return ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(packMetaTransactionsData(nonce, txs));\n}\nfunction subdigestOfTransactions(address, chainId, nonce, txs) {\n  return subdigestOf({\n    address,\n    chainId,\n    digest: digestOfTransactions(nonce, txs)\n  });\n}\nfunction subdigestOfGuestModuleTransactions(guestModule, chainId, txs) {\n  return subdigestOf({\n    address: guestModule,\n    chainId,\n    digest: ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().encode(['string', MetaTransactionsType], ['guest:', sequenceTxAbiEncode(txs)]))\n  });\n}\nfunction toSequenceTransactions(wallet, txs) {\n  return txs.map(tx => toSequenceTransaction(wallet, tx));\n}\nfunction toSequenceTransaction(wallet, tx) {\n  if (tx.to && tx.to !== ethers__WEBPACK_IMPORTED_MODULE_12__.ZeroAddress) {\n    return {\n      nonce: !isNullish(tx.nonce) ? BigInt(tx.nonce) : undefined,\n      transaction: {\n        delegateCall: false,\n        revertOnError: false,\n        gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : undefined,\n        // XXX: `tx.to` could also be ethers Addressable type which returns a getAddress promise\n        // Keeping this as is for now so we don't have to change everything to async\n        to: tx.to,\n        value: BigInt(tx.value || 0),\n        data: tx.data || '0x'\n      }\n    };\n  } else {\n    const walletInterface = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(_0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModule.abi);\n    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('createContract'), [tx.data]);\n    return {\n      nonce: typeof tx.nonce === 'number' ? BigInt(tx.nonce) : undefined,\n      transaction: {\n        delegateCall: false,\n        revertOnError: false,\n        gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : undefined,\n        to: wallet,\n        value: BigInt(tx.value || 0),\n        data\n      }\n    };\n  }\n}\nfunction isSequenceTransaction(tx) {\n  return tx.delegateCall !== undefined || tx.revertOnError !== undefined;\n}\nfunction hasSequenceTransactions(txs) {\n  return txs.every(isSequenceTransaction);\n}\n\n// TODO: We may be able to remove this if we make Transaction === TransactionEncoded\nfunction sequenceTxAbiEncode(txs) {\n  return txs.map(tx => {\n    var _tx$to;\n    return {\n      delegateCall: tx.delegateCall === true,\n      revertOnError: tx.revertOnError === true,\n      gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : 0n,\n      target: (_tx$to = tx.to) != null ? _tx$to : ethers__WEBPACK_IMPORTED_MODULE_12__.ZeroAddress,\n      value: !isNullish(tx.value) ? tx.value : 0n,\n      data: tx.data || '0x'\n    };\n  });\n}\nfunction fromTxAbiEncode(txs) {\n  return txs.map(tx => ({\n    delegateCall: tx.delegateCall,\n    revertOnError: tx.revertOnError,\n    gasLimit: tx.gasLimit,\n    to: tx.target,\n    value: tx.value,\n    data: tx.data\n  }));\n}\n\n// export function appendNonce(txs: Transaction[], nonce: ethers.BigNumberish): Transaction[] {\n//   return txs.map((t: Transaction) => ({ ...t, nonce }))\n// }\n\nfunction encodeNonce(space, nonce) {\n  const bspace = BigInt(space);\n  const bnonce = BigInt(nonce);\n  const shl = 2n ** 96n;\n  if (bnonce / shl !== 0n) {\n    throw new Error('Space already encoded');\n  }\n  return bnonce + bspace * shl;\n}\nfunction decodeNonce(nonce) {\n  const bnonce = BigInt(nonce);\n  const shr = 2n ** 96n;\n  return [bnonce / shr, bnonce % shr];\n}\nfunction fromTransactionish(wallet, transaction) {\n  if (Array.isArray(transaction)) {\n    if (hasSequenceTransactions(transaction)) {\n      return transaction;\n    } else {\n      const stx = toSequenceTransactions(wallet, transaction);\n      return stx.map(t => t.transaction);\n    }\n  } else if (isSequenceTransaction(transaction)) {\n    return [transaction];\n  } else {\n    return [toSequenceTransaction(wallet, transaction).transaction];\n  }\n}\nfunction isTransactionBundle(cand) {\n  return cand !== undefined && cand.entrypoint !== undefined && cand.chainId !== undefined && cand.transactions !== undefined && cand.nonce !== undefined && cand.intent !== undefined && cand.intent.id !== undefined && cand.intent.wallet !== undefined && Array.isArray(cand.transactions) && cand.transactions.reduce((p, c) => p && isSequenceTransaction(c), true);\n}\nfunction isSignedTransactionBundle(cand) {\n  return cand !== undefined && cand.signature !== undefined && cand.signature !== '' && isTransactionBundle(cand);\n}\nfunction encodeBundleExecData(bundle) {\n  const walletInterface = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(_0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModule.abi);\n  return walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), isSignedTransactionBundle(bundle) ? [\n  // Signed transaction bundle has all 3 parameters\n  sequenceTxAbiEncode(bundle.transactions), bundle.nonce, bundle.signature] : [\n  // Unsigned bundle may be a GuestModule call, so signature and nonce are missing\n  sequenceTxAbiEncode(bundle.transactions), 0, new Uint8Array([])]);\n}\n\n// TODO: Use Sequence ABI package\nconst selfExecuteSelector = '0x61c2926c';\nconst selfExecuteAbi = `tuple(\n  bool delegateCall,\n  bool revertOnError,\n  uint256 gasLimit,\n  address target,\n  uint256 value,\n  bytes data\n)[]`;\n\n// Splits Sequence batch transactions into individual parts\nconst unwind = (wallet, transactions) => {\n  const unwound = [];\n  const walletInterface = new ethers__WEBPACK_IMPORTED_MODULE_10__.Interface(_0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModule.abi);\n  for (const tx of transactions) {\n    const txData = ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(tx.data || '0x');\n    if (tx.to === wallet && ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(txData.slice(0, 4)) === selfExecuteSelector) {\n      // Decode as selfExecute call\n      const data = txData.slice(4);\n      const decoded = ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().decode([selfExecuteAbi], data)[0];\n      unwound.push(...unwind(tx.to, decoded.map(d => _extends({}, d, {\n        to: d.target\n      }))));\n    } else {\n      try {\n        const innerTransactions = walletInterface.decodeFunctionData('execute', txData)[0];\n        const unwoundTransactions = unwind(wallet, innerTransactions.map(tx => _extends({}, tx.toObject(), {\n          to: tx.target\n        })));\n        unwound.push(...unwoundTransactions);\n      } catch (_unused) {\n        unwound.push(tx);\n      }\n    }\n  }\n  return unwound;\n};\nconst isNullish = value => value === null || value === void 0;\n\nvar transaction = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MetaTransactionsType: MetaTransactionsType,\n  intendTransactionBundle: intendTransactionBundle,\n  intendedTransactionID: intendedTransactionID,\n  unpackMetaTransactionsData: unpackMetaTransactionsData,\n  packMetaTransactionsData: packMetaTransactionsData,\n  digestOfTransactions: digestOfTransactions,\n  subdigestOfTransactions: subdigestOfTransactions,\n  subdigestOfGuestModuleTransactions: subdigestOfGuestModuleTransactions,\n  toSequenceTransactions: toSequenceTransactions,\n  toSequenceTransaction: toSequenceTransaction,\n  isSequenceTransaction: isSequenceTransaction,\n  hasSequenceTransactions: hasSequenceTransactions,\n  sequenceTxAbiEncode: sequenceTxAbiEncode,\n  fromTxAbiEncode: fromTxAbiEncode,\n  encodeNonce: encodeNonce,\n  decodeNonce: decodeNonce,\n  fromTransactionish: fromTransactionish,\n  isTransactionBundle: isTransactionBundle,\n  isSignedTransactionBundle: isSignedTransactionBundle,\n  encodeBundleExecData: encodeBundleExecData,\n  selfExecuteSelector: selfExecuteSelector,\n  selfExecuteAbi: selfExecuteAbi,\n  unwind: unwind\n});\n\n/* Source of Offchain EIP-6492 validation:\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\n\n// As per ERC-1271\ninterface IERC1271Wallet {\n  function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\n}\n\nerror ERC1271Revert(bytes error);\nerror ERC6492DeployFailed(bytes error);\n\ncontract UniversalSigValidator {\n  bytes32 private constant ERC6492_DETECTION_SUFFIX = 0x6492649264926492649264926492649264926492649264926492649264926492;\n  bytes4 private constant ERC1271_SUCCESS = 0x1626ba7e;\n\n  function isValidSigImpl(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature,\n    bool allowSideEffects,\n    bool deployAlreadyDeployed\n  ) public returns (bool) {\n    uint contractCodeLen = address(_signer).code.length;\n    bytes memory sigToValidate;\n    // The order here is striclty defined in https://eips.ethereum.org/EIPS/eip-6492\n    // - ERC-6492 suffix check and verification first, while being permissive in case the contract is already deployed; if the contract is deployed we will check the sig against the deployed version, this allows 6492 signatures to still be validated while taking into account potential key rotation\n    // - ERC-1271 verification if there's contract code\n    // - finally, ecrecover\n    bool isCounterfactual = bytes32(_signature[_signature.length-32:_signature.length]) == ERC6492_DETECTION_SUFFIX;\n    if (isCounterfactual) {\n      address create2Factory;\n      bytes memory factoryCalldata;\n      (create2Factory, factoryCalldata, sigToValidate) = abi.decode(_signature[0:_signature.length-32], (address, bytes, bytes));\n\n      if (contractCodeLen == 0 || deployAlreadyDeployed) {\n        (bool success, bytes memory err) = create2Factory.call(factoryCalldata);\n        if (!success) revert ERC6492DeployFailed(err);\n      }\n    } else {\n      sigToValidate = _signature;\n    }\n\n    // Try ERC-1271 verification\n    if (isCounterfactual || contractCodeLen > 0) {\n      try IERC1271Wallet(_signer).isValidSignature(_hash, sigToValidate) returns (bytes4 magicValue) {\n        bool isValid = magicValue == ERC1271_SUCCESS;\n\n        // EXPERIMENTAL: This is not part of the EIP-6492 spec *yet*\n        // but it may be useful to retry the call making the factory call\n        // even if the wallet is already deployed, in case the wallet\n        // needs to perform some sort of migration or onchain key rotation\n        if (!isValid && !deployAlreadyDeployed && contractCodeLen > 0) {\n          return isValidSigImpl(_signer, _hash, _signature, allowSideEffects, true);\n        }\n\n        if (contractCodeLen == 0 && isCounterfactual && !allowSideEffects) {\n          // if the call had side effects we need to return the\n          // result using a `revert` (to undo the state changes)\n          assembly {\n            mstore(0, isValid)\n            revert(31, 1)\n          }\n        }\n\n        return isValid;\n      } catch (bytes memory err) {\n        // EXPERIMENTAL: This is not part of the EIP-6492 spec *yet*\n        // but it may be useful to retry the call making the factory call\n        // even if the wallet is already deployed, in case the wallet\n        // needs to perform some sort of migration or onchain key rotation\n        if (!deployAlreadyDeployed && contractCodeLen > 0) {\n          return isValidSigImpl(_signer, _hash, _signature, allowSideEffects, true);\n        }\n\n        revert ERC1271Revert(err);\n      }\n    }\n\n    // ecrecover verification\n    require(_signature.length == 65, 'SignatureValidator#recoverSigner: invalid signature length');\n    bytes32 r = bytes32(_signature[0:32]);\n    bytes32 s = bytes32(_signature[32:64]);\n    uint8 v = uint8(_signature[64]);\n\n    if (v != 27 && v != 28) {\n      revert('SignatureValidator: invalid signature v value');\n    }\n\n    return ecrecover(_hash, v, r, s) == _signer;\n  }\n\n  function isValidSigWithSideEffects(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature\n  ) external returns (bool) {\n    return this.isValidSigImpl(_signer, _hash, _signature, true, false);\n  }\n\n  function isValidSig(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature\n  ) external returns (bool) {\n    try this.isValidSigImpl(_signer, _hash, _signature, false, false) returns (bool isValid) {\n      return isValid;\n    } catch (bytes memory error) {\n      // in order to avoid side effects from the contract getting deployed, the entire call will revert with a single byte result\n      uint len = error.length;\n      if (len == 1) {\n        return error[0] == 0x01;\n        // all other errors are simply forwarded, but in custom formats so that nothing else can revert with a single byte in the call\n      } else {\n        assembly { revert(error, len) }\n      }\n    }\n  }\n\n  // NOTICE: These functions aren't part of the standard\n  // they are helpers that behave like the above functions\n  // but they don't revert on failure, instead they return false\n\n  function isValidSigNoThrow(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature\n  ) external returns (bool) {\n    try this.isValidSigImpl(_signer, _hash, _signature, false, false) returns (bool isValid) {\n      return isValid;\n    } catch (bytes memory error) {\n      // in order to avoid side effects from the contract getting deployed, the entire call will revert with a single byte result\n      uint len = error.length;\n      if (len == 1) {\n        return error[0] == 0x01;\n        // all other errors are simply forwarded, but in custom formats so that nothing else can revert with a single byte in the call\n      } else {\n        // Ignore all other errors and return false\n        return false;\n      }\n    }\n  }\n\n  function isValidSigWithSideEffectsNoThrow(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature\n  ) external returns (bool) {\n    try this.isValidSigImpl(_signer, _hash, _signature, true, false) returns (bool isValid) {\n      return isValid;\n    } catch (bytes memory error) {\n      // Ignore all errors and return false\n      return false;\n    }\n  }\n}\n\n// this is a helper so we can perform validation in a single eth_call without pre-deploying a singleton\ncontract ValidateSigOffchain {\n  constructor (address _signer, bytes32 _hash, bytes memory _signature) {\n    UniversalSigValidator validator = new UniversalSigValidator();\n    bool isValidSig = validator.isValidSigWithSideEffects(_signer, _hash, _signature);\n    assembly {\n      mstore(0, isValidSig)\n      return(31, 1)\n    }\n  }\n}\n*/\n\nconst EIP_6492_OFFCHAIN_DEPLOY_CODE = '0x608060405234801561001057600080fd5b5060405161124a38038061124a83398101604081905261002f91610124565b600060405161003d906100dd565b604051809103906000f080158015610059573d6000803e3d6000fd5b5090506000816001600160a01b0316638f0684308686866040518463ffffffff1660e01b815260040161008e939291906101fb565b6020604051808303816000875af11580156100ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100d19190610244565b9050806000526001601ff35b610fdc8061026e83390190565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561011b578181015183820152602001610103565b50506000910152565b60008060006060848603121561013957600080fd5b83516001600160a01b038116811461015057600080fd5b6020850151604086015191945092506001600160401b038082111561017457600080fd5b818601915086601f83011261018857600080fd5b81518181111561019a5761019a6100ea565b604051601f8201601f19908116603f011681019083821181831017156101c2576101c26100ea565b816040528281528960208487010111156101db57600080fd5b6101ec836020830160208801610100565b80955050505050509250925092565b60018060a01b0384168152826020820152606060408201526000825180606084015261022e816080850160208701610100565b601f01601f191691909101608001949350505050565b60006020828403121561025657600080fd5b8151801515811461026657600080fd5b939250505056fe608060405234801561001057600080fd5b50610fbc806100206000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c806376be4cea1161005057806376be4cea146100a65780638f068430146100b957806398ef1ed8146100cc57600080fd5b80631c6453271461006c5780633d787b6314610093575b600080fd5b61007f61007a366004610ad4565b6100df565b604051901515815260200160405180910390f35b61007f6100a1366004610ad4565b61023d565b61007f6100b4366004610b3e565b61031e565b61007f6100c7366004610ad4565b6108e1565b61007f6100da366004610ad4565b61096e565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061012890889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610181575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261017e91810190610c45565b60015b610232573d8080156101af576040519150601f19603f3d011682016040523d82523d6000602084013e6101b4565b606091505b508051600181900361022757816000815181106101d3576101d3610c69565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f0100000000000000000000000000000000000000000000000000000000000000149250610235915050565b600092505050610235565b90505b949350505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906102879088908890889088906001908990600401610bc3565b6020604051808303816000875af19250505080156102e0575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526102dd91810190610c45565b60015b610232573d80801561030e576040519150601f19603f3d011682016040523d82523d6000602084013e610313565b606091505b506000915050610235565b600073ffffffffffffffffffffffffffffffffffffffff87163b6060827f64926492649264926492649264926492649264926492649264926492649264928888610369602082610c98565b610375928b9290610cd8565b61037e91610d02565b1490508015610484576000606089828a610399602082610c98565b926103a693929190610cd8565b8101906103b39190610e18565b955090925090508415806103c45750865b1561047d576000808373ffffffffffffffffffffffffffffffffffffffff16836040516103f19190610eb2565b6000604051808303816000865af19150503d806000811461042e576040519150601f19603f3d011682016040523d82523d6000602084013e610433565b606091505b50915091508161047a57806040517f9d0d6e2d0000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b60405180910390fd5b50505b50506104be565b87878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294505050505b80806104ca5750600083115b156106bb576040517f1626ba7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b1690631626ba7e90610523908c908690600401610f2b565b602060405180830381865afa92505050801561057a575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261057791810190610f44565b60015b61060f573d8080156105a8576040519150601f19603f3d011682016040523d82523d6000602084013e6105ad565b606091505b50851580156105bc5750600084115b156105db576105d08b8b8b8b8b600161031e565b9450505050506108d7565b806040517f6f2a95990000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b7fffffffff0000000000000000000000000000000000000000000000000000000081167f1626ba7e000000000000000000000000000000000000000000000000000000001480158161065f575086155b801561066b5750600085115b1561068b5761067f8c8c8c8c8c600161031e565b955050505050506108d7565b841580156106965750825b80156106a0575087155b156106af57806000526001601ffd5b94506108d79350505050565b6041871461074b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f5369676e617475726556616c696461746f72237265636f7665725369676e657260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610471565b600061075a6020828a8c610cd8565b61076391610d02565b90506000610775604060208b8d610cd8565b61077e91610d02565b905060008a8a604081811061079557610795610c69565b919091013560f81c915050601b81148015906107b557508060ff16601c14155b15610842576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f5369676e617475726556616c696461746f723a20696e76616c6964207369676e60448201527f617475726520762076616c7565000000000000000000000000000000000000006064820152608401610471565b6040805160008152602081018083528e905260ff831691810191909152606081018490526080810183905273ffffffffffffffffffffffffffffffffffffffff8e169060019060a0016020604051602081039080840390855afa1580156108ad573d6000803e3d6000fd5b5050506020604051035173ffffffffffffffffffffffffffffffffffffffff161496505050505050505b9695505050505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061092b9088908890889088906001908990600401610bc3565b6020604051808303816000875af115801561094a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102329190610c45565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906109b790889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610a10575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610a0d91810190610c45565b60015b610232573d808015610a3e576040519150601f19603f3d011682016040523d82523d6000602084013e610a43565b606091505b5080516001819003610a6257816000815181106101d3576101d3610c69565b8082fd5b73ffffffffffffffffffffffffffffffffffffffff81168114610a8857600080fd5b50565b60008083601f840112610a9d57600080fd5b50813567ffffffffffffffff811115610ab557600080fd5b602083019150836020828501011115610acd57600080fd5b9250929050565b60008060008060608587031215610aea57600080fd5b8435610af581610a66565b935060208501359250604085013567ffffffffffffffff811115610b1857600080fd5b610b2487828801610a8b565b95989497509550505050565b8015158114610a8857600080fd5b60008060008060008060a08789031215610b5757600080fd5b8635610b6281610a66565b955060208701359450604087013567ffffffffffffffff811115610b8557600080fd5b610b9189828a01610a8b565b9095509350506060870135610ba581610b30565b91506080870135610bb581610b30565b809150509295509295509295565b73ffffffffffffffffffffffffffffffffffffffff8716815285602082015260a060408201528360a0820152838560c0830137600060c085830181019190915292151560608201529015156080820152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016909101019392505050565b600060208284031215610c5757600080fd5b8151610c6281610b30565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b81810381811115610cd2577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b92915050565b60008085851115610ce857600080fd5b83861115610cf557600080fd5b5050820193919092039150565b80356020831015610cd2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602084900360031b1b1692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610d7e57600080fd5b813567ffffffffffffffff80821115610d9957610d99610d3e565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610ddf57610ddf610d3e565b81604052838152866020858801011115610df857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215610e2d57600080fd5b8335610e3881610a66565b9250602084013567ffffffffffffffff80821115610e5557600080fd5b610e6187838801610d6d565b93506040860135915080821115610e7757600080fd5b50610e8486828701610d6d565b9150509250925092565b60005b83811015610ea9578181015183820152602001610e91565b50506000910152565b60008251610ec4818460208701610e8e565b9190910192915050565b60008151808452610ee6816020860160208601610e8e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000610c626020830184610ece565b8281526040602082015260006102356040830184610ece565b600060208284031215610f5657600080fd5b81517fffffffff0000000000000000000000000000000000000000000000000000000081168114610c6257600080fdfea26469706673582212201a72aed4b15ffb05b6502997a9bb655992e06590bd26b336dfbb153d7ff6f34b64736f6c63430008120033';\nconst EIP_6492_SUFFIX = '0x6492649264926492649264926492649264926492649264926492649264926492';\n\n// TODO: This is a length payload, we can lower the load by deploying\n// the contract on some of the popular chains, and calling the contract\n// if the provider is one of those chains\nasync function validateEIP6492Offchain(provider, signer, hash, signature) {\n  try {\n    const result = await provider.call({\n      data: ethers__WEBPACK_IMPORTED_MODULE_4__.concat([EIP_6492_OFFCHAIN_DEPLOY_CODE, ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().encode(['address', 'bytes32', 'bytes'], [signer, hash, signature])])\n    });\n    return result === '0x01';\n  } catch (err) {\n    return false;\n  }\n}\n\nvar validateEIP6492 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  EIP_6492_OFFCHAIN_DEPLOY_CODE: EIP_6492_OFFCHAIN_DEPLOY_CODE,\n  EIP_6492_SUFFIX: EIP_6492_SUFFIX,\n  validateEIP6492Offchain: validateEIP6492Offchain\n});\n\n/**\n * Provides stateful information about the wallet.\n */\n\n/**\n * The OnChainReader class fetches on-chain data from a wallet.\n * It is used to understand the \"real\" state of the wallet contract on-chain.\n */\nclass OnChainReader {\n  constructor(provider) {\n    this.provider = provider;\n    // Simple cache to avoid re-fetching the same data\n    this.isDeployedCache = new Set();\n  }\n  module(address) {\n    return new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(address, [..._0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModuleUpgradable.abi, ..._0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.mainModule.abi, ..._0xsequence_abi__WEBPACK_IMPORTED_MODULE_0__.walletContracts.erc1271.abi], this.provider);\n  }\n  async isDeployed(wallet) {\n    // This is safe to cache because the wallet cannot be undeployed once deployed\n    if (this.isDeployedCache.has(wallet)) {\n      return true;\n    }\n    const code = await this.provider.getCode(wallet).then(c => ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(c));\n    const isDeployed = code.length !== 0;\n    if (isDeployed) {\n      this.isDeployedCache.add(wallet);\n    }\n    return isDeployed;\n  }\n  async implementation(wallet) {\n    const position = ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().encode(['address'], [wallet]);\n    const val = await this.provider.getStorage(wallet, position).then(c => ethers__WEBPACK_IMPORTED_MODULE_4__.getBytes(c));\n    if (val.length === 20) {\n      return ethers__WEBPACK_IMPORTED_MODULE_7__.getAddress(ethers__WEBPACK_IMPORTED_MODULE_4__.hexlify(val));\n    }\n    if (val.length === 32) {\n      return ethers__WEBPACK_IMPORTED_MODULE_9__.AbiCoder.defaultAbiCoder().decode(['address'], val)[0];\n    }\n    return undefined;\n  }\n  async imageHash(wallet) {\n    try {\n      const imageHash = await this.module(wallet).imageHash();\n      return imageHash;\n    } catch (_unused) {}\n    return undefined;\n  }\n  async nonce(wallet, space = 0) {\n    try {\n      const nonce = await this.module(wallet).readNonce(space);\n      return nonce;\n    } catch (e) {\n      if (!(await this.isDeployed(wallet))) {\n        return 0;\n      }\n      throw e;\n    }\n  }\n\n  // We use the EIP-6492 validator contract to check the signature\n  // this means that if the wallet is not deployed, then the signature\n  // must be prefixed with a transaction that deploys the wallet\n  async isValidSignature(wallet, digest, signature) {\n    return validateEIP6492Offchain(this.provider, wallet, digest, signature);\n  }\n}\n\nvar reader = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  OnChainReader: OnChainReader\n});\n\n/**\n * Request metadata, used by the wallet to pass additional information through the orchestrator.\n */\n\nfunction isWalletSignRequestMetadata(obj) {\n  return obj && obj.address && obj.digest && obj.chainId !== undefined && obj.config;\n}\n\n/**\n * Request metadata, used by the wallet to pass additional information through the orchestrator.\n */\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  config: config,\n  signature: signature$2,\n  context: context,\n  signer: signer,\n  EIP1271: validateEIP1271,\n  transaction: transaction,\n  reader: reader,\n  EIP6492: validateEIP6492,\n  isWalletSignRequestMetadata: isWalletSignRequestMetadata\n});\n\nconst ALL_CODERS = [{\n  config: ConfigCoder$1,\n  signature: SignatureCoder$1\n}, {\n  config: ConfigCoder,\n  signature: SignatureCoder\n}];\nfunction coderFor(version) {\n  const index = version - 1;\n  if (index < 0 || index >= ALL_CODERS.length) {\n    throw new Error(`No coder for version: ${version}`);\n  }\n  return ALL_CODERS[index];\n}\n\n/**\n *  Same as `coderFor` but returns `generic` coders without versioned types.\n */\nfunction genericCoderFor(version) {\n  return coderFor(version);\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ALL_CODERS: ALL_CODERS,\n  coderFor: coderFor,\n  genericCoderFor: genericCoderFor\n});\n\nconst VERSION = '2.2.13';\n\nconst allVersions = [v1, v2];\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0AweHNlcXVlbmNlK2NvcmVAMi4yLjEzX2V0aGVyc0A2LjEzLjVfYnVmZmVydXRpbEA0LjAuOF91dGYtOC12YWxpZGF0ZUA1LjAuMTBfL25vZGVfbW9kdWxlcy9AMHhzZXF1ZW5jZS9jb3JlL2Rpc3QvMHhzZXF1ZW5jZS1jb3JlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ2tCO0FBQ0Q7O0FBRWpEO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxTQUFTLDJEQUE4QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsNENBQWU7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKO0FBQ0EsZ0JBQWdCLDRDQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFlO0FBQy9CLHNCQUFzQiw0Q0FBZTs7QUFFckM7QUFDQTs7QUFFQTtBQUNBLFlBQVksMkNBQWM7QUFDMUIsWUFBWSwyQ0FBYztBQUMxQixtQkFBbUIsMkNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrREFBcUI7QUFDaEM7QUFDQTtBQUNBLFdBQVcsa0RBQXFCLENBQUMsK0NBQWtCO0FBQ25EO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBZTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJDQUFjO0FBQzFEO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFlO0FBQy9CO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJDQUFjO0FBQ25DO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOENBQWlCLENBQUMsMkNBQWM7QUFDbkQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBaUIsQ0FBQywyQ0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQWM7QUFDbkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtDQUFrQjtBQUN4QixXQUFXLDJDQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxhQUFhLGtEQUFxQjtBQUNsQztBQUNBO0FBQ0Esb0JBQW9CLDRDQUFlO0FBQ25DLGFBQWEsa0RBQXFCO0FBQ2xDO0FBQ0EsV0FBVyxrREFBcUI7QUFDaEMsR0FBRztBQUNILFNBQVMsa0RBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFVBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBZTtBQUNqQztBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3REFBd0QsNkNBQWdCLENBQUMsNENBQWUseUdBQXlHLGtEQUFxQjtBQUN0TixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhDQUFnQixLQUFLLDREQUFlLG9CQUFvQiw0REFBZTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZDQUFnQjtBQUN6QjtBQUNBO0FBQ0EsU0FBUyxrREFBcUI7QUFDOUI7QUFDQTtBQUNBLGNBQWMsNENBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyQ0FBYztBQUNwQjtBQUNBO0FBQ0EsU0FBUywyQ0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQWlCLENBQUMsMkNBQWM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBaUIsQ0FBQywyQ0FBYztBQUMxRDtBQUNBLDRCQUE0QiwyQ0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQ0FBYztBQUN6QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJDQUFjO0FBQzFDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSyxJQUFJLDJDQUFjLE1BQU07QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFxQjtBQUNoQyxHQUFHO0FBQ0g7QUFDQSxXQUFXLGtEQUFxQjtBQUNoQyxHQUFHO0FBQ0g7QUFDQSxnQkFBZ0IsNENBQWU7QUFDL0IsV0FBVyxrREFBcUI7QUFDaEMsR0FBRztBQUNIO0FBQ0EsZ0JBQWdCLDRDQUFlO0FBQy9CLFdBQVcsa0RBQXFCO0FBQ2hDLEdBQUc7QUFDSDtBQUNBLFdBQVcsa0RBQXFCO0FBQ2hDLEdBQUc7QUFDSDtBQUNBLFdBQVcsa0RBQXFCO0FBQ2hDLEdBQUc7QUFDSDtBQUNBLHlCQUF5Qiw0Q0FBZTtBQUN4QyxXQUFXLGtEQUFxQjtBQUNoQyxHQUFHO0FBQ0g7QUFDQSxXQUFXLGtEQUFxQjtBQUNoQztBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0RBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQseUJBQXlCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNENBQWU7QUFDN0I7QUFDQTtBQUNBLHdEQUF3RCxLQUFLO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsU0FBUyxrREFBcUIsMEJBQTBCLDJEQUE4QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsY0FBYyw2Q0FBZ0I7QUFDOUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNENBQWU7QUFDM0QsZUFBZSxrREFBcUI7QUFDcEMsU0FBUyxrREFBcUI7QUFDOUI7QUFDQTtBQUNBLE1BQU0sK0NBQWtCLGtCQUFrQiwyQ0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxnQkFBZ0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtEQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtEQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQWU7QUFDeEMsd0JBQXdCLDRDQUFlO0FBQ3ZDO0FBQ0E7QUFDQSxhQUFhLGtEQUFxQjtBQUNsQyxNQUFNO0FBQ04sYUFBYSxrREFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUFlO0FBQ2xDLFdBQVcsa0RBQXFCO0FBQ2hDO0FBQ0E7QUFDQSxzQkFBc0IsNENBQWU7QUFDckM7QUFDQTtBQUNBLGFBQWEsa0RBQXFCO0FBQ2xDLE1BQU07QUFDTixhQUFhLGtEQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFxQjtBQUNoQztBQUNBO0FBQ0EsV0FBVyxrREFBcUI7QUFDaEM7QUFDQTtBQUNBLFdBQVcsa0RBQXFCO0FBQ2hDO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9DQUFvQztBQUNwQyx3QkFBd0I7QUFDeEI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw2Q0FBZTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw2Q0FBZTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFrQjtBQUNuQyxtQ0FBbUMsK0NBQWtCO0FBQ3JEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SEFBd0g7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBYSxpQ0FBaUMsNENBQWU7QUFDekUsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQWUsY0FBYyw0REFBZSw4QkFBOEIsNERBQWUsb0JBQW9CLDREQUFlO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw0Q0FBZTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0Q0FBZTtBQUNwQywyRUFBMkUsNENBQWU7QUFDMUY7QUFDQSxhQUFhLDhDQUFpQixDQUFDLDJDQUFjO0FBQzdDO0FBQ0E7QUFDQSxhQUFhLDRDQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVnRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BleGFtcGxlcy9sb2dpbi13aXRoLXBhc3Nwb3J0LWd1YXJkaWFuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AMHhzZXF1ZW5jZStjb3JlQDIuMi4xM19ldGhlcnNANi4xMy41X2J1ZmZlcnV0aWxANC4wLjhfdXRmLTgtdmFsaWRhdGVANS4wLjEwXy9ub2RlX21vZHVsZXMvQDB4c2VxdWVuY2UvY29yZS9kaXN0LzB4c2VxdWVuY2UtY29yZS5lc20uanM/MzQ2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHsgd2FsbGV0Q29udHJhY3RzIH0gZnJvbSAnQDB4c2VxdWVuY2UvYWJpJztcbmltcG9ydCB7IE1BWF9VSU5UXzI1NiB9IGZyb20gJ0AweHNlcXVlbmNlL3V0aWxzJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIHJldHVybiBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciB0ID0gYXJndW1lbnRzW2VdO1xuICAgICAgZm9yICh2YXIgciBpbiB0KSAoe30pLmhhc093blByb3BlcnR5LmNhbGwodCwgcikgJiYgKG5bcl0gPSB0W3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIF9leHRlbmRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHN1YmRpZ2VzdE9mKHBheWxvYWQpIHtcbiAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZEtlY2NhazI1NihbJ2J5dGVzJywgJ3VpbnQyNTYnLCAnYWRkcmVzcycsICdieXRlczMyJ10sIFsnMHgxOTAxJywgcGF5bG9hZC5jaGFpbklkLCBwYXlsb2FkLmFkZHJlc3MsIHBheWxvYWQuZGlnZXN0XSk7XG59XG5mdW5jdGlvbiBpc1NpZ25lZFBheWxvYWQocGF5bG9hZCkge1xuICByZXR1cm4gcGF5bG9hZC5kaWdlc3QgIT09IHVuZGVmaW5lZCAmJiBwYXlsb2FkLmNoYWluSWQgIT09IHVuZGVmaW5lZCAmJiBwYXlsb2FkLmFkZHJlc3MgIT09IHVuZGVmaW5lZDtcbn1cblxudmFyIHNpZ25hdHVyZSQyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHN1YmRpZ2VzdE9mOiBzdWJkaWdlc3RPZixcbiAgaXNTaWduZWRQYXlsb2FkOiBpc1NpZ25lZFBheWxvYWRcbn0pO1xuXG5jb25zdCBFSVAxMjcxX01BR0lDX1ZBTFVFID0gJzB4MTYyNmJhN2UnO1xuY29uc3QgRUlQMTI3MV9BQkkgPSBbe1xuICBpbnB1dHM6IFt7XG4gICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMzMicsXG4gICAgdHlwZTogJ2J5dGVzMzInXG4gIH0sIHtcbiAgICBpbnRlcm5hbFR5cGU6ICdieXRlcycsXG4gICAgdHlwZTogJ2J5dGVzJ1xuICB9XSxcbiAgbmFtZTogJ2lzVmFsaWRTaWduYXR1cmUnLFxuICBvdXRwdXRzOiBbe1xuICAgIGludGVybmFsVHlwZTogJ2J5dGVzNCcsXG4gICAgdHlwZTogJ2J5dGVzNCdcbiAgfV0sXG4gIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICB0eXBlOiAnZnVuY3Rpb24nXG59XTtcbmFzeW5jIGZ1bmN0aW9uIGlzVmFsaWRFSVAxMjcxU2lnbmF0dXJlKGFkZHJlc3MsIGRpZ2VzdCwgc2lnbmF0dXJlLCBwcm92aWRlcikge1xuICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoYWRkcmVzcywgRUlQMTI3MV9BQkksIHByb3ZpZGVyKTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udHJhY3QuaXNWYWxpZFNpZ25hdHVyZShkaWdlc3QsIHNpZ25hdHVyZSk7XG4gIHJldHVybiByZXN1bHQgPT09IEVJUDEyNzFfTUFHSUNfVkFMVUU7XG59XG5cbnZhciB2YWxpZGF0ZUVJUDEyNzEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgaXNWYWxpZEVJUDEyNzFTaWduYXR1cmU6IGlzVmFsaWRFSVAxMjcxU2lnbmF0dXJlXG59KTtcblxubGV0IFNpZ1R5cGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFNpZ1R5cGUpIHtcbiAgU2lnVHlwZVtTaWdUeXBlW1wiRUlQNzEyXCJdID0gMV0gPSBcIkVJUDcxMlwiO1xuICBTaWdUeXBlW1NpZ1R5cGVbXCJFVEhfU0lHTlwiXSA9IDJdID0gXCJFVEhfU0lHTlwiO1xuICBTaWdUeXBlW1NpZ1R5cGVbXCJXQUxMRVRfQllURVMzMlwiXSA9IDNdID0gXCJXQUxMRVRfQllURVMzMlwiO1xuICByZXR1cm4gU2lnVHlwZTtcbn0oe30pO1xuZnVuY3Rpb24gY2FuUmVjb3ZlcihzaWduYXR1cmUpIHtcbiAgY29uc3QgYnl0ZXMgPSBldGhlcnMuZ2V0Qnl0ZXMoc2lnbmF0dXJlKTtcbiAgY29uc3QgdHlwZSA9IGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gdHlwZSA9PT0gU2lnVHlwZS5FSVA3MTIgfHwgdHlwZSA9PT0gU2lnVHlwZS5FVEhfU0lHTjtcbn1cbmZ1bmN0aW9uIHJlY292ZXJTaWduZXIoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgY29uc3QgYnl0ZXMgPSBldGhlcnMuZ2V0Qnl0ZXMoc2lnbmF0dXJlKTtcbiAgY29uc3QgZGlnZXN0Qnl0ZXMgPSBldGhlcnMuZ2V0Qnl0ZXMoZGlnZXN0KTtcblxuICAvLyB0eXBlIGlzIGxhc3QgYnl0ZVxuICBjb25zdCB0eXBlID0gYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV07XG5cbiAgLy8gU3BsaXQgcjpzOnZcbiAgY29uc3QgciA9IGV0aGVycy5oZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gIGNvbnN0IHMgPSBldGhlcnMuaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgY29uc3QgdiA9IE51bWJlcihldGhlcnMuaGV4bGlmeShieXRlcy5zbGljZSg2NCwgNjUpKSk7XG4gIGNvbnN0IHNwbGl0U2lnbmF0dXJlID0ge1xuICAgIHIsXG4gICAgcyxcbiAgICB2XG4gIH07XG4gIGlmICh0eXBlID09PSBTaWdUeXBlLkVJUDcxMikge1xuICAgIHJldHVybiBldGhlcnMucmVjb3ZlckFkZHJlc3MoZGlnZXN0Qnl0ZXMsIHNwbGl0U2lnbmF0dXJlKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gU2lnVHlwZS5FVEhfU0lHTikge1xuICAgIHJldHVybiBldGhlcnMucmVjb3ZlckFkZHJlc3MoZXRoZXJzLmhhc2hNZXNzYWdlKGRpZ2VzdEJ5dGVzKSwgc3BsaXRTaWduYXR1cmUpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc2lnbmF0dXJlIHR5cGU6ICR7dHlwZX1gKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRTaWduYXR1cmUoYWRkcmVzcywgZGlnZXN0LCBzaWduYXR1cmUsIHByb3ZpZGVyKSB7XG4gIGNvbnN0IGJ5dGVzID0gZXRoZXJzLmdldEJ5dGVzKHNpZ25hdHVyZSk7XG5cbiAgLy8gdHlwZSBpcyBsYXN0IGJ5dGVcbiAgY29uc3QgdHlwZSA9IGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdO1xuICBpZiAodHlwZSA9PT0gU2lnVHlwZS5FSVA3MTIgfHwgdHlwZSA9PT0gU2lnVHlwZS5FVEhfU0lHTikge1xuICAgIHJldHVybiBhZGRyZXNzID09PSByZWNvdmVyU2lnbmVyKGRpZ2VzdCwgc2lnbmF0dXJlKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gU2lnVHlwZS5XQUxMRVRfQllURVMzMikge1xuICAgIHJldHVybiBpc1ZhbGlkRUlQMTI3MVNpZ25hdHVyZShhZGRyZXNzLCBldGhlcnMuaGV4bGlmeShkaWdlc3QpLCBieXRlcy5zbGljZSgwLCAtMSksIHByb3ZpZGVyKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNpZ25hdHVyZSB0eXBlOiAke3R5cGV9YCk7XG59XG5mdW5jdGlvbiB0cnlSZWNvdmVyU2lnbmVyKGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gIGNvbnN0IGJ5dGVzID0gZXRoZXJzLmdldEJ5dGVzKHNpZ25hdHVyZSk7XG4gIGlmIChieXRlcy5sZW5ndGggIT09IDY2KSByZXR1cm4gdW5kZWZpbmVkO1xuICB0cnkge1xuICAgIHJldHVybiByZWNvdmVyU2lnbmVyKGRpZ2VzdCwgYnl0ZXMpO1xuICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG52YXIgc2lnbmVyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFNpZ1R5cGU6IFNpZ1R5cGUsXG4gIGNhblJlY292ZXI6IGNhblJlY292ZXIsXG4gIHJlY292ZXJTaWduZXI6IHJlY292ZXJTaWduZXIsXG4gIGlzVmFsaWRTaWduYXR1cmU6IGlzVmFsaWRTaWduYXR1cmUsXG4gIHRyeVJlY292ZXJTaWduZXI6IHRyeVJlY292ZXJTaWduZXJcbn0pO1xuXG5sZXQgU2lnbmF0dXJlUGFydFR5cGUkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoU2lnbmF0dXJlUGFydFR5cGUpIHtcbiAgU2lnbmF0dXJlUGFydFR5cGVbU2lnbmF0dXJlUGFydFR5cGVbXCJFT0FTaWduYXR1cmVcIl0gPSAwXSA9IFwiRU9BU2lnbmF0dXJlXCI7XG4gIFNpZ25hdHVyZVBhcnRUeXBlW1NpZ25hdHVyZVBhcnRUeXBlW1wiQWRkcmVzc1wiXSA9IDFdID0gXCJBZGRyZXNzXCI7XG4gIFNpZ25hdHVyZVBhcnRUeXBlW1NpZ25hdHVyZVBhcnRUeXBlW1wiRHluYW1pY1NpZ25hdHVyZVwiXSA9IDJdID0gXCJEeW5hbWljU2lnbmF0dXJlXCI7XG4gIHJldHVybiBTaWduYXR1cmVQYXJ0VHlwZTtcbn0oe30pO1xuZnVuY3Rpb24gaXNBZGRyZXNzTWVtYmVyKG1lbWJlcikge1xuICByZXR1cm4gbWVtYmVyLmFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJiAhaXNVbnJlY292ZXJlZFNpZ25hdHVyZU1lbWJlcihtZW1iZXIpO1xufVxuZnVuY3Rpb24gaXNVbnJlY292ZXJlZFNpZ25hdHVyZU1lbWJlcihtZW1iZXIpIHtcbiAgcmV0dXJuIG1lbWJlci5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJiBtZW1iZXIud2VpZ2h0ICE9PSB1bmRlZmluZWQgJiYgbWVtYmVyLmlzRHluYW1pYyAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNVbnJlY292ZXJlZFNpZ25hdHVyZSQxKHNpZ25hdHVyZSkge1xuICByZXR1cm4gc2lnbmF0dXJlLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkICYmIHNpZ25hdHVyZS5zaWduZXJzICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBkZWNvZGVTaWduYXR1cmUkMShzaWduYXR1cmUpIHtcbiAgY29uc3QgYnl0ZXMgPSBldGhlcnMuZ2V0Qnl0ZXMoc2lnbmF0dXJlKTtcbiAgY29uc3QgdGhyZXNob2xkID0gYnl0ZXNbMF0gPDwgOCB8IGJ5dGVzWzFdO1xuICBjb25zdCBzaWduZXJzID0gW107XG4gIGZvciAobGV0IGkgPSAyOyBpIDwgYnl0ZXMubGVuZ3RoOykge1xuICAgIGNvbnN0IHR5cGUgPSBieXRlc1tpKytdO1xuICAgIGNvbnN0IHdlaWdodCA9IGJ5dGVzW2krK107XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFNpZ25hdHVyZVBhcnRUeXBlJDEuRU9BU2lnbmF0dXJlOlxuICAgICAgICBzaWduZXJzLnB1c2goe1xuICAgICAgICAgIHVucmVjb3ZlcmVkOiB0cnVlLFxuICAgICAgICAgIHdlaWdodCxcbiAgICAgICAgICBzaWduYXR1cmU6IGV0aGVycy5oZXhsaWZ5KGJ5dGVzLnNsaWNlKGksIGkgKyA2NikpLFxuICAgICAgICAgIGlzRHluYW1pYzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGkgKz0gNjY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTaWduYXR1cmVQYXJ0VHlwZSQxLkFkZHJlc3M6XG4gICAgICAgIHNpZ25lcnMucHVzaCh7XG4gICAgICAgICAgd2VpZ2h0LFxuICAgICAgICAgIGFkZHJlc3M6IGV0aGVycy5nZXRBZGRyZXNzKGV0aGVycy5oZXhsaWZ5KGJ5dGVzLnNsaWNlKGksIGkgKyAyMCkpKVxuICAgICAgICB9KTtcbiAgICAgICAgaSArPSAyMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNpZ25hdHVyZVBhcnRUeXBlJDEuRHluYW1pY1NpZ25hdHVyZTpcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGV0aGVycy5nZXRBZGRyZXNzKGV0aGVycy5oZXhsaWZ5KGJ5dGVzLnNsaWNlKGksIGkgKyAyMCkpKTtcbiAgICAgICAgaSArPSAyMDtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGJ5dGVzW2ldIDw8IDggfCBieXRlc1tpICsgMV07XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgc2lnbmVycy5wdXNoKHtcbiAgICAgICAgICB1bnJlY292ZXJlZDogdHJ1ZSxcbiAgICAgICAgICB3ZWlnaHQsXG4gICAgICAgICAgc2lnbmF0dXJlOiBldGhlcnMuaGV4bGlmeShieXRlcy5zbGljZShpLCBpICsgc2l6ZSkpLFxuICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgaXNEeW5hbWljOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpICs9IHNpemU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNpZ25hdHVyZSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAxLFxuICAgIHRocmVzaG9sZCxcbiAgICBzaWduZXJzXG4gIH07XG59XG5mdW5jdGlvbiBlbmNvZGVTaWduYXR1cmUkMShzaWduYXR1cmUpIHtcbiAgaWYgKGV0aGVycy5pc0J5dGVzTGlrZShzaWduYXR1cmUpKSB7XG4gICAgcmV0dXJuIGV0aGVycy5oZXhsaWZ5KHNpZ25hdHVyZSk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHNpZ25lcnMsXG4gICAgdGhyZXNob2xkXG4gIH0gPSBpc1VucmVjb3ZlcmVkU2lnbmF0dXJlJDEoc2lnbmF0dXJlKSA/IHNpZ25hdHVyZSA6IHNpZ25hdHVyZS5jb25maWc7XG4gIGNvbnN0IGVuY29kZWRTaWduZXJzID0gc2lnbmVycy5tYXAocyA9PiB7XG4gICAgaWYgKGlzQWRkcmVzc01lbWJlcihzKSkge1xuICAgICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ3VpbnQ4JywgJ2FkZHJlc3MnXSwgW1NpZ25hdHVyZVBhcnRUeXBlJDEuQWRkcmVzcywgcy53ZWlnaHQsIHMuYWRkcmVzc10pO1xuICAgIH1cbiAgICBpZiAocy5pc0R5bmFtaWMpIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gZXRoZXJzLmdldEJ5dGVzKHMuc2lnbmF0dXJlKTtcbiAgICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICd1aW50OCcsICdhZGRyZXNzJywgJ3VpbnQxNicsICdieXRlcyddLCBbU2lnbmF0dXJlUGFydFR5cGUkMS5EeW5hbWljU2lnbmF0dXJlLCBzLndlaWdodCwgcy5hZGRyZXNzLCBieXRlcy5sZW5ndGgsIGJ5dGVzXSk7XG4gICAgfVxuICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICd1aW50OCcsICdieXRlcyddLCBbU2lnbmF0dXJlUGFydFR5cGUkMS5FT0FTaWduYXR1cmUsIHMud2VpZ2h0LCBzLnNpZ25hdHVyZV0pO1xuICB9KTtcbiAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQxNicsIC4uLm5ldyBBcnJheShlbmNvZGVkU2lnbmVycy5sZW5ndGgpLmZpbGwoJ2J5dGVzJyldLCBbdGhyZXNob2xkLCAuLi5lbmNvZGVkU2lnbmVyc10pO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVjb3ZlclNpZ25hdHVyZSQxKGRhdGEsIHBheWxvYWQsIHByb3ZpZGVyKSB7XG4gIGNvbnN0IHN1YmRpZ2VzdCA9IHN1YmRpZ2VzdE9mKHBheWxvYWQpO1xuICBjb25zdCBzaWduZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoZGF0YS5zaWduZXJzLm1hcChhc3luYyBzID0+IHtcbiAgICBpZiAoaXNBZGRyZXNzTWVtYmVyKHMpKSB7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgaWYgKHMuaXNEeW5hbWljKSB7XG4gICAgICBpZiAoIXMuYWRkcmVzcykgdGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHNpZ25hdHVyZSBwYXJ0IG11c3QgaGF2ZSBhZGRyZXNzJyk7XG4gICAgICBpZiAoIWlzVmFsaWRTaWduYXR1cmUocy5hZGRyZXNzLCBzdWJkaWdlc3QsIHMuc2lnbmF0dXJlLCBwcm92aWRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGR5bmFtaWMgc2lnbmF0dXJlIHBhcnQgJHtzLmFkZHJlc3N9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBzLmFkZHJlc3MsXG4gICAgICAgIHdlaWdodDogcy53ZWlnaHQsXG4gICAgICAgIHNpZ25hdHVyZTogcy5zaWduYXR1cmVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSByZWNvdmVyU2lnbmVyKHN1YmRpZ2VzdCwgcy5zaWduYXR1cmUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgd2VpZ2h0OiBzLndlaWdodCxcbiAgICAgICAgc2lnbmF0dXJlOiBzLnNpZ25hdHVyZVxuICAgICAgfTtcbiAgICB9XG4gIH0pKTtcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAxLFxuICAgIHBheWxvYWQsXG4gICAgc3ViZGlnZXN0LFxuICAgIGNvbmZpZzoge1xuICAgICAgdmVyc2lvbjogMSxcbiAgICAgIHRocmVzaG9sZDogZGF0YS50aHJlc2hvbGQsXG4gICAgICBzaWduZXJzXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZW5jb2RlU2lnbmVycyQxKGNvbmZpZywgc2lnbmF0dXJlcywgc3ViZGlnZXN0cywgXykge1xuICBpZiAoc3ViZGlnZXN0cy5sZW5ndGggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGxpY2l0IHN1YmRpZ2VzdHMgbm90IHN1cHBvcnRlZCBvbiB2MScpO1xuICB9XG4gIGxldCB3ZWlnaHQgPSAwbjtcbiAgY29uc3QgcGFydHMgPSBjb25maWcuc2lnbmVycy5tYXAocyA9PiB7XG4gICAgaWYgKCFzaWduYXR1cmVzLmhhcyhzLmFkZHJlc3MpKSB7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmF0dXJlcy5nZXQocy5hZGRyZXNzKTtcbiAgICBjb25zdCBieXRlcyA9IGV0aGVycy5nZXRCeXRlcyhzaWduYXR1cmUuc2lnbmF0dXJlKTtcbiAgICB3ZWlnaHQgKz0gQmlnSW50KHMud2VpZ2h0KTtcbiAgICBpZiAoc2lnbmF0dXJlLmlzRHluYW1pYyB8fCBieXRlcy5sZW5ndGggIT09IDY2KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHMsIHtcbiAgICAgICAgaXNEeW5hbWljOiB0cnVlLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZS5zaWduYXR1cmUsXG4gICAgICAgIGFkZHJlc3M6IHMuYWRkcmVzc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcywge1xuICAgICAgaXNEeW5hbWljOiBmYWxzZSxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLnNpZ25hdHVyZVxuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgZW5jb2RlZCA9IGVuY29kZVNpZ25hdHVyZSQxKHtcbiAgICB2ZXJzaW9uOiAxLFxuICAgIHRocmVzaG9sZDogY29uZmlnLnRocmVzaG9sZCxcbiAgICBzaWduZXJzOiBwYXJ0c1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGVkLFxuICAgIHdlaWdodFxuICB9O1xufVxuY29uc3QgU2lnbmF0dXJlQ29kZXIkMSA9IHtcbiAgZGVjb2RlOiBkYXRhID0+IHtcbiAgICByZXR1cm4gZGVjb2RlU2lnbmF0dXJlJDEoZGF0YSk7XG4gIH0sXG4gIGVuY29kZTogZGF0YSA9PiB7XG4gICAgcmV0dXJuIGVuY29kZVNpZ25hdHVyZSQxKGRhdGEpO1xuICB9LFxuICB0cmltOiBhc3luYyBkYXRhID0+IHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcbiAgc3VwcG9ydHNOb0NoYWluSWQ6IHRydWUsXG4gIHJlY292ZXI6IChkYXRhLCBwYXlsb2FkLCBwcm92aWRlcikgPT4ge1xuICAgIHJldHVybiByZWNvdmVyU2lnbmF0dXJlJDEoZGF0YSwgcGF5bG9hZCwgcHJvdmlkZXIpO1xuICB9LFxuICBlbmNvZGVTaWduZXJzOiAoY29uZmlnLCBzaWduYXR1cmVzLCBzdWJkaWdlc3RzLCBjaGFpbklkKSA9PiB7XG4gICAgcmV0dXJuIGVuY29kZVNpZ25lcnMkMShjb25maWcsIHNpZ25hdHVyZXMsIHN1YmRpZ2VzdHMpO1xuICB9LFxuICBoYXNFbm91Z2hTaWduaW5nUG93ZXI6IChjb25maWcsIHNpZ25hdHVyZXMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB3ZWlnaHRcbiAgICB9ID0gU2lnbmF0dXJlQ29kZXIkMS5lbmNvZGVTaWduZXJzKGNvbmZpZywgc2lnbmF0dXJlcywgW10sIDApO1xuICAgIHJldHVybiB3ZWlnaHQgPj0gQmlnSW50KGNvbmZpZy50aHJlc2hvbGQpO1xuICB9LFxuICBjaGFpblNpZ25hdHVyZXM6IChfbWFpbiwgX3N1ZmZpeCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIGNoYWluaW5nIG5vdCBzdXBwb3J0ZWQgb24gdjEnKTtcbiAgfSxcbiAgaGFzaFNldEltYWdlSGFzaDogZnVuY3Rpb24gKF9pbWFnZUhhc2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGhhc2ggbm90IHN1cHBvcnRlZCBvbiB2MScpO1xuICB9LFxuICBzaWduYXR1cmVzT2YoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5zaWduZXJzLmZpbHRlcihzID0+IHMuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQpLm1hcChzID0+ICh7XG4gICAgICBhZGRyZXNzOiBzLmFkZHJlc3MsXG4gICAgICBzaWduYXR1cmU6IHMuc2lnbmF0dXJlXG4gICAgfSkpO1xuICB9LFxuICBzaWduYXR1cmVzT2ZEZWNvZGVkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnNpZ25lcnMubWFwKHMgPT4gcy5zaWduYXR1cmUpLmZpbHRlcihzID0+IHMgIT09IHVuZGVmaW5lZCk7XG4gIH1cbn07XG5cbnZhciBzaWduYXR1cmUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBTaWduYXR1cmVQYXJ0VHlwZTogU2lnbmF0dXJlUGFydFR5cGUkMSxcbiAgaXNBZGRyZXNzTWVtYmVyOiBpc0FkZHJlc3NNZW1iZXIsXG4gIGlzVW5yZWNvdmVyZWRTaWduYXR1cmVNZW1iZXI6IGlzVW5yZWNvdmVyZWRTaWduYXR1cmVNZW1iZXIsXG4gIGlzVW5yZWNvdmVyZWRTaWduYXR1cmU6IGlzVW5yZWNvdmVyZWRTaWduYXR1cmUkMSxcbiAgZGVjb2RlU2lnbmF0dXJlOiBkZWNvZGVTaWduYXR1cmUkMSxcbiAgZW5jb2RlU2lnbmF0dXJlOiBlbmNvZGVTaWduYXR1cmUkMSxcbiAgcmVjb3ZlclNpZ25hdHVyZTogcmVjb3ZlclNpZ25hdHVyZSQxLFxuICBlbmNvZGVTaWduZXJzOiBlbmNvZGVTaWduZXJzJDEsXG4gIFNpZ25hdHVyZUNvZGVyOiBTaWduYXR1cmVDb2RlciQxXG59KTtcblxuY29uc3QgQ29uZmlnQ29kZXIkMSA9IHtcbiAgaXNXYWxsZXRDb25maWc6IGNvbmZpZyA9PiB7XG4gICAgcmV0dXJuIGNvbmZpZy52ZXJzaW9uID09PSAxICYmIGNvbmZpZy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCAmJiBjb25maWcuc2lnbmVycyAhPT0gdW5kZWZpbmVkO1xuICB9LFxuICBpbWFnZUhhc2hPZjogY29uZmlnID0+IHtcbiAgICByZXR1cm4gY29uZmlnLnNpZ25lcnMucmVkdWNlKChpbWFnZUhhc2gsIHNpZ25lcikgPT4gZXRoZXJzLmtlY2NhazI1NihldGhlcnMuQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCkuZW5jb2RlKFsnYnl0ZXMzMicsICd1aW50OCcsICdhZGRyZXNzJ10sIFtpbWFnZUhhc2gsIHNpZ25lci53ZWlnaHQsIHNpZ25lci5hZGRyZXNzXSkpLCBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50MjU2J10sIFtjb25maWcudGhyZXNob2xkXSkpO1xuICB9LFxuICBoYXNTdWJkaWdlc3Q6IChfd2FsbGV0Q29uZmlnLCBfc3ViZGlnZXN0KSA9PiB7XG4gICAgLy8gdjEgZG9lcyBub3Qgc3VwcG9ydCBleHBsaWNpdCBzdWJkaWdlc3RzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBpc0NvbXBsZXRlOiBfY29uZmlnID0+IHtcbiAgICAvLyB2MSBkb2VzIG5vdCBzdXBwb3J0IGluY29tcGxldGUgY29uZmlnc1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBjaGVja3BvaW50T2Y6IF9jb25maWcgPT4ge1xuICAgIHJldHVybiAwbjtcbiAgfSxcbiAgc2lnbmVyc09mOiBjb25maWcgPT4ge1xuICAgIHJldHVybiBjb25maWcuc2lnbmVycy5tYXAocyA9PiAoe1xuICAgICAgYWRkcmVzczogcy5hZGRyZXNzLFxuICAgICAgd2VpZ2h0OiBOdW1iZXIocy53ZWlnaHQpXG4gICAgfSkpO1xuICB9LFxuICBmcm9tU2ltcGxlOiBjb25maWcgPT4ge1xuICAgIGlmIChCaWdJbnQoY29uZmlnLmNoZWNrcG9pbnQpICE9PSAwbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd2MSB3YWxsZXQgY29uZmlnIGRvZXMgbm90IHN1cHBvcnQgY2hlY2twb2ludCcpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnN1YmRpZ2VzdHMgJiYgY29uZmlnLnN1YmRpZ2VzdHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd2MSB3YWxsZXQgY29uZmlnIGRvZXMgbm90IHN1cHBvcnQgc3ViZGlnZXN0cycpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbjogMSxcbiAgICAgIHRocmVzaG9sZDogY29uZmlnLnRocmVzaG9sZCxcbiAgICAgIHNpZ25lcnM6IGNvbmZpZy5zaWduZXJzXG4gICAgfTtcbiAgfSxcbiAgdXBkYXRlOiB7XG4gICAgaXNLaW5kVXNlZDogdHJ1ZSxcbiAgICBidWlsZFRyYW5zYWN0aW9uOiAod2FsbGV0LCBjb25maWcsIGNvbnRleHQsIGtpbmQpID0+IHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKFsuLi53YWxsZXRDb250cmFjdHMubWFpbk1vZHVsZS5hYmksIC4uLndhbGxldENvbnRyYWN0cy5tYWluTW9kdWxlVXBncmFkYWJsZS5hYmldKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IFtdO1xuICAgICAgaWYgKCFraW5kIHx8IGtpbmQgPT09ICdmaXJzdCcpIHtcbiAgICAgICAgdHJhbnNhY3Rpb25zLnB1c2goe1xuICAgICAgICAgIHRvOiB3YWxsZXQsXG4gICAgICAgICAgZGF0YTogbW9kdWxlLmVuY29kZUZ1bmN0aW9uRGF0YShtb2R1bGUuZ2V0RnVuY3Rpb24oJ3VwZGF0ZUltcGxlbWVudGF0aW9uJyksIFtjb250ZXh0Lm1haW5Nb2R1bGVVcGdyYWRhYmxlXSksXG4gICAgICAgICAgZ2FzTGltaXQ6IDAsXG4gICAgICAgICAgZGVsZWdhdGVDYWxsOiBmYWxzZSxcbiAgICAgICAgICByZXZlcnRPbkVycm9yOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdHJhbnNhY3Rpb25zLnB1c2goe1xuICAgICAgICB0bzogd2FsbGV0LFxuICAgICAgICBkYXRhOiBtb2R1bGUuZW5jb2RlRnVuY3Rpb25EYXRhKG1vZHVsZS5nZXRGdW5jdGlvbigndXBkYXRlSW1hZ2VIYXNoJyksIFtDb25maWdDb2RlciQxLmltYWdlSGFzaE9mKGNvbmZpZyldKSxcbiAgICAgICAgZ2FzTGltaXQ6IDAsXG4gICAgICAgIGRlbGVnYXRlQ2FsbDogZmFsc2UsXG4gICAgICAgIHJldmVydE9uRXJyb3I6IHRydWUsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudHJ5cG9pbnQ6IHdhbGxldCxcbiAgICAgICAgdHJhbnNhY3Rpb25zXG4gICAgICB9O1xuICAgIH0sXG4gICAgZGVjb2RlVHJhbnNhY3Rpb246IGZ1bmN0aW9uICh0eCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICB9LFxuICB0b0pTT046IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICBjb25zdCBwbGFpbk1lbWJlcnMgPSBjb25maWcuc2lnbmVycy5tYXAoc2lnbmVyID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdlaWdodDogQmlnSW50KHNpZ25lci53ZWlnaHQpLnRvU3RyaW5nKCksXG4gICAgICAgIGFkZHJlc3M6IHNpZ25lci5hZGRyZXNzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB2ZXJzaW9uOiBjb25maWcudmVyc2lvbixcbiAgICAgIHRocmVzaG9sZDogQmlnSW50KGNvbmZpZy50aHJlc2hvbGQpLnRvU3RyaW5nKCksXG4gICAgICBzaWduZXJzOiBwbGFpbk1lbWJlcnNcbiAgICB9KTtcbiAgfSxcbiAgZnJvbUpTT046IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICBjb25zdCBzaWduZXJzID0gcGFyc2VkLnNpZ25lcnMubWFwKHNpZ25lciA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3ZWlnaHQ6IEJpZ0ludChzaWduZXIud2VpZ2h0KSxcbiAgICAgICAgYWRkcmVzczogc2lnbmVyLmFkZHJlc3NcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb246IHBhcnNlZC52ZXJzaW9uLFxuICAgICAgdGhyZXNob2xkOiBCaWdJbnQocGFyc2VkLnRocmVzaG9sZCksXG4gICAgICBzaWduZXJzXG4gICAgfTtcbiAgfSxcbiAgZWRpdENvbmZpZzogZnVuY3Rpb24gKGNvbmZpZywgYWN0aW9uKSB7XG4gICAgdmFyIF9hY3Rpb24kdGhyZXNob2xkO1xuICAgIGNvbnN0IG5ld1NpZ25lcnMgPSBjb25maWcuc2lnbmVycy5zbGljZSgpO1xuICAgIGlmIChhY3Rpb24uY2hlY2twb2ludCAmJiBCaWdJbnQoYWN0aW9uLmNoZWNrcG9pbnQpICE9PSAwbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd2MSB3YWxsZXQgY29uZmlnIGRvZXMgbm90IHN1cHBvcnQgY2hlY2twb2ludCcpO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uLmFkZCkge1xuICAgICAgZm9yIChjb25zdCBzaWduZXIgb2YgYWN0aW9uLmFkZCkge1xuICAgICAgICBpZiAobmV3U2lnbmVycy5maW5kKHMgPT4gcy5hZGRyZXNzID09PSBzaWduZXIuYWRkcmVzcykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuZXdTaWduZXJzLnB1c2goe1xuICAgICAgICAgIHdlaWdodDogc2lnbmVyLndlaWdodCxcbiAgICAgICAgICBhZGRyZXNzOiBzaWduZXIuYWRkcmVzc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFjdGlvbi5yZW1vdmUpIHtcbiAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBhY3Rpb24ucmVtb3ZlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmV3U2lnbmVycy5maW5kSW5kZXgoc2lnbmVyID0+IHNpZ25lci5hZGRyZXNzID09PSBhZGRyZXNzKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICBuZXdTaWduZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb246IGNvbmZpZy52ZXJzaW9uLFxuICAgICAgdGhyZXNob2xkOiAoX2FjdGlvbiR0aHJlc2hvbGQgPSBhY3Rpb24udGhyZXNob2xkKSAhPSBudWxsID8gX2FjdGlvbiR0aHJlc2hvbGQgOiBjb25maWcudGhyZXNob2xkLFxuICAgICAgc2lnbmVyczogbmV3U2lnbmVyc1xuICAgIH07XG4gIH0sXG4gIGJ1aWxkU3R1YlNpZ25hdHVyZTogZnVuY3Rpb24gKGNvbmZpZywgb3ZlcnJpZGVzKSB7XG4gICAgY29uc3QgcGFydHMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbc2lnbmVyLCBzaWduYXR1cmVdIG9mIG92ZXJyaWRlcy5lbnRyaWVzKCkpIHtcbiAgICAgIHBhcnRzLnNldChzaWduZXIsIHtcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBpc0R5bmFtaWM6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmNvZGVkLFxuICAgICAgICB3ZWlnaHRcbiAgICAgIH0gPSBlbmNvZGVTaWduZXJzJDEoY29uZmlnLCBwYXJ0cywgW10pO1xuICAgICAgaWYgKHdlaWdodCA+PSBCaWdJbnQoY29uZmlnLnRocmVzaG9sZCkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lcnMgPSBjb25maWcuc2lnbmVycztcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGFkZHJlc3NcbiAgICB9IG9mIHNpZ25lcnMuc29ydCgoe1xuICAgICAgd2VpZ2h0OiBhXG4gICAgfSwge1xuICAgICAgd2VpZ2h0OiBiXG4gICAgfSkgPT4gTnVtYmVyKGEpIC0gTnVtYmVyKGIpKSkge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gJzB4NGU4MmYwMmYzODhhMTJiNWY5ZDI5ZWFmMjQ1MmRkMDQwYzBlZTU4MDRiNGU1MDRiNGRkNjRlMzk2YzZjNzgxZjJjNzYyNDE5NWFjYmEyNDJkZDgyNWJmZDI1YTI5MDkxMmUzYzIzMDg0MWZkNTVjOWE3MzRjNGRlOGQ5ODk5NDUxYjAyJztcbiAgICAgIHBhcnRzLnNldChhZGRyZXNzLCB7XG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgaXNEeW5hbWljOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVuY29kZWQsXG4gICAgICAgIHdlaWdodFxuICAgICAgfSA9IGVuY29kZVNpZ25lcnMkMShjb25maWcsIHBhcnRzLCBbXSk7XG4gICAgICBpZiAod2VpZ2h0ID49IEJpZ0ludChjb25maWcudGhyZXNob2xkKSkge1xuICAgICAgICByZXR1cm4gZW5jb2RlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZVNpZ25lcnMkMShjb25maWcsIHBhcnRzLCBbXSkuZW5jb2RlZDtcbiAgfVxufTtcblxudmFyIGNvbmZpZyQyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIENvbmZpZ0NvZGVyOiBDb25maWdDb2RlciQxXG59KTtcblxudmFyIGNvbnRleHQkMiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsXG59KTtcblxuY29uc3QgdmVyc2lvbiQxID0gMTtcbmNvbnN0IERlcGxveWVkV2FsbGV0Q29udGV4dCQxID0ge1xuICB2ZXJzaW9uOiB2ZXJzaW9uJDEsXG4gIGZhY3Rvcnk6ICcweGY5RDA5RDYzNEZiODE4YjA1MTQ5MzI5QzFkY0NGQWVBNTM2MzlkOTYnLFxuICBndWVzdE1vZHVsZTogJzB4MDIzOTBGM0U2RTVGRDFDNjc4NkNCNzhGRDMwMjdDMTE3YTk5NTVBNycsXG4gIG1haW5Nb2R1bGU6ICcweGQwMUYxMTg1NWJDY2I5NWY4OEQ3QTQ4NDkyRjY2NDEwZDQ2MzczMTMnLFxuICBtYWluTW9kdWxlVXBncmFkYWJsZTogJzB4N0VGRTZjRTQxNTk1NmM1ZjgwQzY1MzBjQzZjYzgxYjQ4MDhGNjExOCcsXG4gIHdhbGxldENyZWF0aW9uQ29kZTogJzB4NjAzYTYwMGUzZDM5NjAxYTgwNTEzMDU1M2RmMzM2M2QzZDM3M2QzZDNkMzYzZDMwNTQ1YWY0M2Q4MjgwM2U5MDNkOTE2MDE4NTdmZDViZjMnXG59O1xuXG52YXIgdjEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgY29uZmlnOiBjb25maWckMixcbiAgY29udGV4dDogY29udGV4dCQyLFxuICBzaWduYXR1cmU6IHNpZ25hdHVyZSQxLFxuICB2ZXJzaW9uOiB2ZXJzaW9uJDEsXG4gIERlcGxveWVkV2FsbGV0Q29udGV4dDogRGVwbG95ZWRXYWxsZXRDb250ZXh0JDFcbn0pO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0ga2VjY2FrMjU2KFwiU2V0SW1hZ2VIYXNoKGJ5dGVzMzIgaW1hZ2VIYXNoKVwiKVxuY29uc3QgU2V0SW1hZ2VIYXNoUHJlZml4ID0gJzB4ODcxM2E3YzQ0NjVmNmZiZWUyYjZlOWQ2NjQ2ZDFkOWY4M2ZlYzkyOWVkZmM0YmFmNjYxZjNjODY1YmRkMDRkMSc7XG5mdW5jdGlvbiBoYXNoU2V0SW1hZ2VIYXNoKGltYWdlSGFzaCkge1xuICByZXR1cm4gZXRoZXJzLmtlY2NhazI1NihtZXNzYWdlU2V0SW1hZ2VIYXNoKGltYWdlSGFzaCkpO1xufVxuZnVuY3Rpb24gbWVzc2FnZVNldEltYWdlSGFzaChpbWFnZUhhc2gpIHtcbiAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ2J5dGVzMzInLCAnYnl0ZXMzMiddLCBbU2V0SW1hZ2VIYXNoUHJlZml4LCBpbWFnZUhhc2hdKTtcbn1cbmZ1bmN0aW9uIGRlY29kZU1lc3NhZ2VTZXRJbWFnZUhhc2gobWVzc2FnZSkge1xuICBjb25zdCBhcnIgPSBldGhlcnMuZ2V0Qnl0ZXMobWVzc2FnZSk7XG4gIGlmIChhcnIubGVuZ3RoICE9PSA2NCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGV0aGVycy5oZXhsaWZ5KGFyci5zbGljZSgwLCAzMikpICE9PSBTZXRJbWFnZUhhc2hQcmVmaXgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBldGhlcnMuaGV4bGlmeShhcnIuc2xpY2UoMzIsIDY0KSk7XG59XG5mdW5jdGlvbiBpc01lc3NhZ2VTZXRJbWFnZUhhc2gobWVzc2FnZSkge1xuICByZXR1cm4gZGVjb2RlTWVzc2FnZVNldEltYWdlSGFzaChtZXNzYWdlKSAhPT0gdW5kZWZpbmVkO1xufVxuXG52YXIgY2hhaW5lZCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBTZXRJbWFnZUhhc2hQcmVmaXg6IFNldEltYWdlSGFzaFByZWZpeCxcbiAgaGFzaFNldEltYWdlSGFzaDogaGFzaFNldEltYWdlSGFzaCxcbiAgbWVzc2FnZVNldEltYWdlSGFzaDogbWVzc2FnZVNldEltYWdlSGFzaCxcbiAgZGVjb2RlTWVzc2FnZVNldEltYWdlSGFzaDogZGVjb2RlTWVzc2FnZVNldEltYWdlSGFzaCxcbiAgaXNNZXNzYWdlU2V0SW1hZ2VIYXNoOiBpc01lc3NhZ2VTZXRJbWFnZUhhc2hcbn0pO1xuXG5sZXQgU2lnbmF0dXJlVHlwZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoU2lnbmF0dXJlVHlwZSkge1xuICBTaWduYXR1cmVUeXBlW1NpZ25hdHVyZVR5cGVbXCJMZWdhY3lcIl0gPSAwXSA9IFwiTGVnYWN5XCI7XG4gIFNpZ25hdHVyZVR5cGVbU2lnbmF0dXJlVHlwZVtcIkR5bmFtaWNcIl0gPSAxXSA9IFwiRHluYW1pY1wiO1xuICBTaWduYXR1cmVUeXBlW1NpZ25hdHVyZVR5cGVbXCJOb0NoYWluSWREeW5hbWljXCJdID0gMl0gPSBcIk5vQ2hhaW5JZER5bmFtaWNcIjtcbiAgU2lnbmF0dXJlVHlwZVtTaWduYXR1cmVUeXBlW1wiQ2hhaW5lZFwiXSA9IDNdID0gXCJDaGFpbmVkXCI7XG4gIHJldHVybiBTaWduYXR1cmVUeXBlO1xufSh7fSk7XG5sZXQgU2lnbmF0dXJlUGFydFR5cGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFNpZ25hdHVyZVBhcnRUeXBlKSB7XG4gIFNpZ25hdHVyZVBhcnRUeXBlW1NpZ25hdHVyZVBhcnRUeXBlW1wiU2lnbmF0dXJlXCJdID0gMF0gPSBcIlNpZ25hdHVyZVwiO1xuICBTaWduYXR1cmVQYXJ0VHlwZVtTaWduYXR1cmVQYXJ0VHlwZVtcIkFkZHJlc3NcIl0gPSAxXSA9IFwiQWRkcmVzc1wiO1xuICBTaWduYXR1cmVQYXJ0VHlwZVtTaWduYXR1cmVQYXJ0VHlwZVtcIkR5bmFtaWNTaWduYXR1cmVcIl0gPSAyXSA9IFwiRHluYW1pY1NpZ25hdHVyZVwiO1xuICBTaWduYXR1cmVQYXJ0VHlwZVtTaWduYXR1cmVQYXJ0VHlwZVtcIk5vZGVcIl0gPSAzXSA9IFwiTm9kZVwiO1xuICBTaWduYXR1cmVQYXJ0VHlwZVtTaWduYXR1cmVQYXJ0VHlwZVtcIkJyYW5jaFwiXSA9IDRdID0gXCJCcmFuY2hcIjtcbiAgU2lnbmF0dXJlUGFydFR5cGVbU2lnbmF0dXJlUGFydFR5cGVbXCJTdWJkaWdlc3RcIl0gPSA1XSA9IFwiU3ViZGlnZXN0XCI7XG4gIFNpZ25hdHVyZVBhcnRUeXBlW1NpZ25hdHVyZVBhcnRUeXBlW1wiTmVzdGVkXCJdID0gNl0gPSBcIk5lc3RlZFwiO1xuICByZXR1cm4gU2lnbmF0dXJlUGFydFR5cGU7XG59KHt9KTtcbmNvbnN0IFNpZ25hdHVyZVBhcnRUeXBlTGVuZ3RoID0gNjY7XG5mdW5jdGlvbiBpc1VucmVjb3ZlcmVkTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLmxlZnQgIT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1VucmVjb3ZlcmVkTmVzdGVkTGVhZihsZWFmKSB7XG4gIHJldHVybiBsZWFmLnRyZWUgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzVW5yZWNvdmVyZWRTaWduYXR1cmVMZWFmKGxlYWYpIHtcbiAgcmV0dXJuIGxlYWYudW5yZWNvdmVyZWQgJiYgbGVhZi5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJiBsZWFmLmlzRHluYW1pYyAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZGVjb2RlU2lnbmF0dXJlVHJlZShib2R5KSB7XG4gIGxldCBhcnIgPSBldGhlcnMuZ2V0Qnl0ZXMoYm9keSk7XG4gIGxldCBwb2ludGVyO1xuICBjb25zdCBhcHBlbmQgPSAocHJldlBvaW50ZXIsIG5vZGUpID0+IHtcbiAgICBpZiAoIXByZXZQb2ludGVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBub2RlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXByZXZQb2ludGVyLnJpZ2h0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBwcmV2UG9pbnRlci5sZWZ0LFxuICAgICAgICByaWdodDogbm9kZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHByZXZQb2ludGVyLFxuICAgICAgcmlnaHQ6IG5vZGVcbiAgICB9O1xuICB9O1xuICB3aGlsZSAoYXJyLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCB0eXBlID0gYXJyWzBdO1xuICAgIGFyciA9IGFyci5zbGljZSgxKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgU2lnbmF0dXJlUGFydFR5cGUuU2lnbmF0dXJlOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gYXJyWzBdO1xuICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGV0aGVycy5oZXhsaWZ5KGFyci5zbGljZSgxLCBTaWduYXR1cmVQYXJ0VHlwZUxlbmd0aCArIDEpKTtcbiAgICAgICAgICBwb2ludGVyID0gYXBwZW5kKHBvaW50ZXIsIHtcbiAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgIHdlaWdodCxcbiAgICAgICAgICAgIHVucmVjb3ZlcmVkOiB0cnVlLFxuICAgICAgICAgICAgaXNEeW5hbWljOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFyciA9IGFyci5zbGljZShTaWduYXR1cmVQYXJ0VHlwZUxlbmd0aCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTaWduYXR1cmVQYXJ0VHlwZS5BZGRyZXNzOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gYXJyWzBdO1xuICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhldGhlcnMuaGV4bGlmeShhcnIuc2xpY2UoMSwgMjEpKSk7XG4gICAgICAgICAgcG9pbnRlciA9IGFwcGVuZChwb2ludGVyLCB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgd2VpZ2h0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXJyID0gYXJyLnNsaWNlKDIxKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2lnbmF0dXJlUGFydFR5cGUuRHluYW1pY1NpZ25hdHVyZTpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHdlaWdodCA9IGFyclswXTtcbiAgICAgICAgICBjb25zdCBhZGRyZXNzID0gZXRoZXJzLmdldEFkZHJlc3MoZXRoZXJzLmhleGxpZnkoYXJyLnNsaWNlKDEsIDIxKSkpO1xuICAgICAgICAgIGNvbnN0IHNpemUgPSBhcnJbMjFdIDw8IDE2IHwgYXJyWzIyXSA8PCA4IHwgYXJyWzIzXTtcbiAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBldGhlcnMuaGV4bGlmeShhcnIuc2xpY2UoMjQsIDI0ICsgc2l6ZSkpO1xuICAgICAgICAgIHBvaW50ZXIgPSBhcHBlbmQocG9pbnRlciwge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgIHdlaWdodCxcbiAgICAgICAgICAgIHVucmVjb3ZlcmVkOiB0cnVlLFxuICAgICAgICAgICAgaXNEeW5hbWljOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXJyID0gYXJyLnNsaWNlKDI0ICsgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNpZ25hdHVyZVBhcnRUeXBlLk5vZGU6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBub2RlSGFzaCA9IGV0aGVycy5oZXhsaWZ5KGFyci5zbGljZSgwLCAzMikpO1xuICAgICAgICAgIHBvaW50ZXIgPSBhcHBlbmQocG9pbnRlciwge1xuICAgICAgICAgICAgbm9kZUhhc2hcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhcnIgPSBhcnIuc2xpY2UoMzIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTaWduYXR1cmVQYXJ0VHlwZS5CcmFuY2g6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBzaXplID0gYXJyWzBdIDw8IDE2IHwgYXJyWzFdIDw8IDggfCBhcnJbMl07XG4gICAgICAgICAgY29uc3QgYnJhbmNoID0gZGVjb2RlU2lnbmF0dXJlVHJlZShhcnIuc2xpY2UoMywgMyArIHNpemUpKTtcbiAgICAgICAgICBwb2ludGVyID0gYXBwZW5kKHBvaW50ZXIsIGJyYW5jaCk7XG4gICAgICAgICAgYXJyID0gYXJyLnNsaWNlKDMgKyBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2lnbmF0dXJlUGFydFR5cGUuU3ViZGlnZXN0OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgc3ViZGlnZXN0ID0gZXRoZXJzLmhleGxpZnkoYXJyLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgICAgcG9pbnRlciA9IGFwcGVuZChwb2ludGVyLCB7XG4gICAgICAgICAgICBzdWJkaWdlc3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhcnIgPSBhcnIuc2xpY2UoMzIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTaWduYXR1cmVQYXJ0VHlwZS5OZXN0ZWQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB3ZWlnaHQgPSBhcnJbMF07XG4gICAgICAgICAgY29uc3QgdGhyZXNob2xkID0gYXJyWzFdIDw8IDggfCBhcnJbMl07XG4gICAgICAgICAgY29uc3Qgc2l6ZSA9IGFyclszXSA8PCAxNiB8IGFycls0XSA8PCA4IHwgYXJyWzVdO1xuICAgICAgICAgIGNvbnN0IHRyZWUgPSBkZWNvZGVTaWduYXR1cmVUcmVlKGFyci5zbGljZSg2LCA2ICsgc2l6ZSkpO1xuICAgICAgICAgIHBvaW50ZXIgPSBhcHBlbmQocG9pbnRlciwge1xuICAgICAgICAgICAgd2VpZ2h0LFxuICAgICAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICAgICAgdHJlZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFyciA9IGFyci5zbGljZSg2ICsgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2lnbmF0dXJlIHBhcnQgdHlwZTogJHt0eXBlfTogJHtldGhlcnMuaGV4bGlmeShhcnIpfWApO1xuICAgIH1cbiAgfVxuICBpZiAoIXBvaW50ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IHNpZ25hdHVyZSB0cmVlJyk7XG4gIH1cbiAgaWYgKHBvaW50ZXIucmlnaHQpIHtcbiAgICByZXR1cm4gcG9pbnRlcjtcbiAgfVxuICByZXR1cm4gcG9pbnRlci5sZWZ0O1xufVxuY2xhc3MgSW52YWxpZFNpZ25hdHVyZUxlYWZFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobGVhZikge1xuICAgIHN1cGVyKGBJbnZhbGlkIHNpZ25hdHVyZSBsZWFmOiAke0pTT04uc3RyaW5naWZ5KGxlYWYpfWApO1xuICAgIHRoaXMubGVhZiA9IGxlYWY7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlY292ZXJUb3BvbG9neSh1bnJlY292ZXJlZCwgc3ViZGlnZXN0LCBwcm92aWRlcikge1xuICBpZiAoaXNVbnJlY292ZXJlZE5vZGUodW5yZWNvdmVyZWQpKSB7XG4gICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtyZWNvdmVyVG9wb2xvZ3kodW5yZWNvdmVyZWQubGVmdCwgc3ViZGlnZXN0LCBwcm92aWRlciksIHJlY292ZXJUb3BvbG9neSh1bnJlY292ZXJlZC5yaWdodCwgc3ViZGlnZXN0LCBwcm92aWRlcildKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfVxuICBpZiAoaXNVbnJlY292ZXJlZE5lc3RlZExlYWYodW5yZWNvdmVyZWQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdlaWdodDogdW5yZWNvdmVyZWQud2VpZ2h0LFxuICAgICAgdGhyZXNob2xkOiB1bnJlY292ZXJlZC50aHJlc2hvbGQsXG4gICAgICB0cmVlOiBhd2FpdCByZWNvdmVyVG9wb2xvZ3kodW5yZWNvdmVyZWQudHJlZSwgc3ViZGlnZXN0LCBwcm92aWRlcilcbiAgICB9O1xuICB9XG4gIGlmIChpc1VucmVjb3ZlcmVkU2lnbmF0dXJlTGVhZih1bnJlY292ZXJlZCkpIHtcbiAgICBpZiAodW5yZWNvdmVyZWQuaXNEeW5hbWljKSB7XG4gICAgICBpZiAoIXVucmVjb3ZlcmVkLmFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHNpZ25hdHVyZSBsZWFmIHdpdGhvdXQgYWRkcmVzcycpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGlzVmFsaWRTaWduYXR1cmUodW5yZWNvdmVyZWQuYWRkcmVzcywgc3ViZGlnZXN0LCB1bnJlY292ZXJlZC5zaWduYXR1cmUsIHByb3ZpZGVyKTtcbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNpZ25hdHVyZUxlYWZFcnJvcih1bnJlY292ZXJlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3ZWlnaHQ6IHVucmVjb3ZlcmVkLndlaWdodCxcbiAgICAgICAgYWRkcmVzczogdW5yZWNvdmVyZWQuYWRkcmVzcyxcbiAgICAgICAgc2lnbmF0dXJlOiB1bnJlY292ZXJlZC5zaWduYXR1cmUsXG4gICAgICAgIHN1YmRpZ2VzdFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2VpZ2h0OiB1bnJlY292ZXJlZC53ZWlnaHQsXG4gICAgICAgIGFkZHJlc3M6IHJlY292ZXJTaWduZXIoc3ViZGlnZXN0LCB1bnJlY292ZXJlZC5zaWduYXR1cmUpLFxuICAgICAgICBzaWduYXR1cmU6IHVucmVjb3ZlcmVkLnNpZ25hdHVyZSxcbiAgICAgICAgc3ViZGlnZXN0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5yZWNvdmVyZWQ7XG59XG5cbi8vIFRPRE86IEl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byByZS11c2UgZW5jb2RlU2lnbmF0dXJlVHJlZVxuLy8gYW5kIGF2b2lkIGR1cGxpY2F0aW5nIHRoaXMgbG9naWNcbmNvbnN0IHBhcnRFbmNvZGVyID0ge1xuICBjb25jYXQ6IChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ2J5dGVzJywgJ2J5dGVzJ10sIFthLCBiXSk7XG4gIH0sXG4gIG5vZGU6IG5vZGVIYXNoID0+IHtcbiAgICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDgnLCAnYnl0ZXMzMiddLCBbU2lnbmF0dXJlUGFydFR5cGUuTm9kZSwgbm9kZUhhc2hdKTtcbiAgfSxcbiAgYnJhbmNoOiB0cmVlID0+IHtcbiAgICBjb25zdCBhcnIgPSBldGhlcnMuZ2V0Qnl0ZXModHJlZSk7XG4gICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ3VpbnQyNCcsICdieXRlcyddLCBbU2lnbmF0dXJlUGFydFR5cGUuQnJhbmNoLCBhcnIubGVuZ3RoLCBhcnJdKTtcbiAgfSxcbiAgbmVzdGVkOiAod2VpZ2h0LCB0aHJlc2hvbGQsIHRyZWUpID0+IHtcbiAgICBjb25zdCBhcnIgPSBldGhlcnMuZ2V0Qnl0ZXModHJlZSk7XG4gICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ3VpbnQ4JywgJ3VpbnQxNicsICd1aW50MjQnLCAnYnl0ZXMnXSwgW1NpZ25hdHVyZVBhcnRUeXBlLk5lc3RlZCwgd2VpZ2h0LCB0aHJlc2hvbGQsIGFyci5sZW5ndGgsIGFycl0pO1xuICB9LFxuICBzdWJkaWdlc3Q6IHN1YmRpZ2VzdCA9PiB7XG4gICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ2J5dGVzMzInXSwgW1NpZ25hdHVyZVBhcnRUeXBlLlN1YmRpZ2VzdCwgc3ViZGlnZXN0XSk7XG4gIH0sXG4gIHNpZ25hdHVyZTogKHdlaWdodCwgc2lnbmF0dXJlKSA9PiB7XG4gICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ3VpbnQ4JywgJ2J5dGVzJ10sIFtTaWduYXR1cmVQYXJ0VHlwZS5TaWduYXR1cmUsIHdlaWdodCwgc2lnbmF0dXJlXSk7XG4gIH0sXG4gIGR5bmFtaWNTaWduYXR1cmU6ICh3ZWlnaHQsIGFkZHJlc3MsIHNpZ25hdHVyZSkgPT4ge1xuICAgIGNvbnN0IGFyclNpZ25hdHVyZSA9IGV0aGVycy5nZXRCeXRlcyhzaWduYXR1cmUpO1xuICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICd1aW50OCcsICdhZGRyZXNzJywgJ3VpbnQyNCcsICdieXRlcyddLCBbU2lnbmF0dXJlUGFydFR5cGUuRHluYW1pY1NpZ25hdHVyZSwgd2VpZ2h0LCBhZGRyZXNzLCBhcnJTaWduYXR1cmUubGVuZ3RoLCBhcnJTaWduYXR1cmVdKTtcbiAgfSxcbiAgYWRkcmVzczogKHdlaWdodCwgYWRkcmVzcykgPT4ge1xuICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICd1aW50OCcsICdhZGRyZXNzJ10sIFtTaWduYXR1cmVQYXJ0VHlwZS5BZGRyZXNzLCB3ZWlnaHQsIGFkZHJlc3NdKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGVuY29kZVNpZ25lcnMoY29uZmlnLCBwYXJ0cywgc3ViZGlnZXN0cywgY2hhaW5JZCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHRyZWUgPSBlbmNvZGVUcmVlKGNvbmZpZy50cmVlLCBwYXJ0cywgc3ViZGlnZXN0cywgb3B0aW9ucyk7XG4gIGlmIChCaWdJbnQoY2hhaW5JZCkgPT09IDBuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY29kZWQ6IGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ3VpbnQxNicsICd1aW50MzInLCAnYnl0ZXMnXSwgW1NpZ25hdHVyZVR5cGUuTm9DaGFpbklkRHluYW1pYywgY29uZmlnLnRocmVzaG9sZCwgY29uZmlnLmNoZWNrcG9pbnQsIHRyZWUuZW5jb2RlZF0pLFxuICAgICAgd2VpZ2h0OiB0cmVlLndlaWdodFxuICAgIH07XG4gIH1cbiAgaWYgKEJpZ0ludChjb25maWcudGhyZXNob2xkKSA+IDI1NW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW5jb2RlZDogZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDgnLCAndWludDE2JywgJ3VpbnQzMicsICdieXRlcyddLCBbU2lnbmF0dXJlVHlwZS5EeW5hbWljLCBjb25maWcudGhyZXNob2xkLCBjb25maWcuY2hlY2twb2ludCwgdHJlZS5lbmNvZGVkXSksXG4gICAgICB3ZWlnaHQ6IHRyZWUud2VpZ2h0XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZWQ6IGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ3VpbnQ4JywgJ3VpbnQzMicsICdieXRlcyddLCBbU2lnbmF0dXJlVHlwZS5MZWdhY3ksIGNvbmZpZy50aHJlc2hvbGQsIGNvbmZpZy5jaGVja3BvaW50LCB0cmVlLmVuY29kZWRdKSxcbiAgICB3ZWlnaHQ6IHRyZWUud2VpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBlbmNvZGVUcmVlKHRvcG9sb2d5LCBwYXJ0cywgc3ViZGlnZXN0cywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHRyaW0gPSAhb3B0aW9ucy5kaXNhYmxlVHJpbTtcbiAgaWYgKGlzTm9kZSh0b3BvbG9neSkpIHtcbiAgICBjb25zdCBsZWZ0ID0gZW5jb2RlVHJlZSh0b3BvbG9neS5sZWZ0LCBwYXJ0cywgc3ViZGlnZXN0cyk7XG4gICAgY29uc3QgcmlnaHQgPSBlbmNvZGVUcmVlKHRvcG9sb2d5LnJpZ2h0LCBwYXJ0cywgc3ViZGlnZXN0cyk7XG4gICAgY29uc3QgaXNMZWZ0U2lnbmVyID0gaXNTaWduZXJMZWFmKHRvcG9sb2d5LmxlZnQpO1xuICAgIGNvbnN0IGlzUmlnaHRTaWduZXIgPSBpc1NpZ25lckxlYWYodG9wb2xvZ3kucmlnaHQpO1xuICAgIGlmICh0cmltICYmIGxlZnQud2VpZ2h0ID09PSAwbiAmJiByaWdodC53ZWlnaHQgPT09IDBuICYmICFpc0xlZnRTaWduZXIgJiYgIWlzUmlnaHRTaWduZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gaW5jbHVkZSBhbnl0aGluZyBmb3IgdGhpcyBub2RlXG4gICAgICAgIC8vIGp1c3QgdGhlIGhhc2ggd2lsbCBiZSBlbm91Z2hcbiAgICAgICAgZW5jb2RlZDogcGFydEVuY29kZXIubm9kZShoYXNoTm9kZSh0b3BvbG9neSkpLFxuICAgICAgICB3ZWlnaHQ6IDBuXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHJpbSAmJiByaWdodC53ZWlnaHQgPT09IDBuICYmICFpc1JpZ2h0U2lnbmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBUaGUgcmlnaHQgbm9kZSBkb2Vzbid0IGhhdmUgYW55IHdlaWdodFxuICAgICAgICAvLyBidXQgd2Ugc3RpbGwgbmVlZCB0byBpbmNsdWRlIHRoZSBsZWZ0IG5vZGUgZW5jb2RlZFxuICAgICAgICBlbmNvZGVkOiBwYXJ0RW5jb2Rlci5jb25jYXQobGVmdC5lbmNvZGVkLCBwYXJ0RW5jb2Rlci5ub2RlKGhhc2hOb2RlKHRvcG9sb2d5LnJpZ2h0KSkpLFxuICAgICAgICB3ZWlnaHQ6IGxlZnQud2VpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHJpbSAmJiBsZWZ0LndlaWdodCA9PT0gMG4gJiYgIWlzTGVmdFNpZ25lcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gVGhlIGxlZnQgbm9kZSBkb2Vzbid0IGhhdmUgYW55IHdlaWdodFxuICAgICAgICAvLyB3ZSBjYW4ganVzdCBhcHBlbmQgaXRzIGhhc2gsIGJ1dCBmb3IgdGhlIHJpZ2h0IG5vZGVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgXCJicmFuY2hcIlxuICAgICAgICBlbmNvZGVkOiBwYXJ0RW5jb2Rlci5jb25jYXQocGFydEVuY29kZXIubm9kZShoYXNoTm9kZSh0b3BvbG9neS5sZWZ0KSksIHBhcnRFbmNvZGVyLmJyYW5jaChyaWdodC5lbmNvZGVkKSksXG4gICAgICAgIHdlaWdodDogcmlnaHQud2VpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLy8gQm90aCBub2RlcyBoYXZlIHdlaWdodCwgd2UgbmVlZCB0byBpbmNsdWRlIGJvdGhcbiAgICAgIC8vIHRoZSByaWdodCBvbmUgbXVzdCBiZSBhIGJyYW5jaFxuICAgICAgZW5jb2RlZDogcGFydEVuY29kZXIuY29uY2F0KGxlZnQuZW5jb2RlZCwgcGFydEVuY29kZXIuYnJhbmNoKHJpZ2h0LmVuY29kZWQpKSxcbiAgICAgIHdlaWdodDogbGVmdC53ZWlnaHQgKyByaWdodC53ZWlnaHRcbiAgICB9O1xuICB9XG4gIGlmIChpc05lc3RlZExlYWYodG9wb2xvZ3kpKSB7XG4gICAgY29uc3QgdHJlZSA9IGVuY29kZVRyZWUodG9wb2xvZ3kudHJlZSwgcGFydHMsIHN1YmRpZ2VzdHMpO1xuICAgIGlmICh0cmltICYmIHRyZWUud2VpZ2h0ID09PSAwbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlZDogcGFydEVuY29kZXIubm9kZShoYXNoTm9kZSh0b3BvbG9neSkpLFxuICAgICAgICB3ZWlnaHQ6IDBuXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZW5jb2RlZDogcGFydEVuY29kZXIubmVzdGVkKHRvcG9sb2d5LndlaWdodCwgdG9wb2xvZ3kudGhyZXNob2xkLCB0cmVlLmVuY29kZWQpLFxuICAgICAgd2VpZ2h0OiB0cmVlLndlaWdodFxuICAgIH07XG4gIH1cbiAgaWYgKGlzTm9kZUxlYWYodG9wb2xvZ3kpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY29kZWQ6IHBhcnRFbmNvZGVyLm5vZGUoaGFzaE5vZGUodG9wb2xvZ3kpKSxcbiAgICAgIHdlaWdodDogMG5cbiAgICB9O1xuICB9XG4gIGlmIChpc1N1YmRpZ2VzdExlYWYodG9wb2xvZ3kpKSB7XG4gICAgY29uc3QgaW5jbHVkZSA9IHN1YmRpZ2VzdHMuaW5jbHVkZXModG9wb2xvZ3kuc3ViZGlnZXN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgZW5jb2RlZDogcGFydEVuY29kZXIuc3ViZGlnZXN0KHRvcG9sb2d5LnN1YmRpZ2VzdCksXG4gICAgICB3ZWlnaHQ6IGluY2x1ZGUgPyBNQVhfVUlOVF8yNTYgOiAwblxuICAgIH07XG4gIH1cbiAgaWYgKGlzU2lnbmVyTGVhZih0b3BvbG9neSkpIHtcbiAgICBjb25zdCBpbmNsdWRlID0gcGFydHMuaGFzKHRvcG9sb2d5LmFkZHJlc3MpO1xuICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydHMuZ2V0KHRvcG9sb2d5LmFkZHJlc3MpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcGFydC5zaWduYXR1cmU7XG4gICAgICBpZiAob3B0aW9ucy5mb3JjZUR5bmFtaWNFbmNvZGluZyB8fCBwYXJ0LmlzRHluYW1pYykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVuY29kZWQ6IHBhcnRFbmNvZGVyLmR5bmFtaWNTaWduYXR1cmUodG9wb2xvZ3kud2VpZ2h0LCB0b3BvbG9neS5hZGRyZXNzLCBzaWduYXR1cmUpLFxuICAgICAgICAgIHdlaWdodDogQmlnSW50KHRvcG9sb2d5LndlaWdodClcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZW5jb2RlZDogcGFydEVuY29kZXIuc2lnbmF0dXJlKHRvcG9sb2d5LndlaWdodCwgc2lnbmF0dXJlKSxcbiAgICAgICAgICB3ZWlnaHQ6IEJpZ0ludCh0b3BvbG9neS53ZWlnaHQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZWQ6IHBhcnRFbmNvZGVyLmFkZHJlc3ModG9wb2xvZ3kud2VpZ2h0LCB0b3BvbG9neS5hZGRyZXNzKSxcbiAgICAgICAgd2VpZ2h0OiAwblxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRvcG9sb2d5IC0gdW5rbm93biBlcnJvcjogJHtKU09OLnN0cmluZ2lmeSh0b3BvbG9neSl9YCk7XG59XG5mdW5jdGlvbiBkZWVwZXN0Q29uZmlnT2ZTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBpc0NoYWluZWRTaWduYXR1cmUoc2lnbmF0dXJlKSA/IGRlZXBlc3RDb25maWdPZlNpZ25hdHVyZShzaWduYXR1cmUuc3VmZml4W3NpZ25hdHVyZS5zdWZmaXgubGVuZ3RoIC0gMV0pIDogc2lnbmF0dXJlLmNvbmZpZztcbn1cbmZ1bmN0aW9uIGlzVW5yZWNvdmVyZWRTaWduYXR1cmUoc2lnKSB7XG4gIHJldHVybiBzaWcudHlwZSAhPT0gdW5kZWZpbmVkICYmIHNpZy5kZWNvZGVkICE9PSB1bmRlZmluZWQgJiYgc2lnLnZlcnNpb24gIT09IHVuZGVmaW5lZCAmJiBzaWcudmVyc2lvbiA9PT0gMjtcbn1cbmZ1bmN0aW9uIGlzVW5yZWNvdmVyZWRDaGFpbmVkU2lnbmF0dXJlKHNpZykge1xuICByZXR1cm4gc2lnLnN1ZmZpeCAhPT0gdW5kZWZpbmVkICYmIEFycmF5LmlzQXJyYXkoc2lnLnN1ZmZpeCkgJiYgc2lnLnN1ZmZpeC5ldmVyeShpc1VucmVjb3ZlcmVkU2lnbmF0dXJlKTtcbn1cbmZ1bmN0aW9uIGlzU2lnbmF0dXJlKHNpZykge1xuICByZXR1cm4gc2lnLnR5cGUgIT09IHVuZGVmaW5lZCAmJiBzaWcuY29uZmlnICE9PSB1bmRlZmluZWQgJiYgc2lnLmRpZ2VzdCAhPT0gdW5kZWZpbmVkICYmIHNpZy52ZXJzaW9uICE9PSB1bmRlZmluZWQgJiYgc2lnLnZlcnNpb24gPT09IDI7XG59XG5mdW5jdGlvbiBpc0NoYWluZWRTaWduYXR1cmUoc2lnKSB7XG4gIHJldHVybiBzaWcuY2hhaW4gIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KHNpZy5jaGFpbikgJiYgc2lnLmNoYWluLmV2ZXJ5KGlzU2lnbmF0dXJlKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgY29uc3QgYnl0ZXMgPSBldGhlcnMuZ2V0Qnl0ZXMoc2lnbmF0dXJlKTtcbiAgY29uc3QgdHlwZSA9IGJ5dGVzWzBdO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNpZ25hdHVyZVR5cGUuTGVnYWN5OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVyc2lvbjogMixcbiAgICAgICAgdHlwZTogU2lnbmF0dXJlVHlwZS5MZWdhY3ksXG4gICAgICAgIGRlY29kZWQ6IGRlY29kZVNpZ25hdHVyZUJvZHkoYnl0ZXMpXG4gICAgICB9O1xuICAgIGNhc2UgU2lnbmF0dXJlVHlwZS5EeW5hbWljOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVyc2lvbjogMixcbiAgICAgICAgdHlwZTogU2lnbmF0dXJlVHlwZS5EeW5hbWljLFxuICAgICAgICBkZWNvZGVkOiBkZWNvZGVTaWduYXR1cmVCb2R5KGJ5dGVzLnNsaWNlKDEpKVxuICAgICAgfTtcbiAgICBjYXNlIFNpZ25hdHVyZVR5cGUuTm9DaGFpbklkRHluYW1pYzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IDIsXG4gICAgICAgIHR5cGU6IFNpZ25hdHVyZVR5cGUuTm9DaGFpbklkRHluYW1pYyxcbiAgICAgICAgZGVjb2RlZDogZGVjb2RlU2lnbmF0dXJlQm9keShieXRlcy5zbGljZSgxKSlcbiAgICAgIH07XG4gICAgY2FzZSBTaWduYXR1cmVUeXBlLkNoYWluZWQ6XG4gICAgICByZXR1cm4gZGVjb2RlQ2hhaW5lZFNpZ25hdHVyZShieXRlcyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduYXR1cmUgdHlwZTogJHt0eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiBkZWNvZGVTaWduYXR1cmVCb2R5KHNpZ25hdHVyZSkge1xuICBjb25zdCBieXRlcyA9IGV0aGVycy5nZXRCeXRlcyhzaWduYXR1cmUpO1xuICBjb25zdCB0aHJlc2hvbGQgPSBieXRlc1swXSA8PCA4IHwgYnl0ZXNbMV07XG4gIGNvbnN0IGNoZWNrcG9pbnQgPSBieXRlc1syXSA8PCAyNCB8IGJ5dGVzWzNdIDw8IDE2IHwgYnl0ZXNbNF0gPDwgOCB8IGJ5dGVzWzVdO1xuICBjb25zdCB0cmVlID0gZGVjb2RlU2lnbmF0dXJlVHJlZShieXRlcy5zbGljZSg2KSk7XG4gIHJldHVybiB7XG4gICAgdGhyZXNob2xkLFxuICAgIGNoZWNrcG9pbnQsXG4gICAgdHJlZVxuICB9O1xufVxuZnVuY3Rpb24gZGVjb2RlQ2hhaW5lZFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgY29uc3QgYXJyID0gZXRoZXJzLmdldEJ5dGVzKHNpZ25hdHVyZSk7XG4gIGNvbnN0IHR5cGUgPSBhcnJbMF07XG4gIGlmICh0eXBlICE9PSBTaWduYXR1cmVUeXBlLkNoYWluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGNoYWluZWQgc2lnbmF0dXJlIHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICBjb25zdCBjaGFpbiA9IFtdO1xuICBsZXQgaW5kZXggPSAxO1xuICB3aGlsZSAoaW5kZXggPCBhcnIubGVuZ3RoKSB7XG4gICAgY29uc3Qgc2l6ZSA9IGFycltpbmRleF0gPDwgMTYgfCBhcnJbaW5kZXggKyAxXSA8PCA4IHwgYXJyW2luZGV4ICsgMl07XG4gICAgaW5kZXggKz0gMztcbiAgICBjb25zdCBzaWcgPSBkZWNvZGVTaWduYXR1cmUoYXJyLnNsaWNlKGluZGV4LCBpbmRleCArIHNpemUpKTtcbiAgICBjaGFpbi5wdXNoKHNpZyk7XG4gICAgaW5kZXggKz0gc2l6ZTtcbiAgfVxuICBjb25zdCBtYWluID0gY2hhaW5bMF07XG4gIGlmIChpc1VucmVjb3ZlcmVkQ2hhaW5lZFNpZ25hdHVyZShtYWluKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgZmlyc3QgbGluayBvZiBjaGFpbmVkIHNpZ25hdHVyZSB0byBiZSBhIHNpbXBsZSBzaWduYXR1cmUgKG5vdCBjaGFpbmVkKWApO1xuICB9XG4gIGNvbnN0IHN1ZmZpeCA9IGNoYWluLnNsaWNlKDEpO1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG1haW4sIHtcbiAgICBzdWZmaXhcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRJbWFnZUhhc2hTdHJ1Y3QoaW1hZ2VIYXNoKSB7XG4gIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWydieXRlczMyJywgJ2J5dGVzMzInXSwgW2V0aGVycy5zb2xpZGl0eVBhY2tlZEtlY2NhazI1NihbJ3N0cmluZyddLCBbJ1NldEltYWdlSGFzaChieXRlczMyIGltYWdlSGFzaCknXSksIGltYWdlSGFzaF0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVjb3ZlclNpZ25hdHVyZShzaWduYXR1cmUsIHBheWxvYWQsIHByb3ZpZGVyKSB7XG4gIGNvbnN0IHNpZ25lZFBheWxvYWQgPSBwYXlsb2FkLnN1YmRpZ2VzdCA9PT0gdW5kZWZpbmVkID8gcGF5bG9hZCA6IHVuZGVmaW5lZDtcbiAgY29uc3QgaXNOb0NoYWluSWQgPSBzaWduYXR1cmUudHlwZSA9PT0gU2lnbmF0dXJlVHlwZS5Ob0NoYWluSWREeW5hbWljO1xuICBpZiAoaXNOb0NoYWluSWQgJiYgc2lnbmVkUGF5bG9hZCkge1xuICAgIHNpZ25lZFBheWxvYWQuY2hhaW5JZCA9IDA7XG4gIH1cbiAgY29uc3Qgc3ViZGlnZXN0ID0gc2lnbmVkUGF5bG9hZCA/IHN1YmRpZ2VzdE9mKHNpZ25lZFBheWxvYWQpIDogcGF5bG9hZC5zdWJkaWdlc3Q7XG4gIGlmICghaXNVbnJlY292ZXJlZENoYWluZWRTaWduYXR1cmUoc2lnbmF0dXJlKSkge1xuICAgIGNvbnN0IHRyZWUgPSBhd2FpdCByZWNvdmVyVG9wb2xvZ3koc2lnbmF0dXJlLmRlY29kZWQudHJlZSwgc3ViZGlnZXN0LCBwcm92aWRlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb246IDIsXG4gICAgICB0eXBlOiBzaWduYXR1cmUudHlwZSxcbiAgICAgIHN1YmRpZ2VzdCxcbiAgICAgIGNvbmZpZzogX2V4dGVuZHMoe1xuICAgICAgICB2ZXJzaW9uOiAyXG4gICAgICB9LCBzaWduYXR1cmUuZGVjb2RlZCwge1xuICAgICAgICB0cmVlXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgaWYgKCFpc1NpZ25lZFBheWxvYWQoc2lnbmVkUGF5bG9hZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENoYWluZWQgc2lnbmF0dXJlIHJlY292ZXJ5IHJlcXVpcmVzIGRldGFpbGVkIHNpZ25lZCBwYXlsb2FkLCBzdWJkaWdlc3QgaXMgbm90IGVub3VnaGApO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgbXV0YXRlZFBheWxvYWQgPSBzaWduZWRQYXlsb2FkO1xuXG4gIC8vIFJlY292ZXIgdGhlIGNoYWluIG9mIHNpZ25hdHVyZXNcbiAgLy8gTk9USUNFOiBSZW1vdmUgdGhlIHN1ZmZpeCBmcm9tIHRoZSBcImZpcnN0XCIgc2lnYW50dXJlXG4gIC8vIG90aGVyd2lzZSB3ZSByZWN1cnNlIGluZmluaXRlbHlcbiAgZm9yIChjb25zdCBzaWcgb2YgW19leHRlbmRzKHt9LCBzaWduYXR1cmUsIHtcbiAgICBzdWZmaXg6IHVuZGVmaW5lZFxuICB9KSwgLi4uc2lnbmF0dXJlLnN1ZmZpeF0pIHtcbiAgICBjb25zdCByZWNvdmVyZWQgPSBhd2FpdCByZWNvdmVyU2lnbmF0dXJlKHNpZywgbXV0YXRlZFBheWxvYWQsIHByb3ZpZGVyKTtcbiAgICByZXN1bHQudW5zaGlmdChyZWNvdmVyZWQpO1xuICAgIGNvbnN0IG5leHRNZXNzYWdlID0gc2V0SW1hZ2VIYXNoU3RydWN0KGltYWdlSGFzaChkZWVwZXN0Q29uZmlnT2ZTaWduYXR1cmUocmVjb3ZlcmVkKSkpO1xuICAgIG11dGF0ZWRQYXlsb2FkID0gX2V4dGVuZHMoe30sIG11dGF0ZWRQYXlsb2FkLCB7XG4gICAgICBtZXNzYWdlOiBuZXh0TWVzc2FnZSxcbiAgICAgIGRpZ2VzdDogZXRoZXJzLmtlY2NhazI1NihuZXh0TWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtYWluID0gcmVzdWx0WzBdO1xuICBjb25zdCBzdWZmaXggPSByZXN1bHQuc2xpY2UoMSk7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgbWFpbiwge1xuICAgIHN1ZmZpeFxuICB9KTtcbn1cbmZ1bmN0aW9uIGVuY29kZUNoYWluKG1haW4sIHN1ZmZpeCkge1xuICBjb25zdCBhbGxTaWduYXR1cmVzID0gW21haW4sIC4uLihzdWZmaXggfHwgW10pXTtcbiAgY29uc3QgZW5jb2RlZE1hcCA9IGFsbFNpZ25hdHVyZXMubWFwKHMgPT4gZXRoZXJzLmdldEJ5dGVzKGVuY29kZVNpZ25hdHVyZShzKSkpO1xuICBjb25zdCBib2R5ID0gZXRoZXJzLnNvbGlkaXR5UGFja2VkKGVuY29kZWRNYXAubWFwKCgpID0+IFsndWludDI0JywgJ2J5dGVzJ10pLmZsYXQoKSwgZW5jb2RlZE1hcC5tYXAocyA9PiBbcy5sZW5ndGgsIHNdKS5mbGF0KCkpO1xuICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDgnLCAnYnl0ZXMnXSwgW1NpZ25hdHVyZVR5cGUuQ2hhaW5lZCwgYm9keV0pO1xufVxuZnVuY3Rpb24gZW5jb2RlU2lnbmF0dXJlKGRlY29kZWQpIHtcbiAgaWYgKGV0aGVycy5pc0J5dGVzTGlrZShkZWNvZGVkKSkgcmV0dXJuIGV0aGVycy5oZXhsaWZ5KGRlY29kZWQpO1xuICBpZiAoaXNVbnJlY292ZXJlZENoYWluZWRTaWduYXR1cmUoZGVjb2RlZCkgfHwgaXNDaGFpbmVkU2lnbmF0dXJlKGRlY29kZWQpKSB7XG4gICAgcmV0dXJuIGVuY29kZUNoYWluKGVuY29kZVNpZ25hdHVyZShkZWNvZGVkKSwgKGRlY29kZWQuc3VmZml4IHx8IFtdKS5tYXAoZW5jb2RlU2lnbmF0dXJlKSk7XG4gIH1cbiAgY29uc3QgYm9keSA9IGlzVW5yZWNvdmVyZWRTaWduYXR1cmUoZGVjb2RlZCkgPyBkZWNvZGVkLmRlY29kZWQgOiBkZWNvZGVkLmNvbmZpZztcbiAgc3dpdGNoIChkZWNvZGVkLnR5cGUpIHtcbiAgICBjYXNlIFNpZ25hdHVyZVR5cGUuTGVnYWN5OlxuICAgICAgaWYgKEJpZ0ludChib2R5LnRocmVzaG9sZCkgPiAyNTVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTGVnYWN5IHNpZ25hdHVyZSB0aHJlc2hvbGQgaXMgdG9vIGxhcmdlOiAke2JvZHkudGhyZXNob2xkfSAobWF4IDI1NSlgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNvZGVTaWduYXR1cmVCb2R5KGJvZHkpO1xuICAgIGNhc2UgU2lnbmF0dXJlVHlwZS5Ob0NoYWluSWREeW5hbWljOlxuICAgIGNhc2UgU2lnbmF0dXJlVHlwZS5EeW5hbWljOlxuICAgICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ2J5dGVzJ10sIFtkZWNvZGVkLnR5cGUsIGVuY29kZVNpZ25hdHVyZUJvZHkoYm9keSldKTtcbiAgICBjYXNlIFNpZ25hdHVyZVR5cGUuQ2hhaW5lZDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWFjaGFibGUgY29kZTogQ2hhaW5lZCBzaWduYXR1cmUgc2hvdWxkIGJlIGhhbmRsZWQgYWJvdmVgKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZSB0eXBlOiAke2RlY29kZWQudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5jb2RlU2lnbmF0dXJlQm9keShkZWNvZGVkKSB7XG4gIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50MTYnLCAndWludDMyJywgJ2J5dGVzJ10sIFtkZWNvZGVkLnRocmVzaG9sZCwgZGVjb2RlZC5jaGVja3BvaW50LCBlbmNvZGVTaWduYXR1cmVUcmVlKGRlY29kZWQudHJlZSldKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVNpZ25hdHVyZVRyZWUodHJlZSkge1xuICBpZiAoaXNOb2RlKHRyZWUpIHx8IGlzVW5yZWNvdmVyZWROb2RlKHRyZWUpKSB7XG4gICAgY29uc3QgZW5jb2RlZFJpZ2h0ID0gZXRoZXJzLmdldEJ5dGVzKGVuY29kZVNpZ25hdHVyZVRyZWUodHJlZS5yaWdodCkpO1xuICAgIGNvbnN0IGVuY29kZWRMZWZ0ID0gZXRoZXJzLmdldEJ5dGVzKGVuY29kZVNpZ25hdHVyZVRyZWUodHJlZS5sZWZ0KSk7XG4gICAgY29uc3QgaXNCcmFuY2hpbmcgPSBpc05vZGUodHJlZS5yaWdodCkgfHwgaXNVbnJlY292ZXJlZE5vZGUodHJlZS5yaWdodCk7XG4gICAgaWYgKGlzQnJhbmNoaW5nKSB7XG4gICAgICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsnYnl0ZXMnLCAndWludDgnLCAndWludDI0JywgJ2J5dGVzJ10sIFtlbmNvZGVkTGVmdCwgU2lnbmF0dXJlUGFydFR5cGUuQnJhbmNoLCBlbmNvZGVkUmlnaHQubGVuZ3RoLCBlbmNvZGVkUmlnaHRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ2J5dGVzJywgJ2J5dGVzJ10sIFtlbmNvZGVkTGVmdCwgZW5jb2RlZFJpZ2h0XSk7XG4gICAgfVxuICB9XG4gIGlmIChpc05lc3RlZExlYWYodHJlZSkgfHwgaXNVbnJlY292ZXJlZE5lc3RlZExlYWYodHJlZSkpIHtcbiAgICBjb25zdCBuZXN0ZWQgPSBldGhlcnMuZ2V0Qnl0ZXMoZW5jb2RlU2lnbmF0dXJlVHJlZSh0cmVlLnRyZWUpKTtcbiAgICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDgnLCAndWludDgnLCAndWludDE2JywgJ3VpbnQyNCcsICdieXRlcyddLCBbU2lnbmF0dXJlUGFydFR5cGUuTmVzdGVkLCB0cmVlLndlaWdodCwgdHJlZS50aHJlc2hvbGQsIG5lc3RlZC5sZW5ndGgsIG5lc3RlZF0pO1xuICB9XG4gIGlmIChpc1VucmVjb3ZlcmVkU2lnbmF0dXJlTGVhZih0cmVlKSB8fCBpc1NpZ25lckxlYWYodHJlZSkgJiYgdHJlZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGV0aGVycy5nZXRCeXRlcyh0cmVlLnNpZ25hdHVyZSk7XG4gICAgaWYgKHRyZWUuaXNEeW5hbWljIHx8IHNpZ25hdHVyZS5sZW5ndGggIT09IFNpZ25hdHVyZVBhcnRUeXBlTGVuZ3RoKSB7XG4gICAgICBpZiAoIXRyZWUuYWRkcmVzcykgdGhyb3cgbmV3IEVycm9yKGBEeW5hbWljIHNpZ25hdHVyZSBsZWFmIG11c3QgaGF2ZSBhZGRyZXNzYCk7XG4gICAgICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDgnLCAndWludDgnLCAnYWRkcmVzcycsICd1aW50MjQnLCAnYnl0ZXMnXSwgW1NpZ25hdHVyZVBhcnRUeXBlLkR5bmFtaWNTaWduYXR1cmUsIHRyZWUud2VpZ2h0LCB0cmVlLmFkZHJlc3MsIHNpZ25hdHVyZS5sZW5ndGgsIHNpZ25hdHVyZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsndWludDgnLCAndWludDgnLCAnYnl0ZXMnXSwgW1NpZ25hdHVyZVBhcnRUeXBlLlNpZ25hdHVyZSwgdHJlZS53ZWlnaHQsIHNpZ25hdHVyZV0pO1xuICAgIH1cbiAgfVxuICBpZiAoaXNTaWduZXJMZWFmKHRyZWUpKSB7XG4gICAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ4JywgJ3VpbnQ4JywgJ2FkZHJlc3MnXSwgW1NpZ25hdHVyZVBhcnRUeXBlLkFkZHJlc3MsIHRyZWUud2VpZ2h0LCB0cmVlLmFkZHJlc3NdKTtcbiAgfVxuICBpZiAoaXNOb2RlTGVhZih0cmVlKSkge1xuICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICdieXRlczMyJ10sIFtTaWduYXR1cmVQYXJ0VHlwZS5Ob2RlLCB0cmVlLm5vZGVIYXNoXSk7XG4gIH1cbiAgaWYgKGlzU3ViZGlnZXN0TGVhZih0cmVlKSkge1xuICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWyd1aW50OCcsICdieXRlczMyJ10sIFtTaWduYXR1cmVQYXJ0VHlwZS5TdWJkaWdlc3QsIHRyZWUuc3ViZGlnZXN0XSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNpZ25hdHVyZSB0cmVlIHR5cGU6ICR7dHJlZX1gKTtcbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZXNPZih0b3BvbG9neSkge1xuICBpZiAoaXNOb2RlKHRvcG9sb2d5KSkge1xuICAgIHJldHVybiBbLi4uc2lnbmF0dXJlc09mKHRvcG9sb2d5LmxlZnQpLCAuLi5zaWduYXR1cmVzT2YodG9wb2xvZ3kucmlnaHQpXTtcbiAgfVxuICBpZiAoaXNOZXN0ZWRMZWFmKHRvcG9sb2d5KSkge1xuICAgIHJldHVybiBzaWduYXR1cmVzT2YodG9wb2xvZ3kudHJlZSk7XG4gIH1cbiAgaWYgKGlzU2lnbmVyTGVhZih0b3BvbG9neSkgJiYgdG9wb2xvZ3kuc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICBhZGRyZXNzOiB0b3BvbG9neS5hZGRyZXNzLFxuICAgICAgc2lnbmF0dXJlOiB0b3BvbG9neS5zaWduYXR1cmVcbiAgICB9XTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBzaWduYXR1cmVzT2ZEZWNvZGVkKHV0b3BvbG9neSkge1xuICBpZiAoaXNVbnJlY292ZXJlZE5vZGUodXRvcG9sb2d5KSkge1xuICAgIHJldHVybiBbLi4uc2lnbmF0dXJlc09mRGVjb2RlZCh1dG9wb2xvZ3kubGVmdCksIC4uLnNpZ25hdHVyZXNPZkRlY29kZWQodXRvcG9sb2d5LnJpZ2h0KV07XG4gIH1cbiAgaWYgKGlzVW5yZWNvdmVyZWROZXN0ZWRMZWFmKHV0b3BvbG9neSkpIHtcbiAgICByZXR1cm4gc2lnbmF0dXJlc09mRGVjb2RlZCh1dG9wb2xvZ3kudHJlZSk7XG4gIH1cbiAgaWYgKGlzVW5yZWNvdmVyZWRTaWduYXR1cmVMZWFmKHV0b3BvbG9neSkpIHtcbiAgICByZXR1cm4gW3V0b3BvbG9neS5zaWduYXR1cmVdO1xuICB9XG4gIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIHN1YmRpZ2VzdHNPZkRlY29kZWQodXRvcG9sb2d5KSB7XG4gIGlmIChpc1VucmVjb3ZlcmVkTm9kZSh1dG9wb2xvZ3kpKSB7XG4gICAgcmV0dXJuIFsuLi5zdWJkaWdlc3RzT2ZEZWNvZGVkKHV0b3BvbG9neS5sZWZ0KSwgLi4uc3ViZGlnZXN0c09mRGVjb2RlZCh1dG9wb2xvZ3kucmlnaHQpXTtcbiAgfVxuICBpZiAoaXNVbnJlY292ZXJlZE5lc3RlZExlYWYodXRvcG9sb2d5KSkge1xuICAgIHJldHVybiBzdWJkaWdlc3RzT2ZEZWNvZGVkKHV0b3BvbG9neS50cmVlKTtcbiAgfVxuICBpZiAoaXNTdWJkaWdlc3RMZWFmKHV0b3BvbG9neSkpIHtcbiAgICByZXR1cm4gW3V0b3BvbG9neS5zdWJkaWdlc3RdO1xuICB9XG4gIHJldHVybiBbXTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRyaW1TaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIGNvbnN0IGRlY29kZWQgPSB0eXBlb2Ygc2lnbmF0dXJlID09PSAnc3RyaW5nJyA/IGRlY29kZVNpZ25hdHVyZShzaWduYXR1cmUpIDogc2lnbmF0dXJlO1xuICBpZiAoaXNVbnJlY292ZXJlZENoYWluZWRTaWduYXR1cmUoZGVjb2RlZCkpIHtcbiAgICAvLyBXZSBuZWVkIHRvIHRyaW0gZXZlcnkgc3VmZml4IEFORCB0aGUgbWFpbiBzaWduYXR1cmVcbiAgICBjb25zdCBfdHJpbW1lZCA9IGF3YWl0IFByb21pc2UuYWxsKFt0cmltU2lnbmF0dXJlKF9leHRlbmRzKHt9LCBkZWNvZGVkLCB7XG4gICAgICBzdWZmaXg6IHVuZGVmaW5lZFxuICAgIH0pKSwgLi4uZGVjb2RlZC5zdWZmaXgubWFwKHMgPT4gdHJpbVNpZ25hdHVyZShzKSldKTtcbiAgICByZXR1cm4gZW5jb2RlQ2hhaW4oX3RyaW1tZWRbMF0sIF90cmltbWVkLnNsaWNlKDEpKTtcbiAgfVxuICBjb25zdCB7XG4gICAgdHJpbW1lZFxuICB9ID0gYXdhaXQgdHJpbVVucmVjb3ZlcmVkVHJlZShkZWNvZGVkLmRlY29kZWQudHJlZSk7XG4gIHJldHVybiBlbmNvZGVTaWduYXR1cmUoX2V4dGVuZHMoe30sIGRlY29kZWQsIHtcbiAgICBkZWNvZGVkOiBfZXh0ZW5kcyh7fSwgZGVjb2RlZC5kZWNvZGVkLCB7XG4gICAgICB0cmVlOiB0cmltbWVkXG4gICAgfSlcbiAgfSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gdHJpbVVucmVjb3ZlcmVkVHJlZSh0cmVlLCB0cmltU3RhdGljRGlnZXN0ID0gdHJ1ZSkge1xuICBpZiAoaXNVbnJlY292ZXJlZE5vZGUodHJlZSkpIHtcbiAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3RyaW1VbnJlY292ZXJlZFRyZWUodHJlZS5sZWZ0KSwgdHJpbVVucmVjb3ZlcmVkVHJlZSh0cmVlLnJpZ2h0KV0pO1xuICAgIGlmIChsZWZ0LndlaWdodCA9PT0gMCAmJiByaWdodC53ZWlnaHQgPT09IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIElmIGJvdGggd2VpZ2h0cyBhcmUgMCB0aGVuIGl0IG1lYW5zIHdlIGRvbid0IGhhdmUgYW55IHNpZ25hdHVyZXMgeWV0XG4gICAgICAgIC8vIGJlY2F1c2Ugb2YgdGhhdCwgd2Ugc2hvdWxkIGJlIGFibGUgdG8gXCJyZWNvdmVyXCIgdGhlIHRyZWUgd2l0aCBhbnkgc3ViZGlnZXN0XG4gICAgICAgIC8vIGFuZCBzdGlsbCBnZXQgdGhlIHZhbGlkIG5vZGUgaGFzaCAodGhlcmUgc2hvdWxkbid0IGJlIGFueSBzaWduYXR1cmVzIHRvIHZlcmlmeSlcbiAgICAgICAgY29uc3QgcmVjb3ZlcmVkID0gYXdhaXQgcmVjb3ZlclRvcG9sb2d5KHRyZWUsIGV0aGVycy5aZXJvSGFzaCwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3ZWlnaHQ6IDAsXG4gICAgICAgICAgdHJpbW1lZDoge1xuICAgICAgICAgICAgbm9kZUhhc2g6IGhhc2hOb2RlKHJlY292ZXJlZClcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgIC8vIElmIHNvbWV0aGluZyBmYWlscyBpdCdzIG1vcmUgbGlrZWx5IGJlY2F1c2Ugc29tZSBzaWduYXR1cmVzIGhhdmUgc25lYWtlZCBpblxuICAgICAgICAvLyBpbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIGtlZXAgdGhpcyBub2RlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdlaWdodDogbGVmdC53ZWlnaHQgKyByaWdodC53ZWlnaHQsXG4gICAgICAgIHRyaW1tZWQ6IHtcbiAgICAgICAgICBsZWZ0OiBsZWZ0LnRyaW1tZWQsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0LnRyaW1tZWRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5yZWNvdmVyZWROZXN0ZWRMZWFmKHRyZWUpKSB7XG4gICAgY29uc3QgdHJpbW1lZCA9IGF3YWl0IHRyaW1VbnJlY292ZXJlZFRyZWUodHJlZS50cmVlKTtcbiAgICBpZiAodHJpbW1lZC53ZWlnaHQgPT09IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIElmIHRoZSBuZXN0ZWQgbGVhZiBpcyBlbXB0eSwgd2UgY2FuIHJlY292ZXIgaXQgd2l0aCBhbnkgc3ViZGlnZXN0XG4gICAgICAgIC8vIGFuZCBzdGlsbCBnZXQgdGhlIHZhbGlkIG5vZGUgaGFzaCAodGhlcmUgc2hvdWxkbid0IGJlIGFueSBzaWduYXR1cmVzIHRvIHZlcmlmeSlcbiAgICAgICAgY29uc3QgcmVjb3ZlcmVkID0gYXdhaXQgcmVjb3ZlclRvcG9sb2d5KHRyZWUsIGV0aGVycy5aZXJvSGFzaCwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3ZWlnaHQ6IDAsXG4gICAgICAgICAgdHJpbW1lZDoge1xuICAgICAgICAgICAgbm9kZUhhc2g6IGhhc2hOb2RlKHJlY292ZXJlZClcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChfdW51c2VkMikge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgZmFpbHMgaXQncyBtb3JlIGxpa2VseSBiZWNhdXNlIHNvbWUgc2lnbmF0dXJlcyBoYXZlIHNuZWFrZWQgaW5cbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIHNob3VsZCBrZWVwIHRoaXMgbm9kZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2VpZ2h0OiB0cmltbWVkLndlaWdodCxcbiAgICAgIHRyaW1tZWQ6IHtcbiAgICAgICAgd2VpZ2h0OiB0cmVlLndlaWdodCxcbiAgICAgICAgdGhyZXNob2xkOiB0cmVlLnRocmVzaG9sZCxcbiAgICAgICAgdHJlZTogdHJpbW1lZC50cmltbWVkXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIEhhc2ggbm9kZXMgY2FuIGJlIGVuY29kZWQgYXMgc2lnbmVyIGxlYXZlcyBpZiB0aGV5IGhhdmUgYSB3ZWlnaHQgYmVsb3dcbiAgLy8gMjU2LCBtb3N0IGxpa2VseSB0aGUgYXJlIHNpZ25lciBsZWF2ZXMgd3JvbmdseSBlbmNvZGVkXG4gIGlmIChpc05vZGVMZWFmKHRyZWUpICYmIGlzRW5jb2RlZFNpZ25lckxlYWYodHJlZS5ub2RlSGFzaCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2VpZ2h0OiAwLFxuICAgICAgdHJpbW1lZDogX2V4dGVuZHMoe30sIGRlY29kZVNpZ25lckxlYWYodHJlZS5ub2RlSGFzaCkpXG4gICAgfTtcbiAgfVxuICBpZiAoaXNVbnJlY292ZXJlZFNpZ25hdHVyZUxlYWYodHJlZSkgfHwgaXNTaWduZXJMZWFmKHRyZWUpICYmIHRyZWUuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2VpZ2h0OiBOdW1iZXIodHJlZS53ZWlnaHQpLFxuICAgICAgdHJpbW1lZDogdHJlZVxuICAgIH07XG4gIH1cbiAgaWYgKCF0cmltU3RhdGljRGlnZXN0ICYmIGlzU3ViZGlnZXN0TGVhZih0cmVlKSkge1xuICAgIHJldHVybiB7XG4gICAgICB3ZWlnaHQ6ICtJbmZpbml0eSxcbiAgICAgIHRyaW1tZWQ6IHRyZWVcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgd2VpZ2h0OiAwLFxuICAgIHRyaW1tZWQ6IHRyZWVcbiAgfTtcbn1cbmNvbnN0IFNpZ25hdHVyZUNvZGVyID0ge1xuICBkZWNvZGU6IGRhdGEgPT4ge1xuICAgIHJldHVybiBkZWNvZGVTaWduYXR1cmUoZGF0YSk7XG4gIH0sXG4gIGVuY29kZTogZGF0YSA9PiB7XG4gICAgcmV0dXJuIGVuY29kZVNpZ25hdHVyZShkYXRhKTtcbiAgfSxcbiAgdHJpbTogZGF0YSA9PiB7XG4gICAgcmV0dXJuIHRyaW1TaWduYXR1cmUoZGF0YSk7XG4gIH0sXG4gIHN1cHBvcnRzTm9DaGFpbklkOiB0cnVlLFxuICByZWNvdmVyOiAoZGF0YSwgcGF5bG9hZCwgcHJvdmlkZXIpID0+IHtcbiAgICByZXR1cm4gcmVjb3ZlclNpZ25hdHVyZShkYXRhLCBwYXlsb2FkLCBwcm92aWRlcik7XG4gIH0sXG4gIGVuY29kZVNpZ25lcnM6IChjb25maWcsIHNpZ25hdHVyZXMsIHN1YmRpZ2VzdHMsIGNoYWluSWQpID0+IHtcbiAgICByZXR1cm4gZW5jb2RlU2lnbmVycyhjb25maWcsIHNpZ25hdHVyZXMsIHN1YmRpZ2VzdHMsIGNoYWluSWQpO1xuICB9LFxuICBoYXNFbm91Z2hTaWduaW5nUG93ZXI6IChjb25maWcsIHNpZ25hdHVyZXMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB3ZWlnaHRcbiAgICB9ID0gU2lnbmF0dXJlQ29kZXIuZW5jb2RlU2lnbmVycyhjb25maWcsIHNpZ25hdHVyZXMsIFtdLCAwKTtcbiAgICByZXR1cm4gd2VpZ2h0ID49IEJpZ0ludChjb25maWcudGhyZXNob2xkKTtcbiAgfSxcbiAgY2hhaW5TaWduYXR1cmVzOiAobWFpbiwgc3VmZml4KSA9PiB7XG4gICAgLy8gTm90aWNlOiB2MiBleHBlY3RzIHN1ZmZpeCB0byBiZSByZXZlcnNlZFxuICAgIC8vIHRoYXQgYmVpbmc6IGZyb20gc2lnbmVkIHRvIGN1cnJlbnQgaW1hZ2VIYXNoXG4gICAgY29uc3QgcmV2ZXJzZWQgPSBzdWZmaXgucmV2ZXJzZSgpO1xuICAgIGNvbnN0IG1yYXcgPSBldGhlcnMuaXNCeXRlc0xpa2UobWFpbikgPyBtYWluIDogZW5jb2RlU2lnbmF0dXJlKG1haW4pO1xuICAgIGNvbnN0IHNyYXcgPSByZXZlcnNlZC5tYXAocyA9PiBldGhlcnMuaXNCeXRlc0xpa2UocykgPyBzIDogZW5jb2RlU2lnbmF0dXJlKHMpKTtcbiAgICByZXR1cm4gZW5jb2RlQ2hhaW4obXJhdywgc3Jhdyk7XG4gIH0sXG4gIGhhc2hTZXRJbWFnZUhhc2g6IGZ1bmN0aW9uIChpbWFnZUhhc2gpIHtcbiAgICByZXR1cm4gaGFzaFNldEltYWdlSGFzaChpbWFnZUhhc2gpO1xuICB9LFxuICBzaWduYXR1cmVzT2YoY29uZmlnKSB7XG4gICAgcmV0dXJuIHNpZ25hdHVyZXNPZihjb25maWcudHJlZSk7XG4gIH0sXG4gIHNpZ25hdHVyZXNPZkRlY29kZWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIHNpZ25hdHVyZXNPZkRlY29kZWQoZGF0YS5kZWNvZGVkLnRyZWUpO1xuICB9XG59O1xuXG52YXIgc2lnbmF0dXJlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFNpZ25hdHVyZVR5cGU6IFNpZ25hdHVyZVR5cGUsXG4gIFNpZ25hdHVyZVBhcnRUeXBlOiBTaWduYXR1cmVQYXJ0VHlwZSxcbiAgU2lnbmF0dXJlUGFydFR5cGVMZW5ndGg6IFNpZ25hdHVyZVBhcnRUeXBlTGVuZ3RoLFxuICBpc1VucmVjb3ZlcmVkTm9kZTogaXNVbnJlY292ZXJlZE5vZGUsXG4gIGlzVW5yZWNvdmVyZWROZXN0ZWRMZWFmOiBpc1VucmVjb3ZlcmVkTmVzdGVkTGVhZixcbiAgaXNVbnJlY292ZXJlZFNpZ25hdHVyZUxlYWY6IGlzVW5yZWNvdmVyZWRTaWduYXR1cmVMZWFmLFxuICBkZWNvZGVTaWduYXR1cmVUcmVlOiBkZWNvZGVTaWduYXR1cmVUcmVlLFxuICBJbnZhbGlkU2lnbmF0dXJlTGVhZkVycm9yOiBJbnZhbGlkU2lnbmF0dXJlTGVhZkVycm9yLFxuICByZWNvdmVyVG9wb2xvZ3k6IHJlY292ZXJUb3BvbG9neSxcbiAgcGFydEVuY29kZXI6IHBhcnRFbmNvZGVyLFxuICBlbmNvZGVTaWduZXJzOiBlbmNvZGVTaWduZXJzLFxuICBlbmNvZGVUcmVlOiBlbmNvZGVUcmVlLFxuICBkZWVwZXN0Q29uZmlnT2ZTaWduYXR1cmU6IGRlZXBlc3RDb25maWdPZlNpZ25hdHVyZSxcbiAgaXNVbnJlY292ZXJlZFNpZ25hdHVyZTogaXNVbnJlY292ZXJlZFNpZ25hdHVyZSxcbiAgaXNVbnJlY292ZXJlZENoYWluZWRTaWduYXR1cmU6IGlzVW5yZWNvdmVyZWRDaGFpbmVkU2lnbmF0dXJlLFxuICBpc1NpZ25hdHVyZTogaXNTaWduYXR1cmUsXG4gIGlzQ2hhaW5lZFNpZ25hdHVyZTogaXNDaGFpbmVkU2lnbmF0dXJlLFxuICBkZWNvZGVTaWduYXR1cmU6IGRlY29kZVNpZ25hdHVyZSxcbiAgZGVjb2RlU2lnbmF0dXJlQm9keTogZGVjb2RlU2lnbmF0dXJlQm9keSxcbiAgZGVjb2RlQ2hhaW5lZFNpZ25hdHVyZTogZGVjb2RlQ2hhaW5lZFNpZ25hdHVyZSxcbiAgc2V0SW1hZ2VIYXNoU3RydWN0OiBzZXRJbWFnZUhhc2hTdHJ1Y3QsXG4gIHJlY292ZXJTaWduYXR1cmU6IHJlY292ZXJTaWduYXR1cmUsXG4gIGVuY29kZUNoYWluOiBlbmNvZGVDaGFpbixcbiAgZW5jb2RlU2lnbmF0dXJlOiBlbmNvZGVTaWduYXR1cmUsXG4gIGVuY29kZVNpZ25hdHVyZUJvZHk6IGVuY29kZVNpZ25hdHVyZUJvZHksXG4gIGVuY29kZVNpZ25hdHVyZVRyZWU6IGVuY29kZVNpZ25hdHVyZVRyZWUsXG4gIHNpZ25hdHVyZXNPZjogc2lnbmF0dXJlc09mLFxuICBzaWduYXR1cmVzT2ZEZWNvZGVkOiBzaWduYXR1cmVzT2ZEZWNvZGVkLFxuICBzdWJkaWdlc3RzT2ZEZWNvZGVkOiBzdWJkaWdlc3RzT2ZEZWNvZGVkLFxuICB0cmltU2lnbmF0dXJlOiB0cmltU2lnbmF0dXJlLFxuICB0cmltVW5yZWNvdmVyZWRUcmVlOiB0cmltVW5yZWNvdmVyZWRUcmVlLFxuICBTaWduYXR1cmVDb2RlcjogU2lnbmF0dXJlQ29kZXJcbn0pO1xuXG4vL1xuLy8gVHJlZSB0eXBpbmdzIC0gbGVhdmVzXG4vL1xuXG4vLyBUaGlzIGlzIGFuIHVua25vd24gbm9kZVxuLy8gaXQgbWVhbnMgdGhlIHRyZWUgaGFzIGEgYnJhbmNoXG4vLyBidXQgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBjb250ZW50XG5cbmZ1bmN0aW9uIGlzU2lnbmVyTGVhZihsZWFmKSB7XG4gIHJldHVybiBsZWFmLmFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJiBsZWFmLndlaWdodCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdWJkaWdlc3RMZWFmKGxlYWYpIHtcbiAgcmV0dXJuIGxlYWYuc3ViZGlnZXN0ICE9PSB1bmRlZmluZWQgJiYgbGVhZi5hZGRyZXNzID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB0b3BvbG9neVRvSlNPTih0cmVlKSB7XG4gIGlmIChpc05vZGUodHJlZSkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgbGVmdDogdG9wb2xvZ3lUb0pTT04odHJlZS5sZWZ0KSxcbiAgICAgIHJpZ2h0OiB0b3BvbG9neVRvSlNPTih0cmVlLnJpZ2h0KVxuICAgIH0pO1xuICB9XG4gIGlmIChpc05lc3RlZExlYWYodHJlZSkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgd2VpZ2h0OiBCaWdJbnQodHJlZS53ZWlnaHQpLnRvU3RyaW5nKCksXG4gICAgICB0aHJlc2hvbGQ6IEJpZ0ludCh0cmVlLnRocmVzaG9sZCkudG9TdHJpbmcoKSxcbiAgICAgIHRyZWU6IHRvcG9sb2d5VG9KU09OKHRyZWUudHJlZSlcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNTaWduZXJMZWFmKHRyZWUpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGFkZHJlc3M6IHRyZWUuYWRkcmVzcyxcbiAgICAgIHdlaWdodDogQmlnSW50KHRyZWUud2VpZ2h0KS50b1N0cmluZygpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRyZWUpO1xufVxuZnVuY3Rpb24gdG9wb2xvZ3lGcm9tSlNPTihqc29uKSB7XG4gIGNvbnN0IHBhcnNlZCA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xuICBpZiAocGFyc2VkLmxlZnQgIT09IHVuZGVmaW5lZCAmJiBwYXJzZWQucmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0b3BvbG9neUZyb21KU09OKHBhcnNlZC5sZWZ0KSxcbiAgICAgIHJpZ2h0OiB0b3BvbG9neUZyb21KU09OKHBhcnNlZC5yaWdodClcbiAgICB9O1xuICB9XG4gIGlmIChwYXJzZWQud2VpZ2h0ICE9PSB1bmRlZmluZWQgJiYgcGFyc2VkLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkICYmIHBhcnNlZC50cmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2VpZ2h0OiBCaWdJbnQocGFyc2VkLndlaWdodCksXG4gICAgICB0aHJlc2hvbGQ6IEJpZ0ludChwYXJzZWQudGhyZXNob2xkKSxcbiAgICAgIHRyZWU6IHRvcG9sb2d5RnJvbUpTT04ocGFyc2VkLnRyZWUpXG4gICAgfTtcbiAgfVxuICBpZiAocGFyc2VkLmFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJiBwYXJzZWQud2VpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogcGFyc2VkLmFkZHJlc3MsXG4gICAgICB3ZWlnaHQ6IEJpZ0ludChwYXJzZWQud2VpZ2h0KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIGlzTmVzdGVkTGVhZihsZWFmKSB7XG4gIHJldHVybiBsZWFmLnRyZWUgIT09IHVuZGVmaW5lZCAmJiBsZWFmLndlaWdodCAhPT0gdW5kZWZpbmVkICYmIGxlYWYudGhyZXNob2xkICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc05vZGVMZWFmKGxlYWYpIHtcbiAgcmV0dXJuIGxlYWYubm9kZUhhc2ggIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzTGVhZihsZWFmKSB7XG4gIHJldHVybiBpc1NpZ25lckxlYWYobGVhZikgfHwgaXNTdWJkaWdlc3RMZWFmKGxlYWYpIHx8IGlzTmVzdGVkTGVhZihsZWFmKSB8fCBpc05vZGVMZWFmKGxlYWYpO1xufVxuXG4vL1xuLy8gVHJlZSB0eXBpbmdzIC0gbm9kZXNcbi8vXG5cbmZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLmxlZnQgIT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1RvcG9sb2d5KHRvcG9sb2d5KSB7XG4gIHJldHVybiBpc05vZGUodG9wb2xvZ3kpIHx8IGlzTGVhZih0b3BvbG9neSk7XG59XG5mdW5jdGlvbiBlbmNvZGVTaWduZXJMZWFmKGxlYWYpIHtcbiAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ3VpbnQ5NicsICdhZGRyZXNzJ10sIFtsZWFmLndlaWdodCwgbGVhZi5hZGRyZXNzXSk7XG59XG5mdW5jdGlvbiBkZWNvZGVTaWduZXJMZWFmKGVuY29kZWQpIHtcbiAgY29uc3QgYnl0ZXMgPSBldGhlcnMuZ2V0Qnl0ZXMoZW5jb2RlZCk7XG4gIGlmIChieXRlcy5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kZWQgc3RyaW5nIGxlbmd0aCcpO1xuICB9XG4gIGNvbnN0IHdlaWdodCA9IEJpZ0ludChldGhlcnMuaGV4bGlmeShieXRlcy5zbGljZSgwLCAxMikpKTtcbiAgY29uc3QgYWRkcmVzcyA9IGV0aGVycy5nZXRBZGRyZXNzKGV0aGVycy5oZXhsaWZ5KGJ5dGVzLnNsaWNlKDEyKSkpO1xuICByZXR1cm4ge1xuICAgIHdlaWdodCxcbiAgICBhZGRyZXNzXG4gIH07XG59XG5mdW5jdGlvbiBpc0VuY29kZWRTaWduZXJMZWFmKGVuY29kZWQpIHtcbiAgY29uc3QgYnl0ZXMgPSBldGhlcnMuZ2V0Qnl0ZXMoZW5jb2RlZCk7XG4gIGlmIChieXRlcy5sZW5ndGggIT09IDMyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGJ5dGVzLnNsaWNlKDAsIDExKTtcbiAgcmV0dXJuIHByZWZpeC5ldmVyeShieXRlID0+IGJ5dGUgPT09IDApO1xufVxuZnVuY3Rpb24gaGFzaE5vZGUobm9kZSkge1xuICBpZiAoaXNTaWduZXJMZWFmKG5vZGUpKSB7XG4gICAgcmV0dXJuIGVuY29kZVNpZ25lckxlYWYobm9kZSk7XG4gIH1cbiAgaWYgKGlzU3ViZGlnZXN0TGVhZihub2RlKSkge1xuICAgIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWRLZWNjYWsyNTYoWydzdHJpbmcnLCAnYnl0ZXMzMiddLCBbJ1NlcXVlbmNlIHN0YXRpYyBkaWdlc3Q6XFxuJywgbm9kZS5zdWJkaWdlc3RdKTtcbiAgfVxuICBpZiAoaXNOZXN0ZWRMZWFmKG5vZGUpKSB7XG4gICAgY29uc3QgbmVzdGVkID0gaGFzaE5vZGUobm9kZS50cmVlKTtcbiAgICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkS2VjY2FrMjU2KFsnc3RyaW5nJywgJ2J5dGVzMzInLCAndWludDI1NicsICd1aW50MjU2J10sIFsnU2VxdWVuY2UgbmVzdGVkIGNvbmZpZzpcXG4nLCBuZXN0ZWQsIG5vZGUudGhyZXNob2xkLCBub2RlLndlaWdodF0pO1xuICB9XG4gIGlmIChpc05vZGVMZWFmKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZUhhc2g7XG4gIH1cbiAgcmV0dXJuIGV0aGVycy5zb2xpZGl0eVBhY2tlZEtlY2NhazI1NihbJ2J5dGVzMzInLCAnYnl0ZXMzMiddLCBbaGFzaE5vZGUobm9kZS5sZWZ0KSwgaGFzaE5vZGUobm9kZS5yaWdodCldKTtcbn1cbmZ1bmN0aW9uIGxlZnRGYWNlKHRvcG9sb2d5KSB7XG4gIGNvbnN0IHN0YWNrID0gW107XG4gIGxldCBwcmV2ID0gdG9wb2xvZ3k7XG4gIHdoaWxlICghaXNMZWFmKHByZXYpKSB7XG4gICAgc3RhY2sudW5zaGlmdChwcmV2LnJpZ2h0KTtcbiAgICBwcmV2ID0gcHJldi5sZWZ0O1xuICB9XG4gIHN0YWNrLnVuc2hpZnQocHJldik7XG4gIHJldHVybiBzdGFjaztcbn1cblxuLy9cbi8vIFdhbGxldCBjb25maWcgdHlwZXNcbi8vXG5cbmZ1bmN0aW9uIGlzV2FsbGV0Q29uZmlnKGNvbmZpZykge1xuICByZXR1cm4gY29uZmlnLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy5jaGVja3BvaW50ICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLnRyZWUgIT09IHVuZGVmaW5lZCAmJiBjb25maWcudmVyc2lvbiAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy52ZXJzaW9uID09PSAyO1xufVxuZnVuY3Rpb24gaW1hZ2VIYXNoKGNvbmZpZykge1xuICByZXR1cm4gZXRoZXJzLnNvbGlkaXR5UGFja2VkS2VjY2FrMjU2KFsnYnl0ZXMzMicsICd1aW50MjU2J10sIFtldGhlcnMuc29saWRpdHlQYWNrZWRLZWNjYWsyNTYoWydieXRlczMyJywgJ3VpbnQyNTYnXSwgW2hhc2hOb2RlKGNvbmZpZy50cmVlKSwgY29uZmlnLnRocmVzaG9sZF0pLCBjb25maWcuY2hlY2twb2ludF0pO1xufVxuXG4vL1xuLy8gU2ltcGxlIHdhbGxldCBjb25maWcgdHlwZXNcbi8vICh1c2VkIGZvciBidWlsZGluZyBhbmQgcmVhZGluZyBtZXJrbGUgY29uZmlncylcbi8vXG4vLyBkZXY6IGBtZW1iZXJzYCBpcyBhIGZsYXQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyZWVcbi8vICAgICAgaXQga2VlcHMgcmVsZXZhbnQgc3RydWN0dXJlIGxpa2UgJ25lc3RlZCB0cmVlcycgYnV0XG4vLyAgICAgIGl0IGlnbm9yZXMgdGhlIHRyZWUgc3RydWN0dXJlXG4vL1xuLy9cblxuZnVuY3Rpb24gaXNTaW1wbGVOZXN0ZWRNZW1iZXIobWVtYmVyKSB7XG4gIHJldHVybiBtZW1iZXIudGhyZXNob2xkICE9PSB1bmRlZmluZWQgJiYgbWVtYmVyLndlaWdodCAhPT0gdW5kZWZpbmVkICYmIG1lbWJlci5tZW1iZXJzICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB0b3BvbG9neVRvTWVtYmVycyh0cmVlKSB7XG4gIGlmIChpc1NpZ25lckxlYWYodHJlZSkgfHwgaXNTdWJkaWdlc3RMZWFmKHRyZWUpKSB7XG4gICAgcmV0dXJuIFt0cmVlXTtcbiAgfVxuICBpZiAoaXNOZXN0ZWRMZWFmKHRyZWUpKSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICB0aHJlc2hvbGQ6IHRyZWUudGhyZXNob2xkLFxuICAgICAgd2VpZ2h0OiB0cmVlLndlaWdodCxcbiAgICAgIG1lbWJlcnM6IHRvcG9sb2d5VG9NZW1iZXJzKHRyZWUudHJlZSlcbiAgICB9XTtcbiAgfVxuICBpZiAoaXNOb2RlTGVhZih0cmVlKSkge1xuICAgIC8vIHdlIGRvbid0IGtub3cgdGhlIGNvbnRlbnQgb2YgdGhpcyBub2RlXG4gICAgLy8gc28gd2Ugb21pdCBpdFxuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gWy4uLnRvcG9sb2d5VG9NZW1iZXJzKHRyZWUubGVmdCksIC4uLnRvcG9sb2d5VG9NZW1iZXJzKHRyZWUucmlnaHQpXTtcbn1cbmZ1bmN0aW9uIGhhc1Vua25vd25Ob2Rlcyh0cmVlKSB7XG4gIGlmIChpc05vZGVMZWFmKHRyZWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzTm9kZSh0cmVlKSkge1xuICAgIHJldHVybiBoYXNVbmtub3duTm9kZXModHJlZS5sZWZ0KSB8fCBoYXNVbmtub3duTm9kZXModHJlZS5yaWdodCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdG9TaW1wbGVXYWxsZXRDb25maWcoY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgdGhyZXNob2xkOiBjb25maWcudGhyZXNob2xkLFxuICAgIGNoZWNrcG9pbnQ6IGNvbmZpZy5jaGVja3BvaW50LFxuICAgIG1lbWJlcnM6IHRvcG9sb2d5VG9NZW1iZXJzKGNvbmZpZy50cmVlKVxuICB9O1xufVxuY29uc3QgbWVtYmVyc0FzVG9wb2xvZ2llcyA9IChtZW1iZXJzLCBidWlsZGVyKSA9PiB7XG4gIHJldHVybiBtZW1iZXJzLm1hcChtZW1iZXIgPT4ge1xuICAgIGlmIChpc1NpbXBsZU5lc3RlZE1lbWJlcihtZW1iZXIpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmVlOiBidWlsZGVyKG1lbWJlci5tZW1iZXJzKSxcbiAgICAgICAgdGhyZXNob2xkOiBtZW1iZXIudGhyZXNob2xkLFxuICAgICAgICB3ZWlnaHQ6IG1lbWJlci53ZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBtZW1iZXI7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGxlZ2FjeVRvcG9sb2d5QnVpbGRlcihtZW1iZXJzKSB7XG4gIGlmIChtZW1iZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRW1wdHkgbWVtYmVycyBhcnJheScpO1xuICB9XG4gIGNvbnN0IGFzVG9wb2xvZ2llcyA9IG1lbWJlcnNBc1RvcG9sb2dpZXMobWVtYmVycywgbGVnYWN5VG9wb2xvZ3lCdWlsZGVyKTtcbiAgcmV0dXJuIGFzVG9wb2xvZ2llcy5yZWR1Y2UoKGFjYywgbWVtYmVyKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGFjYyxcbiAgICAgIHJpZ2h0OiBtZW1iZXJcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1lcmtsZVRvcG9sb2d5QnVpbGRlcihtZW1iZXJzKSB7XG4gIGlmIChtZW1iZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRW1wdHkgbWVtYmVycyBhcnJheScpO1xuICB9XG4gIGNvbnN0IGxlYXZlcyA9IG1lbWJlcnNBc1RvcG9sb2dpZXMobWVtYmVycywgbWVya2xlVG9wb2xvZ3lCdWlsZGVyKTtcbiAgZm9yIChsZXQgcyA9IGxlYXZlcy5sZW5ndGg7IHMgPiAxOyBzID0gcyAvIDIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMgLyAyOyBpKyspIHtcbiAgICAgIGNvbnN0IGoxID0gaSAqIDI7XG4gICAgICBjb25zdCBqMiA9IGoxICsgMTtcbiAgICAgIGlmIChqMiA+PSBzKSB7XG4gICAgICAgIGxlYXZlc1tpXSA9IGxlYXZlc1tqMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZXNbaV0gPSB7XG4gICAgICAgICAgbGVmdDogbGVhdmVzW2oxXSxcbiAgICAgICAgICByaWdodDogbGVhdmVzW2oyXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbGVhdmVzWzBdO1xufVxuZnVuY3Rpb24gb3B0aW1pemVkMlNpZ25lcnNUb3BvbG9neUJ1aWxkZXIobWVtYmVycykge1xuICBpZiAobWVtYmVycy5sZW5ndGggPiA4KSB7XG4gICAgcmV0dXJuIG1lcmtsZVRvcG9sb2d5QnVpbGRlcihtZW1iZXJzKTtcbiAgfVxuICByZXR1cm4gbGVnYWN5VG9wb2xvZ3lCdWlsZGVyKG1lbWJlcnMpO1xufVxuZnVuY3Rpb24gdG9XYWxsZXRDb25maWcoc2ltcGxlV2FsbGV0Q29uZmlnLCBidWlsZGVyID0gb3B0aW1pemVkMlNpZ25lcnNUb3BvbG9neUJ1aWxkZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAyLFxuICAgIHRocmVzaG9sZDogc2ltcGxlV2FsbGV0Q29uZmlnLnRocmVzaG9sZCxcbiAgICBjaGVja3BvaW50OiBzaW1wbGVXYWxsZXRDb25maWcuY2hlY2twb2ludCxcbiAgICB0cmVlOiBidWlsZGVyKHNpbXBsZVdhbGxldENvbmZpZy5tZW1iZXJzKVxuICB9O1xufVxuZnVuY3Rpb24gaGFzU3ViZGlnZXN0KHRyZWUsIHN1YmRpZ2VzdCkge1xuICBpZiAoaXNTdWJkaWdlc3RMZWFmKHRyZWUpKSB7XG4gICAgcmV0dXJuIHRyZWUuc3ViZGlnZXN0ID09PSBzdWJkaWdlc3Q7XG4gIH1cbiAgaWYgKGlzTm9kZSh0cmVlKSkge1xuICAgIHJldHVybiBoYXNTdWJkaWdlc3QodHJlZS5sZWZ0LCBzdWJkaWdlc3QpIHx8IGhhc1N1YmRpZ2VzdCh0cmVlLnJpZ2h0LCBzdWJkaWdlc3QpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNpZ25lcnNPZih0cmVlKSB7XG4gIGNvbnN0IHN0YWNrID0gW3RyZWVdO1xuICBjb25zdCBzaWduZXJzID0gbmV3IFNldCgpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICBpZiAoaXNOZXN0ZWRMZWFmKG5vZGUpKSB7XG4gICAgICBzdGFjay5wdXNoKG5vZGUudHJlZSk7XG4gICAgfSBlbHNlIGlmIChpc05vZGUobm9kZSkpIHtcbiAgICAgIHN0YWNrLnB1c2gobm9kZS5sZWZ0KTtcbiAgICAgIHN0YWNrLnB1c2gobm9kZS5yaWdodCk7XG4gICAgfSBlbHNlIGlmIChpc1NpZ25lckxlYWYobm9kZSkpIHtcbiAgICAgIHNpZ25lcnMuYWRkKHtcbiAgICAgICAgYWRkcmVzczogbm9kZS5hZGRyZXNzLFxuICAgICAgICB3ZWlnaHQ6IE51bWJlcihub2RlLndlaWdodClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShzaWduZXJzKTtcbn1cbmZ1bmN0aW9uIGlzQ29tcGxldGUodHJlZSkge1xuICBpZiAoaXNOb2RlKHRyZWUpKSB7XG4gICAgcmV0dXJuIGlzQ29tcGxldGUodHJlZS5sZWZ0KSAmJiBpc0NvbXBsZXRlKHRyZWUucmlnaHQpO1xuICB9XG4gIHJldHVybiAhaXNOb2RlTGVhZih0cmVlKTtcbn1cbmNvbnN0IENvbmZpZ0NvZGVyID0ge1xuICBpc1dhbGxldENvbmZpZzogY29uZmlnID0+IHtcbiAgICByZXR1cm4gY29uZmlnLnZlcnNpb24gPT09IDIgJiYgY29uZmlnLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy50cmVlICE9PSB1bmRlZmluZWQ7XG4gIH0sXG4gIGltYWdlSGFzaE9mOiBjb25maWcgPT4ge1xuICAgIHJldHVybiBpbWFnZUhhc2goY29uZmlnKTtcbiAgfSxcbiAgaGFzU3ViZGlnZXN0OiAoY29uZmlnLCBzdWJkaWdlc3QpID0+IHtcbiAgICByZXR1cm4gaGFzU3ViZGlnZXN0KGNvbmZpZy50cmVlLCBzdWJkaWdlc3QpO1xuICB9LFxuICBjaGVja3BvaW50T2Y6IGNvbmZpZyA9PiB7XG4gICAgcmV0dXJuIEJpZ0ludChjb25maWcuY2hlY2twb2ludCk7XG4gIH0sXG4gIHNpZ25lcnNPZjogY29uZmlnID0+IHtcbiAgICByZXR1cm4gc2lnbmVyc09mKGNvbmZpZy50cmVlKTtcbiAgfSxcbiAgZnJvbVNpbXBsZTogY29uZmlnID0+IHtcbiAgICB2YXIgX2NvbmZpZyRzdWJkaWdlc3RzO1xuICAgIHJldHVybiB0b1dhbGxldENvbmZpZyhfZXh0ZW5kcyh7fSwgY29uZmlnLCB7XG4gICAgICBtZW1iZXJzOiBbLi4uY29uZmlnLnNpZ25lcnMsIC4uLigoX2NvbmZpZyRzdWJkaWdlc3RzID0gY29uZmlnLnN1YmRpZ2VzdHMpICE9IG51bGwgPyBfY29uZmlnJHN1YmRpZ2VzdHMgOiBbXSkubWFwKHN1YmRpZ2VzdCA9PiAoe1xuICAgICAgICBzdWJkaWdlc3RcbiAgICAgIH0pKV1cbiAgICB9KSk7XG4gIH0sXG4gIGlzQ29tcGxldGU6IGNvbmZpZyA9PiB7XG4gICAgcmV0dXJuIGlzQ29tcGxldGUoY29uZmlnLnRyZWUpO1xuICB9LFxuICAvLyBpc1ZhbGlkID0gKGNvbmZpZzogV2FsbGV0Q29uZmlnKTogYm9vbGVhbiB7fVxuICAvKipcbiAgICpcbiAgICogTm90aWNlOiBjb250ZXh0IGFuZCBraW5kIGFyZSBpZ25vcmVkIGJlY2F1c2UgdjJcbiAgICogZG9lc24ndCBuZWVkIHRvIG1hbnVhbGx5IHVwZGF0ZSB0aGUgaW1wbGVtZW50YXRpb24gYmVmb3JlXG4gICAqIGEgY29uZmlndXJhdGlvbiB1cGRhdGUsIGl0J3MgYXV0b21hdGljYWxseSBkb25lIGJ5IHRoZSBjb250cmFjdC5cbiAgICpcbiAgICovXG4gIHVwZGF0ZToge1xuICAgIGlzS2luZFVzZWQ6IHRydWUsXG4gICAgYnVpbGRUcmFuc2FjdGlvbjogKHdhbGxldCwgY29uZmlnLCBfY29udGV4dCwgX2tpbmQpID0+IHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKHdhbGxldENvbnRyYWN0cy5tYWluTW9kdWxlVXBncmFkYWJsZS5hYmkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZW50cnlwb2ludDogd2FsbGV0LFxuICAgICAgICB0cmFuc2FjdGlvbnM6IFt7XG4gICAgICAgICAgdG86IHdhbGxldCxcbiAgICAgICAgICBkYXRhOiBtb2R1bGUuZW5jb2RlRnVuY3Rpb25EYXRhKG1vZHVsZS5nZXRGdW5jdGlvbigndXBkYXRlSW1hZ2VIYXNoJyksIFtDb25maWdDb2Rlci5pbWFnZUhhc2hPZihjb25maWcpXSksXG4gICAgICAgICAgZ2FzTGltaXQ6IDAsXG4gICAgICAgICAgZGVsZWdhdGVDYWxsOiBmYWxzZSxcbiAgICAgICAgICByZXZlcnRPbkVycm9yOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgIH0sXG4gICAgZGVjb2RlVHJhbnNhY3Rpb246IGZ1bmN0aW9uICh0eCkge1xuICAgICAgdmFyIF90eCR0cmFuc2FjdGlvbnMkMCR2YSwgX3R4JHRyYW5zYWN0aW9ucyQsIF90eCR0cmFuc2FjdGlvbnMkMCRnYSwgX3R4JHRyYW5zYWN0aW9ucyQyO1xuICAgICAgY29uc3QgbW9kdWxlID0gbmV3IGV0aGVycy5JbnRlcmZhY2Uod2FsbGV0Q29udHJhY3RzLm1haW5Nb2R1bGVVcGdyYWRhYmxlLmFiaSk7XG4gICAgICBpZiAodHgudHJhbnNhY3Rpb25zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24gYnVuZGxlLCBleHBlY3RlZCAxIHRyYW5zYWN0aW9uJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gdHgudHJhbnNhY3Rpb25zWzBdLmRhdGE7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uIGJ1bmRsZSwgZXhwZWN0ZWQgZGF0YScpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVjb2RlZCA9IG1vZHVsZS5kZWNvZGVGdW5jdGlvbkRhdGEobW9kdWxlLmdldEZ1bmN0aW9uKCd1cGRhdGVJbWFnZUhhc2gnKSwgZGF0YSk7XG4gICAgICBpZiAoIWRlY29kZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uIGJ1bmRsZSwgZXhwZWN0ZWQgdmFsaWQgZGF0YScpO1xuICAgICAgfVxuICAgICAgaWYgKHR4LnRyYW5zYWN0aW9uc1swXS50byAhPT0gdHguZW50cnlwb2ludCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24gYnVuZGxlLCBleHBlY3RlZCB0byBiZSBzZW50IHRvIGVudHJ5cG9pbnQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eC50cmFuc2FjdGlvbnNbMF0uZGVsZWdhdGVDYWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbiBidW5kbGUsIGV4cGVjdGVkIG5vdCB0byBiZSBhIGRlbGVnYXRlQ2FsbCcpO1xuICAgICAgfVxuICAgICAgaWYgKCF0eC50cmFuc2FjdGlvbnNbMF0ucmV2ZXJ0T25FcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24gYnVuZGxlLCBleHBlY3RlZCByZXZlcnRPbkVycm9yJyk7XG4gICAgICB9XG4gICAgICBpZiAoQmlnSW50KChfdHgkdHJhbnNhY3Rpb25zJDAkdmEgPSAoX3R4JHRyYW5zYWN0aW9ucyQgPSB0eC50cmFuc2FjdGlvbnNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdHgkdHJhbnNhY3Rpb25zJC52YWx1ZSkgIT0gbnVsbCA/IF90eCR0cmFuc2FjdGlvbnMkMCR2YSA6IDApICE9PSAwbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24gYnVuZGxlLCBleHBlY3RlZCB2YWx1ZSB0byBiZSAwJyk7XG4gICAgICB9XG4gICAgICBpZiAoQmlnSW50KChfdHgkdHJhbnNhY3Rpb25zJDAkZ2EgPSAoX3R4JHRyYW5zYWN0aW9ucyQyID0gdHgudHJhbnNhY3Rpb25zWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3R4JHRyYW5zYWN0aW9ucyQyLmdhc0xpbWl0KSAhPSBudWxsID8gX3R4JHRyYW5zYWN0aW9ucyQwJGdhIDogMCkgIT09IDBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbiBidW5kbGUsIGV4cGVjdGVkIHZhbHVlIHRvIGJlIDAnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IHR4LmVudHJ5cG9pbnQsXG4gICAgICAgIG5ld0ltYWdlSGFzaDogZGVjb2RlZFswXSxcbiAgICAgICAga2luZDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgdG9KU09OOiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHZlcnNpb246IGNvbmZpZy52ZXJzaW9uLFxuICAgICAgdGhyZXNob2xkOiBCaWdJbnQoY29uZmlnLnRocmVzaG9sZCkudG9TdHJpbmcoKSxcbiAgICAgIGNoZWNrcG9pbnQ6IEJpZ0ludChjb25maWcuY2hlY2twb2ludCkudG9TdHJpbmcoKSxcbiAgICAgIHRyZWU6IHRvcG9sb2d5VG9KU09OKGNvbmZpZy50cmVlKVxuICAgIH0pO1xuICB9LFxuICBmcm9tSlNPTjogZnVuY3Rpb24gKGpzb24pIHtcbiAgICBjb25zdCBjb25maWcgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiBjb25maWcudmVyc2lvbixcbiAgICAgIHRocmVzaG9sZDogQmlnSW50KGNvbmZpZy50aHJlc2hvbGQpLFxuICAgICAgY2hlY2twb2ludDogQmlnSW50KGNvbmZpZy5jaGVja3BvaW50KSxcbiAgICAgIHRyZWU6IHRvcG9sb2d5RnJvbUpTT04oY29uZmlnLnRyZWUpXG4gICAgfTtcbiAgfSxcbiAgZWRpdENvbmZpZzogZnVuY3Rpb24gKGNvbmZpZywgYWN0aW9uKSB7XG4gICAgdmFyIF9hY3Rpb24kdGhyZXNob2xkLCBfYWN0aW9uJGNoZWNrcG9pbnQ7XG4gICAgY29uc3QgbWVtYmVycyA9IHRvcG9sb2d5VG9NZW1iZXJzKGNvbmZpZy50cmVlKTtcbiAgICBpZiAoYWN0aW9uLmFkZCkge1xuICAgICAgZm9yIChjb25zdCBzaWduZXIgb2YgYWN0aW9uLmFkZCkge1xuICAgICAgICBpZiAobWVtYmVycy5maW5kKHMgPT4gaXNTaWduZXJMZWFmKHMpICYmIHMuYWRkcmVzcyA9PT0gc2lnbmVyLmFkZHJlc3MpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbWVtYmVycy5wdXNoKHtcbiAgICAgICAgICBhZGRyZXNzOiBzaWduZXIuYWRkcmVzcyxcbiAgICAgICAgICB3ZWlnaHQ6IHNpZ25lci53ZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhY3Rpb24ucmVtb3ZlKSB7XG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgYWN0aW9uLnJlbW92ZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IG1lbWJlcnMuZmluZEluZGV4KHMgPT4gaXNTaWduZXJMZWFmKHMpICYmIHMuYWRkcmVzcyA9PT0gYWRkcmVzcyk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgbWVtYmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiBjb25maWcudmVyc2lvbixcbiAgICAgIHRocmVzaG9sZDogKF9hY3Rpb24kdGhyZXNob2xkID0gYWN0aW9uLnRocmVzaG9sZCkgIT0gbnVsbCA/IF9hY3Rpb24kdGhyZXNob2xkIDogY29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGNoZWNrcG9pbnQ6IChfYWN0aW9uJGNoZWNrcG9pbnQgPSBhY3Rpb24uY2hlY2twb2ludCkgIT0gbnVsbCA/IF9hY3Rpb24kY2hlY2twb2ludCA6IGNvbmZpZy5jaGVja3BvaW50LFxuICAgICAgdHJlZTogb3B0aW1pemVkMlNpZ25lcnNUb3BvbG9neUJ1aWxkZXIobWVtYmVycylcbiAgICB9O1xuICB9LFxuICBidWlsZFN0dWJTaWduYXR1cmU6IGZ1bmN0aW9uIChjb25maWcsIG92ZXJyaWRlcykge1xuICAgIGNvbnN0IHBhcnRzID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW3NpZ25lciwgc2lnbmF0dXJlXSBvZiBvdmVycmlkZXMuZW50cmllcygpKSB7XG4gICAgICBwYXJ0cy5zZXQoc2lnbmVyLCB7XG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgaXNEeW5hbWljOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5jb2RlZCxcbiAgICAgICAgd2VpZ2h0XG4gICAgICB9ID0gZW5jb2RlU2lnbmVycyhjb25maWcsIHBhcnRzLCBbXSwgMCk7XG4gICAgICBpZiAod2VpZ2h0ID49IEJpZ0ludChjb25maWcudGhyZXNob2xkKSkge1xuICAgICAgICByZXR1cm4gZW5jb2RlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2lnbmVycyA9IHNpZ25lcnNPZihjb25maWcudHJlZSk7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBhZGRyZXNzXG4gICAgfSBvZiBzaWduZXJzLnNvcnQoKHtcbiAgICAgIHdlaWdodDogYVxuICAgIH0sIHtcbiAgICAgIHdlaWdodDogYlxuICAgIH0pID0+IGEgLSBiKSkge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gJzB4NGU4MmYwMmYzODhhMTJiNWY5ZDI5ZWFmMjQ1MmRkMDQwYzBlZTU4MDRiNGU1MDRiNGRkNjRlMzk2YzZjNzgxZjJjNzYyNDE5NWFjYmEyNDJkZDgyNWJmZDI1YTI5MDkxMmUzYzIzMDg0MWZkNTVjOWE3MzRjNGRlOGQ5ODk5NDUxYjAyJztcbiAgICAgIHBhcnRzLnNldChhZGRyZXNzLCB7XG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgaXNEeW5hbWljOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVuY29kZWQsXG4gICAgICAgIHdlaWdodFxuICAgICAgfSA9IGVuY29kZVNpZ25lcnMoY29uZmlnLCBwYXJ0cywgW10sIDApO1xuICAgICAgaWYgKHdlaWdodCA+PSBCaWdJbnQoY29uZmlnLnRocmVzaG9sZCkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVTaWduZXJzKGNvbmZpZywgcGFydHMsIFtdLCAwKS5lbmNvZGVkO1xuICB9XG59O1xuXG52YXIgY29uZmlnJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgaXNTaWduZXJMZWFmOiBpc1NpZ25lckxlYWYsXG4gIGlzU3ViZGlnZXN0TGVhZjogaXNTdWJkaWdlc3RMZWFmLFxuICB0b3BvbG9neVRvSlNPTjogdG9wb2xvZ3lUb0pTT04sXG4gIHRvcG9sb2d5RnJvbUpTT046IHRvcG9sb2d5RnJvbUpTT04sXG4gIGlzTmVzdGVkTGVhZjogaXNOZXN0ZWRMZWFmLFxuICBpc05vZGVMZWFmOiBpc05vZGVMZWFmLFxuICBpc0xlYWY6IGlzTGVhZixcbiAgaXNOb2RlOiBpc05vZGUsXG4gIGlzVG9wb2xvZ3k6IGlzVG9wb2xvZ3ksXG4gIGVuY29kZVNpZ25lckxlYWY6IGVuY29kZVNpZ25lckxlYWYsXG4gIGRlY29kZVNpZ25lckxlYWY6IGRlY29kZVNpZ25lckxlYWYsXG4gIGlzRW5jb2RlZFNpZ25lckxlYWY6IGlzRW5jb2RlZFNpZ25lckxlYWYsXG4gIGhhc2hOb2RlOiBoYXNoTm9kZSxcbiAgbGVmdEZhY2U6IGxlZnRGYWNlLFxuICBpc1dhbGxldENvbmZpZzogaXNXYWxsZXRDb25maWcsXG4gIGltYWdlSGFzaDogaW1hZ2VIYXNoLFxuICBpc1NpbXBsZU5lc3RlZE1lbWJlcjogaXNTaW1wbGVOZXN0ZWRNZW1iZXIsXG4gIHRvcG9sb2d5VG9NZW1iZXJzOiB0b3BvbG9neVRvTWVtYmVycyxcbiAgaGFzVW5rbm93bk5vZGVzOiBoYXNVbmtub3duTm9kZXMsXG4gIHRvU2ltcGxlV2FsbGV0Q29uZmlnOiB0b1NpbXBsZVdhbGxldENvbmZpZyxcbiAgbGVnYWN5VG9wb2xvZ3lCdWlsZGVyOiBsZWdhY3lUb3BvbG9neUJ1aWxkZXIsXG4gIG1lcmtsZVRvcG9sb2d5QnVpbGRlcjogbWVya2xlVG9wb2xvZ3lCdWlsZGVyLFxuICBvcHRpbWl6ZWQyU2lnbmVyc1RvcG9sb2d5QnVpbGRlcjogb3B0aW1pemVkMlNpZ25lcnNUb3BvbG9neUJ1aWxkZXIsXG4gIHRvV2FsbGV0Q29uZmlnOiB0b1dhbGxldENvbmZpZyxcbiAgaGFzU3ViZGlnZXN0OiBoYXNTdWJkaWdlc3QsXG4gIHNpZ25lcnNPZjogc2lnbmVyc09mLFxuICBpc0NvbXBsZXRlOiBpc0NvbXBsZXRlLFxuICBDb25maWdDb2RlcjogQ29uZmlnQ29kZXJcbn0pO1xuXG52YXIgY29udGV4dCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG5jb25zdCBjb2RlcnMgPSB7XG4gIGNvbmZpZzogQ29uZmlnQ29kZXIsXG4gIHNpZ25hdHVyZTogU2lnbmF0dXJlQ29kZXJcbn07XG5jb25zdCB2ZXJzaW9uID0gMjtcbmNvbnN0IERlcGxveWVkV2FsbGV0Q29udGV4dCA9IHtcbiAgdmVyc2lvbjogdmVyc2lvbixcbiAgZmFjdG9yeTogJzB4RmFBNWMwYjE0ZDFiRUQ1Qzg4OENhNjU1QjlhOEE1OTExRjc4ZUY0QScsXG4gIGd1ZXN0TW9kdWxlOiAnMHhmZWEyMzBFZTI0M2Y4OEJDNjk4ZEQ4ZjFhRTkzRjgzMDFCNmNkZmFFJyxcbiAgbWFpbk1vZHVsZTogJzB4ZkJmOGYxQTVFMDAwMzQ3NjJEOTI4ZjQ2ZDQzOEI5NDdmNWQ0MDY1ZCcsXG4gIG1haW5Nb2R1bGVVcGdyYWRhYmxlOiAnMHg0MjIyZGNBMzk3NEUzOUE4YjQxYzQxMUZlRERFOWIwOUFlMTRiOTExJyxcbiAgd2FsbGV0Q3JlYXRpb25Db2RlOiAnMHg2MDNhNjAwZTNkMzk2MDFhODA1MTMwNTUzZGYzMzYzZDNkMzczZDNkM2QzNjNkMzA1NDVhZjQzZDgyODAzZTkwM2Q5MTYwMTg1N2ZkNWJmMycsXG4gIHByb3h5SW1wbGVtZW50YXRpb25Ib29rOiAnMHgxZjU2ZGJBRDVlODMxOUYwREU5YTMyM0UyNEEzMWI1MDc3ZEVCMWE0J1xufTtcblxudmFyIHYyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGNvbmZpZzogY29uZmlnJDEsXG4gIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICBjb250ZXh0OiBjb250ZXh0JDEsXG4gIGNoYWluZWQ6IGNoYWluZWQsXG4gIGNvZGVyczogY29kZXJzLFxuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICBEZXBsb3llZFdhbGxldENvbnRleHQ6IERlcGxveWVkV2FsbGV0Q29udGV4dFxufSk7XG5cbnZhciBjb25maWcgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbmZ1bmN0aW9uIGFkZHJlc3NPZihjb250ZXh0LCBpbWFnZUhhc2gpIHtcbiAgY29uc3QgY29kZUhhc2ggPSBldGhlcnMua2VjY2FrMjU2KGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ2J5dGVzJywgJ2J5dGVzMzInXSwgW2NvbnRleHQud2FsbGV0Q3JlYXRpb25Db2RlLCBldGhlcnMuemVyb1BhZFZhbHVlKGNvbnRleHQubWFpbk1vZHVsZSwgMzIpXSkpO1xuICBjb25zdCBoYXNoID0gZXRoZXJzLmtlY2NhazI1NihldGhlcnMuc29saWRpdHlQYWNrZWQoWydieXRlczEnLCAnYWRkcmVzcycsICdieXRlczMyJywgJ2J5dGVzMzInXSwgWycweGZmJywgY29udGV4dC5mYWN0b3J5LCBpbWFnZUhhc2gsIGNvZGVIYXNoXSkpO1xuICByZXR1cm4gZXRoZXJzLmdldEFkZHJlc3MoZXRoZXJzLmRhdGFTbGljZShoYXNoLCAxMikpO1xufVxuYXN5bmMgZnVuY3Rpb24gaXNWYWxpZENvdW50ZXJmYWN0dWFsKHdhbGxldCwgZGlnZXN0LCBzaWduYXR1cmUsIGNoYWluSWQsIHByb3ZpZGVyLCBjb250ZXh0cykge1xuICAvLyBXZSBkb24ndCBrbm93IHRoZSB2ZXJzaW9uIG9mIHRoZSBzaWduYXR1cmVcbiAgLy8gc28gd2UgbmVlZCB0byB0cnkgYWxsIG9mIHRoZW1cbiAgY29uc3QgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGwoYWxsVmVyc2lvbnMubWFwKGFzeW5jIHZlcnNpb24gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZWNvZGVkID0gdmVyc2lvbi5zaWduYXR1cmUuU2lnbmF0dXJlQ29kZXIuZGVjb2RlKGV0aGVycy5oZXhsaWZ5KHNpZ25hdHVyZSkpO1xuICAgICAgY29uc3QgcmVjb3ZlcmVkMSA9IGF3YWl0IHZlcnNpb24uc2lnbmF0dXJlLlNpZ25hdHVyZUNvZGVyLnJlY292ZXIoZGVjb2RlZCwge1xuICAgICAgICBhZGRyZXNzOiB3YWxsZXQsXG4gICAgICAgIGRpZ2VzdDogZXRoZXJzLmhleGxpZnkoZGlnZXN0KSxcbiAgICAgICAgY2hhaW5JZFxuICAgICAgfSwgcHJvdmlkZXIpO1xuICAgICAgY29uc3QgaW1hZ2VIYXNoID0gdmVyc2lvbi5jb25maWcuQ29uZmlnQ29kZXIuaW1hZ2VIYXNoT2YocmVjb3ZlcmVkMS5jb25maWcpO1xuICAgICAgY29uc3QgY291bnRlcmZhY3R1YWxBZGRyZXNzID0gYWRkcmVzc09mKGNvbnRleHRzW3ZlcnNpb24udmVyc2lvbl0sIGltYWdlSGFzaCk7XG4gICAgICBpZiAoY291bnRlcmZhY3R1YWxBZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IHdhbGxldC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGFpbklkPTAgbWVhbnMgbm8gY2hhaW5JZCwgc28gdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCBmb3IgYWxsIGNoYWluc1xuICAgICAgLy8gd2UgbmVlZCB0byBjaGVjayB0aGF0IGNhc2UgdG9vXG4gICAgICBjb25zdCByZWNvdmVyZWQyID0gYXdhaXQgdmVyc2lvbi5zaWduYXR1cmUuU2lnbmF0dXJlQ29kZXIucmVjb3ZlcihkZWNvZGVkLCB7XG4gICAgICAgIGFkZHJlc3M6IHdhbGxldCxcbiAgICAgICAgZGlnZXN0OiBldGhlcnMuaGV4bGlmeShkaWdlc3QpLFxuICAgICAgICBjaGFpbklkXG4gICAgICB9LCBwcm92aWRlcik7XG4gICAgICBjb25zdCBpbWFnZUhhc2gyID0gdmVyc2lvbi5jb25maWcuQ29uZmlnQ29kZXIuaW1hZ2VIYXNoT2YocmVjb3ZlcmVkMi5jb25maWcpO1xuICAgICAgY29uc3QgY291bnRlcmZhY3R1YWxBZGRyZXNzMiA9IGFkZHJlc3NPZihjb250ZXh0c1t2ZXJzaW9uLnZlcnNpb25dLCBpbWFnZUhhc2gyKTtcbiAgICAgIHJldHVybiBjb3VudGVyZmFjdHVhbEFkZHJlc3MyLnRvTG93ZXJDYXNlKCkgPT09IHdhbGxldC50b0xvd2VyQ2FzZSgpO1xuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHt9XG5cbiAgICAvLyBXZSBtb3N0IGxpa2VseSBmYWlsZWQgdG8gZGVjb2RlIHRoZSBzaWduYXR1cmVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pKTtcbiAgcmV0dXJuIHJlcy5zb21lKHIgPT4gcik7XG59XG5mdW5jdGlvbiBpc1ZhbGlkVmVyc2lvbmVkQ29udGV4dChjb250ZXh0cykge1xuICAvLyBudW1iZXIgb2Yga2V5cyBpcyB0aGUgbnVtYmVyIG9mIHZlcnNpb25zXG4gIGNvbnN0IHZlcnNpb25zID0gT2JqZWN0LmtleXMoY29udGV4dHMpLmxlbmd0aDtcblxuICAvLyBjaGVjayB0aGF0IGFsbCB2ZXJzaW9ucyBleGlzdCBhbmQgYXJlIHZhbGlkXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IHZlcnNpb25zOyBpKyspIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY29udGV4dHNbaV07XG4gICAgaWYgKCFjb250ZXh0IHx8IGNvbnRleHQudmVyc2lvbiAhPT0gaSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGxhdGVzdENvbnRleHQoY29udGV4dHMpIHtcbiAgY29uc3QgdmVyc2lvbnMgPSBPYmplY3Qua2V5cyhjb250ZXh0cykubGVuZ3RoO1xuICByZXR1cm4gY29udGV4dHNbdmVyc2lvbnNdO1xufVxuY29uc3QgZGVmYXVsdENvbnRleHRzID0ge1xuICAxOiBEZXBsb3llZFdhbGxldENvbnRleHQkMSxcbiAgMjogRGVwbG95ZWRXYWxsZXRDb250ZXh0XG59O1xuXG52YXIgY29udGV4dCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhZGRyZXNzT2Y6IGFkZHJlc3NPZixcbiAgaXNWYWxpZENvdW50ZXJmYWN0dWFsOiBpc1ZhbGlkQ291bnRlcmZhY3R1YWwsXG4gIGlzVmFsaWRWZXJzaW9uZWRDb250ZXh0OiBpc1ZhbGlkVmVyc2lvbmVkQ29udGV4dCxcbiAgbGF0ZXN0Q29udGV4dDogbGF0ZXN0Q29udGV4dCxcbiAgZGVmYXVsdENvbnRleHRzOiBkZWZhdWx0Q29udGV4dHNcbn0pO1xuXG5jb25zdCBNZXRhVHJhbnNhY3Rpb25zVHlwZSA9IGB0dXBsZShcbiAgYm9vbCBkZWxlZ2F0ZUNhbGwsXG4gIGJvb2wgcmV2ZXJ0T25FcnJvcixcbiAgdWludDI1NiBnYXNMaW1pdCxcbiAgYWRkcmVzcyB0YXJnZXQsXG4gIHVpbnQyNTYgdmFsdWUsXG4gIGJ5dGVzIGRhdGFcbilbXWA7XG5mdW5jdGlvbiBpbnRlbmRUcmFuc2FjdGlvbkJ1bmRsZShidW5kbGUsIHdhbGxldCwgY2hhaW5JZCwgaWQpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBidW5kbGUsIHtcbiAgICBjaGFpbklkLFxuICAgIGludGVudDoge1xuICAgICAgaWQ6IGlkLFxuICAgICAgd2FsbGV0XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGludGVuZGVkVHJhbnNhY3Rpb25JRChidW5kbGUpIHtcbiAgcmV0dXJuIGV0aGVycy5rZWNjYWsyNTYoZXRoZXJzLkFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpLmVuY29kZShbJ2FkZHJlc3MnLCAndWludDI1NicsICdieXRlczMyJ10sIFtidW5kbGUuaW50ZW50LndhbGxldCwgYnVuZGxlLmNoYWluSWQsIGJ1bmRsZS5pbnRlbnQuaWRdKSk7XG59XG5mdW5jdGlvbiB1bnBhY2tNZXRhVHJhbnNhY3Rpb25zRGF0YShkYXRhKSB7XG4gIGNvbnN0IHJlcyA9IGV0aGVycy5BYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKS5kZWNvZGUoWyd1aW50MjU2JywgTWV0YVRyYW5zYWN0aW9uc1R5cGVdLCBkYXRhKTtcbiAgaWYgKHJlcy5sZW5ndGggIT09IDIgfHwgIXJlc1swXSB8fCAhcmVzWzFdKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0YSB0cmFuc2FjdGlvbiBkYXRhJyk7XG4gIHJldHVybiBbcmVzWzBdLCByZXNbMV1dO1xufVxuZnVuY3Rpb24gcGFja01ldGFUcmFuc2FjdGlvbnNEYXRhKG5vbmNlLCB0eHMpIHtcbiAgcmV0dXJuIGV0aGVycy5BYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKS5lbmNvZGUoWyd1aW50MjU2JywgTWV0YVRyYW5zYWN0aW9uc1R5cGVdLCBbbm9uY2UsIHNlcXVlbmNlVHhBYmlFbmNvZGUodHhzKV0pO1xufVxuZnVuY3Rpb24gZGlnZXN0T2ZUcmFuc2FjdGlvbnMobm9uY2UsIHR4cykge1xuICByZXR1cm4gZXRoZXJzLmtlY2NhazI1NihwYWNrTWV0YVRyYW5zYWN0aW9uc0RhdGEobm9uY2UsIHR4cykpO1xufVxuZnVuY3Rpb24gc3ViZGlnZXN0T2ZUcmFuc2FjdGlvbnMoYWRkcmVzcywgY2hhaW5JZCwgbm9uY2UsIHR4cykge1xuICByZXR1cm4gc3ViZGlnZXN0T2Yoe1xuICAgIGFkZHJlc3MsXG4gICAgY2hhaW5JZCxcbiAgICBkaWdlc3Q6IGRpZ2VzdE9mVHJhbnNhY3Rpb25zKG5vbmNlLCB0eHMpXG4gIH0pO1xufVxuZnVuY3Rpb24gc3ViZGlnZXN0T2ZHdWVzdE1vZHVsZVRyYW5zYWN0aW9ucyhndWVzdE1vZHVsZSwgY2hhaW5JZCwgdHhzKSB7XG4gIHJldHVybiBzdWJkaWdlc3RPZih7XG4gICAgYWRkcmVzczogZ3Vlc3RNb2R1bGUsXG4gICAgY2hhaW5JZCxcbiAgICBkaWdlc3Q6IGV0aGVycy5rZWNjYWsyNTYoZXRoZXJzLkFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpLmVuY29kZShbJ3N0cmluZycsIE1ldGFUcmFuc2FjdGlvbnNUeXBlXSwgWydndWVzdDonLCBzZXF1ZW5jZVR4QWJpRW5jb2RlKHR4cyldKSlcbiAgfSk7XG59XG5mdW5jdGlvbiB0b1NlcXVlbmNlVHJhbnNhY3Rpb25zKHdhbGxldCwgdHhzKSB7XG4gIHJldHVybiB0eHMubWFwKHR4ID0+IHRvU2VxdWVuY2VUcmFuc2FjdGlvbih3YWxsZXQsIHR4KSk7XG59XG5mdW5jdGlvbiB0b1NlcXVlbmNlVHJhbnNhY3Rpb24od2FsbGV0LCB0eCkge1xuICBpZiAodHgudG8gJiYgdHgudG8gIT09IGV0aGVycy5aZXJvQWRkcmVzcykge1xuICAgIHJldHVybiB7XG4gICAgICBub25jZTogIWlzTnVsbGlzaCh0eC5ub25jZSkgPyBCaWdJbnQodHgubm9uY2UpIDogdW5kZWZpbmVkLFxuICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgZGVsZWdhdGVDYWxsOiBmYWxzZSxcbiAgICAgICAgcmV2ZXJ0T25FcnJvcjogZmFsc2UsXG4gICAgICAgIGdhc0xpbWl0OiAhaXNOdWxsaXNoKHR4Lmdhc0xpbWl0KSA/IEJpZ0ludCh0eC5nYXNMaW1pdCkgOiB1bmRlZmluZWQsXG4gICAgICAgIC8vIFhYWDogYHR4LnRvYCBjb3VsZCBhbHNvIGJlIGV0aGVycyBBZGRyZXNzYWJsZSB0eXBlIHdoaWNoIHJldHVybnMgYSBnZXRBZGRyZXNzIHByb21pc2VcbiAgICAgICAgLy8gS2VlcGluZyB0aGlzIGFzIGlzIGZvciBub3cgc28gd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgZXZlcnl0aGluZyB0byBhc3luY1xuICAgICAgICB0bzogdHgudG8sXG4gICAgICAgIHZhbHVlOiBCaWdJbnQodHgudmFsdWUgfHwgMCksXG4gICAgICAgIGRhdGE6IHR4LmRhdGEgfHwgJzB4J1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgd2FsbGV0SW50ZXJmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2Uod2FsbGV0Q29udHJhY3RzLm1haW5Nb2R1bGUuYWJpKTtcbiAgICBjb25zdCBkYXRhID0gd2FsbGV0SW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSh3YWxsZXRJbnRlcmZhY2UuZ2V0RnVuY3Rpb24oJ2NyZWF0ZUNvbnRyYWN0JyksIFt0eC5kYXRhXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlOiB0eXBlb2YgdHgubm9uY2UgPT09ICdudW1iZXInID8gQmlnSW50KHR4Lm5vbmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgIGRlbGVnYXRlQ2FsbDogZmFsc2UsXG4gICAgICAgIHJldmVydE9uRXJyb3I6IGZhbHNlLFxuICAgICAgICBnYXNMaW1pdDogIWlzTnVsbGlzaCh0eC5nYXNMaW1pdCkgPyBCaWdJbnQodHguZ2FzTGltaXQpIDogdW5kZWZpbmVkLFxuICAgICAgICB0bzogd2FsbGV0LFxuICAgICAgICB2YWx1ZTogQmlnSW50KHR4LnZhbHVlIHx8IDApLFxuICAgICAgICBkYXRhXG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTZXF1ZW5jZVRyYW5zYWN0aW9uKHR4KSB7XG4gIHJldHVybiB0eC5kZWxlZ2F0ZUNhbGwgIT09IHVuZGVmaW5lZCB8fCB0eC5yZXZlcnRPbkVycm9yICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBoYXNTZXF1ZW5jZVRyYW5zYWN0aW9ucyh0eHMpIHtcbiAgcmV0dXJuIHR4cy5ldmVyeShpc1NlcXVlbmNlVHJhbnNhY3Rpb24pO1xufVxuXG4vLyBUT0RPOiBXZSBtYXkgYmUgYWJsZSB0byByZW1vdmUgdGhpcyBpZiB3ZSBtYWtlIFRyYW5zYWN0aW9uID09PSBUcmFuc2FjdGlvbkVuY29kZWRcbmZ1bmN0aW9uIHNlcXVlbmNlVHhBYmlFbmNvZGUodHhzKSB7XG4gIHJldHVybiB0eHMubWFwKHR4ID0+IHtcbiAgICB2YXIgX3R4JHRvO1xuICAgIHJldHVybiB7XG4gICAgICBkZWxlZ2F0ZUNhbGw6IHR4LmRlbGVnYXRlQ2FsbCA9PT0gdHJ1ZSxcbiAgICAgIHJldmVydE9uRXJyb3I6IHR4LnJldmVydE9uRXJyb3IgPT09IHRydWUsXG4gICAgICBnYXNMaW1pdDogIWlzTnVsbGlzaCh0eC5nYXNMaW1pdCkgPyBCaWdJbnQodHguZ2FzTGltaXQpIDogMG4sXG4gICAgICB0YXJnZXQ6IChfdHgkdG8gPSB0eC50bykgIT0gbnVsbCA/IF90eCR0byA6IGV0aGVycy5aZXJvQWRkcmVzcyxcbiAgICAgIHZhbHVlOiAhaXNOdWxsaXNoKHR4LnZhbHVlKSA/IHR4LnZhbHVlIDogMG4sXG4gICAgICBkYXRhOiB0eC5kYXRhIHx8ICcweCdcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZyb21UeEFiaUVuY29kZSh0eHMpIHtcbiAgcmV0dXJuIHR4cy5tYXAodHggPT4gKHtcbiAgICBkZWxlZ2F0ZUNhbGw6IHR4LmRlbGVnYXRlQ2FsbCxcbiAgICByZXZlcnRPbkVycm9yOiB0eC5yZXZlcnRPbkVycm9yLFxuICAgIGdhc0xpbWl0OiB0eC5nYXNMaW1pdCxcbiAgICB0bzogdHgudGFyZ2V0LFxuICAgIHZhbHVlOiB0eC52YWx1ZSxcbiAgICBkYXRhOiB0eC5kYXRhXG4gIH0pKTtcbn1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZE5vbmNlKHR4czogVHJhbnNhY3Rpb25bXSwgbm9uY2U6IGV0aGVycy5CaWdOdW1iZXJpc2gpOiBUcmFuc2FjdGlvbltdIHtcbi8vICAgcmV0dXJuIHR4cy5tYXAoKHQ6IFRyYW5zYWN0aW9uKSA9PiAoeyAuLi50LCBub25jZSB9KSlcbi8vIH1cblxuZnVuY3Rpb24gZW5jb2RlTm9uY2Uoc3BhY2UsIG5vbmNlKSB7XG4gIGNvbnN0IGJzcGFjZSA9IEJpZ0ludChzcGFjZSk7XG4gIGNvbnN0IGJub25jZSA9IEJpZ0ludChub25jZSk7XG4gIGNvbnN0IHNobCA9IDJuICoqIDk2bjtcbiAgaWYgKGJub25jZSAvIHNobCAhPT0gMG4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NwYWNlIGFscmVhZHkgZW5jb2RlZCcpO1xuICB9XG4gIHJldHVybiBibm9uY2UgKyBic3BhY2UgKiBzaGw7XG59XG5mdW5jdGlvbiBkZWNvZGVOb25jZShub25jZSkge1xuICBjb25zdCBibm9uY2UgPSBCaWdJbnQobm9uY2UpO1xuICBjb25zdCBzaHIgPSAybiAqKiA5Nm47XG4gIHJldHVybiBbYm5vbmNlIC8gc2hyLCBibm9uY2UgJSBzaHJdO1xufVxuZnVuY3Rpb24gZnJvbVRyYW5zYWN0aW9uaXNoKHdhbGxldCwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb24pKSB7XG4gICAgaWYgKGhhc1NlcXVlbmNlVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHggPSB0b1NlcXVlbmNlVHJhbnNhY3Rpb25zKHdhbGxldCwgdHJhbnNhY3Rpb24pO1xuICAgICAgcmV0dXJuIHN0eC5tYXAodCA9PiB0LnRyYW5zYWN0aW9uKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTZXF1ZW5jZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSkge1xuICAgIHJldHVybiBbdHJhbnNhY3Rpb25dO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbdG9TZXF1ZW5jZVRyYW5zYWN0aW9uKHdhbGxldCwgdHJhbnNhY3Rpb24pLnRyYW5zYWN0aW9uXTtcbiAgfVxufVxuZnVuY3Rpb24gaXNUcmFuc2FjdGlvbkJ1bmRsZShjYW5kKSB7XG4gIHJldHVybiBjYW5kICE9PSB1bmRlZmluZWQgJiYgY2FuZC5lbnRyeXBvaW50ICE9PSB1bmRlZmluZWQgJiYgY2FuZC5jaGFpbklkICE9PSB1bmRlZmluZWQgJiYgY2FuZC50cmFuc2FjdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBjYW5kLm5vbmNlICE9PSB1bmRlZmluZWQgJiYgY2FuZC5pbnRlbnQgIT09IHVuZGVmaW5lZCAmJiBjYW5kLmludGVudC5pZCAhPT0gdW5kZWZpbmVkICYmIGNhbmQuaW50ZW50LndhbGxldCAhPT0gdW5kZWZpbmVkICYmIEFycmF5LmlzQXJyYXkoY2FuZC50cmFuc2FjdGlvbnMpICYmIGNhbmQudHJhbnNhY3Rpb25zLnJlZHVjZSgocCwgYykgPT4gcCAmJiBpc1NlcXVlbmNlVHJhbnNhY3Rpb24oYyksIHRydWUpO1xufVxuZnVuY3Rpb24gaXNTaWduZWRUcmFuc2FjdGlvbkJ1bmRsZShjYW5kKSB7XG4gIHJldHVybiBjYW5kICE9PSB1bmRlZmluZWQgJiYgY2FuZC5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJiBjYW5kLnNpZ25hdHVyZSAhPT0gJycgJiYgaXNUcmFuc2FjdGlvbkJ1bmRsZShjYW5kKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUJ1bmRsZUV4ZWNEYXRhKGJ1bmRsZSkge1xuICBjb25zdCB3YWxsZXRJbnRlcmZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZSh3YWxsZXRDb250cmFjdHMubWFpbk1vZHVsZS5hYmkpO1xuICByZXR1cm4gd2FsbGV0SW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSh3YWxsZXRJbnRlcmZhY2UuZ2V0RnVuY3Rpb24oJ2V4ZWN1dGUnKSwgaXNTaWduZWRUcmFuc2FjdGlvbkJ1bmRsZShidW5kbGUpID8gW1xuICAvLyBTaWduZWQgdHJhbnNhY3Rpb24gYnVuZGxlIGhhcyBhbGwgMyBwYXJhbWV0ZXJzXG4gIHNlcXVlbmNlVHhBYmlFbmNvZGUoYnVuZGxlLnRyYW5zYWN0aW9ucyksIGJ1bmRsZS5ub25jZSwgYnVuZGxlLnNpZ25hdHVyZV0gOiBbXG4gIC8vIFVuc2lnbmVkIGJ1bmRsZSBtYXkgYmUgYSBHdWVzdE1vZHVsZSBjYWxsLCBzbyBzaWduYXR1cmUgYW5kIG5vbmNlIGFyZSBtaXNzaW5nXG4gIHNlcXVlbmNlVHhBYmlFbmNvZGUoYnVuZGxlLnRyYW5zYWN0aW9ucyksIDAsIG5ldyBVaW50OEFycmF5KFtdKV0pO1xufVxuXG4vLyBUT0RPOiBVc2UgU2VxdWVuY2UgQUJJIHBhY2thZ2VcbmNvbnN0IHNlbGZFeGVjdXRlU2VsZWN0b3IgPSAnMHg2MWMyOTI2Yyc7XG5jb25zdCBzZWxmRXhlY3V0ZUFiaSA9IGB0dXBsZShcbiAgYm9vbCBkZWxlZ2F0ZUNhbGwsXG4gIGJvb2wgcmV2ZXJ0T25FcnJvcixcbiAgdWludDI1NiBnYXNMaW1pdCxcbiAgYWRkcmVzcyB0YXJnZXQsXG4gIHVpbnQyNTYgdmFsdWUsXG4gIGJ5dGVzIGRhdGFcbilbXWA7XG5cbi8vIFNwbGl0cyBTZXF1ZW5jZSBiYXRjaCB0cmFuc2FjdGlvbnMgaW50byBpbmRpdmlkdWFsIHBhcnRzXG5jb25zdCB1bndpbmQgPSAod2FsbGV0LCB0cmFuc2FjdGlvbnMpID0+IHtcbiAgY29uc3QgdW53b3VuZCA9IFtdO1xuICBjb25zdCB3YWxsZXRJbnRlcmZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZSh3YWxsZXRDb250cmFjdHMubWFpbk1vZHVsZS5hYmkpO1xuICBmb3IgKGNvbnN0IHR4IG9mIHRyYW5zYWN0aW9ucykge1xuICAgIGNvbnN0IHR4RGF0YSA9IGV0aGVycy5nZXRCeXRlcyh0eC5kYXRhIHx8ICcweCcpO1xuICAgIGlmICh0eC50byA9PT0gd2FsbGV0ICYmIGV0aGVycy5oZXhsaWZ5KHR4RGF0YS5zbGljZSgwLCA0KSkgPT09IHNlbGZFeGVjdXRlU2VsZWN0b3IpIHtcbiAgICAgIC8vIERlY29kZSBhcyBzZWxmRXhlY3V0ZSBjYWxsXG4gICAgICBjb25zdCBkYXRhID0gdHhEYXRhLnNsaWNlKDQpO1xuICAgICAgY29uc3QgZGVjb2RlZCA9IGV0aGVycy5BYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKS5kZWNvZGUoW3NlbGZFeGVjdXRlQWJpXSwgZGF0YSlbMF07XG4gICAgICB1bndvdW5kLnB1c2goLi4udW53aW5kKHR4LnRvLCBkZWNvZGVkLm1hcChkID0+IF9leHRlbmRzKHt9LCBkLCB7XG4gICAgICAgIHRvOiBkLnRhcmdldFxuICAgICAgfSkpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGlubmVyVHJhbnNhY3Rpb25zID0gd2FsbGV0SW50ZXJmYWNlLmRlY29kZUZ1bmN0aW9uRGF0YSgnZXhlY3V0ZScsIHR4RGF0YSlbMF07XG4gICAgICAgIGNvbnN0IHVud291bmRUcmFuc2FjdGlvbnMgPSB1bndpbmQod2FsbGV0LCBpbm5lclRyYW5zYWN0aW9ucy5tYXAodHggPT4gX2V4dGVuZHMoe30sIHR4LnRvT2JqZWN0KCksIHtcbiAgICAgICAgICB0bzogdHgudGFyZ2V0XG4gICAgICAgIH0pKSk7XG4gICAgICAgIHVud291bmQucHVzaCguLi51bndvdW5kVHJhbnNhY3Rpb25zKTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgdW53b3VuZC5wdXNoKHR4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVud291bmQ7XG59O1xuY29uc3QgaXNOdWxsaXNoID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMDtcblxudmFyIHRyYW5zYWN0aW9uID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIE1ldGFUcmFuc2FjdGlvbnNUeXBlOiBNZXRhVHJhbnNhY3Rpb25zVHlwZSxcbiAgaW50ZW5kVHJhbnNhY3Rpb25CdW5kbGU6IGludGVuZFRyYW5zYWN0aW9uQnVuZGxlLFxuICBpbnRlbmRlZFRyYW5zYWN0aW9uSUQ6IGludGVuZGVkVHJhbnNhY3Rpb25JRCxcbiAgdW5wYWNrTWV0YVRyYW5zYWN0aW9uc0RhdGE6IHVucGFja01ldGFUcmFuc2FjdGlvbnNEYXRhLFxuICBwYWNrTWV0YVRyYW5zYWN0aW9uc0RhdGE6IHBhY2tNZXRhVHJhbnNhY3Rpb25zRGF0YSxcbiAgZGlnZXN0T2ZUcmFuc2FjdGlvbnM6IGRpZ2VzdE9mVHJhbnNhY3Rpb25zLFxuICBzdWJkaWdlc3RPZlRyYW5zYWN0aW9uczogc3ViZGlnZXN0T2ZUcmFuc2FjdGlvbnMsXG4gIHN1YmRpZ2VzdE9mR3Vlc3RNb2R1bGVUcmFuc2FjdGlvbnM6IHN1YmRpZ2VzdE9mR3Vlc3RNb2R1bGVUcmFuc2FjdGlvbnMsXG4gIHRvU2VxdWVuY2VUcmFuc2FjdGlvbnM6IHRvU2VxdWVuY2VUcmFuc2FjdGlvbnMsXG4gIHRvU2VxdWVuY2VUcmFuc2FjdGlvbjogdG9TZXF1ZW5jZVRyYW5zYWN0aW9uLFxuICBpc1NlcXVlbmNlVHJhbnNhY3Rpb246IGlzU2VxdWVuY2VUcmFuc2FjdGlvbixcbiAgaGFzU2VxdWVuY2VUcmFuc2FjdGlvbnM6IGhhc1NlcXVlbmNlVHJhbnNhY3Rpb25zLFxuICBzZXF1ZW5jZVR4QWJpRW5jb2RlOiBzZXF1ZW5jZVR4QWJpRW5jb2RlLFxuICBmcm9tVHhBYmlFbmNvZGU6IGZyb21UeEFiaUVuY29kZSxcbiAgZW5jb2RlTm9uY2U6IGVuY29kZU5vbmNlLFxuICBkZWNvZGVOb25jZTogZGVjb2RlTm9uY2UsXG4gIGZyb21UcmFuc2FjdGlvbmlzaDogZnJvbVRyYW5zYWN0aW9uaXNoLFxuICBpc1RyYW5zYWN0aW9uQnVuZGxlOiBpc1RyYW5zYWN0aW9uQnVuZGxlLFxuICBpc1NpZ25lZFRyYW5zYWN0aW9uQnVuZGxlOiBpc1NpZ25lZFRyYW5zYWN0aW9uQnVuZGxlLFxuICBlbmNvZGVCdW5kbGVFeGVjRGF0YTogZW5jb2RlQnVuZGxlRXhlY0RhdGEsXG4gIHNlbGZFeGVjdXRlU2VsZWN0b3I6IHNlbGZFeGVjdXRlU2VsZWN0b3IsXG4gIHNlbGZFeGVjdXRlQWJpOiBzZWxmRXhlY3V0ZUFiaSxcbiAgdW53aW5kOiB1bndpbmRcbn0pO1xuXG4vKiBTb3VyY2Ugb2YgT2ZmY2hhaW4gRUlQLTY0OTIgdmFsaWRhdGlvbjpcblxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbnByYWdtYSBzb2xpZGl0eSAwLjguMTg7XG5cblxuLy8gQXMgcGVyIEVSQy0xMjcxXG5pbnRlcmZhY2UgSUVSQzEyNzFXYWxsZXQge1xuICBmdW5jdGlvbiBpc1ZhbGlkU2lnbmF0dXJlKGJ5dGVzMzIgaGFzaCwgYnl0ZXMgY2FsbGRhdGEgc2lnbmF0dXJlKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGJ5dGVzNCBtYWdpY1ZhbHVlKTtcbn1cblxuZXJyb3IgRVJDMTI3MVJldmVydChieXRlcyBlcnJvcik7XG5lcnJvciBFUkM2NDkyRGVwbG95RmFpbGVkKGJ5dGVzIGVycm9yKTtcblxuY29udHJhY3QgVW5pdmVyc2FsU2lnVmFsaWRhdG9yIHtcbiAgYnl0ZXMzMiBwcml2YXRlIGNvbnN0YW50IEVSQzY0OTJfREVURUNUSU9OX1NVRkZJWCA9IDB4NjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjtcbiAgYnl0ZXM0IHByaXZhdGUgY29uc3RhbnQgRVJDMTI3MV9TVUNDRVNTID0gMHgxNjI2YmE3ZTtcblxuICBmdW5jdGlvbiBpc1ZhbGlkU2lnSW1wbChcbiAgICBhZGRyZXNzIF9zaWduZXIsXG4gICAgYnl0ZXMzMiBfaGFzaCxcbiAgICBieXRlcyBjYWxsZGF0YSBfc2lnbmF0dXJlLFxuICAgIGJvb2wgYWxsb3dTaWRlRWZmZWN0cyxcbiAgICBib29sIGRlcGxveUFscmVhZHlEZXBsb3llZFxuICApIHB1YmxpYyByZXR1cm5zIChib29sKSB7XG4gICAgdWludCBjb250cmFjdENvZGVMZW4gPSBhZGRyZXNzKF9zaWduZXIpLmNvZGUubGVuZ3RoO1xuICAgIGJ5dGVzIG1lbW9yeSBzaWdUb1ZhbGlkYXRlO1xuICAgIC8vIFRoZSBvcmRlciBoZXJlIGlzIHN0cmljbHR5IGRlZmluZWQgaW4gaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC02NDkyXG4gICAgLy8gLSBFUkMtNjQ5MiBzdWZmaXggY2hlY2sgYW5kIHZlcmlmaWNhdGlvbiBmaXJzdCwgd2hpbGUgYmVpbmcgcGVybWlzc2l2ZSBpbiBjYXNlIHRoZSBjb250cmFjdCBpcyBhbHJlYWR5IGRlcGxveWVkOyBpZiB0aGUgY29udHJhY3QgaXMgZGVwbG95ZWQgd2Ugd2lsbCBjaGVjayB0aGUgc2lnIGFnYWluc3QgdGhlIGRlcGxveWVkIHZlcnNpb24sIHRoaXMgYWxsb3dzIDY0OTIgc2lnbmF0dXJlcyB0byBzdGlsbCBiZSB2YWxpZGF0ZWQgd2hpbGUgdGFraW5nIGludG8gYWNjb3VudCBwb3RlbnRpYWwga2V5IHJvdGF0aW9uXG4gICAgLy8gLSBFUkMtMTI3MSB2ZXJpZmljYXRpb24gaWYgdGhlcmUncyBjb250cmFjdCBjb2RlXG4gICAgLy8gLSBmaW5hbGx5LCBlY3JlY292ZXJcbiAgICBib29sIGlzQ291bnRlcmZhY3R1YWwgPSBieXRlczMyKF9zaWduYXR1cmVbX3NpZ25hdHVyZS5sZW5ndGgtMzI6X3NpZ25hdHVyZS5sZW5ndGhdKSA9PSBFUkM2NDkyX0RFVEVDVElPTl9TVUZGSVg7XG4gICAgaWYgKGlzQ291bnRlcmZhY3R1YWwpIHtcbiAgICAgIGFkZHJlc3MgY3JlYXRlMkZhY3Rvcnk7XG4gICAgICBieXRlcyBtZW1vcnkgZmFjdG9yeUNhbGxkYXRhO1xuICAgICAgKGNyZWF0ZTJGYWN0b3J5LCBmYWN0b3J5Q2FsbGRhdGEsIHNpZ1RvVmFsaWRhdGUpID0gYWJpLmRlY29kZShfc2lnbmF0dXJlWzA6X3NpZ25hdHVyZS5sZW5ndGgtMzJdLCAoYWRkcmVzcywgYnl0ZXMsIGJ5dGVzKSk7XG5cbiAgICAgIGlmIChjb250cmFjdENvZGVMZW4gPT0gMCB8fCBkZXBsb3lBbHJlYWR5RGVwbG95ZWQpIHtcbiAgICAgICAgKGJvb2wgc3VjY2VzcywgYnl0ZXMgbWVtb3J5IGVycikgPSBjcmVhdGUyRmFjdG9yeS5jYWxsKGZhY3RvcnlDYWxsZGF0YSk7XG4gICAgICAgIGlmICghc3VjY2VzcykgcmV2ZXJ0IEVSQzY0OTJEZXBsb3lGYWlsZWQoZXJyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2lnVG9WYWxpZGF0ZSA9IF9zaWduYXR1cmU7XG4gICAgfVxuXG4gICAgLy8gVHJ5IEVSQy0xMjcxIHZlcmlmaWNhdGlvblxuICAgIGlmIChpc0NvdW50ZXJmYWN0dWFsIHx8IGNvbnRyYWN0Q29kZUxlbiA+IDApIHtcbiAgICAgIHRyeSBJRVJDMTI3MVdhbGxldChfc2lnbmVyKS5pc1ZhbGlkU2lnbmF0dXJlKF9oYXNoLCBzaWdUb1ZhbGlkYXRlKSByZXR1cm5zIChieXRlczQgbWFnaWNWYWx1ZSkge1xuICAgICAgICBib29sIGlzVmFsaWQgPSBtYWdpY1ZhbHVlID09IEVSQzEyNzFfU1VDQ0VTUztcblxuICAgICAgICAvLyBFWFBFUklNRU5UQUw6IFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIEVJUC02NDkyIHNwZWMgKnlldCpcbiAgICAgICAgLy8gYnV0IGl0IG1heSBiZSB1c2VmdWwgdG8gcmV0cnkgdGhlIGNhbGwgbWFraW5nIHRoZSBmYWN0b3J5IGNhbGxcbiAgICAgICAgLy8gZXZlbiBpZiB0aGUgd2FsbGV0IGlzIGFscmVhZHkgZGVwbG95ZWQsIGluIGNhc2UgdGhlIHdhbGxldFxuICAgICAgICAvLyBuZWVkcyB0byBwZXJmb3JtIHNvbWUgc29ydCBvZiBtaWdyYXRpb24gb3Igb25jaGFpbiBrZXkgcm90YXRpb25cbiAgICAgICAgaWYgKCFpc1ZhbGlkICYmICFkZXBsb3lBbHJlYWR5RGVwbG95ZWQgJiYgY29udHJhY3RDb2RlTGVuID4gMCkge1xuICAgICAgICAgIHJldHVybiBpc1ZhbGlkU2lnSW1wbChfc2lnbmVyLCBfaGFzaCwgX3NpZ25hdHVyZSwgYWxsb3dTaWRlRWZmZWN0cywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udHJhY3RDb2RlTGVuID09IDAgJiYgaXNDb3VudGVyZmFjdHVhbCAmJiAhYWxsb3dTaWRlRWZmZWN0cykge1xuICAgICAgICAgIC8vIGlmIHRoZSBjYWxsIGhhZCBzaWRlIGVmZmVjdHMgd2UgbmVlZCB0byByZXR1cm4gdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IHVzaW5nIGEgYHJldmVydGAgKHRvIHVuZG8gdGhlIHN0YXRlIGNoYW5nZXMpXG4gICAgICAgICAgYXNzZW1ibHkge1xuICAgICAgICAgICAgbXN0b3JlKDAsIGlzVmFsaWQpXG4gICAgICAgICAgICByZXZlcnQoMzEsIDEpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICB9IGNhdGNoIChieXRlcyBtZW1vcnkgZXJyKSB7XG4gICAgICAgIC8vIEVYUEVSSU1FTlRBTDogVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgRUlQLTY0OTIgc3BlYyAqeWV0KlxuICAgICAgICAvLyBidXQgaXQgbWF5IGJlIHVzZWZ1bCB0byByZXRyeSB0aGUgY2FsbCBtYWtpbmcgdGhlIGZhY3RvcnkgY2FsbFxuICAgICAgICAvLyBldmVuIGlmIHRoZSB3YWxsZXQgaXMgYWxyZWFkeSBkZXBsb3llZCwgaW4gY2FzZSB0aGUgd2FsbGV0XG4gICAgICAgIC8vIG5lZWRzIHRvIHBlcmZvcm0gc29tZSBzb3J0IG9mIG1pZ3JhdGlvbiBvciBvbmNoYWluIGtleSByb3RhdGlvblxuICAgICAgICBpZiAoIWRlcGxveUFscmVhZHlEZXBsb3llZCAmJiBjb250cmFjdENvZGVMZW4gPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGlzVmFsaWRTaWdJbXBsKF9zaWduZXIsIF9oYXNoLCBfc2lnbmF0dXJlLCBhbGxvd1NpZGVFZmZlY3RzLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldmVydCBFUkMxMjcxUmV2ZXJ0KGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZWNyZWNvdmVyIHZlcmlmaWNhdGlvblxuICAgIHJlcXVpcmUoX3NpZ25hdHVyZS5sZW5ndGggPT0gNjUsICdTaWduYXR1cmVWYWxpZGF0b3IjcmVjb3ZlclNpZ25lcjogaW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gICAgYnl0ZXMzMiByID0gYnl0ZXMzMihfc2lnbmF0dXJlWzA6MzJdKTtcbiAgICBieXRlczMyIHMgPSBieXRlczMyKF9zaWduYXR1cmVbMzI6NjRdKTtcbiAgICB1aW50OCB2ID0gdWludDgoX3NpZ25hdHVyZVs2NF0pO1xuXG4gICAgaWYgKHYgIT0gMjcgJiYgdiAhPSAyOCkge1xuICAgICAgcmV2ZXJ0KCdTaWduYXR1cmVWYWxpZGF0b3I6IGludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWNyZWNvdmVyKF9oYXNoLCB2LCByLCBzKSA9PSBfc2lnbmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNWYWxpZFNpZ1dpdGhTaWRlRWZmZWN0cyhcbiAgICBhZGRyZXNzIF9zaWduZXIsXG4gICAgYnl0ZXMzMiBfaGFzaCxcbiAgICBieXRlcyBjYWxsZGF0YSBfc2lnbmF0dXJlXG4gICkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRTaWdJbXBsKF9zaWduZXIsIF9oYXNoLCBfc2lnbmF0dXJlLCB0cnVlLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ZhbGlkU2lnKFxuICAgIGFkZHJlc3MgX3NpZ25lcixcbiAgICBieXRlczMyIF9oYXNoLFxuICAgIGJ5dGVzIGNhbGxkYXRhIF9zaWduYXR1cmVcbiAgKSBleHRlcm5hbCByZXR1cm5zIChib29sKSB7XG4gICAgdHJ5IHRoaXMuaXNWYWxpZFNpZ0ltcGwoX3NpZ25lciwgX2hhc2gsIF9zaWduYXR1cmUsIGZhbHNlLCBmYWxzZSkgcmV0dXJucyAoYm9vbCBpc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9IGNhdGNoIChieXRlcyBtZW1vcnkgZXJyb3IpIHtcbiAgICAgIC8vIGluIG9yZGVyIHRvIGF2b2lkIHNpZGUgZWZmZWN0cyBmcm9tIHRoZSBjb250cmFjdCBnZXR0aW5nIGRlcGxveWVkLCB0aGUgZW50aXJlIGNhbGwgd2lsbCByZXZlcnQgd2l0aCBhIHNpbmdsZSBieXRlIHJlc3VsdFxuICAgICAgdWludCBsZW4gPSBlcnJvci5sZW5ndGg7XG4gICAgICBpZiAobGVuID09IDEpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yWzBdID09IDB4MDE7XG4gICAgICAgIC8vIGFsbCBvdGhlciBlcnJvcnMgYXJlIHNpbXBseSBmb3J3YXJkZWQsIGJ1dCBpbiBjdXN0b20gZm9ybWF0cyBzbyB0aGF0IG5vdGhpbmcgZWxzZSBjYW4gcmV2ZXJ0IHdpdGggYSBzaW5nbGUgYnl0ZSBpbiB0aGUgY2FsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZW1ibHkgeyByZXZlcnQoZXJyb3IsIGxlbikgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5PVElDRTogVGhlc2UgZnVuY3Rpb25zIGFyZW4ndCBwYXJ0IG9mIHRoZSBzdGFuZGFyZFxuICAvLyB0aGV5IGFyZSBoZWxwZXJzIHRoYXQgYmVoYXZlIGxpa2UgdGhlIGFib3ZlIGZ1bmN0aW9uc1xuICAvLyBidXQgdGhleSBkb24ndCByZXZlcnQgb24gZmFpbHVyZSwgaW5zdGVhZCB0aGV5IHJldHVybiBmYWxzZVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWRTaWdOb1Rocm93KFxuICAgIGFkZHJlc3MgX3NpZ25lcixcbiAgICBieXRlczMyIF9oYXNoLFxuICAgIGJ5dGVzIGNhbGxkYXRhIF9zaWduYXR1cmVcbiAgKSBleHRlcm5hbCByZXR1cm5zIChib29sKSB7XG4gICAgdHJ5IHRoaXMuaXNWYWxpZFNpZ0ltcGwoX3NpZ25lciwgX2hhc2gsIF9zaWduYXR1cmUsIGZhbHNlLCBmYWxzZSkgcmV0dXJucyAoYm9vbCBpc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9IGNhdGNoIChieXRlcyBtZW1vcnkgZXJyb3IpIHtcbiAgICAgIC8vIGluIG9yZGVyIHRvIGF2b2lkIHNpZGUgZWZmZWN0cyBmcm9tIHRoZSBjb250cmFjdCBnZXR0aW5nIGRlcGxveWVkLCB0aGUgZW50aXJlIGNhbGwgd2lsbCByZXZlcnQgd2l0aCBhIHNpbmdsZSBieXRlIHJlc3VsdFxuICAgICAgdWludCBsZW4gPSBlcnJvci5sZW5ndGg7XG4gICAgICBpZiAobGVuID09IDEpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yWzBdID09IDB4MDE7XG4gICAgICAgIC8vIGFsbCBvdGhlciBlcnJvcnMgYXJlIHNpbXBseSBmb3J3YXJkZWQsIGJ1dCBpbiBjdXN0b20gZm9ybWF0cyBzbyB0aGF0IG5vdGhpbmcgZWxzZSBjYW4gcmV2ZXJ0IHdpdGggYSBzaW5nbGUgYnl0ZSBpbiB0aGUgY2FsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWdub3JlIGFsbCBvdGhlciBlcnJvcnMgYW5kIHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNWYWxpZFNpZ1dpdGhTaWRlRWZmZWN0c05vVGhyb3coXG4gICAgYWRkcmVzcyBfc2lnbmVyLFxuICAgIGJ5dGVzMzIgX2hhc2gsXG4gICAgYnl0ZXMgY2FsbGRhdGEgX3NpZ25hdHVyZVxuICApIGV4dGVybmFsIHJldHVybnMgKGJvb2wpIHtcbiAgICB0cnkgdGhpcy5pc1ZhbGlkU2lnSW1wbChfc2lnbmVyLCBfaGFzaCwgX3NpZ25hdHVyZSwgdHJ1ZSwgZmFsc2UpIHJldHVybnMgKGJvb2wgaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfSBjYXRjaCAoYnl0ZXMgbWVtb3J5IGVycm9yKSB7XG4gICAgICAvLyBJZ25vcmUgYWxsIGVycm9ycyBhbmQgcmV0dXJuIGZhbHNlXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbi8vIHRoaXMgaXMgYSBoZWxwZXIgc28gd2UgY2FuIHBlcmZvcm0gdmFsaWRhdGlvbiBpbiBhIHNpbmdsZSBldGhfY2FsbCB3aXRob3V0IHByZS1kZXBsb3lpbmcgYSBzaW5nbGV0b25cbmNvbnRyYWN0IFZhbGlkYXRlU2lnT2ZmY2hhaW4ge1xuICBjb25zdHJ1Y3RvciAoYWRkcmVzcyBfc2lnbmVyLCBieXRlczMyIF9oYXNoLCBieXRlcyBtZW1vcnkgX3NpZ25hdHVyZSkge1xuICAgIFVuaXZlcnNhbFNpZ1ZhbGlkYXRvciB2YWxpZGF0b3IgPSBuZXcgVW5pdmVyc2FsU2lnVmFsaWRhdG9yKCk7XG4gICAgYm9vbCBpc1ZhbGlkU2lnID0gdmFsaWRhdG9yLmlzVmFsaWRTaWdXaXRoU2lkZUVmZmVjdHMoX3NpZ25lciwgX2hhc2gsIF9zaWduYXR1cmUpO1xuICAgIGFzc2VtYmx5IHtcbiAgICAgIG1zdG9yZSgwLCBpc1ZhbGlkU2lnKVxuICAgICAgcmV0dXJuKDMxLCAxKVxuICAgIH1cbiAgfVxufVxuKi9cblxuY29uc3QgRUlQXzY0OTJfT0ZGQ0hBSU5fREVQTE9ZX0NPREUgPSAnMHg2MDgwNjA0MDUyMzQ4MDE1NjEwMDEwNTc2MDAwODBmZDViNTA2MDQwNTE2MTEyNGEzODAzODA2MTEyNGE4MzM5ODEwMTYwNDA4MTkwNTI2MTAwMmY5MTYxMDEyNDU2NWI2MDAwNjA0MDUxNjEwMDNkOTA2MTAwZGQ1NjViNjA0MDUxODA5MTAzOTA2MDAwZjA4MDE1ODAxNTYxMDA1OTU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDkwNTA2MDAwODE2MDAxNjAwMTYwYTAxYjAzMTY2MzhmMDY4NDMwODY4Njg2NjA0MDUxODQ2M2ZmZmZmZmZmMTY2MGUwMWI4MTUyNjAwNDAxNjEwMDhlOTM5MjkxOTA2MTAxZmI1NjViNjAyMDYwNDA1MTgwODMwMzgxNjAwMDg3NWFmMTE1ODAxNTYxMDBhZDU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA1MDYwNDA1MTNkNjAxZjE5NjAxZjgyMDExNjgyMDE4MDYwNDA1MjUwODEwMTkwNjEwMGQxOTE5MDYxMDI0NDU2NWI5MDUwODA2MDAwNTI2MDAxNjAxZmYzNWI2MTBmZGM4MDYxMDI2ZTgzMzkwMTkwNTY1YjYzNGU0ODdiNzE2MGUwMWI2MDAwNTI2MDQxNjAwNDUyNjAyNDYwMDBmZDViNjAwMDViODM4MTEwMTU2MTAxMWI1NzgxODEwMTUxODM4MjAxNTI2MDIwMDE2MTAxMDM1NjViNTA1MDYwMDA5MTAxNTI1NjViNjAwMDgwNjAwMDYwNjA4NDg2MDMxMjE1NjEwMTM5NTc2MDAwODBmZDViODM1MTYwMDE2MDAxNjBhMDFiMDM4MTE2ODExNDYxMDE1MDU3NjAwMDgwZmQ1YjYwMjA4NTAxNTE2MDQwODYwMTUxOTE5NDUwOTI1MDYwMDE2MDAxNjA0MDFiMDM4MDgyMTExNTYxMDE3NDU3NjAwMDgwZmQ1YjgxODYwMTkxNTA4NjYwMWY4MzAxMTI2MTAxODg1NzYwMDA4MGZkNWI4MTUxODE4MTExMTU2MTAxOWE1NzYxMDE5YTYxMDBlYTU2NWI2MDQwNTE2MDFmODIwMTYwMWYxOTkwODExNjYwM2YwMTE2ODEwMTkwODM4MjExODE4MzEwMTcxNTYxMDFjMjU3NjEwMWMyNjEwMGVhNTY1YjgxNjA0MDUyODI4MTUyODk2MDIwODQ4NzAxMDExMTE1NjEwMWRiNTc2MDAwODBmZDViNjEwMWVjODM2MDIwODMwMTYwMjA4ODAxNjEwMTAwNTY1YjgwOTU1MDUwNTA1MDUwNTA5MjUwOTI1MDkyNTY1YjYwMDE4MDYwYTAxYjAzODQxNjgxNTI4MjYwMjA4MjAxNTI2MDYwNjA0MDgyMDE1MjYwMDA4MjUxODA2MDYwODQwMTUyNjEwMjJlODE2MDgwODUwMTYwMjA4NzAxNjEwMTAwNTY1YjYwMWYwMTYwMWYxOTE2OTE5MDkxMDE2MDgwMDE5NDkzNTA1MDUwNTA1NjViNjAwMDYwMjA4Mjg0MDMxMjE1NjEwMjU2NTc2MDAwODBmZDViODE1MTgwMTUxNTgxMTQ2MTAyNjY1NzYwMDA4MGZkNWI5MzkyNTA1MDUwNTZmZTYwODA2MDQwNTIzNDgwMTU2MTAwMTA1NzYwMDA4MGZkNWI1MDYxMGZiYzgwNjEwMDIwNjAwMDM5NjAwMGYzZmU2MDgwNjA0MDUyMzQ4MDE1NjEwMDEwNTc2MDAwODBmZDViNTA2MDA0MzYxMDYxMDA2NzU3NjAwMDM1NjBlMDFjODA2Mzc2YmU0Y2VhMTE2MTAwNTA1NzgwNjM3NmJlNGNlYTE0NjEwMGE2NTc4MDYzOGYwNjg0MzAxNDYxMDBiOTU3ODA2Mzk4ZWYxZWQ4MTQ2MTAwY2M1NzYwMDA4MGZkNWI4MDYzMWM2NDUzMjcxNDYxMDA2YzU3ODA2MzNkNzg3YjYzMTQ2MTAwOTM1NzViNjAwMDgwZmQ1YjYxMDA3ZjYxMDA3YTM2NjAwNDYxMGFkNDU2NWI2MTAwZGY1NjViNjA0MDUxOTAxNTE1ODE1MjYwMjAwMTYwNDA1MTgwOTEwMzkwZjM1YjYxMDA3ZjYxMDBhMTM2NjAwNDYxMGFkNDU2NWI2MTAyM2Q1NjViNjEwMDdmNjEwMGI0MzY2MDA0NjEwYjNlNTY1YjYxMDMxZTU2NWI2MTAwN2Y2MTAwYzczNjYwMDQ2MTBhZDQ1NjViNjEwOGUxNTY1YjYxMDA3ZjYxMDBkYTM2NjAwNDYxMGFkNDU2NWI2MTA5NmU1NjViNjA0MDUxN2Y3NmJlNGNlYTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODE1MjYwMDA5MDMwOTA2Mzc2YmU0Y2VhOTA2MTAxMjg5MDg4OTA4ODkwODg5MDg4OTA4ODkwODE5MDYwMDQwMTYxMGJjMzU2NWI2MDIwNjA0MDUxODA4MzAzODE2MDAwODc1YWYxOTI1MDUwNTA4MDE1NjEwMTgxNTc1MDYwNDA4MDUxNjAxZjNkOTA4MTAxN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmUwMTY4MjAxOTA5MjUyNjEwMTdlOTE4MTAxOTA2MTBjNDU1NjViNjAwMTViNjEwMjMyNTczZDgwODAxNTYxMDFhZjU3NjA0MDUxOTE1MDYwMWYxOTYwM2YzZDAxMTY4MjAxNjA0MDUyM2Q4MjUyM2Q2MDAwNjAyMDg0MDEzZTYxMDFiNDU2NWI2MDYwOTE1MDViNTA4MDUxNjAwMTgxOTAwMzYxMDIyNzU3ODE2MDAwODE1MTgxMTA2MTAxZDM1NzYxMDFkMzYxMGM2OTU2NWI2MDIwOTEwMTAxNTE3ZmZmMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxNjdmMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE0OTI1MDYxMDIzNTkxNTA1MDU2NWI2MDAwOTI1MDUwNTA2MTAyMzU1NjViOTA1MDViOTQ5MzUwNTA1MDUwNTY1YjYwNDA1MTdmNzZiZTRjZWEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgxNTI2MDAwOTAzMDkwNjM3NmJlNGNlYTkwNjEwMjg3OTA4ODkwODg5MDg4OTA4ODkwNjAwMTkwODk5MDYwMDQwMTYxMGJjMzU2NWI2MDIwNjA0MDUxODA4MzAzODE2MDAwODc1YWYxOTI1MDUwNTA4MDE1NjEwMmUwNTc1MDYwNDA4MDUxNjAxZjNkOTA4MTAxN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmUwMTY4MjAxOTA5MjUyNjEwMmRkOTE4MTAxOTA2MTBjNDU1NjViNjAwMTViNjEwMjMyNTczZDgwODAxNTYxMDMwZTU3NjA0MDUxOTE1MDYwMWYxOTYwM2YzZDAxMTY4MjAxNjA0MDUyM2Q4MjUyM2Q2MDAwNjAyMDg0MDEzZTYxMDMxMzU2NWI2MDYwOTE1MDViNTA2MDAwOTE1MDUwNjEwMjM1NTY1YjYwMDA3M2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY4NzE2M2I2MDYwODI3ZjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI4ODg4NjEwMzY5NjAyMDgyNjEwYzk4NTY1YjYxMDM3NTkyOGI5MjkwNjEwY2Q4NTY1YjYxMDM3ZTkxNjEwZDAyNTY1YjE0OTA1MDgwMTU2MTA0ODQ1NzYwMDA2MDYwODk4MjhhNjEwMzk5NjAyMDgyNjEwYzk4NTY1YjkyNjEwM2E2OTM5MjkxOTA2MTBjZDg1NjViODEwMTkwNjEwM2IzOTE5MDYxMGUxODU2NWI5NTUwOTA5MjUwOTA1MDg0MTU4MDYxMDNjNDU3NTA4NjViMTU2MTA0N2Q1NzYwMDA4MDgzNzNmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmMTY4MzYwNDA1MTYxMDNmMTkxOTA2MTBlYjI1NjViNjAwMDYwNDA1MTgwODMwMzgxNjAwMDg2NWFmMTkxNTA1MDNkODA2MDAwODExNDYxMDQyZTU3NjA0MDUxOTE1MDYwMWYxOTYwM2YzZDAxMTY4MjAxNjA0MDUyM2Q4MjUyM2Q2MDAwNjAyMDg0MDEzZTYxMDQzMzU2NWI2MDYwOTE1MDViNTA5MTUwOTE1MDgxNjEwNDdhNTc4MDYwNDA1MTdmOWQwZDZlMmQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgxNTI2MDA0MDE2MTA0NzE5MTkwNjEwZjE4NTY1YjYwNDA1MTgwOTEwMzkwZmQ1YjUwNTA1YjUwNTA2MTA0YmU1NjViODc4NzgwODA2MDFmMDE2MDIwODA5MTA0MDI2MDIwMDE2MDQwNTE5MDgxMDE2MDQwNTI4MDkzOTI5MTkwODE4MTUyNjAyMDAxODM4MzgwODI4NDM3NjAwMDkyMDE5MTkwOTE1MjUwOTI5NDUwNTA1MDUwNWI4MDgwNjEwNGNhNTc1MDYwMDA4MzExNWIxNTYxMDZiYjU3NjA0MDUxN2YxNjI2YmE3ZTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODE1MjczZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjhiMTY5MDYzMTYyNmJhN2U5MDYxMDUyMzkwOGM5MDg2OTA2MDA0MDE2MTBmMmI1NjViNjAyMDYwNDA1MTgwODMwMzgxODY1YWZhOTI1MDUwNTA4MDE1NjEwNTdhNTc1MDYwNDA4MDUxNjAxZjNkOTA4MTAxN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmUwMTY4MjAxOTA5MjUyNjEwNTc3OTE4MTAxOTA2MTBmNDQ1NjViNjAwMTViNjEwNjBmNTczZDgwODAxNTYxMDVhODU3NjA0MDUxOTE1MDYwMWYxOTYwM2YzZDAxMTY4MjAxNjA0MDUyM2Q4MjUyM2Q2MDAwNjAyMDg0MDEzZTYxMDVhZDU2NWI2MDYwOTE1MDViNTA4NTE1ODAxNTYxMDViYzU3NTA2MDAwODQxMTViMTU2MTA1ZGI1NzYxMDVkMDhiOGI4YjhiOGI2MDAxNjEwMzFlNTY1Yjk0NTA1MDUwNTA1MDYxMDhkNzU2NWI4MDYwNDA1MTdmNmYyYTk1OTkwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgxNTI2MDA0MDE2MTA0NzE5MTkwNjEwZjE4NTY1YjdmZmZmZmZmZmYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgxMTY3ZjE2MjZiYTdlMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxNDgwMTU4MTYxMDY1ZjU3NTA4NjE1NWI4MDE1NjEwNjZiNTc1MDYwMDA4NTExNWIxNTYxMDY4YjU3NjEwNjdmOGM4YzhjOGM4YzYwMDE2MTAzMWU1NjViOTU1MDUwNTA1MDUwNTA2MTA4ZDc1NjViODQxNTgwMTU2MTA2OTY1NzUwODI1YjgwMTU2MTA2YTA1NzUwODcxNTViMTU2MTA2YWY1NzgwNjAwMDUyNjAwMTYwMWZmZDViOTQ1MDYxMDhkNzkzNTA1MDUwNTA1NjViNjA0MTg3MTQ2MTA3NGI1NzYwNDA1MTdmMDhjMzc5YTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgxNTI2MDIwNjAwNDgyMDE1MjYwM2E2MDI0ODIwMTUyN2Y1MzY5Njc2ZTYxNzQ3NTcyNjU1NjYxNmM2OTY0NjE3NDZmNzIyMzcyNjU2MzZmNzY2NTcyNTM2OTY3NmU2NTcyNjA0NDgyMDE1MjdmM2EyMDY5NmU3NjYxNmM2OTY0MjA3MzY5Njc2ZTYxNzQ3NTcyNjUyMDZjNjU2ZTY3NzQ2ODAwMDAwMDAwMDAwMDYwNjQ4MjAxNTI2MDg0MDE2MTA0NzE1NjViNjAwMDYxMDc1YTYwMjA4MjhhOGM2MTBjZDg1NjViNjEwNzYzOTE2MTBkMDI1NjViOTA1MDYwMDA2MTA3NzU2MDQwNjAyMDhiOGQ2MTBjZDg1NjViNjEwNzdlOTE2MTBkMDI1NjViOTA1MDYwMDA4YThhNjA0MDgxODExMDYxMDc5NTU3NjEwNzk1NjEwYzY5NTY1YjkxOTA5MTAxMzU2MGY4MWM5MTUwNTA2MDFiODExNDgwMTU5MDYxMDdiNTU3NTA4MDYwZmYxNjYwMWMxNDE1NWIxNTYxMDg0MjU3NjA0MDUxN2YwOGMzNzlhMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODE1MjYwMjA2MDA0ODIwMTUyNjAyZDYwMjQ4MjAxNTI3ZjUzNjk2NzZlNjE3NDc1NzI2NTU2NjE2YzY5NjQ2MTc0NmY3MjNhMjA2OTZlNzY2MTZjNjk2NDIwNzM2OTY3NmU2MDQ0ODIwMTUyN2Y2MTc0NzU3MjY1MjA3NjIwNzY2MTZjNzU2NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjA2NDgyMDE1MjYwODQwMTYxMDQ3MTU2NWI2MDQwODA1MTYwMDA4MTUyNjAyMDgxMDE4MDgzNTI4ZTkwNTI2MGZmODMxNjkxODEwMTkxOTA5MTUyNjA2MDgxMDE4NDkwNTI2MDgwODEwMTgzOTA1MjczZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjhlMTY5MDYwMDE5MDYwYTAwMTYwMjA2MDQwNTE2MDIwODEwMzkwODA4NDAzOTA4NTVhZmExNTgwMTU2MTA4YWQ1NzNkNjAwMDgwM2UzZDYwMDBmZDViNTA1MDUwNjAyMDYwNDA1MTAzNTE3M2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYxNjE0OTY1MDUwNTA1MDUwNTA1MDViOTY5NTUwNTA1MDUwNTA1MDU2NWI2MDQwNTE3Zjc2YmU0Y2VhMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MTUyNjAwMDkwMzA5MDYzNzZiZTRjZWE5MDYxMDkyYjkwODg5MDg4OTA4ODkwODg5MDYwMDE5MDg5OTA2MDA0MDE2MTBiYzM1NjViNjAyMDYwNDA1MTgwODMwMzgxNjAwMDg3NWFmMTE1ODAxNTYxMDk0YTU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA1MDYwNDA1MTNkNjAxZjE5NjAxZjgyMDExNjgyMDE4MDYwNDA1MjUwODEwMTkwNjEwMjMyOTE5MDYxMGM0NTU2NWI2MDQwNTE3Zjc2YmU0Y2VhMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MTUyNjAwMDkwMzA5MDYzNzZiZTRjZWE5MDYxMDliNzkwODg5MDg4OTA4ODkwODg5MDg4OTA4MTkwNjAwNDAxNjEwYmMzNTY1YjYwMjA2MDQwNTE4MDgzMDM4MTYwMDA4NzVhZjE5MjUwNTA1MDgwMTU2MTBhMTA1NzUwNjA0MDgwNTE2MDFmM2Q5MDgxMDE3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZTAxNjgyMDE5MDkyNTI2MTBhMGQ5MTgxMDE5MDYxMGM0NTU2NWI2MDAxNWI2MTAyMzI1NzNkODA4MDE1NjEwYTNlNTc2MDQwNTE5MTUwNjAxZjE5NjAzZjNkMDExNjgyMDE2MDQwNTIzZDgyNTIzZDYwMDA2MDIwODQwMTNlNjEwYTQzNTY1YjYwNjA5MTUwNWI1MDgwNTE2MDAxODE5MDAzNjEwYTYyNTc4MTYwMDA4MTUxODExMDYxMDFkMzU3NjEwMWQzNjEwYzY5NTY1YjgwODJmZDViNzNmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmODExNjgxMTQ2MTBhODg1NzYwMDA4MGZkNWI1MDU2NWI2MDAwODA4MzYwMWY4NDAxMTI2MTBhOWQ1NzYwMDA4MGZkNWI1MDgxMzU2N2ZmZmZmZmZmZmZmZmZmZmY4MTExMTU2MTBhYjU1NzYwMDA4MGZkNWI2MDIwODMwMTkxNTA4MzYwMjA4Mjg1MDEwMTExMTU2MTBhY2Q1NzYwMDA4MGZkNWI5MjUwOTI5MDUwNTY1YjYwMDA4MDYwMDA4MDYwNjA4NTg3MDMxMjE1NjEwYWVhNTc2MDAwODBmZDViODQzNTYxMGFmNTgxNjEwYTY2NTY1YjkzNTA2MDIwODUwMTM1OTI1MDYwNDA4NTAxMzU2N2ZmZmZmZmZmZmZmZmZmZmY4MTExMTU2MTBiMTg1NzYwMDA4MGZkNWI2MTBiMjQ4NzgyODgwMTYxMGE4YjU2NWI5NTk4OTQ5NzUwOTU1MDUwNTA1MDU2NWI4MDE1MTU4MTE0NjEwYTg4NTc2MDAwODBmZDViNjAwMDgwNjAwMDgwNjAwMDgwNjBhMDg3ODkwMzEyMTU2MTBiNTc1NzYwMDA4MGZkNWI4NjM1NjEwYjYyODE2MTBhNjY1NjViOTU1MDYwMjA4NzAxMzU5NDUwNjA0MDg3MDEzNTY3ZmZmZmZmZmZmZmZmZmZmZjgxMTExNTYxMGI4NTU3NjAwMDgwZmQ1YjYxMGI5MTg5ODI4YTAxNjEwYThiNTY1YjkwOTU1MDkzNTA1MDYwNjA4NzAxMzU2MTBiYTU4MTYxMGIzMDU2NWI5MTUwNjA4MDg3MDEzNTYxMGJiNTgxNjEwYjMwNTY1YjgwOTE1MDUwOTI5NTUwOTI5NTUwOTI5NTU2NWI3M2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY4NzE2ODE1Mjg1NjAyMDgyMDE1MjYwYTA2MDQwODIwMTUyODM2MGEwODIwMTUyODM4NTYwYzA4MzAxMzc2MDAwNjBjMDg1ODMwMTgxMDE5MTkwOTE1MjkyMTUxNTYwNjA4MjAxNTI5MDE1MTU2MDgwODIwMTUyNjAxZjkwOTIwMTdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlMDE2OTA5MTAxMDE5MzkyNTA1MDUwNTY1YjYwMDA2MDIwODI4NDAzMTIxNTYxMGM1NzU3NjAwMDgwZmQ1YjgxNTE2MTBjNjI4MTYxMGIzMDU2NWI5MzkyNTA1MDUwNTY1YjdmNGU0ODdiNzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDA1MjYwMzI2MDA0NTI2MDI0NjAwMGZkNWI4MTgxMDM4MTgxMTExNTYxMGNkMjU3N2Y0ZTQ4N2I3MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwMDUyNjAxMTYwMDQ1MjYwMjQ2MDAwZmQ1YjkyOTE1MDUwNTY1YjYwMDA4MDg1ODUxMTE1NjEwY2U4NTc2MDAwODBmZDViODM4NjExMTU2MTBjZjU1NzYwMDA4MGZkNWI1MDUwODIwMTkzOTE5MDkyMDM5MTUwNTY1YjgwMzU2MDIwODMxMDE1NjEwY2QyNTc3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY2MDIwODQ5MDAzNjAwMzFiMWIxNjkyOTE1MDUwNTY1YjdmNGU0ODdiNzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDA1MjYwNDE2MDA0NTI2MDI0NjAwMGZkNWI2MDAwODI2MDFmODMwMTEyNjEwZDdlNTc2MDAwODBmZDViODEzNTY3ZmZmZmZmZmZmZmZmZmZmZjgwODIxMTE1NjEwZDk5NTc2MTBkOTk2MTBkM2U1NjViNjA0MDUxNjAxZjgzMDE3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZTA5MDgxMTY2MDNmMDExNjgxMDE5MDgyODIxMTgxODMxMDE3MTU2MTBkZGY1NzYxMGRkZjYxMGQzZTU2NWI4MTYwNDA1MjgzODE1Mjg2NjAyMDg1ODgwMTAxMTExNTYxMGRmODU3NjAwMDgwZmQ1YjgzNjAyMDg3MDE2MDIwODMwMTM3NjAwMDYwMjA4NTgzMDEwMTUyODA5NDUwNTA1MDUwNTA5MjkxNTA1MDU2NWI2MDAwODA2MDAwNjA2MDg0ODYwMzEyMTU2MTBlMmQ1NzYwMDA4MGZkNWI4MzM1NjEwZTM4ODE2MTBhNjY1NjViOTI1MDYwMjA4NDAxMzU2N2ZmZmZmZmZmZmZmZmZmZmY4MDgyMTExNTYxMGU1NTU3NjAwMDgwZmQ1YjYxMGU2MTg3ODM4ODAxNjEwZDZkNTY1YjkzNTA2MDQwODYwMTM1OTE1MDgwODIxMTE1NjEwZTc3NTc2MDAwODBmZDViNTA2MTBlODQ4NjgyODcwMTYxMGQ2ZDU2NWI5MTUwNTA5MjUwOTI1MDkyNTY1YjYwMDA1YjgzODExMDE1NjEwZWE5NTc4MTgxMDE1MTgzODIwMTUyNjAyMDAxNjEwZTkxNTY1YjUwNTA2MDAwOTEwMTUyNTY1YjYwMDA4MjUxNjEwZWM0ODE4NDYwMjA4NzAxNjEwZThlNTY1YjkxOTA5MTAxOTI5MTUwNTA1NjViNjAwMDgxNTE4MDg0NTI2MTBlZTY4MTYwMjA4NjAxNjAyMDg2MDE2MTBlOGU1NjViNjAxZjAxN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmUwMTY5MjkwOTIwMTYwMjAwMTkyOTE1MDUwNTY1YjYwMjA4MTUyNjAwMDYxMGM2MjYwMjA4MzAxODQ2MTBlY2U1NjViODI4MTUyNjA0MDYwMjA4MjAxNTI2MDAwNjEwMjM1NjA0MDgzMDE4NDYxMGVjZTU2NWI2MDAwNjAyMDgyODQwMzEyMTU2MTBmNTY1NzYwMDA4MGZkNWI4MTUxN2ZmZmZmZmZmZjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODExNjgxMTQ2MTBjNjI1NzYwMDA4MGZkZmVhMjY0Njk3MDY2NzM1ODIyMTIyMDFhNzJhZWQ0YjE1ZmZiMDViNjUwMjk5N2E5YmI2NTU5OTJlMDY1OTBiZDI2YjMzNmRmYmIxNTNkN2ZmNmYzNGI2NDczNmY2YzYzNDMwMDA4MTIwMDMzJztcbmNvbnN0IEVJUF82NDkyX1NVRkZJWCA9ICcweDY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTInO1xuXG4vLyBUT0RPOiBUaGlzIGlzIGEgbGVuZ3RoIHBheWxvYWQsIHdlIGNhbiBsb3dlciB0aGUgbG9hZCBieSBkZXBsb3lpbmdcbi8vIHRoZSBjb250cmFjdCBvbiBzb21lIG9mIHRoZSBwb3B1bGFyIGNoYWlucywgYW5kIGNhbGxpbmcgdGhlIGNvbnRyYWN0XG4vLyBpZiB0aGUgcHJvdmlkZXIgaXMgb25lIG9mIHRob3NlIGNoYWluc1xuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVFSVA2NDkyT2ZmY2hhaW4ocHJvdmlkZXIsIHNpZ25lciwgaGFzaCwgc2lnbmF0dXJlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuY2FsbCh7XG4gICAgICBkYXRhOiBldGhlcnMuY29uY2F0KFtFSVBfNjQ5Ml9PRkZDSEFJTl9ERVBMT1lfQ09ERSwgZXRoZXJzLkFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpLmVuY29kZShbJ2FkZHJlc3MnLCAnYnl0ZXMzMicsICdieXRlcyddLCBbc2lnbmVyLCBoYXNoLCBzaWduYXR1cmVdKV0pXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gJzB4MDEnO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxudmFyIHZhbGlkYXRlRUlQNjQ5MiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBFSVBfNjQ5Ml9PRkZDSEFJTl9ERVBMT1lfQ09ERTogRUlQXzY0OTJfT0ZGQ0hBSU5fREVQTE9ZX0NPREUsXG4gIEVJUF82NDkyX1NVRkZJWDogRUlQXzY0OTJfU1VGRklYLFxuICB2YWxpZGF0ZUVJUDY0OTJPZmZjaGFpbjogdmFsaWRhdGVFSVA2NDkyT2ZmY2hhaW5cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVzIHN0YXRlZnVsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB3YWxsZXQuXG4gKi9cblxuLyoqXG4gKiBUaGUgT25DaGFpblJlYWRlciBjbGFzcyBmZXRjaGVzIG9uLWNoYWluIGRhdGEgZnJvbSBhIHdhbGxldC5cbiAqIEl0IGlzIHVzZWQgdG8gdW5kZXJzdGFuZCB0aGUgXCJyZWFsXCIgc3RhdGUgb2YgdGhlIHdhbGxldCBjb250cmFjdCBvbi1jaGFpbi5cbiAqL1xuY2xhc3MgT25DaGFpblJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIC8vIFNpbXBsZSBjYWNoZSB0byBhdm9pZCByZS1mZXRjaGluZyB0aGUgc2FtZSBkYXRhXG4gICAgdGhpcy5pc0RlcGxveWVkQ2FjaGUgPSBuZXcgU2V0KCk7XG4gIH1cbiAgbW9kdWxlKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gbmV3IGV0aGVycy5Db250cmFjdChhZGRyZXNzLCBbLi4ud2FsbGV0Q29udHJhY3RzLm1haW5Nb2R1bGVVcGdyYWRhYmxlLmFiaSwgLi4ud2FsbGV0Q29udHJhY3RzLm1haW5Nb2R1bGUuYWJpLCAuLi53YWxsZXRDb250cmFjdHMuZXJjMTI3MS5hYmldLCB0aGlzLnByb3ZpZGVyKTtcbiAgfVxuICBhc3luYyBpc0RlcGxveWVkKHdhbGxldCkge1xuICAgIC8vIFRoaXMgaXMgc2FmZSB0byBjYWNoZSBiZWNhdXNlIHRoZSB3YWxsZXQgY2Fubm90IGJlIHVuZGVwbG95ZWQgb25jZSBkZXBsb3llZFxuICAgIGlmICh0aGlzLmlzRGVwbG95ZWRDYWNoZS5oYXMod2FsbGV0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldENvZGUod2FsbGV0KS50aGVuKGMgPT4gZXRoZXJzLmdldEJ5dGVzKGMpKTtcbiAgICBjb25zdCBpc0RlcGxveWVkID0gY29kZS5sZW5ndGggIT09IDA7XG4gICAgaWYgKGlzRGVwbG95ZWQpIHtcbiAgICAgIHRoaXMuaXNEZXBsb3llZENhY2hlLmFkZCh3YWxsZXQpO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZXBsb3llZDtcbiAgfVxuICBhc3luYyBpbXBsZW1lbnRhdGlvbih3YWxsZXQpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGV0aGVycy5BYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKS5lbmNvZGUoWydhZGRyZXNzJ10sIFt3YWxsZXRdKTtcbiAgICBjb25zdCB2YWwgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFN0b3JhZ2Uod2FsbGV0LCBwb3NpdGlvbikudGhlbihjID0+IGV0aGVycy5nZXRCeXRlcyhjKSk7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDIwKSB7XG4gICAgICByZXR1cm4gZXRoZXJzLmdldEFkZHJlc3MoZXRoZXJzLmhleGxpZnkodmFsKSk7XG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAzMikge1xuICAgICAgcmV0dXJuIGV0aGVycy5BYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKS5kZWNvZGUoWydhZGRyZXNzJ10sIHZhbClbMF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgYXN5bmMgaW1hZ2VIYXNoKHdhbGxldCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpbWFnZUhhc2ggPSBhd2FpdCB0aGlzLm1vZHVsZSh3YWxsZXQpLmltYWdlSGFzaCgpO1xuICAgICAgcmV0dXJuIGltYWdlSGFzaDtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgYXN5bmMgbm9uY2Uod2FsbGV0LCBzcGFjZSA9IDApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCB0aGlzLm1vZHVsZSh3YWxsZXQpLnJlYWROb25jZShzcGFjZSk7XG4gICAgICByZXR1cm4gbm9uY2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoYXdhaXQgdGhpcy5pc0RlcGxveWVkKHdhbGxldCkpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICAvLyBXZSB1c2UgdGhlIEVJUC02NDkyIHZhbGlkYXRvciBjb250cmFjdCB0byBjaGVjayB0aGUgc2lnbmF0dXJlXG4gIC8vIHRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgd2FsbGV0IGlzIG5vdCBkZXBsb3llZCwgdGhlbiB0aGUgc2lnbmF0dXJlXG4gIC8vIG11c3QgYmUgcHJlZml4ZWQgd2l0aCBhIHRyYW5zYWN0aW9uIHRoYXQgZGVwbG95cyB0aGUgd2FsbGV0XG4gIGFzeW5jIGlzVmFsaWRTaWduYXR1cmUod2FsbGV0LCBkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiB2YWxpZGF0ZUVJUDY0OTJPZmZjaGFpbih0aGlzLnByb3ZpZGVyLCB3YWxsZXQsIGRpZ2VzdCwgc2lnbmF0dXJlKTtcbiAgfVxufVxuXG52YXIgcmVhZGVyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIE9uQ2hhaW5SZWFkZXI6IE9uQ2hhaW5SZWFkZXJcbn0pO1xuXG4vKipcbiAqIFJlcXVlc3QgbWV0YWRhdGEsIHVzZWQgYnkgdGhlIHdhbGxldCB0byBwYXNzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdGhyb3VnaCB0aGUgb3JjaGVzdHJhdG9yLlxuICovXG5cbmZ1bmN0aW9uIGlzV2FsbGV0U2lnblJlcXVlc3RNZXRhZGF0YShvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouYWRkcmVzcyAmJiBvYmouZGlnZXN0ICYmIG9iai5jaGFpbklkICE9PSB1bmRlZmluZWQgJiYgb2JqLmNvbmZpZztcbn1cblxuLyoqXG4gKiBSZXF1ZXN0IG1ldGFkYXRhLCB1c2VkIGJ5IHRoZSB3YWxsZXQgdG8gcGFzcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRocm91Z2ggdGhlIG9yY2hlc3RyYXRvci5cbiAqL1xuXG52YXIgaW5kZXgkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjb25maWc6IGNvbmZpZyxcbiAgc2lnbmF0dXJlOiBzaWduYXR1cmUkMixcbiAgY29udGV4dDogY29udGV4dCxcbiAgc2lnbmVyOiBzaWduZXIsXG4gIEVJUDEyNzE6IHZhbGlkYXRlRUlQMTI3MSxcbiAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLFxuICByZWFkZXI6IHJlYWRlcixcbiAgRUlQNjQ5MjogdmFsaWRhdGVFSVA2NDkyLFxuICBpc1dhbGxldFNpZ25SZXF1ZXN0TWV0YWRhdGE6IGlzV2FsbGV0U2lnblJlcXVlc3RNZXRhZGF0YVxufSk7XG5cbmNvbnN0IEFMTF9DT0RFUlMgPSBbe1xuICBjb25maWc6IENvbmZpZ0NvZGVyJDEsXG4gIHNpZ25hdHVyZTogU2lnbmF0dXJlQ29kZXIkMVxufSwge1xuICBjb25maWc6IENvbmZpZ0NvZGVyLFxuICBzaWduYXR1cmU6IFNpZ25hdHVyZUNvZGVyXG59XTtcbmZ1bmN0aW9uIGNvZGVyRm9yKHZlcnNpb24pIHtcbiAgY29uc3QgaW5kZXggPSB2ZXJzaW9uIC0gMTtcbiAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBBTExfQ09ERVJTLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29kZXIgZm9yIHZlcnNpb246ICR7dmVyc2lvbn1gKTtcbiAgfVxuICByZXR1cm4gQUxMX0NPREVSU1tpbmRleF07XG59XG5cbi8qKlxuICogIFNhbWUgYXMgYGNvZGVyRm9yYCBidXQgcmV0dXJucyBgZ2VuZXJpY2AgY29kZXJzIHdpdGhvdXQgdmVyc2lvbmVkIHR5cGVzLlxuICovXG5mdW5jdGlvbiBnZW5lcmljQ29kZXJGb3IodmVyc2lvbikge1xuICByZXR1cm4gY29kZXJGb3IodmVyc2lvbik7XG59XG5cbnZhciBpbmRleCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBTExfQ09ERVJTOiBBTExfQ09ERVJTLFxuICBjb2RlckZvcjogY29kZXJGb3IsXG4gIGdlbmVyaWNDb2RlckZvcjogZ2VuZXJpY0NvZGVyRm9yXG59KTtcblxuY29uc3QgVkVSU0lPTiA9ICcyLjIuMTMnO1xuXG5jb25zdCBhbGxWZXJzaW9ucyA9IFt2MSwgdjJdO1xuXG5leHBvcnQgeyBWRVJTSU9OLCBhbGxWZXJzaW9ucywgaW5kZXgkMSBhcyBjb21tb25zLCBpbmRleCBhcyB1bml2ZXJzYWwsIHYxLCB2MiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/.pnpm/@0xsequence+core@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/core/dist/0xsequence-core.esm.js\n");

/***/ })

};
;