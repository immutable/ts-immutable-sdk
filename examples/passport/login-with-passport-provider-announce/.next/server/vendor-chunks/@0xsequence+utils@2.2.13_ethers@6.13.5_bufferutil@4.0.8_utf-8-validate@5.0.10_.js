"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@0xsequence+utils@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_";
exports.ids = ["vendor-chunks/@0xsequence+utils@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/.pnpm/@0xsequence+utils@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/utils/dist/0xsequence-utils.esm.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@0xsequence+utils@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/utils/dist/0xsequence-utils.esm.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   MAX_UINT_256: () => (/* binding */ MAX_UINT_256),\n/* harmony export */   MerkleTreeGenerator: () => (/* binding */ MerkleTreeGenerator),\n/* harmony export */   PromiseCache: () => (/* binding */ PromiseCache),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64DecodeObject: () => (/* binding */ base64DecodeObject),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64EncodeObject: () => (/* binding */ base64EncodeObject),\n/* harmony export */   bigintReplacer: () => (/* binding */ bigintReplacer),\n/* harmony export */   bigintReviver: () => (/* binding */ bigintReviver),\n/* harmony export */   configureLogger: () => (/* binding */ configureLogger),\n/* harmony export */   defineProperties: () => (/* binding */ defineProperties),\n/* harmony export */   encodeMessageDigest: () => (/* binding */ encodeMessageDigest),\n/* harmony export */   encodeTypedDataDigest: () => (/* binding */ encodeTypedDataDigest),\n/* harmony export */   encodeTypedDataHash: () => (/* binding */ encodeTypedDataHash),\n/* harmony export */   extractProjectIdFromAccessKey: () => (/* binding */ extractProjectIdFromAccessKey),\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatUnits: () => (/* binding */ formatUnits),\n/* harmony export */   getFetchRequest: () => (/* binding */ getFetchRequest),\n/* harmony export */   getRandomInt: () => (/* binding */ getRandomInt),\n/* harmony export */   getSaleItemsLeaf: () => (/* binding */ getSaleItemsLeaf),\n/* harmony export */   isBigNumberish: () => (/* binding */ isBigNumberish),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   jwtDecodeClaims: () => (/* binding */ jwtDecodeClaims),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   packMessageData: () => (/* binding */ packMessageData),\n/* harmony export */   parseEther: () => (/* binding */ parseEther),\n/* harmony export */   parseUnits: () => (/* binding */ parseUnits),\n/* harmony export */   promisify: () => (/* binding */ promisify),\n/* harmony export */   queryStringFromObject: () => (/* binding */ queryStringFromObject),\n/* harmony export */   queryStringToObject: () => (/* binding */ queryStringToObject),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties),\n/* harmony export */   sanitizeAlphanumeric: () => (/* binding */ sanitizeAlphanumeric),\n/* harmony export */   sanitizeHost: () => (/* binding */ sanitizeHost),\n/* harmony export */   sanitizeNumberString: () => (/* binding */ sanitizeNumberString),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   subDigestOf: () => (/* binding */ subDigestOf),\n/* harmony export */   toHexString: () => (/* binding */ toHexString),\n/* harmony export */   urlClean: () => (/* binding */ urlClean)\n/* harmony export */ });\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-base64 */ \"(ssr)/../../../node_modules/.pnpm/js-base64@3.7.7/node_modules/js-base64/base64.mjs\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/solidity.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/hash/typed-data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(ssr)/../../../node_modules/.pnpm/ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/ethers/lib.esm/ethers.js\");\n\n\n\nconst extractProjectIdFromAccessKey = accessKey => {\n  // Convert URL-safe base64 string to standard base64 string\n  const base64String = accessKey.replace(/-/g, '+').replace(/_/g, '/');\n  // Decode the base64 string to a binary string\n  const binaryString = atob(base64String);\n\n  // Convert the binary string to a byte array (Uint8Array)\n  const byteArray = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    byteArray[i] = binaryString.charCodeAt(i);\n  }\n  if (byteArray[0] !== 1) {\n    throw new Error('UnsupportedVersion');\n  }\n\n  // Extract the project ID from bytes 2 to 9 (8 bytes)\n  const projectIdBytes = byteArray.slice(1, 9);\n  const projectId = projectIdBytes[7] | projectIdBytes[6] << 8 | projectIdBytes[5] << 16 | projectIdBytes[4] << 24 | projectIdBytes[3] << 32 | projectIdBytes[2] << 40 | projectIdBytes[1] << 48 | projectIdBytes[0] << 56;\n  return projectId;\n};\n\nconst MAX_UINT_256 = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n\n// ethers implement this method but doesn't exports it\nconst isBigNumberish = value => {\n  return value != null && (typeof value === 'number' && value % 1 === 0 || typeof value === 'string' && !!value.match(/^-?[0-9]+$/) || ethers__WEBPACK_IMPORTED_MODULE_0__.isHexString(value) || typeof value === 'bigint');\n};\n\n// Even length zero-padded hex string with 0x prefix\nconst toHexString = value => {\n  const result = value.toString(16);\n  return `${result.length % 2 === 0 ? '0x' : '0x0'}${result}`;\n};\nconst parseUnits = (value, decimals = 18) => {\n  let [integer, fraction = '0'] = value.split('.');\n  const negative = integer.startsWith('-');\n  if (negative) {\n    integer = integer.slice(1);\n  }\n\n  // trim trailing zeros.\n  fraction = fraction.replace(/(0+)$/, '');\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    integer = `${Math.round(Number(`${integer}.${fraction}`))}`;\n    fraction = '';\n  } else if (fraction.length > decimals) {\n    const [left, unit, right] = [fraction.slice(0, decimals - 1), fraction.slice(decimals - 1, decimals), fraction.slice(decimals)];\n    const rounded = Math.round(Number(`${unit}.${right}`));\n    if (rounded > 9) {\n      fraction = `${BigInt(left) + 1n}0`.padStart(left.length + 1, '0');\n    } else {\n      fraction = `${left}${rounded}`;\n    }\n    if (fraction.length > decimals) {\n      fraction = fraction.slice(1);\n      integer = `${BigInt(integer) + 1n}`;\n    }\n    fraction = fraction.slice(0, decimals);\n  } else {\n    fraction = fraction.padEnd(decimals, '0');\n  }\n  return BigInt(`${negative ? '-' : ''}${integer}${fraction}`);\n};\nconst parseEther = value => parseUnits(value, 18);\nconst formatUnits = (value, decimals = 18) => {\n  let display = value.toString();\n  const negative = display.startsWith('-');\n  if (negative) {\n    display = display.slice(1);\n  }\n  display = display.padStart(decimals, '0');\n  const integer = display.slice(0, display.length - decimals);\n  let fraction = display.slice(display.length - decimals);\n  fraction = fraction.replace(/(0+)$/, '');\n  return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;\n};\nconst formatEther = value => formatUnits(value, 18);\n\n// JSON.stringify doesn't handle BigInts, so we need to replace them with objects\nconst bigintReplacer = (key, value) => {\n  if (typeof value === 'bigint') {\n    return {\n      $bigint: value.toString()\n    };\n  }\n  return value;\n};\n\n// JSON.parse will need to convert our serialized bigints back into BigInt\nconst bigintReviver = (key, value) => {\n  if (value !== null && typeof value === 'object' && '$bigint' in value && typeof value.$bigint === 'string') {\n    return BigInt(value.$bigint);\n  }\n\n  // BigNumber compatibility with older versions of sequence.js with ethers v5\n  if (value !== null && typeof value === 'object' && value.type === 'BigNumber' && ethers__WEBPACK_IMPORTED_MODULE_0__.isHexString(value.hex)) {\n    return BigInt(value.hex);\n  }\n  return value;\n};\n\nconst base64Encode = val => {\n  return js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.encode(val, true);\n};\nconst base64EncodeObject = obj => {\n  return js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.encode(JSON.stringify(obj, bigintReplacer), true);\n};\nconst base64Decode = encodedString => {\n  if (encodedString === null || encodedString === undefined) {\n    return undefined;\n  }\n  return js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.decode(encodedString);\n};\nconst base64DecodeObject = encodedObject => {\n  if (encodedObject === null || encodedObject === undefined) {\n    return undefined;\n  }\n  return JSON.parse(js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.decode(encodedObject), bigintReviver);\n};\n\nconst encodeMessageDigest = message => {\n  if (typeof message === 'string') {\n    return ethers__WEBPACK_IMPORTED_MODULE_0__.getBytes(ethers__WEBPACK_IMPORTED_MODULE_2__.id(message));\n  } else {\n    return ethers__WEBPACK_IMPORTED_MODULE_0__.getBytes(ethers__WEBPACK_IMPORTED_MODULE_3__.keccak256(message));\n  }\n};\n\n// packMessageData encodes the specified data ready for the Sequence Wallet contracts.\nconst packMessageData = (walletAddress, chainId, digest) => {\n  return ethers__WEBPACK_IMPORTED_MODULE_4__.solidityPacked(['string', 'uint256', 'address', 'bytes32'], ['\\x19\\x01', chainId, walletAddress, digest]);\n};\nconst subDigestOf = (address, chainId, digest) => {\n  return ethers__WEBPACK_IMPORTED_MODULE_3__.keccak256(packMessageData(address, chainId, digest));\n};\n\nconst isNode = () => {\n  if (typeof window === 'undefined' && typeof process === 'object') {\n    return true;\n  } else {\n    return false;\n  }\n};\nconst isBrowser = () => !isNode();\n\nconst jwtDecodeClaims = jwt => {\n  const parts = jwt.split('.');\n  if (parts.length !== 3) {\n    throw new Error('invalid jwt');\n  }\n  const claims = JSON.parse(js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.decode(parts[1]));\n  return claims;\n};\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\nvar logLevel = /*#__PURE__*/function (logLevel) {\n  logLevel[logLevel[\"DEBUG\"] = 1] = \"DEBUG\";\n  logLevel[logLevel[\"INFO\"] = 2] = \"INFO\";\n  logLevel[logLevel[\"WARN\"] = 3] = \"WARN\";\n  logLevel[logLevel[\"ERROR\"] = 4] = \"ERROR\";\n  logLevel[logLevel[\"DISABLED\"] = 5] = \"DISABLED\";\n  return logLevel;\n}(logLevel || {});\nclass Logger {\n  constructor(config) {\n    this.config = config;\n    this.logLevel = void 0;\n    this.configure(config);\n  }\n  configure(config) {\n    this.config = _extends({}, this.config, config);\n    switch (this.config.logLevel) {\n      case 'DEBUG':\n        this.logLevel = logLevel.DEBUG;\n        break;\n      case 'INFO':\n        this.logLevel = logLevel.INFO;\n        break;\n      case 'WARN':\n        this.logLevel = logLevel.WARN;\n        break;\n      case 'ERROR':\n        this.logLevel = logLevel.ERROR;\n        break;\n      case 'DISABLED':\n        this.logLevel = logLevel.DISABLED;\n        break;\n      default:\n        this.logLevel = logLevel.INFO;\n        break;\n    }\n\n    // undefined silence value will disable the default silence flag\n    if (this.config.silence === undefined) {\n      this.config.silence = false;\n    }\n  }\n  debug(message, ...optionalParams) {\n    if (this.config.silence === true) return;\n    if (this.logLevel === logLevel.DEBUG) {\n      console.log(message, ...optionalParams);\n    }\n  }\n  info(message, ...optionalParams) {\n    if (this.config.silence === true) return;\n    if (this.logLevel <= logLevel.INFO) {\n      console.log(message, ...optionalParams);\n    }\n  }\n  warn(message, ...optionalParams) {\n    if (this.config.silence === true) return;\n    if (this.logLevel <= logLevel.WARN) {\n      console.warn(message, ...optionalParams);\n      if (this.config.onwarn) {\n        this.config.onwarn(message, optionalParams);\n      }\n    }\n  }\n  error(message, ...optionalParams) {\n    if (this.config.silence === true) return;\n    if (this.logLevel <= logLevel.ERROR) {\n      console.error(message, ...optionalParams);\n      if (this.config.onerror) {\n        this.config.onerror(message, optionalParams);\n      }\n    }\n  }\n}\nconst logger = new Logger({\n  logLevel: 'INFO',\n  // By default we silence the logger. In tests we should call `configureLogger`\n  // below to set silence: false.\n  silence: true\n});\nconst configureLogger = config => logger.configure(config);\n\nclass Base {\n  static bufferIndexOf(array, element, isSorted = false) {\n    if (isSorted) {\n      return Base.binarySearch(array, element, Base.compare);\n    }\n    const eqChecker = (buffer1, buffer2) => {\n      if (buffer1 === buffer2) {\n        return true;\n      }\n      if (buffer1.length !== buffer2.length) {\n        return false;\n      }\n      for (let i = 0; i < buffer1.length; i++) {\n        if (buffer1[i] !== buffer2[i]) {\n          return false;\n        }\n      }\n      return true;\n    };\n    return Base.linearSearch(array, element, eqChecker);\n  }\n  static binarySearch(array, element, compareFunction) {\n    let start = 0;\n    let end = array.length - 1;\n\n    // Iterate while start not meets end\n    while (start <= end) {\n      // Find the mid index\n      const mid = Math.floor((start + end) / 2);\n\n      // Check if the mid value is greater than, equal to, or less than search element.\n      const ordering = compareFunction(array[mid], element);\n\n      // If element is present at mid, start iterating for searching first appearance.\n      if (ordering === 0) {\n        // Linear reverse iteration until the first matching item index is found.\n        for (let i = mid - 1; i >= 0; i--) {\n          if (compareFunction(array[i], element) === 0) continue;\n          return i + 1;\n        }\n        return 0;\n      } /* Else look in left or right half accordingly */else if (ordering < 0) {\n        start = mid + 1;\n      } else {\n        end = mid - 1;\n      }\n    }\n    return -1;\n  }\n  static compare(a, b) {\n    // Determine the minimum length to compare\n    const len = Math.min(a.length, b.length);\n\n    // Compare byte by byte\n    for (let i = 0; i < len; i++) {\n      if (a[i] !== b[i]) {\n        return a[i] - b[i];\n      }\n    }\n\n    // If all compared bytes are equal, compare lengths\n    return a.length - b.length;\n  }\n  static linearSearch(array, element, eqChecker) {\n    for (let i = 0; i < array.length; i++) {\n      if (eqChecker(array[i], element)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  static bufferify(value) {\n    if (typeof value === 'string') {\n      return ethers__WEBPACK_IMPORTED_MODULE_0__.getBytes(value);\n    }\n    return value;\n  }\n  static isHexString(v) {\n    return typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n  }\n  static bufferToHex(value, withPrefix = true) {\n    const prefixed = ethers__WEBPACK_IMPORTED_MODULE_0__.hexlify(value);\n    return withPrefix ? prefixed : prefixed.substring(2);\n  }\n  static bufferifyFn(f) {\n    return value => {\n      return Base.bufferify(f(value));\n    };\n  }\n}\n\nclass MerkleTree extends Base {\n  constructor(leaves, options = {}) {\n    super();\n    this.hashFn = void 0;\n    this.leaves = [];\n    this.layers = [];\n    this.sortLeaves = false;\n    this.sortPairs = false;\n    this.sortLeaves = !!options.sortLeaves;\n    this.sortPairs = !!options.sortPairs;\n    this.hashFn = Base.bufferifyFn(ethers__WEBPACK_IMPORTED_MODULE_3__.keccak256);\n    this.processLeaves(leaves);\n  }\n  getOptions() {\n    return {\n      sortLeaves: this.sortLeaves,\n      sortPairs: this.sortPairs\n    };\n  }\n  processLeaves(leaves) {\n    this.leaves = leaves.map(Base.bufferify);\n    if (this.sortLeaves) {\n      this.leaves = this.leaves.sort(Base.compare);\n    }\n    this.createHashes(this.leaves);\n  }\n  createHashes(nodes) {\n    this.layers = [nodes];\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n      this.layers.push([]);\n      const layerLimit = nodes.length;\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i >= layerLimit) {\n          this.layers[layerIndex].push(...nodes.slice(layerLimit));\n          break;\n        } else if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            // push copy of hash and continue iteration\n            this.layers[layerIndex].push(nodes[i]);\n            continue;\n          }\n        }\n        const left = nodes[i];\n        const right = i + 1 === nodes.length ? left : nodes[i + 1];\n        const combined = [left, right];\n        if (this.sortPairs) {\n          combined.sort(Base.compare);\n        }\n        const hash = this.hashFn(ethers__WEBPACK_IMPORTED_MODULE_0__.concat(combined));\n        this.layers[layerIndex].push(hash);\n      }\n      nodes = this.layers[layerIndex];\n    }\n  }\n  getRoot() {\n    if (this.layers.length === 0) {\n      return Uint8Array.from([]);\n    }\n    return this.layers[this.layers.length - 1][0] || Uint8Array.from([]);\n  }\n  getHexRoot() {\n    return Base.bufferToHex(this.getRoot());\n  }\n  getProof(leaf, index) {\n    if (typeof leaf === 'undefined') {\n      throw new Error('leaf is required');\n    }\n    leaf = Base.bufferify(leaf);\n    const proof = [];\n    if (!Number.isInteger(index)) {\n      index = -1;\n      for (let i = 0; i < this.leaves.length; i++) {\n        if (Base.compare(leaf, this.leaves[i]) === 0) {\n          index = i;\n        }\n      }\n    }\n\n    // Type fix\n    index = index;\n    if (index <= -1) {\n      return [];\n    }\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode ? index - 1 : index + 1;\n      if (pairIndex < layer.length) {\n        proof.push({\n          position: isRightNode ? 'left' : 'right',\n          data: layer[pairIndex]\n        });\n      }\n\n      // set index to parent index\n      index = index / 2 | 0;\n    }\n    return proof;\n  }\n  getHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => Base.bufferToHex(item.data));\n  }\n  verify(proof, targetNode, root) {\n    let hash = Base.bufferify(targetNode);\n    root = Base.bufferify(root);\n    if (!Array.isArray(proof) || !targetNode || !root) {\n      return false;\n    }\n    for (let i = 0; i < proof.length; i++) {\n      const node = proof[i];\n      let data;\n      let isLeftNode;\n      if (typeof node === 'string') {\n        data = Base.bufferify(node);\n        isLeftNode = true;\n      } else if (node instanceof Object) {\n        data = node.data;\n        isLeftNode = node.position === 'left';\n      } else {\n        throw new Error('Expected node to be of type string or object');\n      }\n      const buffers = [];\n      if (this.sortPairs) {\n        if (Base.compare(hash, data) < 0) {\n          buffers.push(hash, data);\n        } else {\n          buffers.push(data, hash);\n        }\n        hash = this.hashFn(ethers__WEBPACK_IMPORTED_MODULE_0__.concat(buffers));\n      } else {\n        buffers.push(hash);\n        buffers[isLeftNode ? 'unshift' : 'push'](data);\n        hash = this.hashFn(ethers__WEBPACK_IMPORTED_MODULE_0__.concat(buffers));\n      }\n    }\n    return Base.compare(hash, root) === 0;\n  }\n}\n\nclass MerkleTreeGenerator {\n  constructor(elements, toLeaf) {\n    this.elements = void 0;\n    this.toLeaf = void 0;\n    this.tree = void 0;\n    this.elements = elements;\n    this.toLeaf = toLeaf;\n  }\n  generateTree() {\n    const hashed = this.elements.map(e => this.toLeaf(e));\n    return new MerkleTree(hashed, {\n      sortPairs: true,\n      sortLeaves: true\n    });\n  }\n  generateRoot() {\n    if (!this.tree) this.tree = this.generateTree();\n    return this.tree.getHexRoot();\n  }\n  generateProof(element) {\n    if (!this.elements.includes(element)) throw new Error('Element not found');\n    if (!this.tree) this.tree = this.generateTree();\n    return this.tree.getHexProof(this.toLeaf(element));\n  }\n  verifyProof(element, proof) {\n    if (!this.elements.includes(element)) throw new Error('Element not found');\n    if (!this.tree) this.tree = this.generateTree();\n    return this.tree.verify(proof, this.toLeaf(element), this.generateRoot());\n  }\n}\nconst getSaleItemsLeaf = element => ethers__WEBPACK_IMPORTED_MODULE_4__.solidityPackedKeccak256(['address', 'uint256'], [element.address.toLowerCase(), element.tokenId]);\n\n// export const getEthersConnectionInfo = (url: string, projectAccessKey?: string, jwt?: string): ConnectionInfo => {\n//   const headers: {\n//     [key: string]: string | number\n//   } = {}\n\n//   if (jwt && jwt.length > 0) {\n//     headers['Authorization'] = `BEARER ${jwt}`\n//   }\n//   if (projectAccessKey && projectAccessKey.length > 0) {\n//     headers['X-Access-Key'] = projectAccessKey\n//   }\n\n//   return {\n//     url,\n//     headers,\n//     skipFetchSetup: true,\n//     fetchOptions: {\n//       mode: 'cors',\n//       cache: 'force-cache',\n//       credentials: 'same-origin',\n//       redirect: 'follow',\n//       referrer: 'client'\n//     }\n//   }\n// }\n\nconst getFetchRequest = (url, projectAccessKey, jwt) => {\n  const req = new ethers__WEBPACK_IMPORTED_MODULE_5__.FetchRequest(url);\n  if (jwt) {\n    req.setHeader('Authorization', `BEARER ${jwt}`);\n  }\n  if (projectAccessKey) {\n    req.setHeader('X-Access-Key', projectAccessKey);\n  }\n  return req;\n};\n\nclass PromiseCache {\n  constructor() {\n    this.cache = void 0;\n    this.cache = new Map();\n  }\n  do(key, validMilliseconds, task, ...args) {\n    key = `${key}:${ethers__WEBPACK_IMPORTED_MODULE_2__.id(JSON.stringify(args, deterministically))}`;\n    let entry = this.cache.get(key);\n    if (entry) {\n      if (entry.expiration) {\n        if (new Date() >= entry.expiration) {\n          entry = undefined;\n          this.cache.delete(key);\n        }\n      }\n    }\n    if (!entry) {\n      const entry_ = {\n        promise: task(...args)\n      };\n      if (validMilliseconds !== undefined) {\n        entry_.promise = entry_.promise.then(result => {\n          entry_.expiration = new Date(Date.now() + validMilliseconds);\n          return result;\n        });\n      }\n      entry = entry_;\n      this.cache.set(key, entry);\n    }\n    return entry.promise;\n  }\n}\nfunction deterministically(_key, value) {\n  if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n    return Object.fromEntries(Object.entries(value).sort());\n  }\n  return value;\n}\n\nfunction promisify(f, thisContext) {\n  return function (...a) {\n    const args = Array.prototype.slice.call(a);\n    return new Promise(async (resolve, reject) => {\n      try {\n        args.push((err, result) => err ? reject(err) : resolve(result));\n        await f.apply(thisContext, args);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n}\n\nfunction queryStringFromObject(name, obj) {\n  const k = encodeURIComponent(name);\n  const v = encodeURIComponent(JSON.stringify(obj));\n  return `${k}=${v}`;\n}\nfunction queryStringToObject(qs) {\n  const p = qs.split('&');\n  const o = {};\n  for (const v of p) {\n    const z = v.split('=');\n    o[decodeURIComponent(z[0])] = JSON.parse(decodeURIComponent(z[1]));\n  }\n  return o;\n}\n\nconst getRandomInt = (min = 0, max = Number.MAX_SAFE_INTEGER) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n// sanitizeNumberString accepts a number string and returns back a clean number string.\n// For example, input '1234.5678' will return '1234.5678' but '12javascript:{}etc' will return '12'\nconst sanitizeNumberString = numString => {\n  if (!numString || typeof numString !== 'string') {\n    return '';\n  }\n  const v = numString.match(/[\\d.]+/);\n  return v && v.length > 0 ? v[0].trim() : '';\n};\n\n// sanitizeAlphanumeric accepts any string and returns alphanumeric contents only\nconst sanitizeAlphanumeric = alphanum => {\n  if (!alphanum || typeof alphanum !== 'string') {\n    return '';\n  }\n  const v = alphanum.match(/[\\w\\s\\d]+/);\n  return v && v.length > 0 ? v[0].trim() : '';\n};\n\n// sanitizeHost accepts any string and returns valid host string\nconst sanitizeHost = host => {\n  if (!host || typeof host !== 'string') {\n    return '';\n  }\n  const v = host.match(/[\\w\\d.\\-:\\/]+/);\n  return v && v.length > 0 ? v[0].trim() : '';\n};\n\nconst sleep = t => {\n  return new Promise(resolve => {\n    const timeout = setTimeout(() => {\n      clearTimeout(timeout);\n      resolve();\n    }, t);\n  });\n};\n\nconst encodeTypedDataHash = typedData => {\n  const types = _extends({}, typedData.types);\n\n  // remove EIP712Domain key from types as ethers will auto-gen it in\n  // the hash encoder below\n  delete types['EIP712Domain'];\n  return ethers__WEBPACK_IMPORTED_MODULE_6__.TypedDataEncoder.hash(typedData.domain, types, typedData.message);\n};\nconst encodeTypedDataDigest = typedData => {\n  return ethers__WEBPACK_IMPORTED_MODULE_0__.getBytes(encodeTypedDataHash(typedData));\n};\n\nconst {\n  defineProperties,\n  resolveProperties\n} = ethers__WEBPACK_IMPORTED_MODULE_7__;\n\n// urlClean removes double slashes from url path\nconst urlClean = url => url.replace(/([^:]\\/)\\/+/g, '$1');\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0AweHNlcXVlbmNlK3V0aWxzQDIuMi4xM19ldGhlcnNANi4xMy41X2J1ZmZlcnV0aWxANC4wLjhfdXRmLTgtdmFsaWRhdGVANS4wLjEwXy9ub2RlX21vZHVsZXMvQDB4c2VxdWVuY2UvdXRpbHMvZGlzdC8weHNlcXVlbmNlLXV0aWxzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDSDs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVJQUF1SSwrQ0FBa0I7QUFDeko7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1Q0FBdUMsRUFBRSxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUIsUUFBUSxHQUFHLFNBQVMsSUFBSTtBQUM5RDtBQUNBLElBQUk7QUFDSjtBQUNBLHlDQUF5QyxLQUFLLEdBQUcsTUFBTTtBQUN2RDtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMsTUFBTTtBQUNOLG9CQUFvQixLQUFLLEVBQUUsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0IsRUFBRSxRQUFRLEVBQUUsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQixFQUFFLGVBQWUsRUFBRSxlQUFlLFNBQVMsT0FBTztBQUNsRjtBQUNBOztBQUVB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QUFDckM7QUFDQSw2Q0FBNkMsSUFBSTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJLEdBQUcsc0NBQVMsMENBQTBDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksRUFBRSxHQUFHLEVBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0RBQXVCO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTLDRDQUFlO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQ0FBTTs7QUFFVjtBQUNBOztBQUV3b0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZXhhbXBsZXMvbG9naW4td2l0aC1wYXNzcG9ydC1wcm92aWRlci1hbm5vdW5jZS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQDB4c2VxdWVuY2UrdXRpbHNAMi4yLjEzX2V0aGVyc0A2LjEzLjVfYnVmZmVydXRpbEA0LjAuOF91dGYtOC12YWxpZGF0ZUA1LjAuMTBfL25vZGVfbW9kdWxlcy9AMHhzZXF1ZW5jZS91dGlscy9kaXN0LzB4c2VxdWVuY2UtdXRpbHMuZXNtLmpzP2FkOGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZTY0IH0gZnJvbSAnanMtYmFzZTY0JztcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5cbmNvbnN0IGV4dHJhY3RQcm9qZWN0SWRGcm9tQWNjZXNzS2V5ID0gYWNjZXNzS2V5ID0+IHtcbiAgLy8gQ29udmVydCBVUkwtc2FmZSBiYXNlNjQgc3RyaW5nIHRvIHN0YW5kYXJkIGJhc2U2NCBzdHJpbmdcbiAgY29uc3QgYmFzZTY0U3RyaW5nID0gYWNjZXNzS2V5LnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJyk7XG4gIC8vIERlY29kZSB0aGUgYmFzZTY0IHN0cmluZyB0byBhIGJpbmFyeSBzdHJpbmdcbiAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjRTdHJpbmcpO1xuXG4gIC8vIENvbnZlcnQgdGhlIGJpbmFyeSBzdHJpbmcgdG8gYSBieXRlIGFycmF5IChVaW50OEFycmF5KVxuICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlQXJyYXlbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgfVxuICBpZiAoYnl0ZUFycmF5WzBdICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZFZlcnNpb24nKTtcbiAgfVxuXG4gIC8vIEV4dHJhY3QgdGhlIHByb2plY3QgSUQgZnJvbSBieXRlcyAyIHRvIDkgKDggYnl0ZXMpXG4gIGNvbnN0IHByb2plY3RJZEJ5dGVzID0gYnl0ZUFycmF5LnNsaWNlKDEsIDkpO1xuICBjb25zdCBwcm9qZWN0SWQgPSBwcm9qZWN0SWRCeXRlc1s3XSB8IHByb2plY3RJZEJ5dGVzWzZdIDw8IDggfCBwcm9qZWN0SWRCeXRlc1s1XSA8PCAxNiB8IHByb2plY3RJZEJ5dGVzWzRdIDw8IDI0IHwgcHJvamVjdElkQnl0ZXNbM10gPDwgMzIgfCBwcm9qZWN0SWRCeXRlc1syXSA8PCA0MCB8IHByb2plY3RJZEJ5dGVzWzFdIDw8IDQ4IHwgcHJvamVjdElkQnl0ZXNbMF0gPDwgNTY7XG4gIHJldHVybiBwcm9qZWN0SWQ7XG59O1xuXG5jb25zdCBNQVhfVUlOVF8yNTYgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpO1xuXG4vLyBldGhlcnMgaW1wbGVtZW50IHRoaXMgbWV0aG9kIGJ1dCBkb2Vzbid0IGV4cG9ydHMgaXRcbmNvbnN0IGlzQmlnTnVtYmVyaXNoID0gdmFsdWUgPT4ge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAlIDEgPT09IDAgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhIXZhbHVlLm1hdGNoKC9eLT9bMC05XSskLykgfHwgZXRoZXJzLmlzSGV4U3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKTtcbn07XG5cbi8vIEV2ZW4gbGVuZ3RoIHplcm8tcGFkZGVkIGhleCBzdHJpbmcgd2l0aCAweCBwcmVmaXhcbmNvbnN0IHRvSGV4U3RyaW5nID0gdmFsdWUgPT4ge1xuICBjb25zdCByZXN1bHQgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gIHJldHVybiBgJHtyZXN1bHQubGVuZ3RoICUgMiA9PT0gMCA/ICcweCcgOiAnMHgwJ30ke3Jlc3VsdH1gO1xufTtcbmNvbnN0IHBhcnNlVW5pdHMgPSAodmFsdWUsIGRlY2ltYWxzID0gMTgpID0+IHtcbiAgbGV0IFtpbnRlZ2VyLCBmcmFjdGlvbiA9ICcwJ10gPSB2YWx1ZS5zcGxpdCgnLicpO1xuICBjb25zdCBuZWdhdGl2ZSA9IGludGVnZXIuc3RhcnRzV2l0aCgnLScpO1xuICBpZiAobmVnYXRpdmUpIHtcbiAgICBpbnRlZ2VyID0gaW50ZWdlci5zbGljZSgxKTtcbiAgfVxuXG4gIC8vIHRyaW0gdHJhaWxpbmcgemVyb3MuXG4gIGZyYWN0aW9uID0gZnJhY3Rpb24ucmVwbGFjZSgvKDArKSQvLCAnJyk7XG5cbiAgLy8gcm91bmQgb2ZmIGlmIHRoZSBmcmFjdGlvbiBpcyBsYXJnZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGRlY2ltYWxzLlxuICBpZiAoZGVjaW1hbHMgPT09IDApIHtcbiAgICBpbnRlZ2VyID0gYCR7TWF0aC5yb3VuZChOdW1iZXIoYCR7aW50ZWdlcn0uJHtmcmFjdGlvbn1gKSl9YDtcbiAgICBmcmFjdGlvbiA9ICcnO1xuICB9IGVsc2UgaWYgKGZyYWN0aW9uLmxlbmd0aCA+IGRlY2ltYWxzKSB7XG4gICAgY29uc3QgW2xlZnQsIHVuaXQsIHJpZ2h0XSA9IFtmcmFjdGlvbi5zbGljZSgwLCBkZWNpbWFscyAtIDEpLCBmcmFjdGlvbi5zbGljZShkZWNpbWFscyAtIDEsIGRlY2ltYWxzKSwgZnJhY3Rpb24uc2xpY2UoZGVjaW1hbHMpXTtcbiAgICBjb25zdCByb3VuZGVkID0gTWF0aC5yb3VuZChOdW1iZXIoYCR7dW5pdH0uJHtyaWdodH1gKSk7XG4gICAgaWYgKHJvdW5kZWQgPiA5KSB7XG4gICAgICBmcmFjdGlvbiA9IGAke0JpZ0ludChsZWZ0KSArIDFufTBgLnBhZFN0YXJ0KGxlZnQubGVuZ3RoICsgMSwgJzAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhY3Rpb24gPSBgJHtsZWZ0fSR7cm91bmRlZH1gO1xuICAgIH1cbiAgICBpZiAoZnJhY3Rpb24ubGVuZ3RoID4gZGVjaW1hbHMpIHtcbiAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb24uc2xpY2UoMSk7XG4gICAgICBpbnRlZ2VyID0gYCR7QmlnSW50KGludGVnZXIpICsgMW59YDtcbiAgICB9XG4gICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zbGljZSgwLCBkZWNpbWFscyk7XG4gIH0gZWxzZSB7XG4gICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5wYWRFbmQoZGVjaW1hbHMsICcwJyk7XG4gIH1cbiAgcmV0dXJuIEJpZ0ludChgJHtuZWdhdGl2ZSA/ICctJyA6ICcnfSR7aW50ZWdlcn0ke2ZyYWN0aW9ufWApO1xufTtcbmNvbnN0IHBhcnNlRXRoZXIgPSB2YWx1ZSA9PiBwYXJzZVVuaXRzKHZhbHVlLCAxOCk7XG5jb25zdCBmb3JtYXRVbml0cyA9ICh2YWx1ZSwgZGVjaW1hbHMgPSAxOCkgPT4ge1xuICBsZXQgZGlzcGxheSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIGNvbnN0IG5lZ2F0aXZlID0gZGlzcGxheS5zdGFydHNXaXRoKCctJyk7XG4gIGlmIChuZWdhdGl2ZSkge1xuICAgIGRpc3BsYXkgPSBkaXNwbGF5LnNsaWNlKDEpO1xuICB9XG4gIGRpc3BsYXkgPSBkaXNwbGF5LnBhZFN0YXJ0KGRlY2ltYWxzLCAnMCcpO1xuICBjb25zdCBpbnRlZ2VyID0gZGlzcGxheS5zbGljZSgwLCBkaXNwbGF5Lmxlbmd0aCAtIGRlY2ltYWxzKTtcbiAgbGV0IGZyYWN0aW9uID0gZGlzcGxheS5zbGljZShkaXNwbGF5Lmxlbmd0aCAtIGRlY2ltYWxzKTtcbiAgZnJhY3Rpb24gPSBmcmFjdGlvbi5yZXBsYWNlKC8oMCspJC8sICcnKTtcbiAgcmV0dXJuIGAke25lZ2F0aXZlID8gJy0nIDogJyd9JHtpbnRlZ2VyIHx8ICcwJ30ke2ZyYWN0aW9uID8gYC4ke2ZyYWN0aW9ufWAgOiAnJ31gO1xufTtcbmNvbnN0IGZvcm1hdEV0aGVyID0gdmFsdWUgPT4gZm9ybWF0VW5pdHModmFsdWUsIDE4KTtcblxuLy8gSlNPTi5zdHJpbmdpZnkgZG9lc24ndCBoYW5kbGUgQmlnSW50cywgc28gd2UgbmVlZCB0byByZXBsYWNlIHRoZW0gd2l0aCBvYmplY3RzXG5jb25zdCBiaWdpbnRSZXBsYWNlciA9IChrZXksIHZhbHVlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICRiaWdpbnQ6IHZhbHVlLnRvU3RyaW5nKClcbiAgICB9O1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIEpTT04ucGFyc2Ugd2lsbCBuZWVkIHRvIGNvbnZlcnQgb3VyIHNlcmlhbGl6ZWQgYmlnaW50cyBiYWNrIGludG8gQmlnSW50XG5jb25zdCBiaWdpbnRSZXZpdmVyID0gKGtleSwgdmFsdWUpID0+IHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgJyRiaWdpbnQnIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS4kYmlnaW50ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBCaWdJbnQodmFsdWUuJGJpZ2ludCk7XG4gIH1cblxuICAvLyBCaWdOdW1iZXIgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIHNlcXVlbmNlLmpzIHdpdGggZXRoZXJzIHY1XG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLnR5cGUgPT09ICdCaWdOdW1iZXInICYmIGV0aGVycy5pc0hleFN0cmluZyh2YWx1ZS5oZXgpKSB7XG4gICAgcmV0dXJuIEJpZ0ludCh2YWx1ZS5oZXgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmNvbnN0IGJhc2U2NEVuY29kZSA9IHZhbCA9PiB7XG4gIHJldHVybiBCYXNlNjQuZW5jb2RlKHZhbCwgdHJ1ZSk7XG59O1xuY29uc3QgYmFzZTY0RW5jb2RlT2JqZWN0ID0gb2JqID0+IHtcbiAgcmV0dXJuIEJhc2U2NC5lbmNvZGUoSlNPTi5zdHJpbmdpZnkob2JqLCBiaWdpbnRSZXBsYWNlciksIHRydWUpO1xufTtcbmNvbnN0IGJhc2U2NERlY29kZSA9IGVuY29kZWRTdHJpbmcgPT4ge1xuICBpZiAoZW5jb2RlZFN0cmluZyA9PT0gbnVsbCB8fCBlbmNvZGVkU3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBCYXNlNjQuZGVjb2RlKGVuY29kZWRTdHJpbmcpO1xufTtcbmNvbnN0IGJhc2U2NERlY29kZU9iamVjdCA9IGVuY29kZWRPYmplY3QgPT4ge1xuICBpZiAoZW5jb2RlZE9iamVjdCA9PT0gbnVsbCB8fCBlbmNvZGVkT2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBKU09OLnBhcnNlKEJhc2U2NC5kZWNvZGUoZW5jb2RlZE9iamVjdCksIGJpZ2ludFJldml2ZXIpO1xufTtcblxuY29uc3QgZW5jb2RlTWVzc2FnZURpZ2VzdCA9IG1lc3NhZ2UgPT4ge1xuICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV0aGVycy5nZXRCeXRlcyhldGhlcnMuaWQobWVzc2FnZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBldGhlcnMuZ2V0Qnl0ZXMoZXRoZXJzLmtlY2NhazI1NihtZXNzYWdlKSk7XG4gIH1cbn07XG5cbi8vIHBhY2tNZXNzYWdlRGF0YSBlbmNvZGVzIHRoZSBzcGVjaWZpZWQgZGF0YSByZWFkeSBmb3IgdGhlIFNlcXVlbmNlIFdhbGxldCBjb250cmFjdHMuXG5jb25zdCBwYWNrTWVzc2FnZURhdGEgPSAod2FsbGV0QWRkcmVzcywgY2hhaW5JZCwgZGlnZXN0KSA9PiB7XG4gIHJldHVybiBldGhlcnMuc29saWRpdHlQYWNrZWQoWydzdHJpbmcnLCAndWludDI1NicsICdhZGRyZXNzJywgJ2J5dGVzMzInXSwgWydcXHgxOVxceDAxJywgY2hhaW5JZCwgd2FsbGV0QWRkcmVzcywgZGlnZXN0XSk7XG59O1xuY29uc3Qgc3ViRGlnZXN0T2YgPSAoYWRkcmVzcywgY2hhaW5JZCwgZGlnZXN0KSA9PiB7XG4gIHJldHVybiBldGhlcnMua2VjY2FrMjU2KHBhY2tNZXNzYWdlRGF0YShhZGRyZXNzLCBjaGFpbklkLCBkaWdlc3QpKTtcbn07XG5cbmNvbnN0IGlzTm9kZSA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbmNvbnN0IGlzQnJvd3NlciA9ICgpID0+ICFpc05vZGUoKTtcblxuY29uc3Qgand0RGVjb2RlQ2xhaW1zID0gand0ID0+IHtcbiAgY29uc3QgcGFydHMgPSBqd3Quc3BsaXQoJy4nKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBqd3QnKTtcbiAgfVxuICBjb25zdCBjbGFpbXMgPSBKU09OLnBhcnNlKEJhc2U2NC5kZWNvZGUocGFydHNbMV0pKTtcbiAgcmV0dXJuIGNsYWltcztcbn07XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICByZXR1cm4gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAobikge1xuICAgIGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50c1tlXTtcbiAgICAgIGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9LCBfZXh0ZW5kcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG52YXIgbG9nTGV2ZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKGxvZ0xldmVsKSB7XG4gIGxvZ0xldmVsW2xvZ0xldmVsW1wiREVCVUdcIl0gPSAxXSA9IFwiREVCVUdcIjtcbiAgbG9nTGV2ZWxbbG9nTGV2ZWxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcbiAgbG9nTGV2ZWxbbG9nTGV2ZWxbXCJXQVJOXCJdID0gM10gPSBcIldBUk5cIjtcbiAgbG9nTGV2ZWxbbG9nTGV2ZWxbXCJFUlJPUlwiXSA9IDRdID0gXCJFUlJPUlwiO1xuICBsb2dMZXZlbFtsb2dMZXZlbFtcIkRJU0FCTEVEXCJdID0gNV0gPSBcIkRJU0FCTEVEXCI7XG4gIHJldHVybiBsb2dMZXZlbDtcbn0obG9nTGV2ZWwgfHwge30pO1xuY2xhc3MgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5sb2dMZXZlbCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZ3VyZShjb25maWcpO1xuICB9XG4gIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IF9leHRlbmRzKHt9LCB0aGlzLmNvbmZpZywgY29uZmlnKTtcbiAgICBzd2l0Y2ggKHRoaXMuY29uZmlnLmxvZ0xldmVsKSB7XG4gICAgICBjYXNlICdERUJVRyc6XG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBsb2dMZXZlbC5ERUJVRztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJTkZPJzpcbiAgICAgICAgdGhpcy5sb2dMZXZlbCA9IGxvZ0xldmVsLklORk87XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnV0FSTic6XG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBsb2dMZXZlbC5XQVJOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0VSUk9SJzpcbiAgICAgICAgdGhpcy5sb2dMZXZlbCA9IGxvZ0xldmVsLkVSUk9SO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0RJU0FCTEVEJzpcbiAgICAgICAgdGhpcy5sb2dMZXZlbCA9IGxvZ0xldmVsLkRJU0FCTEVEO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBsb2dMZXZlbC5JTkZPO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyB1bmRlZmluZWQgc2lsZW5jZSB2YWx1ZSB3aWxsIGRpc2FibGUgdGhlIGRlZmF1bHQgc2lsZW5jZSBmbGFnXG4gICAgaWYgKHRoaXMuY29uZmlnLnNpbGVuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jb25maWcuc2lsZW5jZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBkZWJ1ZyhtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykge1xuICAgIGlmICh0aGlzLmNvbmZpZy5zaWxlbmNlID09PSB0cnVlKSByZXR1cm47XG4gICAgaWYgKHRoaXMubG9nTGV2ZWwgPT09IGxvZ0xldmVsLkRFQlVHKSB7XG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgfVxuICB9XG4gIGluZm8obWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpIHtcbiAgICBpZiAodGhpcy5jb25maWcuc2lsZW5jZSA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmxvZ0xldmVsIDw9IGxvZ0xldmVsLklORk8pIHtcbiAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcbiAgICB9XG4gIH1cbiAgd2FybihtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykge1xuICAgIGlmICh0aGlzLmNvbmZpZy5zaWxlbmNlID09PSB0cnVlKSByZXR1cm47XG4gICAgaWYgKHRoaXMubG9nTGV2ZWwgPD0gbG9nTGV2ZWwuV0FSTikge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5vbndhcm4pIHtcbiAgICAgICAgdGhpcy5jb25maWcub253YXJuKG1lc3NhZ2UsIG9wdGlvbmFsUGFyYW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZXJyb3IobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpIHtcbiAgICBpZiAodGhpcy5jb25maWcuc2lsZW5jZSA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmxvZ0xldmVsIDw9IGxvZ0xldmVsLkVSUk9SKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5vbmVycm9yKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm9uZXJyb3IobWVzc2FnZSwgb3B0aW9uYWxQYXJhbXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih7XG4gIGxvZ0xldmVsOiAnSU5GTycsXG4gIC8vIEJ5IGRlZmF1bHQgd2Ugc2lsZW5jZSB0aGUgbG9nZ2VyLiBJbiB0ZXN0cyB3ZSBzaG91bGQgY2FsbCBgY29uZmlndXJlTG9nZ2VyYFxuICAvLyBiZWxvdyB0byBzZXQgc2lsZW5jZTogZmFsc2UuXG4gIHNpbGVuY2U6IHRydWVcbn0pO1xuY29uc3QgY29uZmlndXJlTG9nZ2VyID0gY29uZmlnID0+IGxvZ2dlci5jb25maWd1cmUoY29uZmlnKTtcblxuY2xhc3MgQmFzZSB7XG4gIHN0YXRpYyBidWZmZXJJbmRleE9mKGFycmF5LCBlbGVtZW50LCBpc1NvcnRlZCA9IGZhbHNlKSB7XG4gICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICByZXR1cm4gQmFzZS5iaW5hcnlTZWFyY2goYXJyYXksIGVsZW1lbnQsIEJhc2UuY29tcGFyZSk7XG4gICAgfVxuICAgIGNvbnN0IGVxQ2hlY2tlciA9IChidWZmZXIxLCBidWZmZXIyKSA9PiB7XG4gICAgICBpZiAoYnVmZmVyMSA9PT0gYnVmZmVyMikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChidWZmZXIxLmxlbmd0aCAhPT0gYnVmZmVyMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChidWZmZXIxW2ldICE9PSBidWZmZXIyW2ldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlLmxpbmVhclNlYXJjaChhcnJheSwgZWxlbWVudCwgZXFDaGVja2VyKTtcbiAgfVxuICBzdGF0aWMgYmluYXJ5U2VhcmNoKGFycmF5LCBlbGVtZW50LCBjb21wYXJlRnVuY3Rpb24pIHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSBhcnJheS5sZW5ndGggLSAxO1xuXG4gICAgLy8gSXRlcmF0ZSB3aGlsZSBzdGFydCBub3QgbWVldHMgZW5kXG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgICAgLy8gRmluZCB0aGUgbWlkIGluZGV4XG4gICAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1pZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4sIGVxdWFsIHRvLCBvciBsZXNzIHRoYW4gc2VhcmNoIGVsZW1lbnQuXG4gICAgICBjb25zdCBvcmRlcmluZyA9IGNvbXBhcmVGdW5jdGlvbihhcnJheVttaWRdLCBlbGVtZW50KTtcblxuICAgICAgLy8gSWYgZWxlbWVudCBpcyBwcmVzZW50IGF0IG1pZCwgc3RhcnQgaXRlcmF0aW5nIGZvciBzZWFyY2hpbmcgZmlyc3QgYXBwZWFyYW5jZS5cbiAgICAgIGlmIChvcmRlcmluZyA9PT0gMCkge1xuICAgICAgICAvLyBMaW5lYXIgcmV2ZXJzZSBpdGVyYXRpb24gdW50aWwgdGhlIGZpcnN0IG1hdGNoaW5nIGl0ZW0gaW5kZXggaXMgZm91bmQuXG4gICAgICAgIGZvciAobGV0IGkgPSBtaWQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChjb21wYXJlRnVuY3Rpb24oYXJyYXlbaV0sIGVsZW1lbnQpID09PSAwKSBjb250aW51ZTtcbiAgICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IC8qIEVsc2UgbG9vayBpbiBsZWZ0IG9yIHJpZ2h0IGhhbGYgYWNjb3JkaW5nbHkgKi9lbHNlIGlmIChvcmRlcmluZyA8IDApIHtcbiAgICAgICAgc3RhcnQgPSBtaWQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gbWlkIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHN0YXRpYyBjb21wYXJlKGEsIGIpIHtcbiAgICAvLyBEZXRlcm1pbmUgdGhlIG1pbmltdW0gbGVuZ3RoIHRvIGNvbXBhcmVcbiAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuXG4gICAgLy8gQ29tcGFyZSBieXRlIGJ5IGJ5dGVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICByZXR1cm4gYVtpXSAtIGJbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgYWxsIGNvbXBhcmVkIGJ5dGVzIGFyZSBlcXVhbCwgY29tcGFyZSBsZW5ndGhzXG4gICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gIH1cbiAgc3RhdGljIGxpbmVhclNlYXJjaChhcnJheSwgZWxlbWVudCwgZXFDaGVja2VyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGVxQ2hlY2tlcihhcnJheVtpXSwgZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBzdGF0aWMgYnVmZmVyaWZ5KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBldGhlcnMuZ2V0Qnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGlzSGV4U3RyaW5nKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnICYmIC9eKDB4KT9bMC05QS1GYS1mXSokLy50ZXN0KHYpO1xuICB9XG4gIHN0YXRpYyBidWZmZXJUb0hleCh2YWx1ZSwgd2l0aFByZWZpeCA9IHRydWUpIHtcbiAgICBjb25zdCBwcmVmaXhlZCA9IGV0aGVycy5oZXhsaWZ5KHZhbHVlKTtcbiAgICByZXR1cm4gd2l0aFByZWZpeCA/IHByZWZpeGVkIDogcHJlZml4ZWQuc3Vic3RyaW5nKDIpO1xuICB9XG4gIHN0YXRpYyBidWZmZXJpZnlGbihmKSB7XG4gICAgcmV0dXJuIHZhbHVlID0+IHtcbiAgICAgIHJldHVybiBCYXNlLmJ1ZmZlcmlmeShmKHZhbHVlKSk7XG4gICAgfTtcbiAgfVxufVxuXG5jbGFzcyBNZXJrbGVUcmVlIGV4dGVuZHMgQmFzZSB7XG4gIGNvbnN0cnVjdG9yKGxlYXZlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmhhc2hGbiA9IHZvaWQgMDtcbiAgICB0aGlzLmxlYXZlcyA9IFtdO1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgdGhpcy5zb3J0TGVhdmVzID0gZmFsc2U7XG4gICAgdGhpcy5zb3J0UGFpcnMgPSBmYWxzZTtcbiAgICB0aGlzLnNvcnRMZWF2ZXMgPSAhIW9wdGlvbnMuc29ydExlYXZlcztcbiAgICB0aGlzLnNvcnRQYWlycyA9ICEhb3B0aW9ucy5zb3J0UGFpcnM7XG4gICAgdGhpcy5oYXNoRm4gPSBCYXNlLmJ1ZmZlcmlmeUZuKGV0aGVycy5rZWNjYWsyNTYpO1xuICAgIHRoaXMucHJvY2Vzc0xlYXZlcyhsZWF2ZXMpO1xuICB9XG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvcnRMZWF2ZXM6IHRoaXMuc29ydExlYXZlcyxcbiAgICAgIHNvcnRQYWlyczogdGhpcy5zb3J0UGFpcnNcbiAgICB9O1xuICB9XG4gIHByb2Nlc3NMZWF2ZXMobGVhdmVzKSB7XG4gICAgdGhpcy5sZWF2ZXMgPSBsZWF2ZXMubWFwKEJhc2UuYnVmZmVyaWZ5KTtcbiAgICBpZiAodGhpcy5zb3J0TGVhdmVzKSB7XG4gICAgICB0aGlzLmxlYXZlcyA9IHRoaXMubGVhdmVzLnNvcnQoQmFzZS5jb21wYXJlKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVIYXNoZXModGhpcy5sZWF2ZXMpO1xuICB9XG4gIGNyZWF0ZUhhc2hlcyhub2Rlcykge1xuICAgIHRoaXMubGF5ZXJzID0gW25vZGVzXTtcbiAgICB3aGlsZSAobm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgbGF5ZXJJbmRleCA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcbiAgICAgIHRoaXMubGF5ZXJzLnB1c2goW10pO1xuICAgICAgY29uc3QgbGF5ZXJMaW1pdCA9IG5vZGVzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKGkgPj0gbGF5ZXJMaW1pdCkge1xuICAgICAgICAgIHRoaXMubGF5ZXJzW2xheWVySW5kZXhdLnB1c2goLi4ubm9kZXMuc2xpY2UobGF5ZXJMaW1pdCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgLy8gcHVzaCBjb3B5IG9mIGhhc2ggYW5kIGNvbnRpbnVlIGl0ZXJhdGlvblxuICAgICAgICAgICAgdGhpcy5sYXllcnNbbGF5ZXJJbmRleF0ucHVzaChub2Rlc1tpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVmdCA9IG5vZGVzW2ldO1xuICAgICAgICBjb25zdCByaWdodCA9IGkgKyAxID09PSBub2Rlcy5sZW5ndGggPyBsZWZ0IDogbm9kZXNbaSArIDFdO1xuICAgICAgICBjb25zdCBjb21iaW5lZCA9IFtsZWZ0LCByaWdodF07XG4gICAgICAgIGlmICh0aGlzLnNvcnRQYWlycykge1xuICAgICAgICAgIGNvbWJpbmVkLnNvcnQoQmFzZS5jb21wYXJlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5oYXNoRm4oZXRoZXJzLmNvbmNhdChjb21iaW5lZCkpO1xuICAgICAgICB0aGlzLmxheWVyc1tsYXllckluZGV4XS5wdXNoKGhhc2gpO1xuICAgICAgfVxuICAgICAgbm9kZXMgPSB0aGlzLmxheWVyc1tsYXllckluZGV4XTtcbiAgICB9XG4gIH1cbiAgZ2V0Um9vdCgpIHtcbiAgICBpZiAodGhpcy5sYXllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJzW3RoaXMubGF5ZXJzLmxlbmd0aCAtIDFdWzBdIHx8IFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gIH1cbiAgZ2V0SGV4Um9vdCgpIHtcbiAgICByZXR1cm4gQmFzZS5idWZmZXJUb0hleCh0aGlzLmdldFJvb3QoKSk7XG4gIH1cbiAgZ2V0UHJvb2YobGVhZiwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIGxlYWYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlYWYgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgbGVhZiA9IEJhc2UuYnVmZmVyaWZ5KGxlYWYpO1xuICAgIGNvbnN0IHByb29mID0gW107XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGluZGV4KSkge1xuICAgICAgaW5kZXggPSAtMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEJhc2UuY29tcGFyZShsZWFmLCB0aGlzLmxlYXZlc1tpXSkgPT09IDApIHtcbiAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUeXBlIGZpeFxuICAgIGluZGV4ID0gaW5kZXg7XG4gICAgaWYgKGluZGV4IDw9IC0xKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnNbaV07XG4gICAgICBjb25zdCBpc1JpZ2h0Tm9kZSA9IGluZGV4ICUgMjtcbiAgICAgIGNvbnN0IHBhaXJJbmRleCA9IGlzUmlnaHROb2RlID8gaW5kZXggLSAxIDogaW5kZXggKyAxO1xuICAgICAgaWYgKHBhaXJJbmRleCA8IGxheWVyLmxlbmd0aCkge1xuICAgICAgICBwcm9vZi5wdXNoKHtcbiAgICAgICAgICBwb3NpdGlvbjogaXNSaWdodE5vZGUgPyAnbGVmdCcgOiAncmlnaHQnLFxuICAgICAgICAgIGRhdGE6IGxheWVyW3BhaXJJbmRleF1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBpbmRleCB0byBwYXJlbnQgaW5kZXhcbiAgICAgIGluZGV4ID0gaW5kZXggLyAyIHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHByb29mO1xuICB9XG4gIGdldEhleFByb29mKGxlYWYsIGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJvb2YobGVhZiwgaW5kZXgpLm1hcChpdGVtID0+IEJhc2UuYnVmZmVyVG9IZXgoaXRlbS5kYXRhKSk7XG4gIH1cbiAgdmVyaWZ5KHByb29mLCB0YXJnZXROb2RlLCByb290KSB7XG4gICAgbGV0IGhhc2ggPSBCYXNlLmJ1ZmZlcmlmeSh0YXJnZXROb2RlKTtcbiAgICByb290ID0gQmFzZS5idWZmZXJpZnkocm9vdCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb29mKSB8fCAhdGFyZ2V0Tm9kZSB8fCAhcm9vdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb29mLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gcHJvb2ZbaV07XG4gICAgICBsZXQgZGF0YTtcbiAgICAgIGxldCBpc0xlZnROb2RlO1xuICAgICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRhID0gQmFzZS5idWZmZXJpZnkobm9kZSk7XG4gICAgICAgIGlzTGVmdE5vZGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIGRhdGEgPSBub2RlLmRhdGE7XG4gICAgICAgIGlzTGVmdE5vZGUgPSBub2RlLnBvc2l0aW9uID09PSAnbGVmdCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG5vZGUgdG8gYmUgb2YgdHlwZSBzdHJpbmcgb3Igb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgICBpZiAodGhpcy5zb3J0UGFpcnMpIHtcbiAgICAgICAgaWYgKEJhc2UuY29tcGFyZShoYXNoLCBkYXRhKSA8IDApIHtcbiAgICAgICAgICBidWZmZXJzLnB1c2goaGFzaCwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVycy5wdXNoKGRhdGEsIGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGhhc2ggPSB0aGlzLmhhc2hGbihldGhlcnMuY29uY2F0KGJ1ZmZlcnMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChoYXNoKTtcbiAgICAgICAgYnVmZmVyc1tpc0xlZnROb2RlID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShkYXRhKTtcbiAgICAgICAgaGFzaCA9IHRoaXMuaGFzaEZuKGV0aGVycy5jb25jYXQoYnVmZmVycykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQmFzZS5jb21wYXJlKGhhc2gsIHJvb3QpID09PSAwO1xuICB9XG59XG5cbmNsYXNzIE1lcmtsZVRyZWVHZW5lcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihlbGVtZW50cywgdG9MZWFmKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLnRvTGVhZiA9IHZvaWQgMDtcbiAgICB0aGlzLnRyZWUgPSB2b2lkIDA7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIHRoaXMudG9MZWFmID0gdG9MZWFmO1xuICB9XG4gIGdlbmVyYXRlVHJlZSgpIHtcbiAgICBjb25zdCBoYXNoZWQgPSB0aGlzLmVsZW1lbnRzLm1hcChlID0+IHRoaXMudG9MZWFmKGUpKTtcbiAgICByZXR1cm4gbmV3IE1lcmtsZVRyZWUoaGFzaGVkLCB7XG4gICAgICBzb3J0UGFpcnM6IHRydWUsXG4gICAgICBzb3J0TGVhdmVzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZ2VuZXJhdGVSb290KCkge1xuICAgIGlmICghdGhpcy50cmVlKSB0aGlzLnRyZWUgPSB0aGlzLmdlbmVyYXRlVHJlZSgpO1xuICAgIHJldHVybiB0aGlzLnRyZWUuZ2V0SGV4Um9vdCgpO1xuICB9XG4gIGdlbmVyYXRlUHJvb2YoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy5lbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSkgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IG5vdCBmb3VuZCcpO1xuICAgIGlmICghdGhpcy50cmVlKSB0aGlzLnRyZWUgPSB0aGlzLmdlbmVyYXRlVHJlZSgpO1xuICAgIHJldHVybiB0aGlzLnRyZWUuZ2V0SGV4UHJvb2YodGhpcy50b0xlYWYoZWxlbWVudCkpO1xuICB9XG4gIHZlcmlmeVByb29mKGVsZW1lbnQsIHByb29mKSB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpKSB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgbm90IGZvdW5kJyk7XG4gICAgaWYgKCF0aGlzLnRyZWUpIHRoaXMudHJlZSA9IHRoaXMuZ2VuZXJhdGVUcmVlKCk7XG4gICAgcmV0dXJuIHRoaXMudHJlZS52ZXJpZnkocHJvb2YsIHRoaXMudG9MZWFmKGVsZW1lbnQpLCB0aGlzLmdlbmVyYXRlUm9vdCgpKTtcbiAgfVxufVxuY29uc3QgZ2V0U2FsZUl0ZW1zTGVhZiA9IGVsZW1lbnQgPT4gZXRoZXJzLnNvbGlkaXR5UGFja2VkS2VjY2FrMjU2KFsnYWRkcmVzcycsICd1aW50MjU2J10sIFtlbGVtZW50LmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgZWxlbWVudC50b2tlbklkXSk7XG5cbi8vIGV4cG9ydCBjb25zdCBnZXRFdGhlcnNDb25uZWN0aW9uSW5mbyA9ICh1cmw6IHN0cmluZywgcHJvamVjdEFjY2Vzc0tleT86IHN0cmluZywgand0Pzogc3RyaW5nKTogQ29ubmVjdGlvbkluZm8gPT4ge1xuLy8gICBjb25zdCBoZWFkZXJzOiB7XG4vLyAgICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyXG4vLyAgIH0gPSB7fVxuXG4vLyAgIGlmIChqd3QgJiYgand0Lmxlbmd0aCA+IDApIHtcbi8vICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQkVBUkVSICR7and0fWBcbi8vICAgfVxuLy8gICBpZiAocHJvamVjdEFjY2Vzc0tleSAmJiBwcm9qZWN0QWNjZXNzS2V5Lmxlbmd0aCA+IDApIHtcbi8vICAgICBoZWFkZXJzWydYLUFjY2Vzcy1LZXknXSA9IHByb2plY3RBY2Nlc3NLZXlcbi8vICAgfVxuXG4vLyAgIHJldHVybiB7XG4vLyAgICAgdXJsLFxuLy8gICAgIGhlYWRlcnMsXG4vLyAgICAgc2tpcEZldGNoU2V0dXA6IHRydWUsXG4vLyAgICAgZmV0Y2hPcHRpb25zOiB7XG4vLyAgICAgICBtb2RlOiAnY29ycycsXG4vLyAgICAgICBjYWNoZTogJ2ZvcmNlLWNhY2hlJyxcbi8vICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuLy8gICAgICAgcmVkaXJlY3Q6ICdmb2xsb3cnLFxuLy8gICAgICAgcmVmZXJyZXI6ICdjbGllbnQnXG4vLyAgICAgfVxuLy8gICB9XG4vLyB9XG5cbmNvbnN0IGdldEZldGNoUmVxdWVzdCA9ICh1cmwsIHByb2plY3RBY2Nlc3NLZXksIGp3dCkgPT4ge1xuICBjb25zdCByZXEgPSBuZXcgZXRoZXJzLkZldGNoUmVxdWVzdCh1cmwpO1xuICBpZiAoand0KSB7XG4gICAgcmVxLnNldEhlYWRlcignQXV0aG9yaXphdGlvbicsIGBCRUFSRVIgJHtqd3R9YCk7XG4gIH1cbiAgaWYgKHByb2plY3RBY2Nlc3NLZXkpIHtcbiAgICByZXEuc2V0SGVhZGVyKCdYLUFjY2Vzcy1LZXknLCBwcm9qZWN0QWNjZXNzS2V5KTtcbiAgfVxuICByZXR1cm4gcmVxO1xufTtcblxuY2xhc3MgUHJvbWlzZUNhY2hlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jYWNoZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG4gIGRvKGtleSwgdmFsaWRNaWxsaXNlY29uZHMsIHRhc2ssIC4uLmFyZ3MpIHtcbiAgICBrZXkgPSBgJHtrZXl9OiR7ZXRoZXJzLmlkKEpTT04uc3RyaW5naWZ5KGFyZ3MsIGRldGVybWluaXN0aWNhbGx5KSl9YDtcbiAgICBsZXQgZW50cnkgPSB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgaWYgKGVudHJ5LmV4cGlyYXRpb24pIHtcbiAgICAgICAgaWYgKG5ldyBEYXRlKCkgPj0gZW50cnkuZXhwaXJhdGlvbikge1xuICAgICAgICAgIGVudHJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgY29uc3QgZW50cnlfID0ge1xuICAgICAgICBwcm9taXNlOiB0YXNrKC4uLmFyZ3MpXG4gICAgICB9O1xuICAgICAgaWYgKHZhbGlkTWlsbGlzZWNvbmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW50cnlfLnByb21pc2UgPSBlbnRyeV8ucHJvbWlzZS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgZW50cnlfLmV4cGlyYXRpb24gPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgdmFsaWRNaWxsaXNlY29uZHMpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZW50cnkgPSBlbnRyeV87XG4gICAgICB0aGlzLmNhY2hlLnNldChrZXksIGVudHJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5LnByb21pc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNhbGx5KF9rZXksIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModmFsdWUpLnNvcnQoKSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBwcm9taXNpZnkoZiwgdGhpc0NvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICguLi5hKSB7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhcmdzLnB1c2goKGVyciwgcmVzdWx0KSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzdWx0KSk7XG4gICAgICAgIGF3YWl0IGYuYXBwbHkodGhpc0NvbnRleHQsIGFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5U3RyaW5nRnJvbU9iamVjdChuYW1lLCBvYmopIHtcbiAgY29uc3QgayA9IGVuY29kZVVSSUNvbXBvbmVudChuYW1lKTtcbiAgY29uc3QgdiA9IGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgcmV0dXJuIGAke2t9PSR7dn1gO1xufVxuZnVuY3Rpb24gcXVlcnlTdHJpbmdUb09iamVjdChxcykge1xuICBjb25zdCBwID0gcXMuc3BsaXQoJyYnKTtcbiAgY29uc3QgbyA9IHt9O1xuICBmb3IgKGNvbnN0IHYgb2YgcCkge1xuICAgIGNvbnN0IHogPSB2LnNwbGl0KCc9Jyk7XG4gICAgb1tkZWNvZGVVUklDb21wb25lbnQoelswXSldID0gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQoelsxXSkpO1xuICB9XG4gIHJldHVybiBvO1xufVxuXG5jb25zdCBnZXRSYW5kb21JbnQgPSAobWluID0gMCwgbWF4ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpID0+IHtcbiAgbWluID0gTWF0aC5jZWlsKG1pbik7XG4gIG1heCA9IE1hdGguZmxvb3IobWF4KTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG59O1xuXG4vLyBzYW5pdGl6ZU51bWJlclN0cmluZyBhY2NlcHRzIGEgbnVtYmVyIHN0cmluZyBhbmQgcmV0dXJucyBiYWNrIGEgY2xlYW4gbnVtYmVyIHN0cmluZy5cbi8vIEZvciBleGFtcGxlLCBpbnB1dCAnMTIzNC41Njc4JyB3aWxsIHJldHVybiAnMTIzNC41Njc4JyBidXQgJzEyamF2YXNjcmlwdDp7fWV0Yycgd2lsbCByZXR1cm4gJzEyJ1xuY29uc3Qgc2FuaXRpemVOdW1iZXJTdHJpbmcgPSBudW1TdHJpbmcgPT4ge1xuICBpZiAoIW51bVN0cmluZyB8fCB0eXBlb2YgbnVtU3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCB2ID0gbnVtU3RyaW5nLm1hdGNoKC9bXFxkLl0rLyk7XG4gIHJldHVybiB2ICYmIHYubGVuZ3RoID4gMCA/IHZbMF0udHJpbSgpIDogJyc7XG59O1xuXG4vLyBzYW5pdGl6ZUFscGhhbnVtZXJpYyBhY2NlcHRzIGFueSBzdHJpbmcgYW5kIHJldHVybnMgYWxwaGFudW1lcmljIGNvbnRlbnRzIG9ubHlcbmNvbnN0IHNhbml0aXplQWxwaGFudW1lcmljID0gYWxwaGFudW0gPT4ge1xuICBpZiAoIWFscGhhbnVtIHx8IHR5cGVvZiBhbHBoYW51bSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgY29uc3QgdiA9IGFscGhhbnVtLm1hdGNoKC9bXFx3XFxzXFxkXSsvKTtcbiAgcmV0dXJuIHYgJiYgdi5sZW5ndGggPiAwID8gdlswXS50cmltKCkgOiAnJztcbn07XG5cbi8vIHNhbml0aXplSG9zdCBhY2NlcHRzIGFueSBzdHJpbmcgYW5kIHJldHVybnMgdmFsaWQgaG9zdCBzdHJpbmdcbmNvbnN0IHNhbml0aXplSG9zdCA9IGhvc3QgPT4ge1xuICBpZiAoIWhvc3QgfHwgdHlwZW9mIGhvc3QgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IHYgPSBob3N0Lm1hdGNoKC9bXFx3XFxkLlxcLTpcXC9dKy8pO1xuICByZXR1cm4gdiAmJiB2Lmxlbmd0aCA+IDAgPyB2WzBdLnRyaW0oKSA6ICcnO1xufTtcblxuY29uc3Qgc2xlZXAgPSB0ID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9LCB0KTtcbiAgfSk7XG59O1xuXG5jb25zdCBlbmNvZGVUeXBlZERhdGFIYXNoID0gdHlwZWREYXRhID0+IHtcbiAgY29uc3QgdHlwZXMgPSBfZXh0ZW5kcyh7fSwgdHlwZWREYXRhLnR5cGVzKTtcblxuICAvLyByZW1vdmUgRUlQNzEyRG9tYWluIGtleSBmcm9tIHR5cGVzIGFzIGV0aGVycyB3aWxsIGF1dG8tZ2VuIGl0IGluXG4gIC8vIHRoZSBoYXNoIGVuY29kZXIgYmVsb3dcbiAgZGVsZXRlIHR5cGVzWydFSVA3MTJEb21haW4nXTtcbiAgcmV0dXJuIGV0aGVycy5UeXBlZERhdGFFbmNvZGVyLmhhc2godHlwZWREYXRhLmRvbWFpbiwgdHlwZXMsIHR5cGVkRGF0YS5tZXNzYWdlKTtcbn07XG5jb25zdCBlbmNvZGVUeXBlZERhdGFEaWdlc3QgPSB0eXBlZERhdGEgPT4ge1xuICByZXR1cm4gZXRoZXJzLmdldEJ5dGVzKGVuY29kZVR5cGVkRGF0YUhhc2godHlwZWREYXRhKSk7XG59O1xuXG5jb25zdCB7XG4gIGRlZmluZVByb3BlcnRpZXMsXG4gIHJlc29sdmVQcm9wZXJ0aWVzXG59ID0gZXRoZXJzO1xuXG4vLyB1cmxDbGVhbiByZW1vdmVzIGRvdWJsZSBzbGFzaGVzIGZyb20gdXJsIHBhdGhcbmNvbnN0IHVybENsZWFuID0gdXJsID0+IHVybC5yZXBsYWNlKC8oW146XVxcLylcXC8rL2csICckMScpO1xuXG5leHBvcnQgeyBMb2dnZXIsIE1BWF9VSU5UXzI1NiwgTWVya2xlVHJlZUdlbmVyYXRvciwgUHJvbWlzZUNhY2hlLCBiYXNlNjREZWNvZGUsIGJhc2U2NERlY29kZU9iamVjdCwgYmFzZTY0RW5jb2RlLCBiYXNlNjRFbmNvZGVPYmplY3QsIGJpZ2ludFJlcGxhY2VyLCBiaWdpbnRSZXZpdmVyLCBjb25maWd1cmVMb2dnZXIsIGRlZmluZVByb3BlcnRpZXMsIGVuY29kZU1lc3NhZ2VEaWdlc3QsIGVuY29kZVR5cGVkRGF0YURpZ2VzdCwgZW5jb2RlVHlwZWREYXRhSGFzaCwgZXh0cmFjdFByb2plY3RJZEZyb21BY2Nlc3NLZXksIGZvcm1hdEV0aGVyLCBmb3JtYXRVbml0cywgZ2V0RmV0Y2hSZXF1ZXN0LCBnZXRSYW5kb21JbnQsIGdldFNhbGVJdGVtc0xlYWYsIGlzQmlnTnVtYmVyaXNoLCBpc0Jyb3dzZXIsIGlzTm9kZSwgand0RGVjb2RlQ2xhaW1zLCBsb2dnZXIsIHBhY2tNZXNzYWdlRGF0YSwgcGFyc2VFdGhlciwgcGFyc2VVbml0cywgcHJvbWlzaWZ5LCBxdWVyeVN0cmluZ0Zyb21PYmplY3QsIHF1ZXJ5U3RyaW5nVG9PYmplY3QsIHJlc29sdmVQcm9wZXJ0aWVzLCBzYW5pdGl6ZUFscGhhbnVtZXJpYywgc2FuaXRpemVIb3N0LCBzYW5pdGl6ZU51bWJlclN0cmluZywgc2xlZXAsIHN1YkRpZ2VzdE9mLCB0b0hleFN0cmluZywgdXJsQ2xlYW4gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/.pnpm/@0xsequence+utils@2.2.13_ethers@6.13.5_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/utils/dist/0xsequence-utils.esm.js\n");

/***/ })

};
;