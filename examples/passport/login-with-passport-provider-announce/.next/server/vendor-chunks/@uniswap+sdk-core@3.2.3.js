"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@uniswap+sdk-core@3.2.3";
exports.ids = ["vendor-chunks/@uniswap+sdk-core@3.2.3"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/.pnpm/@uniswap+sdk-core@3.2.3/node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@uniswap+sdk-core@3.2.3/node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CurrencyAmount: () => (/* binding */ CurrencyAmount),\n/* harmony export */   Ether: () => (/* binding */ Ether),\n/* harmony export */   Fraction: () => (/* binding */ Fraction),\n/* harmony export */   MaxUint256: () => (/* binding */ MaxUint256),\n/* harmony export */   NativeCurrency: () => (/* binding */ NativeCurrency),\n/* harmony export */   Percent: () => (/* binding */ Percent),\n/* harmony export */   Price: () => (/* binding */ Price),\n/* harmony export */   Rounding: () => (/* binding */ Rounding),\n/* harmony export */   SupportedChainId: () => (/* binding */ SupportedChainId),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   TradeType: () => (/* binding */ TradeType),\n/* harmony export */   WETH9: () => (/* binding */ WETH9),\n/* harmony export */   computePriceImpact: () => (/* binding */ computePriceImpact),\n/* harmony export */   sortedInsert: () => (/* binding */ sortedInsert),\n/* harmony export */   sqrt: () => (/* binding */ sqrt),\n/* harmony export */   validateAndParseAddress: () => (/* binding */ validateAndParseAddress)\n/* harmony export */ });\n/* harmony import */ var jsbi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsbi */ \"(ssr)/../../../node_modules/.pnpm/jsbi@3.2.5/node_modules/jsbi/dist/jsbi.mjs\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/../../../node_modules/.pnpm/tiny-invariant@1.3.1/node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var decimal_js_light__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! decimal.js-light */ \"(ssr)/../../../node_modules/.pnpm/decimal.js-light@2.5.1/node_modules/decimal.js-light/decimal.mjs\");\n/* harmony import */ var big_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big.js */ \"(ssr)/../../../node_modules/.pnpm/big.js@5.2.2/node_modules/big.js/big.mjs\");\n/* harmony import */ var toformat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! toformat */ \"(ssr)/../../../node_modules/.pnpm/toformat@2.0.0/node_modules/toformat/toFormat.js\");\n/* harmony import */ var toformat__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(toformat__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/../../../node_modules/.pnpm/@ethersproject+address@5.7.0/node_modules/@ethersproject/address/lib.esm/index.js\");\n\n\n\n\n\n\n\nvar SupportedChainId;\n\n(function (SupportedChainId) {\n  SupportedChainId[SupportedChainId[\"MAINNET\"] = 1] = \"MAINNET\";\n  SupportedChainId[SupportedChainId[\"GOERLI\"] = 5] = \"GOERLI\";\n  SupportedChainId[SupportedChainId[\"SEPOLIA\"] = 11155111] = \"SEPOLIA\";\n  SupportedChainId[SupportedChainId[\"ARBITRUM_ONE\"] = 42161] = \"ARBITRUM_ONE\";\n  SupportedChainId[SupportedChainId[\"ARBITRUM_GOERLI\"] = 421613] = \"ARBITRUM_GOERLI\";\n  SupportedChainId[SupportedChainId[\"OPTIMISM\"] = 10] = \"OPTIMISM\";\n  SupportedChainId[SupportedChainId[\"OPTIMISM_GOERLI\"] = 420] = \"OPTIMISM_GOERLI\";\n  SupportedChainId[SupportedChainId[\"POLYGON\"] = 137] = \"POLYGON\";\n  SupportedChainId[SupportedChainId[\"POLYGON_MUMBAI\"] = 80001] = \"POLYGON_MUMBAI\";\n  SupportedChainId[SupportedChainId[\"CELO\"] = 42220] = \"CELO\";\n  SupportedChainId[SupportedChainId[\"CELO_ALFAJORES\"] = 44787] = \"CELO_ALFAJORES\";\n  SupportedChainId[SupportedChainId[\"BNB\"] = 56] = \"BNB\";\n})(SupportedChainId || (SupportedChainId = {}));\n\nvar TradeType;\n\n(function (TradeType) {\n  TradeType[TradeType[\"EXACT_INPUT\"] = 0] = \"EXACT_INPUT\";\n  TradeType[TradeType[\"EXACT_OUTPUT\"] = 1] = \"EXACT_OUTPUT\";\n})(TradeType || (TradeType = {}));\n\nvar Rounding;\n\n(function (Rounding) {\n  Rounding[Rounding[\"ROUND_DOWN\"] = 0] = \"ROUND_DOWN\";\n  Rounding[Rounding[\"ROUND_HALF_UP\"] = 1] = \"ROUND_HALF_UP\";\n  Rounding[Rounding[\"ROUND_UP\"] = 2] = \"ROUND_UP\";\n})(Rounding || (Rounding = {}));\n\nvar MaxUint256 = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar _toSignificantRoundin, _toFixedRounding;\nvar Decimal = /*#__PURE__*/toformat__WEBPACK_IMPORTED_MODULE_4___default()(decimal_js_light__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\nvar Big = /*#__PURE__*/toformat__WEBPACK_IMPORTED_MODULE_4___default()(big_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nvar toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal.ROUND_UP, _toSignificantRoundin);\nvar toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);\nvar Fraction = /*#__PURE__*/function () {\n  function Fraction(numerator, denominator) {\n    if (denominator === void 0) {\n      denominator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(1);\n    }\n\n    this.numerator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(numerator);\n    this.denominator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(denominator);\n  }\n\n  Fraction.tryParseFraction = function tryParseFraction(fractionish) {\n    if (fractionish instanceof jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"] || typeof fractionish === 'number' || typeof fractionish === 'string') return new Fraction(fractionish);\n    if ('numerator' in fractionish && 'denominator' in fractionish) return fractionish;\n    throw new Error('Could not parse fraction');\n  } // performs floor division\n  ;\n\n  var _proto = Fraction.prototype;\n\n  _proto.invert = function invert() {\n    return new Fraction(this.denominator, this.numerator);\n  };\n\n  _proto.add = function add(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.numerator, otherParsed.numerator), this.denominator);\n    }\n\n    return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator)), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.denominator, otherParsed.denominator));\n  };\n\n  _proto.subtract = function subtract(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtract(this.numerator, otherParsed.numerator), this.denominator);\n    }\n\n    return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtract(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator)), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.denominator, otherParsed.denominator));\n  };\n\n  _proto.lessThan = function lessThan(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThan(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator));\n  };\n\n  _proto.equalTo = function equalTo(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator));\n  };\n\n  _proto.greaterThan = function greaterThan(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].greaterThan(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator));\n  };\n\n  _proto.multiply = function multiply(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.numerator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.denominator, otherParsed.denominator));\n  };\n\n  _proto.divide = function divide(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.denominator, otherParsed.numerator));\n  };\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_HALF_UP;\n    }\n\n    !Number.isInteger(significantDigits) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, significantDigits + \" is not an integer.\") : 0 : void 0;\n    !(significantDigits > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, significantDigits + \" is not positive.\") : 0 : void 0;\n    Decimal.set({\n      precision: significantDigits + 1,\n      rounding: toSignificantRounding[rounding]\n    });\n    var quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);\n    return quotient.toFormat(quotient.decimalPlaces(), format);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_HALF_UP;\n    }\n\n    !Number.isInteger(decimalPlaces) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, decimalPlaces + \" is not an integer.\") : 0 : void 0;\n    !(decimalPlaces >= 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, decimalPlaces + \" is negative.\") : 0 : void 0;\n    Big.DP = decimalPlaces;\n    Big.RM = toFixedRounding[rounding];\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);\n  }\n  /**\r\n   * Helper method for converting any super class back to a fraction\r\n   */\n  ;\n\n  _createClass(Fraction, [{\n    key: \"quotient\",\n    get: function get() {\n      return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(this.numerator, this.denominator);\n    } // remainder after floor division\n\n  }, {\n    key: \"remainder\",\n    get: function get() {\n      return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].remainder(this.numerator, this.denominator), this.denominator);\n    }\n  }, {\n    key: \"asFraction\",\n    get: function get() {\n      return new Fraction(this.numerator, this.denominator);\n    }\n  }]);\n\n  return Fraction;\n}();\n\nvar Big$1 = /*#__PURE__*/toformat__WEBPACK_IMPORTED_MODULE_4___default()(big_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nvar CurrencyAmount = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(CurrencyAmount, _Fraction);\n\n  function CurrencyAmount(currency, numerator, denominator) {\n    var _this;\n\n    _this = _Fraction.call(this, numerator, denominator) || this;\n    !jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThanOrEqual(_this.quotient, MaxUint256) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'AMOUNT') : 0 : void 0;\n    _this.currency = currency;\n    _this.decimalScale = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exponentiate(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(10), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(currency.decimals));\n    return _this;\n  }\n  /**\r\n   * Returns a new currency amount instance from the unitless amount of token, i.e. the raw amount\r\n   * @param currency the currency in the amount\r\n   * @param rawAmount the raw token or ether amount\r\n   */\n\n\n  CurrencyAmount.fromRawAmount = function fromRawAmount(currency, rawAmount) {\n    return new CurrencyAmount(currency, rawAmount);\n  }\n  /**\r\n   * Construct a currency amount with a denominator that is not equal to 1\r\n   * @param currency the currency\r\n   * @param numerator the numerator of the fractional token amount\r\n   * @param denominator the denominator of the fractional token amount\r\n   */\n  ;\n\n  CurrencyAmount.fromFractionalAmount = function fromFractionalAmount(currency, numerator, denominator) {\n    return new CurrencyAmount(currency, numerator, denominator);\n  };\n\n  var _proto = CurrencyAmount.prototype;\n\n  _proto.add = function add(other) {\n    !this.currency.equals(other.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'CURRENCY') : 0 : void 0;\n\n    var added = _Fraction.prototype.add.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, added.numerator, added.denominator);\n  };\n\n  _proto.subtract = function subtract(other) {\n    !this.currency.equals(other.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'CURRENCY') : 0 : void 0;\n\n    var subtracted = _Fraction.prototype.subtract.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator);\n  };\n\n  _proto.multiply = function multiply(other) {\n    var multiplied = _Fraction.prototype.multiply.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator);\n  };\n\n  _proto.divide = function divide(other) {\n    var divided = _Fraction.prototype.divide.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, divided.numerator, divided.denominator);\n  };\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 6;\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_DOWN;\n    }\n\n    return _Fraction.prototype.divide.call(this, this.decimalScale).toSignificant(significantDigits, format, rounding);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = this.currency.decimals;\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_DOWN;\n    }\n\n    !(decimalPlaces <= this.currency.decimals) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'DECIMALS') : 0 : void 0;\n    return _Fraction.prototype.divide.call(this, this.decimalScale).toFixed(decimalPlaces, format, rounding);\n  };\n\n  _proto.toExact = function toExact(format) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n\n    Big$1.DP = this.currency.decimals;\n    return new Big$1(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format);\n  };\n\n  _createClass(CurrencyAmount, [{\n    key: \"wrapped\",\n    get: function get() {\n      if (this.currency.isToken) return this;\n      return CurrencyAmount.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator);\n    }\n  }]);\n\n  return CurrencyAmount;\n}(Fraction);\n\nvar ONE_HUNDRED = /*#__PURE__*/new Fraction( /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(100));\n/**\r\n * Converts a fraction to a percent\r\n * @param fraction the fraction to convert\r\n */\n\nfunction toPercent(fraction) {\n  return new Percent(fraction.numerator, fraction.denominator);\n}\n\nvar Percent = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(Percent, _Fraction);\n\n  function Percent() {\n    var _this;\n\n    _this = _Fraction.apply(this, arguments) || this;\n    /**\r\n     * This boolean prevents a fraction from being interpreted as a Percent\r\n     */\n\n    _this.isPercent = true;\n    return _this;\n  }\n\n  var _proto = Percent.prototype;\n\n  _proto.add = function add(other) {\n    return toPercent(_Fraction.prototype.add.call(this, other));\n  };\n\n  _proto.subtract = function subtract(other) {\n    return toPercent(_Fraction.prototype.subtract.call(this, other));\n  };\n\n  _proto.multiply = function multiply(other) {\n    return toPercent(_Fraction.prototype.multiply.call(this, other));\n  };\n\n  _proto.divide = function divide(other) {\n    return toPercent(_Fraction.prototype.divide.call(this, other));\n  };\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 5;\n    }\n\n    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toSignificant(significantDigits, format, rounding);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = 2;\n    }\n\n    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toFixed(decimalPlaces, format, rounding);\n  };\n\n  return Percent;\n}(Fraction);\n\nvar Price = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(Price, _Fraction);\n\n  /**\r\n   * Construct a price, either with the base and quote currency amount, or the\r\n   * @param args\r\n   */\n  function Price() {\n    var _this;\n\n    var baseCurrency, quoteCurrency, denominator, numerator;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 4) {\n      baseCurrency = args[0];\n      quoteCurrency = args[1];\n      denominator = args[2];\n      numerator = args[3];\n    } else {\n      var result = args[0].quoteAmount.divide(args[0].baseAmount);\n      var _ref = [args[0].baseAmount.currency, args[0].quoteAmount.currency, result.denominator, result.numerator];\n      baseCurrency = _ref[0];\n      quoteCurrency = _ref[1];\n      denominator = _ref[2];\n      numerator = _ref[3];\n    }\n\n    _this = _Fraction.call(this, numerator, denominator) || this;\n    _this.baseCurrency = baseCurrency;\n    _this.quoteCurrency = quoteCurrency;\n    _this.scalar = new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exponentiate(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(10), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(baseCurrency.decimals)), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exponentiate(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(10), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(quoteCurrency.decimals)));\n    return _this;\n  }\n  /**\r\n   * Flip the price, switching the base and quote currency\r\n   */\n\n\n  var _proto = Price.prototype;\n\n  _proto.invert = function invert() {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);\n  }\n  /**\r\n   * Multiply the price by another price, returning a new price. The other price must have the same base currency as this price's quote currency\r\n   * @param other the other price\r\n   */\n  ;\n\n  _proto.multiply = function multiply(other) {\n    !this.quoteCurrency.equals(other.baseCurrency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n\n    var fraction = _Fraction.prototype.multiply.call(this, other);\n\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);\n  }\n  /**\r\n   * Return the amount of quote currency corresponding to a given amount of the base currency\r\n   * @param currencyAmount the amount of base currency to quote against the price\r\n   */\n  ;\n\n  _proto.quote = function quote(currencyAmount) {\n    !currencyAmount.currency.equals(this.baseCurrency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n\n    var result = _Fraction.prototype.multiply.call(this, currencyAmount);\n\n    return CurrencyAmount.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator);\n  }\n  /**\r\n   * Get the value scaled by decimals for formatting\r\n   * @private\r\n   */\n  ;\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 6;\n    }\n\n    return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = 4;\n    }\n\n    return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding);\n  };\n\n  _createClass(Price, [{\n    key: \"adjustedForDecimals\",\n    get: function get() {\n      return _Fraction.prototype.multiply.call(this, this.scalar);\n    }\n  }]);\n\n  return Price;\n}(Fraction);\n\n/**\r\n * A currency is any fungible financial instrument, including Ether, all ERC20 tokens, and other chain-native currencies\r\n */\n\nvar BaseCurrency =\n/**\r\n * Constructs an instance of the base class `BaseCurrency`.\r\n * @param chainId the chain ID on which this currency resides\r\n * @param decimals decimals of the currency\r\n * @param symbol symbol of the currency\r\n * @param name of the currency\r\n */\nfunction BaseCurrency(chainId, decimals, symbol, name) {\n  !Number.isSafeInteger(chainId) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'CHAIN_ID') : 0 : void 0;\n  !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'DECIMALS') : 0 : void 0;\n  this.chainId = chainId;\n  this.decimals = decimals;\n  this.symbol = symbol;\n  this.name = name;\n};\n\n/**\r\n * Represents the native currency of the chain on which it resides, e.g.\r\n */\n\nvar NativeCurrency = /*#__PURE__*/function (_BaseCurrency) {\n  _inheritsLoose(NativeCurrency, _BaseCurrency);\n\n  function NativeCurrency() {\n    var _this;\n\n    _this = _BaseCurrency.apply(this, arguments) || this;\n    _this.isNative = true;\n    _this.isToken = false;\n    return _this;\n  }\n\n  return NativeCurrency;\n}(BaseCurrency);\n\n/**\r\n * Validates an address and returns the parsed (checksummed) version of that address\r\n * @param address the unchecksummed hex address\r\n */\n\nfunction validateAndParseAddress(address) {\n  try {\n    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_5__.getAddress)(address);\n  } catch (error) {\n    throw new Error(address + \" is not a valid address.\");\n  }\n} // Checks a string starts with 0x, is 42 characters long and contains only hex characters after 0x\n\nvar startsWith0xLen42HexRegex = /^0x[0-9a-fA-F]{40}$/;\n/**\r\n * Checks if an address is valid by checking 0x prefix, length === 42 and hex encoding.\r\n * @param address the unchecksummed hex address\r\n */\n\nfunction checkValidAddress(address) {\n  if (startsWith0xLen42HexRegex.test(address)) {\n    return address;\n  }\n\n  throw new Error(address + \" is not a valid address.\");\n}\n\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\n\nvar Token = /*#__PURE__*/function (_BaseCurrency) {\n  _inheritsLoose(Token, _BaseCurrency);\n\n  /**\r\n   *\r\n   * @param chainId {@link BaseCurrency#chainId}\r\n   * @param address The contract address on the chain on which this token lives\r\n   * @param decimals {@link BaseCurrency#decimals}\r\n   * @param symbol {@link BaseCurrency#symbol}\r\n   * @param name {@link BaseCurrency#name}\r\n   * @param bypassChecksum If true it only checks for length === 42, startsWith 0x and contains only hex characters\r\n   */\n  function Token(chainId, address, decimals, symbol, name, bypassChecksum) {\n    var _this;\n\n    _this = _BaseCurrency.call(this, chainId, decimals, symbol, name) || this;\n    _this.isNative = false;\n    _this.isToken = true;\n\n    if (bypassChecksum) {\n      _this.address = checkValidAddress(address);\n    } else {\n      _this.address = validateAndParseAddress(address);\n    }\n\n    return _this;\n  }\n  /**\r\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n   * @param other other token to compare\r\n   */\n\n\n  var _proto = Token.prototype;\n\n  _proto.equals = function equals(other) {\n    return other.isToken && this.chainId === other.chainId && this.address.toLowerCase() === other.address.toLowerCase();\n  }\n  /**\r\n   * Returns true if the address of this token sorts before the address of the other token\r\n   * @param other other token to compare\r\n   * @throws if the tokens have the same address\r\n   * @throws if the tokens are on different chains\r\n   */\n  ;\n\n  _proto.sortsBefore = function sortsBefore(other) {\n    !(this.chainId === other.chainId) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'CHAIN_IDS') : 0 : void 0;\n    !(this.address.toLowerCase() !== other.address.toLowerCase()) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'ADDRESSES') : 0 : void 0;\n    return this.address.toLowerCase() < other.address.toLowerCase();\n  }\n  /**\r\n   * Return this token, which does not need to be wrapped\r\n   */\n  ;\n\n  _createClass(Token, [{\n    key: \"wrapped\",\n    get: function get() {\n      return this;\n    }\n  }]);\n\n  return Token;\n}(BaseCurrency);\n\nvar _WETH;\n/**\r\n * Known WETH9 implementation addresses, used in our implementation of Ether#wrapped\r\n */\n\nvar WETH9 = (_WETH = {}, _WETH[1] = /*#__PURE__*/new Token(1, '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', 18, 'WETH', 'Wrapped Ether'), _WETH[3] = /*#__PURE__*/new Token(3, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'), _WETH[4] = /*#__PURE__*/new Token(4, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'), _WETH[5] = /*#__PURE__*/new Token(5, '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6', 18, 'WETH', 'Wrapped Ether'), _WETH[42] = /*#__PURE__*/new Token(42, '0xd0A1E359811322d97991E03f863a0C30C2cF029C', 18, 'WETH', 'Wrapped Ether'), _WETH[10] = /*#__PURE__*/new Token(10, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[69] = /*#__PURE__*/new Token(69, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[42161] = /*#__PURE__*/new Token(42161, '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1', 18, 'WETH', 'Wrapped Ether'), _WETH[421611] = /*#__PURE__*/new Token(421611, '0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681', 18, 'WETH', 'Wrapped Ether'), _WETH);\n\n/**\r\n * Ether is the main usage of a 'native' currency, i.e. for Ethereum mainnet and all testnets\r\n */\n\nvar Ether = /*#__PURE__*/function (_NativeCurrency) {\n  _inheritsLoose(Ether, _NativeCurrency);\n\n  function Ether(chainId) {\n    return _NativeCurrency.call(this, chainId, 18, 'ETH', 'Ether') || this;\n  }\n\n  Ether.onChain = function onChain(chainId) {\n    var _this$_etherCache$cha;\n\n    return (_this$_etherCache$cha = this._etherCache[chainId]) != null ? _this$_etherCache$cha : this._etherCache[chainId] = new Ether(chainId);\n  };\n\n  var _proto = Ether.prototype;\n\n  _proto.equals = function equals(other) {\n    return other.isNative && other.chainId === this.chainId;\n  };\n\n  _createClass(Ether, [{\n    key: \"wrapped\",\n    get: function get() {\n      var weth9 = WETH9[this.chainId];\n      !!!weth9 ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'WRAPPED') : 0 : void 0;\n      return weth9;\n    }\n  }]);\n\n  return Ether;\n}(NativeCurrency);\nEther._etherCache = {};\n\n/**\r\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\r\n * @param midPrice mid price before the trade\r\n * @param inputAmount the input amount of the trade\r\n * @param outputAmount the output amount of the trade\r\n */\n\nfunction computePriceImpact(midPrice, inputAmount, outputAmount) {\n  var quotedOutputAmount = midPrice.quote(inputAmount); // calculate price impact := (exactQuote - outputAmount) / exactQuote\n\n  var priceImpact = quotedOutputAmount.subtract(outputAmount).divide(quotedOutputAmount);\n  return new Percent(priceImpact.numerator, priceImpact.denominator);\n}\n\n// `maxSize` by removing the last item\n\nfunction sortedInsert(items, add, maxSize, comparator) {\n  !(maxSize > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'MAX_SIZE_ZERO') : 0 : void 0; // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n\n  !(items.length <= maxSize) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'ITEMS_SIZE') : 0 : void 0; // short circuit first item add\n\n  if (items.length === 0) {\n    items.push(add);\n    return null;\n  } else {\n    var isFull = items.length === maxSize; // short circuit if full and the additional item does not come before the last item\n\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add;\n    }\n\n    var lo = 0,\n        hi = items.length;\n\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n\n    items.splice(lo, 0, add);\n    return isFull ? items.pop() : null;\n  }\n}\n\nvar MAX_SAFE_INTEGER = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(Number.MAX_SAFE_INTEGER);\nvar ZERO = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(0);\nvar ONE = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(1);\nvar TWO = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(2);\n/**\r\n * Computes floor(sqrt(value))\r\n * @param value the value for which to compute the square root, rounded down\r\n */\n\nfunction sqrt(value) {\n  !jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].greaterThanOrEqual(value, ZERO) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'NEGATIVE') : 0 : void 0; // rely on built in sqrt if possible\n\n  if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThan(value, MAX_SAFE_INTEGER)) {\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(Math.floor(Math.sqrt(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toNumber(value))));\n  }\n\n  var z;\n  var x;\n  z = value;\n  x = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(value, TWO), ONE);\n\n  while (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThan(x, z)) {\n    z = x;\n    x = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(value, x), x), TWO);\n  }\n\n  return z;\n}\n\n\n//# sourceMappingURL=sdk-core.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B1bmlzd2FwK3Nkay1jb3JlQDMuMi4zL25vZGVfbW9kdWxlcy9AdW5pc3dhcC9zZGstY29yZS9kaXN0L3Nkay1jb3JlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUNlO0FBQ0M7QUFDZDtBQUNNO0FBQ29COztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0Qjs7QUFFN0IsOEJBQThCLDRDQUFJOztBQUVsQztBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLCtDQUFRLENBQUMsd0RBQVE7QUFDNUMsdUJBQXVCLCtDQUFRLENBQUMsOENBQUk7QUFDcEMsdURBQXVEO0FBQ3ZELDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQUk7QUFDeEI7O0FBRUEscUJBQXFCLDRDQUFJO0FBQ3pCLHVCQUF1Qiw0Q0FBSTtBQUMzQjs7QUFFQTtBQUNBLCtCQUErQiw0Q0FBSTtBQUNuQztBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsNENBQUk7QUFDWiwwQkFBMEIsNENBQUk7QUFDOUI7O0FBRUEsd0JBQXdCLDRDQUFJLEtBQUssNENBQUksb0RBQW9ELDRDQUFJLHFEQUFxRCw0Q0FBSTtBQUN0Sjs7QUFFQTtBQUNBOztBQUVBLFFBQVEsNENBQUk7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LEtBQXFDLEdBQUcsMERBQVMsd0JBQXdCLENBQWdCLFdBQVc7O0FBRW5JO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLDRDQUFJO0FBQ3hDLHdCQUF3Qiw0Q0FBSTtBQUM1Qix1QkFBdUIsNENBQUk7QUFDM0IsdUJBQXVCLDRDQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyw0Q0FBSSxtQ0FBbUMsS0FBcUMsR0FBRywwREFBUyxzQkFBc0IsQ0FBZ0IsV0FBVzs7QUFFNUksTUFBTSw0Q0FBSTtBQUNWLFdBQVcsNENBQUksNkJBQTZCLDRDQUFJO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNENBQUksS0FBSyw0Q0FBSTs7QUFFbkIsU0FBUyw0Q0FBSTtBQUNiO0FBQ0EsUUFBUSw0Q0FBSSxRQUFRLDRDQUFJLEtBQUssNENBQUk7QUFDakM7O0FBRUE7QUFDQTs7QUFFNk07QUFDN00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZXhhbXBsZXMvbG9naW4td2l0aC1wYXNzcG9ydC1wcm92aWRlci1hbm5vdW5jZS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHVuaXN3YXArc2RrLWNvcmVAMy4yLjMvbm9kZV9tb2R1bGVzL0B1bmlzd2FwL3Nkay1jb3JlL2Rpc3Qvc2RrLWNvcmUuZXNtLmpzP2Y2YmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEpTQkkgZnJvbSAnanNiaSc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3RpbnktaW52YXJpYW50JztcbmltcG9ydCBfRGVjaW1hbCBmcm9tICdkZWNpbWFsLmpzLWxpZ2h0JztcbmltcG9ydCBfQmlnIGZyb20gJ2JpZy5qcyc7XG5pbXBvcnQgdG9Gb3JtYXQgZnJvbSAndG9mb3JtYXQnO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L2FkZHJlc3MnO1xuXG52YXIgU3VwcG9ydGVkQ2hhaW5JZDtcblxuKGZ1bmN0aW9uIChTdXBwb3J0ZWRDaGFpbklkKSB7XG4gIFN1cHBvcnRlZENoYWluSWRbU3VwcG9ydGVkQ2hhaW5JZFtcIk1BSU5ORVRcIl0gPSAxXSA9IFwiTUFJTk5FVFwiO1xuICBTdXBwb3J0ZWRDaGFpbklkW1N1cHBvcnRlZENoYWluSWRbXCJHT0VSTElcIl0gPSA1XSA9IFwiR09FUkxJXCI7XG4gIFN1cHBvcnRlZENoYWluSWRbU3VwcG9ydGVkQ2hhaW5JZFtcIlNFUE9MSUFcIl0gPSAxMTE1NTExMV0gPSBcIlNFUE9MSUFcIjtcbiAgU3VwcG9ydGVkQ2hhaW5JZFtTdXBwb3J0ZWRDaGFpbklkW1wiQVJCSVRSVU1fT05FXCJdID0gNDIxNjFdID0gXCJBUkJJVFJVTV9PTkVcIjtcbiAgU3VwcG9ydGVkQ2hhaW5JZFtTdXBwb3J0ZWRDaGFpbklkW1wiQVJCSVRSVU1fR09FUkxJXCJdID0gNDIxNjEzXSA9IFwiQVJCSVRSVU1fR09FUkxJXCI7XG4gIFN1cHBvcnRlZENoYWluSWRbU3VwcG9ydGVkQ2hhaW5JZFtcIk9QVElNSVNNXCJdID0gMTBdID0gXCJPUFRJTUlTTVwiO1xuICBTdXBwb3J0ZWRDaGFpbklkW1N1cHBvcnRlZENoYWluSWRbXCJPUFRJTUlTTV9HT0VSTElcIl0gPSA0MjBdID0gXCJPUFRJTUlTTV9HT0VSTElcIjtcbiAgU3VwcG9ydGVkQ2hhaW5JZFtTdXBwb3J0ZWRDaGFpbklkW1wiUE9MWUdPTlwiXSA9IDEzN10gPSBcIlBPTFlHT05cIjtcbiAgU3VwcG9ydGVkQ2hhaW5JZFtTdXBwb3J0ZWRDaGFpbklkW1wiUE9MWUdPTl9NVU1CQUlcIl0gPSA4MDAwMV0gPSBcIlBPTFlHT05fTVVNQkFJXCI7XG4gIFN1cHBvcnRlZENoYWluSWRbU3VwcG9ydGVkQ2hhaW5JZFtcIkNFTE9cIl0gPSA0MjIyMF0gPSBcIkNFTE9cIjtcbiAgU3VwcG9ydGVkQ2hhaW5JZFtTdXBwb3J0ZWRDaGFpbklkW1wiQ0VMT19BTEZBSk9SRVNcIl0gPSA0NDc4N10gPSBcIkNFTE9fQUxGQUpPUkVTXCI7XG4gIFN1cHBvcnRlZENoYWluSWRbU3VwcG9ydGVkQ2hhaW5JZFtcIkJOQlwiXSA9IDU2XSA9IFwiQk5CXCI7XG59KShTdXBwb3J0ZWRDaGFpbklkIHx8IChTdXBwb3J0ZWRDaGFpbklkID0ge30pKTtcblxudmFyIFRyYWRlVHlwZTtcblxuKGZ1bmN0aW9uIChUcmFkZVR5cGUpIHtcbiAgVHJhZGVUeXBlW1RyYWRlVHlwZVtcIkVYQUNUX0lOUFVUXCJdID0gMF0gPSBcIkVYQUNUX0lOUFVUXCI7XG4gIFRyYWRlVHlwZVtUcmFkZVR5cGVbXCJFWEFDVF9PVVRQVVRcIl0gPSAxXSA9IFwiRVhBQ1RfT1VUUFVUXCI7XG59KShUcmFkZVR5cGUgfHwgKFRyYWRlVHlwZSA9IHt9KSk7XG5cbnZhciBSb3VuZGluZztcblxuKGZ1bmN0aW9uIChSb3VuZGluZykge1xuICBSb3VuZGluZ1tSb3VuZGluZ1tcIlJPVU5EX0RPV05cIl0gPSAwXSA9IFwiUk9VTkRfRE9XTlwiO1xuICBSb3VuZGluZ1tSb3VuZGluZ1tcIlJPVU5EX0hBTEZfVVBcIl0gPSAxXSA9IFwiUk9VTkRfSEFMRl9VUFwiO1xuICBSb3VuZGluZ1tSb3VuZGluZ1tcIlJPVU5EX1VQXCJdID0gMl0gPSBcIlJPVU5EX1VQXCI7XG59KShSb3VuZGluZyB8fCAoUm91bmRpbmcgPSB7fSkpO1xuXG52YXIgTWF4VWludDI1NiA9IC8qI19fUFVSRV9fKi9KU0JJLkJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyk7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgX3RvU2lnbmlmaWNhbnRSb3VuZGluLCBfdG9GaXhlZFJvdW5kaW5nO1xudmFyIERlY2ltYWwgPSAvKiNfX1BVUkVfXyovdG9Gb3JtYXQoX0RlY2ltYWwpO1xudmFyIEJpZyA9IC8qI19fUFVSRV9fKi90b0Zvcm1hdChfQmlnKTtcbnZhciB0b1NpZ25pZmljYW50Um91bmRpbmcgPSAoX3RvU2lnbmlmaWNhbnRSb3VuZGluID0ge30sIF90b1NpZ25pZmljYW50Um91bmRpbltSb3VuZGluZy5ST1VORF9ET1dOXSA9IERlY2ltYWwuUk9VTkRfRE9XTiwgX3RvU2lnbmlmaWNhbnRSb3VuZGluW1JvdW5kaW5nLlJPVU5EX0hBTEZfVVBdID0gRGVjaW1hbC5ST1VORF9IQUxGX1VQLCBfdG9TaWduaWZpY2FudFJvdW5kaW5bUm91bmRpbmcuUk9VTkRfVVBdID0gRGVjaW1hbC5ST1VORF9VUCwgX3RvU2lnbmlmaWNhbnRSb3VuZGluKTtcbnZhciB0b0ZpeGVkUm91bmRpbmcgPSAoX3RvRml4ZWRSb3VuZGluZyA9IHt9LCBfdG9GaXhlZFJvdW5kaW5nW1JvdW5kaW5nLlJPVU5EX0RPV05dID0gMCwgX3RvRml4ZWRSb3VuZGluZ1tSb3VuZGluZy5ST1VORF9IQUxGX1VQXSA9IDEsIF90b0ZpeGVkUm91bmRpbmdbUm91bmRpbmcuUk9VTkRfVVBdID0gMywgX3RvRml4ZWRSb3VuZGluZyk7XG52YXIgRnJhY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGcmFjdGlvbihudW1lcmF0b3IsIGRlbm9taW5hdG9yKSB7XG4gICAgaWYgKGRlbm9taW5hdG9yID09PSB2b2lkIDApIHtcbiAgICAgIGRlbm9taW5hdG9yID0gSlNCSS5CaWdJbnQoMSk7XG4gICAgfVxuXG4gICAgdGhpcy5udW1lcmF0b3IgPSBKU0JJLkJpZ0ludChudW1lcmF0b3IpO1xuICAgIHRoaXMuZGVub21pbmF0b3IgPSBKU0JJLkJpZ0ludChkZW5vbWluYXRvcik7XG4gIH1cblxuICBGcmFjdGlvbi50cnlQYXJzZUZyYWN0aW9uID0gZnVuY3Rpb24gdHJ5UGFyc2VGcmFjdGlvbihmcmFjdGlvbmlzaCkge1xuICAgIGlmIChmcmFjdGlvbmlzaCBpbnN0YW5jZW9mIEpTQkkgfHwgdHlwZW9mIGZyYWN0aW9uaXNoID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgZnJhY3Rpb25pc2ggPT09ICdzdHJpbmcnKSByZXR1cm4gbmV3IEZyYWN0aW9uKGZyYWN0aW9uaXNoKTtcbiAgICBpZiAoJ251bWVyYXRvcicgaW4gZnJhY3Rpb25pc2ggJiYgJ2Rlbm9taW5hdG9yJyBpbiBmcmFjdGlvbmlzaCkgcmV0dXJuIGZyYWN0aW9uaXNoO1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHBhcnNlIGZyYWN0aW9uJyk7XG4gIH0gLy8gcGVyZm9ybXMgZmxvb3IgZGl2aXNpb25cbiAgO1xuXG4gIHZhciBfcHJvdG8gPSBGcmFjdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmludmVydCA9IGZ1bmN0aW9uIGludmVydCgpIHtcbiAgICByZXR1cm4gbmV3IEZyYWN0aW9uKHRoaXMuZGVub21pbmF0b3IsIHRoaXMubnVtZXJhdG9yKTtcbiAgfTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKG90aGVyKSB7XG4gICAgdmFyIG90aGVyUGFyc2VkID0gRnJhY3Rpb24udHJ5UGFyc2VGcmFjdGlvbihvdGhlcik7XG5cbiAgICBpZiAoSlNCSS5lcXVhbCh0aGlzLmRlbm9taW5hdG9yLCBvdGhlclBhcnNlZC5kZW5vbWluYXRvcikpIHtcbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oSlNCSS5hZGQodGhpcy5udW1lcmF0b3IsIG90aGVyUGFyc2VkLm51bWVyYXRvciksIHRoaXMuZGVub21pbmF0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRnJhY3Rpb24oSlNCSS5hZGQoSlNCSS5tdWx0aXBseSh0aGlzLm51bWVyYXRvciwgb3RoZXJQYXJzZWQuZGVub21pbmF0b3IpLCBKU0JJLm11bHRpcGx5KG90aGVyUGFyc2VkLm51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvcikpLCBKU0JJLm11bHRpcGx5KHRoaXMuZGVub21pbmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSk7XG4gIH07XG5cbiAgX3Byb3RvLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qob3RoZXIpIHtcbiAgICB2YXIgb3RoZXJQYXJzZWQgPSBGcmFjdGlvbi50cnlQYXJzZUZyYWN0aW9uKG90aGVyKTtcblxuICAgIGlmIChKU0JJLmVxdWFsKHRoaXMuZGVub21pbmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSkge1xuICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbihKU0JJLnN1YnRyYWN0KHRoaXMubnVtZXJhdG9yLCBvdGhlclBhcnNlZC5udW1lcmF0b3IpLCB0aGlzLmRlbm9taW5hdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEZyYWN0aW9uKEpTQkkuc3VidHJhY3QoSlNCSS5tdWx0aXBseSh0aGlzLm51bWVyYXRvciwgb3RoZXJQYXJzZWQuZGVub21pbmF0b3IpLCBKU0JJLm11bHRpcGx5KG90aGVyUGFyc2VkLm51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvcikpLCBKU0JJLm11bHRpcGx5KHRoaXMuZGVub21pbmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSk7XG4gIH07XG5cbiAgX3Byb3RvLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcbiAgICB2YXIgb3RoZXJQYXJzZWQgPSBGcmFjdGlvbi50cnlQYXJzZUZyYWN0aW9uKG90aGVyKTtcbiAgICByZXR1cm4gSlNCSS5sZXNzVGhhbihKU0JJLm11bHRpcGx5KHRoaXMubnVtZXJhdG9yLCBvdGhlclBhcnNlZC5kZW5vbWluYXRvciksIEpTQkkubXVsdGlwbHkob3RoZXJQYXJzZWQubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yKSk7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFsVG8gPSBmdW5jdGlvbiBlcXVhbFRvKG90aGVyKSB7XG4gICAgdmFyIG90aGVyUGFyc2VkID0gRnJhY3Rpb24udHJ5UGFyc2VGcmFjdGlvbihvdGhlcik7XG4gICAgcmV0dXJuIEpTQkkuZXF1YWwoSlNCSS5tdWx0aXBseSh0aGlzLm51bWVyYXRvciwgb3RoZXJQYXJzZWQuZGVub21pbmF0b3IpLCBKU0JJLm11bHRpcGx5KG90aGVyUGFyc2VkLm51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvcikpO1xuICB9O1xuXG4gIF9wcm90by5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7XG4gICAgdmFyIG90aGVyUGFyc2VkID0gRnJhY3Rpb24udHJ5UGFyc2VGcmFjdGlvbihvdGhlcik7XG4gICAgcmV0dXJuIEpTQkkuZ3JlYXRlclRoYW4oSlNCSS5tdWx0aXBseSh0aGlzLm51bWVyYXRvciwgb3RoZXJQYXJzZWQuZGVub21pbmF0b3IpLCBKU0JJLm11bHRpcGx5KG90aGVyUGFyc2VkLm51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvcikpO1xuICB9O1xuXG4gIF9wcm90by5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG90aGVyKSB7XG4gICAgdmFyIG90aGVyUGFyc2VkID0gRnJhY3Rpb24udHJ5UGFyc2VGcmFjdGlvbihvdGhlcik7XG4gICAgcmV0dXJuIG5ldyBGcmFjdGlvbihKU0JJLm11bHRpcGx5KHRoaXMubnVtZXJhdG9yLCBvdGhlclBhcnNlZC5udW1lcmF0b3IpLCBKU0JJLm11bHRpcGx5KHRoaXMuZGVub21pbmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSk7XG4gIH07XG5cbiAgX3Byb3RvLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShvdGhlcikge1xuICAgIHZhciBvdGhlclBhcnNlZCA9IEZyYWN0aW9uLnRyeVBhcnNlRnJhY3Rpb24ob3RoZXIpO1xuICAgIHJldHVybiBuZXcgRnJhY3Rpb24oSlNCSS5tdWx0aXBseSh0aGlzLm51bWVyYXRvciwgb3RoZXJQYXJzZWQuZGVub21pbmF0b3IpLCBKU0JJLm11bHRpcGx5KHRoaXMuZGVub21pbmF0b3IsIG90aGVyUGFyc2VkLm51bWVyYXRvcikpO1xuICB9O1xuXG4gIF9wcm90by50b1NpZ25pZmljYW50ID0gZnVuY3Rpb24gdG9TaWduaWZpY2FudChzaWduaWZpY2FudERpZ2l0cywgZm9ybWF0LCByb3VuZGluZykge1xuICAgIGlmIChmb3JtYXQgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0ID0ge1xuICAgICAgICBncm91cFNlcGFyYXRvcjogJydcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHJvdW5kaW5nID09PSB2b2lkIDApIHtcbiAgICAgIHJvdW5kaW5nID0gUm91bmRpbmcuUk9VTkRfSEFMRl9VUDtcbiAgICB9XG5cbiAgICAhTnVtYmVyLmlzSW50ZWdlcihzaWduaWZpY2FudERpZ2l0cykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIHNpZ25pZmljYW50RGlnaXRzICsgXCIgaXMgbm90IGFuIGludGVnZXIuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKHNpZ25pZmljYW50RGlnaXRzID4gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIHNpZ25pZmljYW50RGlnaXRzICsgXCIgaXMgbm90IHBvc2l0aXZlLlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgRGVjaW1hbC5zZXQoe1xuICAgICAgcHJlY2lzaW9uOiBzaWduaWZpY2FudERpZ2l0cyArIDEsXG4gICAgICByb3VuZGluZzogdG9TaWduaWZpY2FudFJvdW5kaW5nW3JvdW5kaW5nXVxuICAgIH0pO1xuICAgIHZhciBxdW90aWVudCA9IG5ldyBEZWNpbWFsKHRoaXMubnVtZXJhdG9yLnRvU3RyaW5nKCkpLmRpdih0aGlzLmRlbm9taW5hdG9yLnRvU3RyaW5nKCkpLnRvU2lnbmlmaWNhbnREaWdpdHMoc2lnbmlmaWNhbnREaWdpdHMpO1xuICAgIHJldHVybiBxdW90aWVudC50b0Zvcm1hdChxdW90aWVudC5kZWNpbWFsUGxhY2VzKCksIGZvcm1hdCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvRml4ZWQgPSBmdW5jdGlvbiB0b0ZpeGVkKGRlY2ltYWxQbGFjZXMsIGZvcm1hdCwgcm91bmRpbmcpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHtcbiAgICAgIGZvcm1hdCA9IHtcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcnXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChyb3VuZGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICByb3VuZGluZyA9IFJvdW5kaW5nLlJPVU5EX0hBTEZfVVA7XG4gICAgfVxuXG4gICAgIU51bWJlci5pc0ludGVnZXIoZGVjaW1hbFBsYWNlcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGRlY2ltYWxQbGFjZXMgKyBcIiBpcyBub3QgYW4gaW50ZWdlci5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEoZGVjaW1hbFBsYWNlcyA+PSAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgZGVjaW1hbFBsYWNlcyArIFwiIGlzIG5lZ2F0aXZlLlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgQmlnLkRQID0gZGVjaW1hbFBsYWNlcztcbiAgICBCaWcuUk0gPSB0b0ZpeGVkUm91bmRpbmdbcm91bmRpbmddO1xuICAgIHJldHVybiBuZXcgQmlnKHRoaXMubnVtZXJhdG9yLnRvU3RyaW5nKCkpLmRpdih0aGlzLmRlbm9taW5hdG9yLnRvU3RyaW5nKCkpLnRvRm9ybWF0KGRlY2ltYWxQbGFjZXMsIGZvcm1hdCk7XG4gIH1cbiAgLyoqXHJcbiAgICogSGVscGVyIG1ldGhvZCBmb3IgY29udmVydGluZyBhbnkgc3VwZXIgY2xhc3MgYmFjayB0byBhIGZyYWN0aW9uXHJcbiAgICovXG4gIDtcblxuICBfY3JlYXRlQ2xhc3MoRnJhY3Rpb24sIFt7XG4gICAga2V5OiBcInF1b3RpZW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gSlNCSS5kaXZpZGUodGhpcy5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpO1xuICAgIH0gLy8gcmVtYWluZGVyIGFmdGVyIGZsb29yIGRpdmlzaW9uXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1haW5kZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oSlNCSS5yZW1haW5kZXIodGhpcy5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpLCB0aGlzLmRlbm9taW5hdG9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXNGcmFjdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbih0aGlzLm51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvcik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZyYWN0aW9uO1xufSgpO1xuXG52YXIgQmlnJDEgPSAvKiNfX1BVUkVfXyovdG9Gb3JtYXQoX0JpZyk7XG52YXIgQ3VycmVuY3lBbW91bnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9GcmFjdGlvbikge1xuICBfaW5oZXJpdHNMb29zZShDdXJyZW5jeUFtb3VudCwgX0ZyYWN0aW9uKTtcblxuICBmdW5jdGlvbiBDdXJyZW5jeUFtb3VudChjdXJyZW5jeSwgbnVtZXJhdG9yLCBkZW5vbWluYXRvcikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0ZyYWN0aW9uLmNhbGwodGhpcywgbnVtZXJhdG9yLCBkZW5vbWluYXRvcikgfHwgdGhpcztcbiAgICAhSlNCSS5sZXNzVGhhbk9yRXF1YWwoX3RoaXMucXVvdGllbnQsIE1heFVpbnQyNTYpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQU1PVU5UJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIF90aGlzLmN1cnJlbmN5ID0gY3VycmVuY3k7XG4gICAgX3RoaXMuZGVjaW1hbFNjYWxlID0gSlNCSS5leHBvbmVudGlhdGUoSlNCSS5CaWdJbnQoMTApLCBKU0JJLkJpZ0ludChjdXJyZW5jeS5kZWNpbWFscykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IGN1cnJlbmN5IGFtb3VudCBpbnN0YW5jZSBmcm9tIHRoZSB1bml0bGVzcyBhbW91bnQgb2YgdG9rZW4sIGkuZS4gdGhlIHJhdyBhbW91bnRcclxuICAgKiBAcGFyYW0gY3VycmVuY3kgdGhlIGN1cnJlbmN5IGluIHRoZSBhbW91bnRcclxuICAgKiBAcGFyYW0gcmF3QW1vdW50IHRoZSByYXcgdG9rZW4gb3IgZXRoZXIgYW1vdW50XHJcbiAgICovXG5cblxuICBDdXJyZW5jeUFtb3VudC5mcm9tUmF3QW1vdW50ID0gZnVuY3Rpb24gZnJvbVJhd0Ftb3VudChjdXJyZW5jeSwgcmF3QW1vdW50KSB7XG4gICAgcmV0dXJuIG5ldyBDdXJyZW5jeUFtb3VudChjdXJyZW5jeSwgcmF3QW1vdW50KTtcbiAgfVxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBjdXJyZW5jeSBhbW91bnQgd2l0aCBhIGRlbm9taW5hdG9yIHRoYXQgaXMgbm90IGVxdWFsIHRvIDFcclxuICAgKiBAcGFyYW0gY3VycmVuY3kgdGhlIGN1cnJlbmN5XHJcbiAgICogQHBhcmFtIG51bWVyYXRvciB0aGUgbnVtZXJhdG9yIG9mIHRoZSBmcmFjdGlvbmFsIHRva2VuIGFtb3VudFxyXG4gICAqIEBwYXJhbSBkZW5vbWluYXRvciB0aGUgZGVub21pbmF0b3Igb2YgdGhlIGZyYWN0aW9uYWwgdG9rZW4gYW1vdW50XHJcbiAgICovXG4gIDtcblxuICBDdXJyZW5jeUFtb3VudC5mcm9tRnJhY3Rpb25hbEFtb3VudCA9IGZ1bmN0aW9uIGZyb21GcmFjdGlvbmFsQW1vdW50KGN1cnJlbmN5LCBudW1lcmF0b3IsIGRlbm9taW5hdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBDdXJyZW5jeUFtb3VudChjdXJyZW5jeSwgbnVtZXJhdG9yLCBkZW5vbWluYXRvcik7XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IEN1cnJlbmN5QW1vdW50LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKG90aGVyKSB7XG4gICAgIXRoaXMuY3VycmVuY3kuZXF1YWxzKG90aGVyLmN1cnJlbmN5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NVUlJFTkNZJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdmFyIGFkZGVkID0gX0ZyYWN0aW9uLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBvdGhlcik7XG5cbiAgICByZXR1cm4gQ3VycmVuY3lBbW91bnQuZnJvbUZyYWN0aW9uYWxBbW91bnQodGhpcy5jdXJyZW5jeSwgYWRkZWQubnVtZXJhdG9yLCBhZGRlZC5kZW5vbWluYXRvcik7XG4gIH07XG5cbiAgX3Byb3RvLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qob3RoZXIpIHtcbiAgICAhdGhpcy5jdXJyZW5jeS5lcXVhbHMob3RoZXIuY3VycmVuY3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ1VSUkVOQ1knKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgc3VidHJhY3RlZCA9IF9GcmFjdGlvbi5wcm90b3R5cGUuc3VidHJhY3QuY2FsbCh0aGlzLCBvdGhlcik7XG5cbiAgICByZXR1cm4gQ3VycmVuY3lBbW91bnQuZnJvbUZyYWN0aW9uYWxBbW91bnQodGhpcy5jdXJyZW5jeSwgc3VidHJhY3RlZC5udW1lcmF0b3IsIHN1YnRyYWN0ZWQuZGVub21pbmF0b3IpO1xuICB9O1xuXG4gIF9wcm90by5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG90aGVyKSB7XG4gICAgdmFyIG11bHRpcGxpZWQgPSBfRnJhY3Rpb24ucHJvdG90eXBlLm11bHRpcGx5LmNhbGwodGhpcywgb3RoZXIpO1xuXG4gICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21GcmFjdGlvbmFsQW1vdW50KHRoaXMuY3VycmVuY3ksIG11bHRpcGxpZWQubnVtZXJhdG9yLCBtdWx0aXBsaWVkLmRlbm9taW5hdG9yKTtcbiAgfTtcblxuICBfcHJvdG8uZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKG90aGVyKSB7XG4gICAgdmFyIGRpdmlkZWQgPSBfRnJhY3Rpb24ucHJvdG90eXBlLmRpdmlkZS5jYWxsKHRoaXMsIG90aGVyKTtcblxuICAgIHJldHVybiBDdXJyZW5jeUFtb3VudC5mcm9tRnJhY3Rpb25hbEFtb3VudCh0aGlzLmN1cnJlbmN5LCBkaXZpZGVkLm51bWVyYXRvciwgZGl2aWRlZC5kZW5vbWluYXRvcik7XG4gIH07XG5cbiAgX3Byb3RvLnRvU2lnbmlmaWNhbnQgPSBmdW5jdGlvbiB0b1NpZ25pZmljYW50KHNpZ25pZmljYW50RGlnaXRzLCBmb3JtYXQsIHJvdW5kaW5nKSB7XG4gICAgaWYgKHNpZ25pZmljYW50RGlnaXRzID09PSB2b2lkIDApIHtcbiAgICAgIHNpZ25pZmljYW50RGlnaXRzID0gNjtcbiAgICB9XG5cbiAgICBpZiAocm91bmRpbmcgPT09IHZvaWQgMCkge1xuICAgICAgcm91bmRpbmcgPSBSb3VuZGluZy5ST1VORF9ET1dOO1xuICAgIH1cblxuICAgIHJldHVybiBfRnJhY3Rpb24ucHJvdG90eXBlLmRpdmlkZS5jYWxsKHRoaXMsIHRoaXMuZGVjaW1hbFNjYWxlKS50b1NpZ25pZmljYW50KHNpZ25pZmljYW50RGlnaXRzLCBmb3JtYXQsIHJvdW5kaW5nKTtcbiAgfTtcblxuICBfcHJvdG8udG9GaXhlZCA9IGZ1bmN0aW9uIHRvRml4ZWQoZGVjaW1hbFBsYWNlcywgZm9ybWF0LCByb3VuZGluZykge1xuICAgIGlmIChkZWNpbWFsUGxhY2VzID09PSB2b2lkIDApIHtcbiAgICAgIGRlY2ltYWxQbGFjZXMgPSB0aGlzLmN1cnJlbmN5LmRlY2ltYWxzO1xuICAgIH1cblxuICAgIGlmIChyb3VuZGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICByb3VuZGluZyA9IFJvdW5kaW5nLlJPVU5EX0RPV047XG4gICAgfVxuXG4gICAgIShkZWNpbWFsUGxhY2VzIDw9IHRoaXMuY3VycmVuY3kuZGVjaW1hbHMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnREVDSU1BTFMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIF9GcmFjdGlvbi5wcm90b3R5cGUuZGl2aWRlLmNhbGwodGhpcywgdGhpcy5kZWNpbWFsU2NhbGUpLnRvRml4ZWQoZGVjaW1hbFBsYWNlcywgZm9ybWF0LCByb3VuZGluZyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvRXhhY3QgPSBmdW5jdGlvbiB0b0V4YWN0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0ID0ge1xuICAgICAgICBncm91cFNlcGFyYXRvcjogJydcbiAgICAgIH07XG4gICAgfVxuXG4gICAgQmlnJDEuRFAgPSB0aGlzLmN1cnJlbmN5LmRlY2ltYWxzO1xuICAgIHJldHVybiBuZXcgQmlnJDEodGhpcy5xdW90aWVudC50b1N0cmluZygpKS5kaXYodGhpcy5kZWNpbWFsU2NhbGUudG9TdHJpbmcoKSkudG9Gb3JtYXQoZm9ybWF0KTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoQ3VycmVuY3lBbW91bnQsIFt7XG4gICAga2V5OiBcIndyYXBwZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbmN5LmlzVG9rZW4pIHJldHVybiB0aGlzO1xuICAgICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21GcmFjdGlvbmFsQW1vdW50KHRoaXMuY3VycmVuY3kud3JhcHBlZCwgdGhpcy5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDdXJyZW5jeUFtb3VudDtcbn0oRnJhY3Rpb24pO1xuXG52YXIgT05FX0hVTkRSRUQgPSAvKiNfX1BVUkVfXyovbmV3IEZyYWN0aW9uKCAvKiNfX1BVUkVfXyovSlNCSS5CaWdJbnQoMTAwKSk7XG4vKipcclxuICogQ29udmVydHMgYSBmcmFjdGlvbiB0byBhIHBlcmNlbnRcclxuICogQHBhcmFtIGZyYWN0aW9uIHRoZSBmcmFjdGlvbiB0byBjb252ZXJ0XHJcbiAqL1xuXG5mdW5jdGlvbiB0b1BlcmNlbnQoZnJhY3Rpb24pIHtcbiAgcmV0dXJuIG5ldyBQZXJjZW50KGZyYWN0aW9uLm51bWVyYXRvciwgZnJhY3Rpb24uZGVub21pbmF0b3IpO1xufVxuXG52YXIgUGVyY2VudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0ZyYWN0aW9uKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBlcmNlbnQsIF9GcmFjdGlvbik7XG5cbiAgZnVuY3Rpb24gUGVyY2VudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9GcmFjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGJvb2xlYW4gcHJldmVudHMgYSBmcmFjdGlvbiBmcm9tIGJlaW5nIGludGVycHJldGVkIGFzIGEgUGVyY2VudFxyXG4gICAgICovXG5cbiAgICBfdGhpcy5pc1BlcmNlbnQgPSB0cnVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQZXJjZW50LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKG90aGVyKSB7XG4gICAgcmV0dXJuIHRvUGVyY2VudChfRnJhY3Rpb24ucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIG90aGVyKSk7XG4gIH07XG5cbiAgX3Byb3RvLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qob3RoZXIpIHtcbiAgICByZXR1cm4gdG9QZXJjZW50KF9GcmFjdGlvbi5wcm90b3R5cGUuc3VidHJhY3QuY2FsbCh0aGlzLCBvdGhlcikpO1xuICB9O1xuXG4gIF9wcm90by5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG90aGVyKSB7XG4gICAgcmV0dXJuIHRvUGVyY2VudChfRnJhY3Rpb24ucHJvdG90eXBlLm11bHRpcGx5LmNhbGwodGhpcywgb3RoZXIpKTtcbiAgfTtcblxuICBfcHJvdG8uZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKG90aGVyKSB7XG4gICAgcmV0dXJuIHRvUGVyY2VudChfRnJhY3Rpb24ucHJvdG90eXBlLmRpdmlkZS5jYWxsKHRoaXMsIG90aGVyKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU2lnbmlmaWNhbnQgPSBmdW5jdGlvbiB0b1NpZ25pZmljYW50KHNpZ25pZmljYW50RGlnaXRzLCBmb3JtYXQsIHJvdW5kaW5nKSB7XG4gICAgaWYgKHNpZ25pZmljYW50RGlnaXRzID09PSB2b2lkIDApIHtcbiAgICAgIHNpZ25pZmljYW50RGlnaXRzID0gNTtcbiAgICB9XG5cbiAgICByZXR1cm4gX0ZyYWN0aW9uLnByb3RvdHlwZS5tdWx0aXBseS5jYWxsKHRoaXMsIE9ORV9IVU5EUkVEKS50b1NpZ25pZmljYW50KHNpZ25pZmljYW50RGlnaXRzLCBmb3JtYXQsIHJvdW5kaW5nKTtcbiAgfTtcblxuICBfcHJvdG8udG9GaXhlZCA9IGZ1bmN0aW9uIHRvRml4ZWQoZGVjaW1hbFBsYWNlcywgZm9ybWF0LCByb3VuZGluZykge1xuICAgIGlmIChkZWNpbWFsUGxhY2VzID09PSB2b2lkIDApIHtcbiAgICAgIGRlY2ltYWxQbGFjZXMgPSAyO1xuICAgIH1cblxuICAgIHJldHVybiBfRnJhY3Rpb24ucHJvdG90eXBlLm11bHRpcGx5LmNhbGwodGhpcywgT05FX0hVTkRSRUQpLnRvRml4ZWQoZGVjaW1hbFBsYWNlcywgZm9ybWF0LCByb3VuZGluZyk7XG4gIH07XG5cbiAgcmV0dXJuIFBlcmNlbnQ7XG59KEZyYWN0aW9uKTtcblxudmFyIFByaWNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRnJhY3Rpb24pIHtcbiAgX2luaGVyaXRzTG9vc2UoUHJpY2UsIF9GcmFjdGlvbik7XG5cbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgcHJpY2UsIGVpdGhlciB3aXRoIHRoZSBiYXNlIGFuZCBxdW90ZSBjdXJyZW5jeSBhbW91bnQsIG9yIHRoZVxyXG4gICAqIEBwYXJhbSBhcmdzXHJcbiAgICovXG4gIGZ1bmN0aW9uIFByaWNlKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBiYXNlQ3VycmVuY3ksIHF1b3RlQ3VycmVuY3ksIGRlbm9taW5hdG9yLCBudW1lcmF0b3I7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICBiYXNlQ3VycmVuY3kgPSBhcmdzWzBdO1xuICAgICAgcXVvdGVDdXJyZW5jeSA9IGFyZ3NbMV07XG4gICAgICBkZW5vbWluYXRvciA9IGFyZ3NbMl07XG4gICAgICBudW1lcmF0b3IgPSBhcmdzWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1swXS5xdW90ZUFtb3VudC5kaXZpZGUoYXJnc1swXS5iYXNlQW1vdW50KTtcbiAgICAgIHZhciBfcmVmID0gW2FyZ3NbMF0uYmFzZUFtb3VudC5jdXJyZW5jeSwgYXJnc1swXS5xdW90ZUFtb3VudC5jdXJyZW5jeSwgcmVzdWx0LmRlbm9taW5hdG9yLCByZXN1bHQubnVtZXJhdG9yXTtcbiAgICAgIGJhc2VDdXJyZW5jeSA9IF9yZWZbMF07XG4gICAgICBxdW90ZUN1cnJlbmN5ID0gX3JlZlsxXTtcbiAgICAgIGRlbm9taW5hdG9yID0gX3JlZlsyXTtcbiAgICAgIG51bWVyYXRvciA9IF9yZWZbM107XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfRnJhY3Rpb24uY2FsbCh0aGlzLCBudW1lcmF0b3IsIGRlbm9taW5hdG9yKSB8fCB0aGlzO1xuICAgIF90aGlzLmJhc2VDdXJyZW5jeSA9IGJhc2VDdXJyZW5jeTtcbiAgICBfdGhpcy5xdW90ZUN1cnJlbmN5ID0gcXVvdGVDdXJyZW5jeTtcbiAgICBfdGhpcy5zY2FsYXIgPSBuZXcgRnJhY3Rpb24oSlNCSS5leHBvbmVudGlhdGUoSlNCSS5CaWdJbnQoMTApLCBKU0JJLkJpZ0ludChiYXNlQ3VycmVuY3kuZGVjaW1hbHMpKSwgSlNCSS5leHBvbmVudGlhdGUoSlNCSS5CaWdJbnQoMTApLCBKU0JJLkJpZ0ludChxdW90ZUN1cnJlbmN5LmRlY2ltYWxzKSkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBGbGlwIHRoZSBwcmljZSwgc3dpdGNoaW5nIHRoZSBiYXNlIGFuZCBxdW90ZSBjdXJyZW5jeVxyXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFByaWNlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgIHJldHVybiBuZXcgUHJpY2UodGhpcy5xdW90ZUN1cnJlbmN5LCB0aGlzLmJhc2VDdXJyZW5jeSwgdGhpcy5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpO1xuICB9XG4gIC8qKlxyXG4gICAqIE11bHRpcGx5IHRoZSBwcmljZSBieSBhbm90aGVyIHByaWNlLCByZXR1cm5pbmcgYSBuZXcgcHJpY2UuIFRoZSBvdGhlciBwcmljZSBtdXN0IGhhdmUgdGhlIHNhbWUgYmFzZSBjdXJyZW5jeSBhcyB0aGlzIHByaWNlJ3MgcXVvdGUgY3VycmVuY3lcclxuICAgKiBAcGFyYW0gb3RoZXIgdGhlIG90aGVyIHByaWNlXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShvdGhlcikge1xuICAgICF0aGlzLnF1b3RlQ3VycmVuY3kuZXF1YWxzKG90aGVyLmJhc2VDdXJyZW5jeSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdUT0tFTicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciBmcmFjdGlvbiA9IF9GcmFjdGlvbi5wcm90b3R5cGUubXVsdGlwbHkuY2FsbCh0aGlzLCBvdGhlcik7XG5cbiAgICByZXR1cm4gbmV3IFByaWNlKHRoaXMuYmFzZUN1cnJlbmN5LCBvdGhlci5xdW90ZUN1cnJlbmN5LCBmcmFjdGlvbi5kZW5vbWluYXRvciwgZnJhY3Rpb24ubnVtZXJhdG9yKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGFtb3VudCBvZiBxdW90ZSBjdXJyZW5jeSBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gYW1vdW50IG9mIHRoZSBiYXNlIGN1cnJlbmN5XHJcbiAgICogQHBhcmFtIGN1cnJlbmN5QW1vdW50IHRoZSBhbW91bnQgb2YgYmFzZSBjdXJyZW5jeSB0byBxdW90ZSBhZ2FpbnN0IHRoZSBwcmljZVxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnF1b3RlID0gZnVuY3Rpb24gcXVvdGUoY3VycmVuY3lBbW91bnQpIHtcbiAgICAhY3VycmVuY3lBbW91bnQuY3VycmVuY3kuZXF1YWxzKHRoaXMuYmFzZUN1cnJlbmN5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1RPS0VOJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdmFyIHJlc3VsdCA9IF9GcmFjdGlvbi5wcm90b3R5cGUubXVsdGlwbHkuY2FsbCh0aGlzLCBjdXJyZW5jeUFtb3VudCk7XG5cbiAgICByZXR1cm4gQ3VycmVuY3lBbW91bnQuZnJvbUZyYWN0aW9uYWxBbW91bnQodGhpcy5xdW90ZUN1cnJlbmN5LCByZXN1bHQubnVtZXJhdG9yLCByZXN1bHQuZGVub21pbmF0b3IpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgdmFsdWUgc2NhbGVkIGJ5IGRlY2ltYWxzIGZvciBmb3JtYXR0aW5nXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1NpZ25pZmljYW50ID0gZnVuY3Rpb24gdG9TaWduaWZpY2FudChzaWduaWZpY2FudERpZ2l0cywgZm9ybWF0LCByb3VuZGluZykge1xuICAgIGlmIChzaWduaWZpY2FudERpZ2l0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBzaWduaWZpY2FudERpZ2l0cyA9IDY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYWRqdXN0ZWRGb3JEZWNpbWFscy50b1NpZ25pZmljYW50KHNpZ25pZmljYW50RGlnaXRzLCBmb3JtYXQsIHJvdW5kaW5nKTtcbiAgfTtcblxuICBfcHJvdG8udG9GaXhlZCA9IGZ1bmN0aW9uIHRvRml4ZWQoZGVjaW1hbFBsYWNlcywgZm9ybWF0LCByb3VuZGluZykge1xuICAgIGlmIChkZWNpbWFsUGxhY2VzID09PSB2b2lkIDApIHtcbiAgICAgIGRlY2ltYWxQbGFjZXMgPSA0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFkanVzdGVkRm9yRGVjaW1hbHMudG9GaXhlZChkZWNpbWFsUGxhY2VzLCBmb3JtYXQsIHJvdW5kaW5nKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoUHJpY2UsIFt7XG4gICAga2V5OiBcImFkanVzdGVkRm9yRGVjaW1hbHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfRnJhY3Rpb24ucHJvdG90eXBlLm11bHRpcGx5LmNhbGwodGhpcywgdGhpcy5zY2FsYXIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQcmljZTtcbn0oRnJhY3Rpb24pO1xuXG4vKipcclxuICogQSBjdXJyZW5jeSBpcyBhbnkgZnVuZ2libGUgZmluYW5jaWFsIGluc3RydW1lbnQsIGluY2x1ZGluZyBFdGhlciwgYWxsIEVSQzIwIHRva2VucywgYW5kIG90aGVyIGNoYWluLW5hdGl2ZSBjdXJyZW5jaWVzXHJcbiAqL1xuXG52YXIgQmFzZUN1cnJlbmN5ID1cbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIHRoZSBiYXNlIGNsYXNzIGBCYXNlQ3VycmVuY3lgLlxyXG4gKiBAcGFyYW0gY2hhaW5JZCB0aGUgY2hhaW4gSUQgb24gd2hpY2ggdGhpcyBjdXJyZW5jeSByZXNpZGVzXHJcbiAqIEBwYXJhbSBkZWNpbWFscyBkZWNpbWFscyBvZiB0aGUgY3VycmVuY3lcclxuICogQHBhcmFtIHN5bWJvbCBzeW1ib2wgb2YgdGhlIGN1cnJlbmN5XHJcbiAqIEBwYXJhbSBuYW1lIG9mIHRoZSBjdXJyZW5jeVxyXG4gKi9cbmZ1bmN0aW9uIEJhc2VDdXJyZW5jeShjaGFpbklkLCBkZWNpbWFscywgc3ltYm9sLCBuYW1lKSB7XG4gICFOdW1iZXIuaXNTYWZlSW50ZWdlcihjaGFpbklkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NIQUlOX0lEJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhKGRlY2ltYWxzID49IDAgJiYgZGVjaW1hbHMgPCAyNTUgJiYgTnVtYmVyLmlzSW50ZWdlcihkZWNpbWFscykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnREVDSU1BTFMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gIHRoaXMuZGVjaW1hbHMgPSBkZWNpbWFscztcbiAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG59O1xuXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgbmF0aXZlIGN1cnJlbmN5IG9mIHRoZSBjaGFpbiBvbiB3aGljaCBpdCByZXNpZGVzLCBlLmcuXHJcbiAqL1xuXG52YXIgTmF0aXZlQ3VycmVuY3kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQ3VycmVuY3kpIHtcbiAgX2luaGVyaXRzTG9vc2UoTmF0aXZlQ3VycmVuY3ksIF9CYXNlQ3VycmVuY3kpO1xuXG4gIGZ1bmN0aW9uIE5hdGl2ZUN1cnJlbmN5KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VDdXJyZW5jeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuaXNOYXRpdmUgPSB0cnVlO1xuICAgIF90aGlzLmlzVG9rZW4gPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gTmF0aXZlQ3VycmVuY3k7XG59KEJhc2VDdXJyZW5jeSk7XG5cbi8qKlxyXG4gKiBWYWxpZGF0ZXMgYW4gYWRkcmVzcyBhbmQgcmV0dXJucyB0aGUgcGFyc2VkIChjaGVja3N1bW1lZCkgdmVyc2lvbiBvZiB0aGF0IGFkZHJlc3NcclxuICogQHBhcmFtIGFkZHJlc3MgdGhlIHVuY2hlY2tzdW1tZWQgaGV4IGFkZHJlc3NcclxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzKGFkZHJlc3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYWRkcmVzcyArIFwiIGlzIG5vdCBhIHZhbGlkIGFkZHJlc3MuXCIpO1xuICB9XG59IC8vIENoZWNrcyBhIHN0cmluZyBzdGFydHMgd2l0aCAweCwgaXMgNDIgY2hhcmFjdGVycyBsb25nIGFuZCBjb250YWlucyBvbmx5IGhleCBjaGFyYWN0ZXJzIGFmdGVyIDB4XG5cbnZhciBzdGFydHNXaXRoMHhMZW40MkhleFJlZ2V4ID0gL14weFswLTlhLWZBLUZdezQwfSQvO1xuLyoqXHJcbiAqIENoZWNrcyBpZiBhbiBhZGRyZXNzIGlzIHZhbGlkIGJ5IGNoZWNraW5nIDB4IHByZWZpeCwgbGVuZ3RoID09PSA0MiBhbmQgaGV4IGVuY29kaW5nLlxyXG4gKiBAcGFyYW0gYWRkcmVzcyB0aGUgdW5jaGVja3N1bW1lZCBoZXggYWRkcmVzc1xyXG4gKi9cblxuZnVuY3Rpb24gY2hlY2tWYWxpZEFkZHJlc3MoYWRkcmVzcykge1xuICBpZiAoc3RhcnRzV2l0aDB4TGVuNDJIZXhSZWdleC50ZXN0KGFkZHJlc3MpKSB7XG4gICAgcmV0dXJuIGFkZHJlc3M7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoYWRkcmVzcyArIFwiIGlzIG5vdCBhIHZhbGlkIGFkZHJlc3MuXCIpO1xufVxuXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBFUkMyMCB0b2tlbiB3aXRoIGEgdW5pcXVlIGFkZHJlc3MgYW5kIHNvbWUgbWV0YWRhdGEuXHJcbiAqL1xuXG52YXIgVG9rZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQ3VycmVuY3kpIHtcbiAgX2luaGVyaXRzTG9vc2UoVG9rZW4sIF9CYXNlQ3VycmVuY3kpO1xuXG4gIC8qKlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGNoYWluSWQge0BsaW5rIEJhc2VDdXJyZW5jeSNjaGFpbklkfVxyXG4gICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBjb250cmFjdCBhZGRyZXNzIG9uIHRoZSBjaGFpbiBvbiB3aGljaCB0aGlzIHRva2VuIGxpdmVzXHJcbiAgICogQHBhcmFtIGRlY2ltYWxzIHtAbGluayBCYXNlQ3VycmVuY3kjZGVjaW1hbHN9XHJcbiAgICogQHBhcmFtIHN5bWJvbCB7QGxpbmsgQmFzZUN1cnJlbmN5I3N5bWJvbH1cclxuICAgKiBAcGFyYW0gbmFtZSB7QGxpbmsgQmFzZUN1cnJlbmN5I25hbWV9XHJcbiAgICogQHBhcmFtIGJ5cGFzc0NoZWNrc3VtIElmIHRydWUgaXQgb25seSBjaGVja3MgZm9yIGxlbmd0aCA9PT0gNDIsIHN0YXJ0c1dpdGggMHggYW5kIGNvbnRhaW5zIG9ubHkgaGV4IGNoYXJhY3RlcnNcclxuICAgKi9cbiAgZnVuY3Rpb24gVG9rZW4oY2hhaW5JZCwgYWRkcmVzcywgZGVjaW1hbHMsIHN5bWJvbCwgbmFtZSwgYnlwYXNzQ2hlY2tzdW0pIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlQ3VycmVuY3kuY2FsbCh0aGlzLCBjaGFpbklkLCBkZWNpbWFscywgc3ltYm9sLCBuYW1lKSB8fCB0aGlzO1xuICAgIF90aGlzLmlzTmF0aXZlID0gZmFsc2U7XG4gICAgX3RoaXMuaXNUb2tlbiA9IHRydWU7XG5cbiAgICBpZiAoYnlwYXNzQ2hlY2tzdW0pIHtcbiAgICAgIF90aGlzLmFkZHJlc3MgPSBjaGVja1ZhbGlkQWRkcmVzcyhhZGRyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuYWRkcmVzcyA9IHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzKGFkZHJlc3MpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byB0b2tlbnMgYXJlIGVxdWl2YWxlbnQsIGkuZS4gaGF2ZSB0aGUgc2FtZSBjaGFpbklkIGFuZCBhZGRyZXNzLlxyXG4gICAqIEBwYXJhbSBvdGhlciBvdGhlciB0b2tlbiB0byBjb21wYXJlXHJcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gVG9rZW4ucHJvdG90eXBlO1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIuaXNUb2tlbiAmJiB0aGlzLmNoYWluSWQgPT09IG90aGVyLmNoYWluSWQgJiYgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IG90aGVyLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3Mgb2YgdGhpcyB0b2tlbiBzb3J0cyBiZWZvcmUgdGhlIGFkZHJlc3Mgb2YgdGhlIG90aGVyIHRva2VuXHJcbiAgICogQHBhcmFtIG90aGVyIG90aGVyIHRva2VuIHRvIGNvbXBhcmVcclxuICAgKiBAdGhyb3dzIGlmIHRoZSB0b2tlbnMgaGF2ZSB0aGUgc2FtZSBhZGRyZXNzXHJcbiAgICogQHRocm93cyBpZiB0aGUgdG9rZW5zIGFyZSBvbiBkaWZmZXJlbnQgY2hhaW5zXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uc29ydHNCZWZvcmUgPSBmdW5jdGlvbiBzb3J0c0JlZm9yZShvdGhlcikge1xuICAgICEodGhpcy5jaGFpbklkID09PSBvdGhlci5jaGFpbklkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NIQUlOX0lEUycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpICE9PSBvdGhlci5hZGRyZXNzLnRvTG93ZXJDYXNlKCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQUREUkVTU0VTJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA8IG90aGVyLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm4gdGhpcyB0b2tlbiwgd2hpY2ggZG9lcyBub3QgbmVlZCB0byBiZSB3cmFwcGVkXHJcbiAgICovXG4gIDtcblxuICBfY3JlYXRlQ2xhc3MoVG9rZW4sIFt7XG4gICAga2V5OiBcIndyYXBwZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUb2tlbjtcbn0oQmFzZUN1cnJlbmN5KTtcblxudmFyIF9XRVRIO1xuLyoqXHJcbiAqIEtub3duIFdFVEg5IGltcGxlbWVudGF0aW9uIGFkZHJlc3NlcywgdXNlZCBpbiBvdXIgaW1wbGVtZW50YXRpb24gb2YgRXRoZXIjd3JhcHBlZFxyXG4gKi9cblxudmFyIFdFVEg5ID0gKF9XRVRIID0ge30sIF9XRVRIWzFdID0gLyojX19QVVJFX18qL25ldyBUb2tlbigxLCAnMHhDMDJhYUEzOWIyMjNGRThEMEEwZTVDNEYyN2VBRDkwODNDNzU2Q2MyJywgMTgsICdXRVRIJywgJ1dyYXBwZWQgRXRoZXInKSwgX1dFVEhbM10gPSAvKiNfX1BVUkVfXyovbmV3IFRva2VuKDMsICcweGM3Nzg0MTdFMDYzMTQxMTM5RmNlMDEwOTgyNzgwMTQwQWEwY0Q1QWInLCAxOCwgJ1dFVEgnLCAnV3JhcHBlZCBFdGhlcicpLCBfV0VUSFs0XSA9IC8qI19fUFVSRV9fKi9uZXcgVG9rZW4oNCwgJzB4Yzc3ODQxN0UwNjMxNDExMzlGY2UwMTA5ODI3ODAxNDBBYTBjRDVBYicsIDE4LCAnV0VUSCcsICdXcmFwcGVkIEV0aGVyJyksIF9XRVRIWzVdID0gLyojX19QVVJFX18qL25ldyBUb2tlbig1LCAnMHhCNEZCRjI3MTE0M0Y0RkJmN0I5MUE1ZGVkMzE4MDVlNDJiMjIwOGQ2JywgMTgsICdXRVRIJywgJ1dyYXBwZWQgRXRoZXInKSwgX1dFVEhbNDJdID0gLyojX19QVVJFX18qL25ldyBUb2tlbig0MiwgJzB4ZDBBMUUzNTk4MTEzMjJkOTc5OTFFMDNmODYzYTBDMzBDMmNGMDI5QycsIDE4LCAnV0VUSCcsICdXcmFwcGVkIEV0aGVyJyksIF9XRVRIWzEwXSA9IC8qI19fUFVSRV9fKi9uZXcgVG9rZW4oMTAsICcweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYnLCAxOCwgJ1dFVEgnLCAnV3JhcHBlZCBFdGhlcicpLCBfV0VUSFs2OV0gPSAvKiNfX1BVUkVfXyovbmV3IFRva2VuKDY5LCAnMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2JywgMTgsICdXRVRIJywgJ1dyYXBwZWQgRXRoZXInKSwgX1dFVEhbNDIxNjFdID0gLyojX19QVVJFX18qL25ldyBUb2tlbig0MjE2MSwgJzB4ODJhRjQ5NDQ3RDhhMDdlM2JkOTVCRDBkNTZmMzUyNDE1MjNmQmFiMScsIDE4LCAnV0VUSCcsICdXcmFwcGVkIEV0aGVyJyksIF9XRVRIWzQyMTYxMV0gPSAvKiNfX1BVUkVfXyovbmV3IFRva2VuKDQyMTYxMSwgJzB4QjQ3ZTZBNWY4YjMzYjNGMTc2MDNDODNhMDUzNUE5ZGNEN0UzMjY4MScsIDE4LCAnV0VUSCcsICdXcmFwcGVkIEV0aGVyJyksIF9XRVRIKTtcblxuLyoqXHJcbiAqIEV0aGVyIGlzIHRoZSBtYWluIHVzYWdlIG9mIGEgJ25hdGl2ZScgY3VycmVuY3ksIGkuZS4gZm9yIEV0aGVyZXVtIG1haW5uZXQgYW5kIGFsbCB0ZXN0bmV0c1xyXG4gKi9cblxudmFyIEV0aGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTmF0aXZlQ3VycmVuY3kpIHtcbiAgX2luaGVyaXRzTG9vc2UoRXRoZXIsIF9OYXRpdmVDdXJyZW5jeSk7XG5cbiAgZnVuY3Rpb24gRXRoZXIoY2hhaW5JZCkge1xuICAgIHJldHVybiBfTmF0aXZlQ3VycmVuY3kuY2FsbCh0aGlzLCBjaGFpbklkLCAxOCwgJ0VUSCcsICdFdGhlcicpIHx8IHRoaXM7XG4gIH1cblxuICBFdGhlci5vbkNoYWluID0gZnVuY3Rpb24gb25DaGFpbihjaGFpbklkKSB7XG4gICAgdmFyIF90aGlzJF9ldGhlckNhY2hlJGNoYTtcblxuICAgIHJldHVybiAoX3RoaXMkX2V0aGVyQ2FjaGUkY2hhID0gdGhpcy5fZXRoZXJDYWNoZVtjaGFpbklkXSkgIT0gbnVsbCA/IF90aGlzJF9ldGhlckNhY2hlJGNoYSA6IHRoaXMuX2V0aGVyQ2FjaGVbY2hhaW5JZF0gPSBuZXcgRXRoZXIoY2hhaW5JZCk7XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IEV0aGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzTmF0aXZlICYmIG90aGVyLmNoYWluSWQgPT09IHRoaXMuY2hhaW5JZDtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoRXRoZXIsIFt7XG4gICAga2V5OiBcIndyYXBwZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciB3ZXRoOSA9IFdFVEg5W3RoaXMuY2hhaW5JZF07XG4gICAgICAhISF3ZXRoOSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1dSQVBQRUQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gd2V0aDk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV0aGVyO1xufShOYXRpdmVDdXJyZW5jeSk7XG5FdGhlci5fZXRoZXJDYWNoZSA9IHt9O1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgcGVyY2VudCBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG1pZCBwcmljZSBhbmQgdGhlIGV4ZWN1dGlvbiBwcmljZSwgaS5lLiBwcmljZSBpbXBhY3QuXHJcbiAqIEBwYXJhbSBtaWRQcmljZSBtaWQgcHJpY2UgYmVmb3JlIHRoZSB0cmFkZVxyXG4gKiBAcGFyYW0gaW5wdXRBbW91bnQgdGhlIGlucHV0IGFtb3VudCBvZiB0aGUgdHJhZGVcclxuICogQHBhcmFtIG91dHB1dEFtb3VudCB0aGUgb3V0cHV0IGFtb3VudCBvZiB0aGUgdHJhZGVcclxuICovXG5cbmZ1bmN0aW9uIGNvbXB1dGVQcmljZUltcGFjdChtaWRQcmljZSwgaW5wdXRBbW91bnQsIG91dHB1dEFtb3VudCkge1xuICB2YXIgcXVvdGVkT3V0cHV0QW1vdW50ID0gbWlkUHJpY2UucXVvdGUoaW5wdXRBbW91bnQpOyAvLyBjYWxjdWxhdGUgcHJpY2UgaW1wYWN0IDo9IChleGFjdFF1b3RlIC0gb3V0cHV0QW1vdW50KSAvIGV4YWN0UXVvdGVcblxuICB2YXIgcHJpY2VJbXBhY3QgPSBxdW90ZWRPdXRwdXRBbW91bnQuc3VidHJhY3Qob3V0cHV0QW1vdW50KS5kaXZpZGUocXVvdGVkT3V0cHV0QW1vdW50KTtcbiAgcmV0dXJuIG5ldyBQZXJjZW50KHByaWNlSW1wYWN0Lm51bWVyYXRvciwgcHJpY2VJbXBhY3QuZGVub21pbmF0b3IpO1xufVxuXG4vLyBgbWF4U2l6ZWAgYnkgcmVtb3ZpbmcgdGhlIGxhc3QgaXRlbVxuXG5mdW5jdGlvbiBzb3J0ZWRJbnNlcnQoaXRlbXMsIGFkZCwgbWF4U2l6ZSwgY29tcGFyYXRvcikge1xuICAhKG1heFNpemUgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ01BWF9TSVpFX1pFUk8nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7IC8vIHRoaXMgaXMgYW4gaW52YXJpYW50IGJlY2F1c2UgdGhlIGludGVyZmFjZSBjYW5ub3QgcmV0dXJuIG11bHRpcGxlIHJlbW92ZWQgaXRlbXMgaWYgaXRlbXMubGVuZ3RoIGV4Y2VlZHMgbWF4U2l6ZVxuXG4gICEoaXRlbXMubGVuZ3RoIDw9IG1heFNpemUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSVRFTVNfU0laRScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDsgLy8gc2hvcnQgY2lyY3VpdCBmaXJzdCBpdGVtIGFkZFxuXG4gIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICBpdGVtcy5wdXNoKGFkZCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlzRnVsbCA9IGl0ZW1zLmxlbmd0aCA9PT0gbWF4U2l6ZTsgLy8gc2hvcnQgY2lyY3VpdCBpZiBmdWxsIGFuZCB0aGUgYWRkaXRpb25hbCBpdGVtIGRvZXMgbm90IGNvbWUgYmVmb3JlIHRoZSBsYXN0IGl0ZW1cblxuICAgIGlmIChpc0Z1bGwgJiYgY29tcGFyYXRvcihpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSwgYWRkKSA8PSAwKSB7XG4gICAgICByZXR1cm4gYWRkO1xuICAgIH1cblxuICAgIHZhciBsbyA9IDAsXG4gICAgICAgIGhpID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuXG4gICAgICBpZiAoY29tcGFyYXRvcihpdGVtc1ttaWRdLCBhZGQpIDw9IDApIHtcbiAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGkgPSBtaWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXRlbXMuc3BsaWNlKGxvLCAwLCBhZGQpO1xuICAgIHJldHVybiBpc0Z1bGwgPyBpdGVtcy5wb3AoKSA6IG51bGw7XG4gIH1cbn1cblxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAvKiNfX1BVUkVfXyovSlNCSS5CaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xudmFyIFpFUk8gPSAvKiNfX1BVUkVfXyovSlNCSS5CaWdJbnQoMCk7XG52YXIgT05FID0gLyojX19QVVJFX18qL0pTQkkuQmlnSW50KDEpO1xudmFyIFRXTyA9IC8qI19fUFVSRV9fKi9KU0JJLkJpZ0ludCgyKTtcbi8qKlxyXG4gKiBDb21wdXRlcyBmbG9vcihzcXJ0KHZhbHVlKSlcclxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSBmb3Igd2hpY2ggdG8gY29tcHV0ZSB0aGUgc3F1YXJlIHJvb3QsIHJvdW5kZWQgZG93blxyXG4gKi9cblxuZnVuY3Rpb24gc3FydCh2YWx1ZSkge1xuICAhSlNCSS5ncmVhdGVyVGhhbk9yRXF1YWwodmFsdWUsIFpFUk8pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTkVHQVRJVkUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7IC8vIHJlbHkgb24gYnVpbHQgaW4gc3FydCBpZiBwb3NzaWJsZVxuXG4gIGlmIChKU0JJLmxlc3NUaGFuKHZhbHVlLCBNQVhfU0FGRV9JTlRFR0VSKSkge1xuICAgIHJldHVybiBKU0JJLkJpZ0ludChNYXRoLmZsb29yKE1hdGguc3FydChKU0JJLnRvTnVtYmVyKHZhbHVlKSkpKTtcbiAgfVxuXG4gIHZhciB6O1xuICB2YXIgeDtcbiAgeiA9IHZhbHVlO1xuICB4ID0gSlNCSS5hZGQoSlNCSS5kaXZpZGUodmFsdWUsIFRXTyksIE9ORSk7XG5cbiAgd2hpbGUgKEpTQkkubGVzc1RoYW4oeCwgeikpIHtcbiAgICB6ID0geDtcbiAgICB4ID0gSlNCSS5kaXZpZGUoSlNCSS5hZGQoSlNCSS5kaXZpZGUodmFsdWUsIHgpLCB4KSwgVFdPKTtcbiAgfVxuXG4gIHJldHVybiB6O1xufVxuXG5leHBvcnQgeyBDdXJyZW5jeUFtb3VudCwgRXRoZXIsIEZyYWN0aW9uLCBNYXhVaW50MjU2LCBOYXRpdmVDdXJyZW5jeSwgUGVyY2VudCwgUHJpY2UsIFJvdW5kaW5nLCBTdXBwb3J0ZWRDaGFpbklkLCBUb2tlbiwgVHJhZGVUeXBlLCBXRVRIOSwgY29tcHV0ZVByaWNlSW1wYWN0LCBzb3J0ZWRJbnNlcnQsIHNxcnQsIHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZGstY29yZS5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/.pnpm/@uniswap+sdk-core@3.2.3/node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js\n");

/***/ })

};
;