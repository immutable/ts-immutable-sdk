"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/oidc-client-ts@2.4.0";
exports.ids = ["vendor-chunks/oidc-client-ts@2.4.0"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/.pnpm/oidc-client-ts@2.4.0/node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/oidc-client-ts@2.4.0/node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccessTokenEvents: () => (/* binding */ AccessTokenEvents),\n/* harmony export */   CheckSessionIFrame: () => (/* binding */ CheckSessionIFrame),\n/* harmony export */   ErrorResponse: () => (/* binding */ ErrorResponse),\n/* harmony export */   ErrorTimeout: () => (/* binding */ ErrorTimeout),\n/* harmony export */   InMemoryWebStorage: () => (/* binding */ InMemoryWebStorage),\n/* harmony export */   Log: () => (/* binding */ Log),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   MetadataService: () => (/* binding */ MetadataService),\n/* harmony export */   OidcClient: () => (/* binding */ OidcClient),\n/* harmony export */   OidcClientSettingsStore: () => (/* binding */ OidcClientSettingsStore),\n/* harmony export */   SessionMonitor: () => (/* binding */ SessionMonitor),\n/* harmony export */   SigninResponse: () => (/* binding */ SigninResponse),\n/* harmony export */   SigninState: () => (/* binding */ SigninState),\n/* harmony export */   SignoutResponse: () => (/* binding */ SignoutResponse),\n/* harmony export */   State: () => (/* binding */ State),\n/* harmony export */   User: () => (/* binding */ User),\n/* harmony export */   UserManager: () => (/* binding */ UserManager),\n/* harmony export */   UserManagerSettingsStore: () => (/* binding */ UserManagerSettingsStore),\n/* harmony export */   Version: () => (/* binding */ Version),\n/* harmony export */   WebStorageStateStore: () => (/* binding */ WebStorageStateStore)\n/* harmony export */ });\n/* harmony import */ var crypto_js_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js/core.js */ \"(ssr)/../../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/core.js\");\n/* harmony import */ var crypto_js_sha256_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto-js/sha256.js */ \"(ssr)/../../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/sha256.js\");\n/* harmony import */ var crypto_js_enc_base64_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto-js/enc-base64.js */ \"(ssr)/../../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-base64.js\");\n/* harmony import */ var crypto_js_enc_utf8_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto-js/enc-utf8.js */ \"(ssr)/../../../node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/enc-utf8.js\");\n/* harmony import */ var jwt_decode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! jwt-decode */ \"(ssr)/../../../node_modules/.pnpm/jwt-decode@3.1.2/node_modules/jwt-decode/build/jwt-decode.esm.js\");\n// src/utils/CryptoUtils.ts\n\n\n\n\n\n// src/utils/Logger.ts\nvar nopLogger = {\n  debug: () => void 0,\n  info: () => void 0,\n  warn: () => void 0,\n  error: () => void 0\n};\nvar level;\nvar logger;\nvar Log = /* @__PURE__ */ ((Log2) => {\n  Log2[Log2[\"NONE\"] = 0] = \"NONE\";\n  Log2[Log2[\"ERROR\"] = 1] = \"ERROR\";\n  Log2[Log2[\"WARN\"] = 2] = \"WARN\";\n  Log2[Log2[\"INFO\"] = 3] = \"INFO\";\n  Log2[Log2[\"DEBUG\"] = 4] = \"DEBUG\";\n  return Log2;\n})(Log || {});\n((Log2) => {\n  function reset() {\n    level = 3 /* INFO */;\n    logger = nopLogger;\n  }\n  Log2.reset = reset;\n  function setLevel(value) {\n    if (!(0 /* NONE */ <= value && value <= 4 /* DEBUG */)) {\n      throw new Error(\"Invalid log level\");\n    }\n    level = value;\n  }\n  Log2.setLevel = setLevel;\n  function setLogger(value) {\n    logger = value;\n  }\n  Log2.setLogger = setLogger;\n})(Log || (Log = {}));\nvar Logger = class {\n  constructor(_name) {\n    this._name = _name;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  debug(...args) {\n    if (level >= 4 /* DEBUG */) {\n      logger.debug(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  info(...args) {\n    if (level >= 3 /* INFO */) {\n      logger.info(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  warn(...args) {\n    if (level >= 2 /* WARN */) {\n      logger.warn(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  error(...args) {\n    if (level >= 1 /* ERROR */) {\n      logger.error(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n  throw(err) {\n    this.error(err);\n    throw err;\n  }\n  create(method) {\n    const methodLogger = Object.create(this);\n    methodLogger._method = method;\n    methodLogger.debug(\"begin\");\n    return methodLogger;\n  }\n  static createStatic(name, staticMethod) {\n    const staticLogger = new Logger(`${name}.${staticMethod}`);\n    staticLogger.debug(\"begin\");\n    return staticLogger;\n  }\n  static _format(name, method) {\n    const prefix = `[${name}]`;\n    return method ? `${prefix} ${method}:` : prefix;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  // helpers for static class methods\n  static debug(name, ...args) {\n    if (level >= 4 /* DEBUG */) {\n      logger.debug(Logger._format(name), ...args);\n    }\n  }\n  static info(name, ...args) {\n    if (level >= 3 /* INFO */) {\n      logger.info(Logger._format(name), ...args);\n    }\n  }\n  static warn(name, ...args) {\n    if (level >= 2 /* WARN */) {\n      logger.warn(Logger._format(name), ...args);\n    }\n  }\n  static error(name, ...args) {\n    if (level >= 1 /* ERROR */) {\n      logger.error(Logger._format(name), ...args);\n    }\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n};\nLog.reset();\n\n// src/utils/CryptoUtils.ts\nvar UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\nvar CryptoUtils = class {\n  static _randomWord() {\n    return crypto_js_core_js__WEBPACK_IMPORTED_MODULE_0__.lib.WordArray.random(1).words[0];\n  }\n  /**\n   * Generates RFC4122 version 4 guid\n   */\n  static generateUUIDv4() {\n    const uuid = UUID_V4_TEMPLATE.replace(\n      /[018]/g,\n      (c) => (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16)\n    );\n    return uuid.replace(/-/g, \"\");\n  }\n  /**\n   * PKCE: Generate a code verifier\n   */\n  static generateCodeVerifier() {\n    return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();\n  }\n  /**\n   * PKCE: Generate a code challenge\n   */\n  static generateCodeChallenge(code_verifier) {\n    try {\n      const hashed = crypto_js_sha256_js__WEBPACK_IMPORTED_MODULE_1__(code_verifier);\n      return crypto_js_enc_base64_js__WEBPACK_IMPORTED_MODULE_2__.stringify(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n    } catch (err) {\n      Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n      throw err;\n    }\n  }\n  /**\n   * Generates a base64-encoded string for a basic auth header\n   */\n  static generateBasicAuth(client_id, client_secret) {\n    const basicAuth = crypto_js_enc_utf8_js__WEBPACK_IMPORTED_MODULE_3__.parse([client_id, client_secret].join(\":\"));\n    return crypto_js_enc_base64_js__WEBPACK_IMPORTED_MODULE_2__.stringify(basicAuth);\n  }\n};\n\n// src/utils/Event.ts\nvar Event = class {\n  constructor(_name) {\n    this._name = _name;\n    this._logger = new Logger(`Event('${this._name}')`);\n    this._callbacks = [];\n  }\n  addHandler(cb) {\n    this._callbacks.push(cb);\n    return () => this.removeHandler(cb);\n  }\n  removeHandler(cb) {\n    const idx = this._callbacks.lastIndexOf(cb);\n    if (idx >= 0) {\n      this._callbacks.splice(idx, 1);\n    }\n  }\n  raise(...ev) {\n    this._logger.debug(\"raise:\", ...ev);\n    for (const cb of this._callbacks) {\n      void cb(...ev);\n    }\n  }\n};\n\n// src/utils/JwtUtils.ts\n\nvar JwtUtils = class {\n  // IMPORTANT: doesn't validate the token\n  static decode(token) {\n    try {\n      return (0,jwt_decode__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(token);\n    } catch (err) {\n      Logger.error(\"JwtUtils.decode\", err);\n      throw err;\n    }\n  }\n};\n\n// src/utils/PopupUtils.ts\nvar PopupUtils = class {\n  /**\n   * Populates a map of window features with a placement centered in front of\n   * the current window. If no explicit width is given, a default value is\n   * binned into [800, 720, 600, 480, 360] based on the current window's width.\n   */\n  static center({ ...features }) {\n    var _a, _b, _c;\n    if (features.width == null)\n      features.width = (_a = [800, 720, 600, 480].find((width) => width <= window.outerWidth / 1.618)) != null ? _a : 360;\n    (_b = features.left) != null ? _b : features.left = Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n    if (features.height != null)\n      (_c = features.top) != null ? _c : features.top = Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n    return features;\n  }\n  static serialize(features) {\n    return Object.entries(features).filter(([, value]) => value != null).map(([key, value]) => `${key}=${typeof value !== \"boolean\" ? value : value ? \"yes\" : \"no\"}`).join(\",\");\n  }\n};\n\n// src/utils/Timer.ts\nvar Timer = class extends Event {\n  constructor() {\n    super(...arguments);\n    this._logger = new Logger(`Timer('${this._name}')`);\n    this._timerHandle = null;\n    this._expiration = 0;\n    this._callback = () => {\n      const diff = this._expiration - Timer.getEpochTime();\n      this._logger.debug(\"timer completes in\", diff);\n      if (this._expiration <= Timer.getEpochTime()) {\n        this.cancel();\n        super.raise();\n      }\n    };\n  }\n  // get the time\n  static getEpochTime() {\n    return Math.floor(Date.now() / 1e3);\n  }\n  init(durationInSeconds) {\n    const logger2 = this._logger.create(\"init\");\n    durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n    const expiration = Timer.getEpochTime() + durationInSeconds;\n    if (this.expiration === expiration && this._timerHandle) {\n      logger2.debug(\"skipping since already initialized for expiration at\", this.expiration);\n      return;\n    }\n    this.cancel();\n    logger2.debug(\"using duration\", durationInSeconds);\n    this._expiration = expiration;\n    const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n    this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1e3);\n  }\n  get expiration() {\n    return this._expiration;\n  }\n  cancel() {\n    this._logger.create(\"cancel\");\n    if (this._timerHandle) {\n      clearInterval(this._timerHandle);\n      this._timerHandle = null;\n    }\n  }\n};\n\n// src/utils/UrlUtils.ts\nvar UrlUtils = class {\n  static readParams(url, responseMode = \"query\") {\n    if (!url)\n      throw new TypeError(\"Invalid URL\");\n    const parsedUrl = new URL(url, \"http://127.0.0.1\");\n    const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n    return new URLSearchParams(params.slice(1));\n  }\n};\nvar URL_STATE_DELIMITER = \";\";\n\n// src/errors/ErrorResponse.ts\nvar ErrorResponse = class extends Error {\n  constructor(args, form) {\n    var _a, _b, _c;\n    super(args.error_description || args.error || \"\");\n    this.form = form;\n    /** Marker to detect class: \"ErrorResponse\" */\n    this.name = \"ErrorResponse\";\n    if (!args.error) {\n      Logger.error(\"ErrorResponse\", \"No error passed\");\n      throw new Error(\"No error passed\");\n    }\n    this.error = args.error;\n    this.error_description = (_a = args.error_description) != null ? _a : null;\n    this.error_uri = (_b = args.error_uri) != null ? _b : null;\n    this.state = args.userState;\n    this.session_state = (_c = args.session_state) != null ? _c : null;\n    this.url_state = args.url_state;\n  }\n};\n\n// src/errors/ErrorTimeout.ts\nvar ErrorTimeout = class extends Error {\n  constructor(message) {\n    super(message);\n    /** Marker to detect class: \"ErrorTimeout\" */\n    this.name = \"ErrorTimeout\";\n  }\n};\n\n// src/AccessTokenEvents.ts\nvar AccessTokenEvents = class {\n  constructor(args) {\n    this._logger = new Logger(\"AccessTokenEvents\");\n    this._expiringTimer = new Timer(\"Access token expiring\");\n    this._expiredTimer = new Timer(\"Access token expired\");\n    this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n  }\n  load(container) {\n    const logger2 = this._logger.create(\"load\");\n    if (container.access_token && container.expires_in !== void 0) {\n      const duration = container.expires_in;\n      logger2.debug(\"access token present, remaining duration:\", duration);\n      if (duration > 0) {\n        let expiring = duration - this._expiringNotificationTimeInSeconds;\n        if (expiring <= 0) {\n          expiring = 1;\n        }\n        logger2.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n        this._expiringTimer.init(expiring);\n      } else {\n        logger2.debug(\"canceling existing expiring timer because we're past expiration.\");\n        this._expiringTimer.cancel();\n      }\n      const expired = duration + 1;\n      logger2.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n      this._expiredTimer.init(expired);\n    } else {\n      this._expiringTimer.cancel();\n      this._expiredTimer.cancel();\n    }\n  }\n  unload() {\n    this._logger.debug(\"unload: canceling existing access token timers\");\n    this._expiringTimer.cancel();\n    this._expiredTimer.cancel();\n  }\n  /**\n   * Add callback: Raised prior to the access token expiring.\n   */\n  addAccessTokenExpiring(cb) {\n    return this._expiringTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised prior to the access token expiring.\n   */\n  removeAccessTokenExpiring(cb) {\n    this._expiringTimer.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised after the access token has expired.\n   */\n  addAccessTokenExpired(cb) {\n    return this._expiredTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised after the access token has expired.\n   */\n  removeAccessTokenExpired(cb) {\n    this._expiredTimer.removeHandler(cb);\n  }\n};\n\n// src/CheckSessionIFrame.ts\nvar CheckSessionIFrame = class {\n  constructor(_callback, _client_id, url, _intervalInSeconds, _stopOnError) {\n    this._callback = _callback;\n    this._client_id = _client_id;\n    this._intervalInSeconds = _intervalInSeconds;\n    this._stopOnError = _stopOnError;\n    this._logger = new Logger(\"CheckSessionIFrame\");\n    this._timer = null;\n    this._session_state = null;\n    this._message = (e) => {\n      if (e.origin === this._frame_origin && e.source === this._frame.contentWindow) {\n        if (e.data === \"error\") {\n          this._logger.error(\"error message from check session op iframe\");\n          if (this._stopOnError) {\n            this.stop();\n          }\n        } else if (e.data === \"changed\") {\n          this._logger.debug(\"changed message from check session op iframe\");\n          this.stop();\n          void this._callback();\n        } else {\n          this._logger.debug(e.data + \" message from check session op iframe\");\n        }\n      }\n    };\n    const parsedUrl = new URL(url);\n    this._frame_origin = parsedUrl.origin;\n    this._frame = window.document.createElement(\"iframe\");\n    this._frame.style.visibility = \"hidden\";\n    this._frame.style.position = \"fixed\";\n    this._frame.style.left = \"-1000px\";\n    this._frame.style.top = \"0\";\n    this._frame.width = \"0\";\n    this._frame.height = \"0\";\n    this._frame.src = parsedUrl.href;\n  }\n  load() {\n    return new Promise((resolve) => {\n      this._frame.onload = () => {\n        resolve();\n      };\n      window.document.body.appendChild(this._frame);\n      window.addEventListener(\"message\", this._message, false);\n    });\n  }\n  start(session_state) {\n    if (this._session_state === session_state) {\n      return;\n    }\n    this._logger.create(\"start\");\n    this.stop();\n    this._session_state = session_state;\n    const send = () => {\n      if (!this._frame.contentWindow || !this._session_state) {\n        return;\n      }\n      this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n    };\n    send();\n    this._timer = setInterval(send, this._intervalInSeconds * 1e3);\n  }\n  stop() {\n    this._logger.create(\"stop\");\n    this._session_state = null;\n    if (this._timer) {\n      clearInterval(this._timer);\n      this._timer = null;\n    }\n  }\n};\n\n// src/InMemoryWebStorage.ts\nvar InMemoryWebStorage = class {\n  constructor() {\n    this._logger = new Logger(\"InMemoryWebStorage\");\n    this._data = {};\n  }\n  clear() {\n    this._logger.create(\"clear\");\n    this._data = {};\n  }\n  getItem(key) {\n    this._logger.create(`getItem('${key}')`);\n    return this._data[key];\n  }\n  setItem(key, value) {\n    this._logger.create(`setItem('${key}')`);\n    this._data[key] = value;\n  }\n  removeItem(key) {\n    this._logger.create(`removeItem('${key}')`);\n    delete this._data[key];\n  }\n  get length() {\n    return Object.getOwnPropertyNames(this._data).length;\n  }\n  key(index) {\n    return Object.getOwnPropertyNames(this._data)[index];\n  }\n};\n\n// src/JsonService.ts\nvar JsonService = class {\n  constructor(additionalContentTypes = [], _jwtHandler = null, _extraHeaders = {}) {\n    this._jwtHandler = _jwtHandler;\n    this._extraHeaders = _extraHeaders;\n    this._logger = new Logger(\"JsonService\");\n    this._contentTypes = [];\n    this._contentTypes.push(...additionalContentTypes, \"application/json\");\n    if (_jwtHandler) {\n      this._contentTypes.push(\"application/jwt\");\n    }\n  }\n  async fetchWithTimeout(input, init = {}) {\n    const { timeoutInSeconds, ...initFetch } = init;\n    if (!timeoutInSeconds) {\n      return await fetch(input, initFetch);\n    }\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1e3);\n    try {\n      const response = await fetch(input, {\n        ...init,\n        signal: controller.signal\n      });\n      return response;\n    } catch (err) {\n      if (err instanceof DOMException && err.name === \"AbortError\") {\n        throw new ErrorTimeout(\"Network timed out\");\n      }\n      throw err;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n  async getJson(url, {\n    token,\n    credentials\n  } = {}) {\n    const logger2 = this._logger.create(\"getJson\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \")\n    };\n    if (token) {\n      logger2.debug(\"token passed, setting Authorization header\");\n      headers[\"Authorization\"] = \"Bearer \" + token;\n    }\n    this.appendExtraHeaders(headers);\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, { method: \"GET\", headers, credentials });\n    } catch (err) {\n      logger2.error(\"Network Error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {\n      logger2.throw(new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`));\n    }\n    if (response.ok && this._jwtHandler && (contentType == null ? void 0 : contentType.startsWith(\"application/jwt\"))) {\n      return await this._jwtHandler(await response.text());\n    }\n    let json;\n    try {\n      json = await response.json();\n    } catch (err) {\n      logger2.error(\"Error parsing JSON response\", err);\n      if (response.ok)\n        throw err;\n      throw new Error(`${response.statusText} (${response.status})`);\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (json.error) {\n        throw new ErrorResponse(json);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n  async postForm(url, {\n    body,\n    basicAuth,\n    timeoutInSeconds,\n    initCredentials\n  }) {\n    const logger2 = this._logger.create(\"postForm\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \"),\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\n    };\n    if (basicAuth !== void 0) {\n      headers[\"Authorization\"] = \"Basic \" + basicAuth;\n    }\n    this.appendExtraHeaders(headers);\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, { method: \"POST\", headers, body, timeoutInSeconds, credentials: initCredentials });\n    } catch (err) {\n      logger2.error(\"Network error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {\n      throw new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`);\n    }\n    const responseText = await response.text();\n    let json = {};\n    if (responseText) {\n      try {\n        json = JSON.parse(responseText);\n      } catch (err) {\n        logger2.error(\"Error parsing JSON response\", err);\n        if (response.ok)\n          throw err;\n        throw new Error(`${response.statusText} (${response.status})`);\n      }\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (json.error) {\n        throw new ErrorResponse(json, body);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n  appendExtraHeaders(headers) {\n    const logger2 = this._logger.create(\"appendExtraHeaders\");\n    const customKeys = Object.keys(this._extraHeaders);\n    const protectedHeaders = [\n      \"authorization\",\n      \"accept\",\n      \"content-type\"\n    ];\n    if (customKeys.length === 0) {\n      return;\n    }\n    customKeys.forEach((headerName) => {\n      if (protectedHeaders.includes(headerName.toLocaleLowerCase())) {\n        logger2.warn(\"Protected header could not be overridden\", headerName, protectedHeaders);\n        return;\n      }\n      const content = typeof this._extraHeaders[headerName] === \"function\" ? this._extraHeaders[headerName]() : this._extraHeaders[headerName];\n      if (content && content !== \"\") {\n        headers[headerName] = content;\n      }\n    });\n  }\n};\n\n// src/MetadataService.ts\nvar MetadataService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"MetadataService\");\n    this._signingKeys = null;\n    this._metadata = null;\n    this._metadataUrl = this._settings.metadataUrl;\n    this._jsonService = new JsonService(\n      [\"application/jwk-set+json\"],\n      null,\n      this._settings.extraHeaders\n    );\n    if (this._settings.signingKeys) {\n      this._logger.debug(\"using signingKeys from settings\");\n      this._signingKeys = this._settings.signingKeys;\n    }\n    if (this._settings.metadata) {\n      this._logger.debug(\"using metadata from settings\");\n      this._metadata = this._settings.metadata;\n    }\n    if (this._settings.fetchRequestCredentials) {\n      this._logger.debug(\"using fetchRequestCredentials from settings\");\n      this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n    }\n  }\n  resetSigningKeys() {\n    this._signingKeys = null;\n  }\n  async getMetadata() {\n    const logger2 = this._logger.create(\"getMetadata\");\n    if (this._metadata) {\n      logger2.debug(\"using cached values\");\n      return this._metadata;\n    }\n    if (!this._metadataUrl) {\n      logger2.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n      throw null;\n    }\n    logger2.debug(\"getting metadata from\", this._metadataUrl);\n    const metadata = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials });\n    logger2.debug(\"merging remote JSON with seed metadata\");\n    this._metadata = Object.assign({}, this._settings.metadataSeed, metadata);\n    return this._metadata;\n  }\n  getIssuer() {\n    return this._getMetadataProperty(\"issuer\");\n  }\n  getAuthorizationEndpoint() {\n    return this._getMetadataProperty(\"authorization_endpoint\");\n  }\n  getUserInfoEndpoint() {\n    return this._getMetadataProperty(\"userinfo_endpoint\");\n  }\n  getTokenEndpoint(optional = true) {\n    return this._getMetadataProperty(\"token_endpoint\", optional);\n  }\n  getCheckSessionIframe() {\n    return this._getMetadataProperty(\"check_session_iframe\", true);\n  }\n  getEndSessionEndpoint() {\n    return this._getMetadataProperty(\"end_session_endpoint\", true);\n  }\n  getRevocationEndpoint(optional = true) {\n    return this._getMetadataProperty(\"revocation_endpoint\", optional);\n  }\n  getKeysEndpoint(optional = true) {\n    return this._getMetadataProperty(\"jwks_uri\", optional);\n  }\n  async _getMetadataProperty(name, optional = false) {\n    const logger2 = this._logger.create(`_getMetadataProperty('${name}')`);\n    const metadata = await this.getMetadata();\n    logger2.debug(\"resolved\");\n    if (metadata[name] === void 0) {\n      if (optional === true) {\n        logger2.warn(\"Metadata does not contain optional property\");\n        return void 0;\n      }\n      logger2.throw(new Error(\"Metadata does not contain property \" + name));\n    }\n    return metadata[name];\n  }\n  async getSigningKeys() {\n    const logger2 = this._logger.create(\"getSigningKeys\");\n    if (this._signingKeys) {\n      logger2.debug(\"returning signingKeys from cache\");\n      return this._signingKeys;\n    }\n    const jwks_uri = await this.getKeysEndpoint(false);\n    logger2.debug(\"got jwks_uri\", jwks_uri);\n    const keySet = await this._jsonService.getJson(jwks_uri);\n    logger2.debug(\"got key set\", keySet);\n    if (!Array.isArray(keySet.keys)) {\n      logger2.throw(new Error(\"Missing keys on keyset\"));\n      throw null;\n    }\n    this._signingKeys = keySet.keys;\n    return this._signingKeys;\n  }\n};\n\n// src/WebStorageStateStore.ts\nvar WebStorageStateStore = class {\n  constructor({\n    prefix = \"oidc.\",\n    store = localStorage\n  } = {}) {\n    this._logger = new Logger(\"WebStorageStateStore\");\n    this._store = store;\n    this._prefix = prefix;\n  }\n  async set(key, value) {\n    this._logger.create(`set('${key}')`);\n    key = this._prefix + key;\n    await this._store.setItem(key, value);\n  }\n  async get(key) {\n    this._logger.create(`get('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    return item;\n  }\n  async remove(key) {\n    this._logger.create(`remove('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    await this._store.removeItem(key);\n    return item;\n  }\n  async getAllKeys() {\n    this._logger.create(\"getAllKeys\");\n    const len = await this._store.length;\n    const keys = [];\n    for (let index = 0; index < len; index++) {\n      const key = await this._store.key(index);\n      if (key && key.indexOf(this._prefix) === 0) {\n        keys.push(key.substr(this._prefix.length));\n      }\n    }\n    return keys;\n  }\n};\n\n// src/OidcClientSettings.ts\nvar DefaultResponseType = \"code\";\nvar DefaultScope = \"openid\";\nvar DefaultClientAuthentication = \"client_secret_post\";\nvar DefaultResponseMode = \"query\";\nvar DefaultStaleStateAgeInSeconds = 60 * 15;\nvar DefaultClockSkewInSeconds = 60 * 5;\nvar OidcClientSettingsStore = class {\n  constructor({\n    // metadata related\n    authority,\n    metadataUrl,\n    metadata,\n    signingKeys,\n    metadataSeed,\n    // client related\n    client_id,\n    client_secret,\n    response_type = DefaultResponseType,\n    scope = DefaultScope,\n    redirect_uri,\n    post_logout_redirect_uri,\n    client_authentication = DefaultClientAuthentication,\n    // optional protocol\n    prompt,\n    display,\n    max_age,\n    ui_locales,\n    acr_values,\n    resource,\n    response_mode = DefaultResponseMode,\n    // behavior flags\n    filterProtocolClaims = true,\n    loadUserInfo = false,\n    staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n    clockSkewInSeconds = DefaultClockSkewInSeconds,\n    userInfoJwtIssuer = \"OP\",\n    mergeClaims = false,\n    disablePKCE = false,\n    // other behavior\n    stateStore,\n    refreshTokenCredentials,\n    revokeTokenAdditionalContentTypes,\n    fetchRequestCredentials,\n    refreshTokenAllowedScope,\n    // extra\n    extraQueryParams = {},\n    extraTokenParams = {},\n    extraHeaders = {}\n  }) {\n    this.authority = authority;\n    if (metadataUrl) {\n      this.metadataUrl = metadataUrl;\n    } else {\n      this.metadataUrl = authority;\n      if (authority) {\n        if (!this.metadataUrl.endsWith(\"/\")) {\n          this.metadataUrl += \"/\";\n        }\n        this.metadataUrl += \".well-known/openid-configuration\";\n      }\n    }\n    this.metadata = metadata;\n    this.metadataSeed = metadataSeed;\n    this.signingKeys = signingKeys;\n    this.client_id = client_id;\n    this.client_secret = client_secret;\n    this.response_type = response_type;\n    this.scope = scope;\n    this.redirect_uri = redirect_uri;\n    this.post_logout_redirect_uri = post_logout_redirect_uri;\n    this.client_authentication = client_authentication;\n    this.prompt = prompt;\n    this.display = display;\n    this.max_age = max_age;\n    this.ui_locales = ui_locales;\n    this.acr_values = acr_values;\n    this.resource = resource;\n    this.response_mode = response_mode;\n    this.filterProtocolClaims = filterProtocolClaims != null ? filterProtocolClaims : true;\n    this.loadUserInfo = !!loadUserInfo;\n    this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n    this.clockSkewInSeconds = clockSkewInSeconds;\n    this.userInfoJwtIssuer = userInfoJwtIssuer;\n    this.mergeClaims = !!mergeClaims;\n    this.disablePKCE = !!disablePKCE;\n    this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n    if (fetchRequestCredentials && refreshTokenCredentials) {\n      console.warn(\"Both fetchRequestCredentials and refreshTokenCredentials is set. Only fetchRequestCredentials will be used.\");\n    }\n    this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : refreshTokenCredentials ? refreshTokenCredentials : \"same-origin\";\n    if (stateStore) {\n      this.stateStore = stateStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n      this.stateStore = new WebStorageStateStore({ store });\n    }\n    this.refreshTokenAllowedScope = refreshTokenAllowedScope;\n    this.extraQueryParams = extraQueryParams;\n    this.extraTokenParams = extraTokenParams;\n    this.extraHeaders = extraHeaders;\n  }\n};\n\n// src/UserInfoService.ts\nvar UserInfoService = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"UserInfoService\");\n    this._getClaimsFromJwt = async (responseText) => {\n      const logger2 = this._logger.create(\"_getClaimsFromJwt\");\n      try {\n        const payload = JwtUtils.decode(responseText);\n        logger2.debug(\"JWT decoding successful\");\n        return payload;\n      } catch (err) {\n        logger2.error(\"Error parsing JWT response\");\n        throw err;\n      }\n    };\n    this._jsonService = new JsonService(\n      void 0,\n      this._getClaimsFromJwt,\n      this._settings.extraHeaders\n    );\n  }\n  async getClaims(token) {\n    const logger2 = this._logger.create(\"getClaims\");\n    if (!token) {\n      this._logger.throw(new Error(\"No token passed\"));\n    }\n    const url = await this._metadataService.getUserInfoEndpoint();\n    logger2.debug(\"got userinfo url\", url);\n    const claims = await this._jsonService.getJson(url, {\n      token,\n      credentials: this._settings.fetchRequestCredentials\n    });\n    logger2.debug(\"got claims\", claims);\n    return claims;\n  }\n};\n\n// src/TokenClient.ts\nvar TokenClient = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"TokenClient\");\n    this._jsonService = new JsonService(\n      this._settings.revokeTokenAdditionalContentTypes,\n      null,\n      this._settings.extraHeaders\n    );\n  }\n  /**\n   * Exchange code.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n   */\n  async exchangeCode({\n    grant_type = \"authorization_code\",\n    redirect_uri = this._settings.redirect_uri,\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeCode\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!redirect_uri) {\n      logger2.throw(new Error(\"A redirect_uri is required\"));\n    }\n    if (!args.code) {\n      logger2.throw(new Error(\"A code is required\"));\n    }\n    const params = new URLSearchParams({ grant_type, redirect_uri });\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Exchange credentials.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2\n   */\n  async exchangeCredentials({\n    grant_type = \"password\",\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    scope = this._settings.scope,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeCredentials\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    const params = new URLSearchParams({ grant_type, scope });\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Exchange a refresh token.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-6\n   */\n  async exchangeRefreshToken({\n    grant_type = \"refresh_token\",\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    timeoutInSeconds,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeRefreshToken\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!args.refresh_token) {\n      logger2.throw(new Error(\"A refresh_token is required\"));\n    }\n    const params = new URLSearchParams({ grant_type });\n    for (const [key, value] of Object.entries(args)) {\n      if (Array.isArray(value)) {\n        value.forEach((param) => params.append(key, param));\n      } else if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Revoke an access or refresh token.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n   */\n  async revoke(args) {\n    var _a;\n    const logger2 = this._logger.create(\"revoke\");\n    if (!args.token) {\n      logger2.throw(new Error(\"A token is required\"));\n    }\n    const url = await this._metadataService.getRevocationEndpoint(false);\n    logger2.debug(`got revocation endpoint, revoking ${(_a = args.token_type_hint) != null ? _a : \"default token type\"}`);\n    const params = new URLSearchParams();\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    params.set(\"client_id\", this._settings.client_id);\n    if (this._settings.client_secret) {\n      params.set(\"client_secret\", this._settings.client_secret);\n    }\n    await this._jsonService.postForm(url, { body: params });\n    logger2.debug(\"got response\");\n  }\n};\n\n// src/ResponseValidator.ts\nvar ResponseValidator = class {\n  constructor(_settings, _metadataService, _claimsService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._claimsService = _claimsService;\n    this._logger = new Logger(\"ResponseValidator\");\n    this._userInfoService = new UserInfoService(this._settings, this._metadataService);\n    this._tokenClient = new TokenClient(this._settings, this._metadataService);\n  }\n  async validateSigninResponse(response, state) {\n    const logger2 = this._logger.create(\"validateSigninResponse\");\n    this._processSigninState(response, state);\n    logger2.debug(\"state processed\");\n    await this._processCode(response, state);\n    logger2.debug(\"code processed\");\n    if (response.isOpenId) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, state == null ? void 0 : state.skipUserInfo, response.isOpenId);\n    logger2.debug(\"claims processed\");\n  }\n  async validateCredentialsResponse(response, skipUserInfo) {\n    const logger2 = this._logger.create(\"validateCredentialsResponse\");\n    if (response.isOpenId && !!response.id_token) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, skipUserInfo, response.isOpenId);\n    logger2.debug(\"claims processed\");\n  }\n  async validateRefreshResponse(response, state) {\n    var _a, _b;\n    const logger2 = this._logger.create(\"validateRefreshResponse\");\n    response.userState = state.data;\n    (_a = response.session_state) != null ? _a : response.session_state = state.session_state;\n    (_b = response.scope) != null ? _b : response.scope = state.scope;\n    if (response.isOpenId && !!response.id_token) {\n      this._validateIdTokenAttributes(response, state.id_token);\n      logger2.debug(\"ID Token validated\");\n    }\n    if (!response.id_token) {\n      response.id_token = state.id_token;\n      response.profile = state.profile;\n    }\n    const hasIdToken = response.isOpenId && !!response.id_token;\n    await this._processClaims(response, false, hasIdToken);\n    logger2.debug(\"claims processed\");\n  }\n  validateSignoutResponse(response, state) {\n    const logger2 = this._logger.create(\"validateSignoutResponse\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n  }\n  _processSigninState(response, state) {\n    var _a;\n    const logger2 = this._logger.create(\"_processSigninState\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    if (!state.client_id) {\n      logger2.throw(new Error(\"No client_id on state\"));\n    }\n    if (!state.authority) {\n      logger2.throw(new Error(\"No authority on state\"));\n    }\n    if (this._settings.authority !== state.authority) {\n      logger2.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n    }\n    if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n      logger2.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    response.url_state = state.url_state;\n    (_a = response.scope) != null ? _a : response.scope = state.scope;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n    if (state.code_verifier && !response.code) {\n      logger2.throw(new Error(\"Expected code in response\"));\n    }\n  }\n  async _processClaims(response, skipUserInfo = false, validateSub = true) {\n    const logger2 = this._logger.create(\"_processClaims\");\n    response.profile = this._claimsService.filterProtocolClaims(response.profile);\n    if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n      logger2.debug(\"not loading user info\");\n      return;\n    }\n    logger2.debug(\"loading user info\");\n    const claims = await this._userInfoService.getClaims(response.access_token);\n    logger2.debug(\"user info claims received from user info endpoint\");\n    if (validateSub && claims.sub !== response.profile.sub) {\n      logger2.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n    }\n    response.profile = this._claimsService.mergeClaims(response.profile, this._claimsService.filterProtocolClaims(claims));\n    logger2.debug(\"user info claims received, updated profile:\", response.profile);\n  }\n  async _processCode(response, state) {\n    const logger2 = this._logger.create(\"_processCode\");\n    if (response.code) {\n      logger2.debug(\"Validating code\");\n      const tokenResponse = await this._tokenClient.exchangeCode({\n        client_id: state.client_id,\n        client_secret: state.client_secret,\n        code: response.code,\n        redirect_uri: state.redirect_uri,\n        code_verifier: state.code_verifier,\n        ...state.extraTokenParams\n      });\n      Object.assign(response, tokenResponse);\n    } else {\n      logger2.debug(\"No code to process\");\n    }\n  }\n  _validateIdTokenAttributes(response, existingToken) {\n    var _a;\n    const logger2 = this._logger.create(\"_validateIdTokenAttributes\");\n    logger2.debug(\"decoding ID Token JWT\");\n    const incoming = JwtUtils.decode((_a = response.id_token) != null ? _a : \"\");\n    if (!incoming.sub) {\n      logger2.throw(new Error(\"ID Token is missing a subject claim\"));\n    }\n    if (existingToken) {\n      const existing = JwtUtils.decode(existingToken);\n      if (incoming.sub !== existing.sub) {\n        logger2.throw(new Error(\"sub in id_token does not match current sub\"));\n      }\n      if (incoming.auth_time && incoming.auth_time !== existing.auth_time) {\n        logger2.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n      }\n      if (incoming.azp && incoming.azp !== existing.azp) {\n        logger2.throw(new Error(\"azp in id_token does not match original azp\"));\n      }\n      if (!incoming.azp && existing.azp) {\n        logger2.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n      }\n    }\n    response.profile = incoming;\n  }\n};\n\n// src/State.ts\nvar State = class {\n  constructor(args) {\n    this.id = args.id || CryptoUtils.generateUUIDv4();\n    this.data = args.data;\n    if (args.created && args.created > 0) {\n      this.created = args.created;\n    } else {\n      this.created = Timer.getEpochTime();\n    }\n    this.request_type = args.request_type;\n    this.url_state = args.url_state;\n  }\n  toStorageString() {\n    new Logger(\"State\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"State\", \"fromStorageString\");\n    return new State(JSON.parse(storageString));\n  }\n  static async clearStaleState(storage, age) {\n    const logger2 = Logger.createStatic(\"State\", \"clearStaleState\");\n    const cutoff = Timer.getEpochTime() - age;\n    const keys = await storage.getAllKeys();\n    logger2.debug(\"got keys\", keys);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const item = await storage.get(key);\n      let remove = false;\n      if (item) {\n        try {\n          const state = State.fromStorageString(item);\n          logger2.debug(\"got item from key:\", key, state.created);\n          if (state.created <= cutoff) {\n            remove = true;\n          }\n        } catch (err) {\n          logger2.error(\"Error parsing state for key:\", key, err);\n          remove = true;\n        }\n      } else {\n        logger2.debug(\"no item in storage for key:\", key);\n        remove = true;\n      }\n      if (remove) {\n        logger2.debug(\"removed item for key:\", key);\n        void storage.remove(key);\n      }\n    }\n  }\n};\n\n// src/SigninState.ts\nvar SigninState = class extends State {\n  constructor(args) {\n    super(args);\n    if (args.code_verifier === true) {\n      this.code_verifier = CryptoUtils.generateCodeVerifier();\n    } else if (args.code_verifier) {\n      this.code_verifier = args.code_verifier;\n    }\n    if (this.code_verifier) {\n      this.code_challenge = CryptoUtils.generateCodeChallenge(this.code_verifier);\n    }\n    this.authority = args.authority;\n    this.client_id = args.client_id;\n    this.redirect_uri = args.redirect_uri;\n    this.scope = args.scope;\n    this.client_secret = args.client_secret;\n    this.extraTokenParams = args.extraTokenParams;\n    this.response_mode = args.response_mode;\n    this.skipUserInfo = args.skipUserInfo;\n  }\n  toStorageString() {\n    new Logger(\"SigninState\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state,\n      code_verifier: this.code_verifier,\n      authority: this.authority,\n      client_id: this.client_id,\n      redirect_uri: this.redirect_uri,\n      scope: this.scope,\n      client_secret: this.client_secret,\n      extraTokenParams: this.extraTokenParams,\n      response_mode: this.response_mode,\n      skipUserInfo: this.skipUserInfo\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"SigninState\", \"fromStorageString\");\n    const data = JSON.parse(storageString);\n    return new SigninState(data);\n  }\n};\n\n// src/SigninRequest.ts\nvar SigninRequest = class {\n  constructor({\n    // mandatory\n    url,\n    authority,\n    client_id,\n    redirect_uri,\n    response_type,\n    scope,\n    // optional\n    state_data,\n    response_mode,\n    request_type,\n    client_secret,\n    nonce,\n    url_state,\n    resource,\n    skipUserInfo,\n    extraQueryParams,\n    extraTokenParams,\n    disablePKCE,\n    ...optionalParams\n  }) {\n    this._logger = new Logger(\"SigninRequest\");\n    if (!url) {\n      this._logger.error(\"ctor: No url passed\");\n      throw new Error(\"url\");\n    }\n    if (!client_id) {\n      this._logger.error(\"ctor: No client_id passed\");\n      throw new Error(\"client_id\");\n    }\n    if (!redirect_uri) {\n      this._logger.error(\"ctor: No redirect_uri passed\");\n      throw new Error(\"redirect_uri\");\n    }\n    if (!response_type) {\n      this._logger.error(\"ctor: No response_type passed\");\n      throw new Error(\"response_type\");\n    }\n    if (!scope) {\n      this._logger.error(\"ctor: No scope passed\");\n      throw new Error(\"scope\");\n    }\n    if (!authority) {\n      this._logger.error(\"ctor: No authority passed\");\n      throw new Error(\"authority\");\n    }\n    this.state = new SigninState({\n      data: state_data,\n      request_type,\n      url_state,\n      code_verifier: !disablePKCE,\n      client_id,\n      authority,\n      redirect_uri,\n      response_mode,\n      client_secret,\n      scope,\n      extraTokenParams,\n      skipUserInfo\n    });\n    const parsedUrl = new URL(url);\n    parsedUrl.searchParams.append(\"client_id\", client_id);\n    parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n    parsedUrl.searchParams.append(\"response_type\", response_type);\n    parsedUrl.searchParams.append(\"scope\", scope);\n    if (nonce) {\n      parsedUrl.searchParams.append(\"nonce\", nonce);\n    }\n    let state = this.state.id;\n    if (url_state) {\n      state = `${state}${URL_STATE_DELIMITER}${url_state}`;\n    }\n    parsedUrl.searchParams.append(\"state\", state);\n    if (this.state.code_challenge) {\n      parsedUrl.searchParams.append(\"code_challenge\", this.state.code_challenge);\n      parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n    }\n    if (resource) {\n      const resources = Array.isArray(resource) ? resource : [resource];\n      resources.forEach((r) => parsedUrl.searchParams.append(\"resource\", r));\n    }\n    for (const [key, value] of Object.entries({ response_mode, ...optionalParams, ...extraQueryParams })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    this.url = parsedUrl.href;\n  }\n};\n\n// src/SigninResponse.ts\nvar OidcScope = \"openid\";\nvar SigninResponse = class {\n  constructor(params) {\n    /** @see {@link User.access_token} */\n    this.access_token = \"\";\n    /** @see {@link User.token_type} */\n    this.token_type = \"\";\n    /** @see {@link User.profile} */\n    this.profile = {};\n    this.state = params.get(\"state\");\n    this.session_state = params.get(\"session_state\");\n    if (this.state) {\n      const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n      this.state = splitState[0];\n      if (splitState.length > 1) {\n        this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n      }\n    }\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n    this.code = params.get(\"code\");\n  }\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (typeof value === \"string\")\n      value = Number(value);\n    if (value !== void 0 && value >= 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  get isOpenId() {\n    var _a;\n    return ((_a = this.scope) == null ? void 0 : _a.split(\" \").includes(OidcScope)) || !!this.id_token;\n  }\n};\n\n// src/SignoutRequest.ts\nvar SignoutRequest = class {\n  constructor({\n    url,\n    state_data,\n    id_token_hint,\n    post_logout_redirect_uri,\n    extraQueryParams,\n    request_type,\n    client_id\n  }) {\n    this._logger = new Logger(\"SignoutRequest\");\n    if (!url) {\n      this._logger.error(\"ctor: No url passed\");\n      throw new Error(\"url\");\n    }\n    const parsedUrl = new URL(url);\n    if (id_token_hint) {\n      parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n    }\n    if (client_id) {\n      parsedUrl.searchParams.append(\"client_id\", client_id);\n    }\n    if (post_logout_redirect_uri) {\n      parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n      if (state_data) {\n        this.state = new State({ data: state_data, request_type });\n        parsedUrl.searchParams.append(\"state\", this.state.id);\n      }\n    }\n    for (const [key, value] of Object.entries({ ...extraQueryParams })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    this.url = parsedUrl.href;\n  }\n};\n\n// src/SignoutResponse.ts\nvar SignoutResponse = class {\n  constructor(params) {\n    this.state = params.get(\"state\");\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n  }\n};\n\n// src/ClaimsService.ts\nvar DefaultProtocolClaims = [\n  \"nbf\",\n  \"jti\",\n  \"auth_time\",\n  \"nonce\",\n  \"acr\",\n  \"amr\",\n  \"azp\",\n  \"at_hash\"\n  // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n];\nvar InternalRequiredProtocolClaims = [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"];\nvar ClaimsService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"ClaimsService\");\n  }\n  filterProtocolClaims(claims) {\n    const result = { ...claims };\n    if (this._settings.filterProtocolClaims) {\n      let protocolClaims;\n      if (Array.isArray(this._settings.filterProtocolClaims)) {\n        protocolClaims = this._settings.filterProtocolClaims;\n      } else {\n        protocolClaims = DefaultProtocolClaims;\n      }\n      for (const claim of protocolClaims) {\n        if (!InternalRequiredProtocolClaims.includes(claim)) {\n          delete result[claim];\n        }\n      }\n    }\n    return result;\n  }\n  mergeClaims(claims1, claims2) {\n    const result = { ...claims1 };\n    for (const [claim, values] of Object.entries(claims2)) {\n      for (const value of Array.isArray(values) ? values : [values]) {\n        const previousValue = result[claim];\n        if (previousValue === void 0) {\n          result[claim] = value;\n        } else if (Array.isArray(previousValue)) {\n          if (!previousValue.includes(value)) {\n            previousValue.push(value);\n          }\n        } else if (result[claim] !== value) {\n          if (typeof value === \"object\" && this._settings.mergeClaims) {\n            result[claim] = this.mergeClaims(previousValue, value);\n          } else {\n            result[claim] = [previousValue, value];\n          }\n        }\n      }\n    }\n    return result;\n  }\n};\n\n// src/OidcClient.ts\nvar OidcClient = class {\n  constructor(settings, metadataService) {\n    this._logger = new Logger(\"OidcClient\");\n    this.settings = settings instanceof OidcClientSettingsStore ? settings : new OidcClientSettingsStore(settings);\n    this.metadataService = metadataService != null ? metadataService : new MetadataService(this.settings);\n    this._claimsService = new ClaimsService(this.settings);\n    this._validator = new ResponseValidator(this.settings, this.metadataService, this._claimsService);\n    this._tokenClient = new TokenClient(this.settings, this.metadataService);\n  }\n  async createSigninRequest({\n    state,\n    request,\n    request_uri,\n    request_type,\n    id_token_hint,\n    login_hint,\n    skipUserInfo,\n    nonce,\n    url_state,\n    response_type = this.settings.response_type,\n    scope = this.settings.scope,\n    redirect_uri = this.settings.redirect_uri,\n    prompt = this.settings.prompt,\n    display = this.settings.display,\n    max_age = this.settings.max_age,\n    ui_locales = this.settings.ui_locales,\n    acr_values = this.settings.acr_values,\n    resource = this.settings.resource,\n    response_mode = this.settings.response_mode,\n    extraQueryParams = this.settings.extraQueryParams,\n    extraTokenParams = this.settings.extraTokenParams\n  }) {\n    const logger2 = this._logger.create(\"createSigninRequest\");\n    if (response_type !== \"code\") {\n      throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n    }\n    const url = await this.metadataService.getAuthorizationEndpoint();\n    logger2.debug(\"Received authorization endpoint\", url);\n    const signinRequest = new SigninRequest({\n      url,\n      authority: this.settings.authority,\n      client_id: this.settings.client_id,\n      redirect_uri,\n      response_type,\n      scope,\n      state_data: state,\n      url_state,\n      prompt,\n      display,\n      max_age,\n      ui_locales,\n      id_token_hint,\n      login_hint,\n      acr_values,\n      resource,\n      request,\n      request_uri,\n      extraQueryParams,\n      extraTokenParams,\n      request_type,\n      response_mode,\n      client_secret: this.settings.client_secret,\n      skipUserInfo,\n      nonce,\n      disablePKCE: this.settings.disablePKCE\n    });\n    await this.clearStaleState();\n    const signinState = signinRequest.state;\n    await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n    return signinRequest;\n  }\n  async readSigninResponseState(url, removeState = false) {\n    const logger2 = this._logger.create(\"readSigninResponseState\");\n    const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.throw(new Error(\"No state in response\"));\n      throw null;\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = SigninState.fromStorageString(storedStateString);\n    return { state, response };\n  }\n  async processSigninResponse(url) {\n    const logger2 = this._logger.create(\"processSigninResponse\");\n    const { state, response } = await this.readSigninResponseState(url, true);\n    logger2.debug(\"received state from storage; validating response\");\n    await this._validator.validateSigninResponse(response, state);\n    return response;\n  }\n  async processResourceOwnerPasswordCredentials({\n    username,\n    password,\n    skipUserInfo = false,\n    extraTokenParams = {}\n  }) {\n    const tokenResponse = await this._tokenClient.exchangeCredentials({ username, password, ...extraTokenParams });\n    const signinResponse = new SigninResponse(new URLSearchParams());\n    Object.assign(signinResponse, tokenResponse);\n    await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n    return signinResponse;\n  }\n  async useRefreshToken({\n    state,\n    timeoutInSeconds\n  }) {\n    var _a;\n    const logger2 = this._logger.create(\"useRefreshToken\");\n    let scope;\n    if (this.settings.refreshTokenAllowedScope === void 0) {\n      scope = state.scope;\n    } else {\n      const allowableScopes = this.settings.refreshTokenAllowedScope.split(\" \");\n      const providedScopes = ((_a = state.scope) == null ? void 0 : _a.split(\" \")) || [];\n      scope = providedScopes.filter((s) => allowableScopes.includes(s)).join(\" \");\n    }\n    const result = await this._tokenClient.exchangeRefreshToken({\n      refresh_token: state.refresh_token,\n      resource: state.resource,\n      // provide the (possible filtered) scope list\n      scope,\n      timeoutInSeconds\n    });\n    const response = new SigninResponse(new URLSearchParams());\n    Object.assign(response, result);\n    logger2.debug(\"validating response\", response);\n    await this._validator.validateRefreshResponse(response, {\n      ...state,\n      // overide the scope in the state handed over to the validator\n      // so it can set the granted scope to the requested scope in case none is included in the response\n      scope\n    });\n    return response;\n  }\n  async createSignoutRequest({\n    state,\n    id_token_hint,\n    client_id,\n    request_type,\n    post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n    extraQueryParams = this.settings.extraQueryParams\n  } = {}) {\n    const logger2 = this._logger.create(\"createSignoutRequest\");\n    const url = await this.metadataService.getEndSessionEndpoint();\n    if (!url) {\n      logger2.throw(new Error(\"No end session endpoint\"));\n      throw null;\n    }\n    logger2.debug(\"Received end session endpoint\", url);\n    if (!client_id && post_logout_redirect_uri && !id_token_hint) {\n      client_id = this.settings.client_id;\n    }\n    const request = new SignoutRequest({\n      url,\n      id_token_hint,\n      client_id,\n      post_logout_redirect_uri,\n      state_data: state,\n      extraQueryParams,\n      request_type\n    });\n    await this.clearStaleState();\n    const signoutState = request.state;\n    if (signoutState) {\n      logger2.debug(\"Signout request has state to persist\");\n      await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n    }\n    return request;\n  }\n  async readSignoutResponseState(url, removeState = false) {\n    const logger2 = this._logger.create(\"readSignoutResponseState\");\n    const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.debug(\"No state in response\");\n      if (response.error) {\n        logger2.warn(\"Response was error:\", response.error);\n        throw new ErrorResponse(response);\n      }\n      return { state: void 0, response };\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = State.fromStorageString(storedStateString);\n    return { state, response };\n  }\n  async processSignoutResponse(url) {\n    const logger2 = this._logger.create(\"processSignoutResponse\");\n    const { state, response } = await this.readSignoutResponseState(url, true);\n    if (state) {\n      logger2.debug(\"Received state from storage; validating response\");\n      this._validator.validateSignoutResponse(response, state);\n    } else {\n      logger2.debug(\"No state from storage; skipping response validation\");\n    }\n    return response;\n  }\n  clearStaleState() {\n    this._logger.create(\"clearStaleState\");\n    return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n  }\n  async revokeToken(token, type) {\n    this._logger.create(\"revokeToken\");\n    return await this._tokenClient.revoke({\n      token,\n      token_type_hint: type\n    });\n  }\n};\n\n// src/SessionMonitor.ts\nvar SessionMonitor = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SessionMonitor\");\n    this._start = async (user) => {\n      const session_state = user.session_state;\n      if (!session_state) {\n        return;\n      }\n      const logger2 = this._logger.create(\"_start\");\n      if (user.profile) {\n        this._sub = user.profile.sub;\n        this._sid = user.profile.sid;\n        logger2.debug(\"session_state\", session_state, \", sub\", this._sub);\n      } else {\n        this._sub = void 0;\n        this._sid = void 0;\n        logger2.debug(\"session_state\", session_state, \", anonymous user\");\n      }\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.start(session_state);\n        return;\n      }\n      try {\n        const url = await this._userManager.metadataService.getCheckSessionIframe();\n        if (url) {\n          logger2.debug(\"initializing check session iframe\");\n          const client_id = this._userManager.settings.client_id;\n          const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n          const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n          const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n          await checkSessionIFrame.load();\n          this._checkSessionIFrame = checkSessionIFrame;\n          checkSessionIFrame.start(session_state);\n        } else {\n          logger2.warn(\"no check session iframe found in the metadata\");\n        }\n      } catch (err) {\n        logger2.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n      }\n    };\n    this._stop = () => {\n      const logger2 = this._logger.create(\"_stop\");\n      this._sub = void 0;\n      this._sid = void 0;\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.stop();\n      }\n      if (this._userManager.settings.monitorAnonymousSession) {\n        const timerHandle = setInterval(async () => {\n          clearInterval(timerHandle);\n          try {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n              const tmpUser = {\n                session_state: session.session_state,\n                profile: session.sub && session.sid ? {\n                  sub: session.sub,\n                  sid: session.sid\n                } : null\n              };\n              void this._start(tmpUser);\n            }\n          } catch (err) {\n            logger2.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n          }\n        }, 1e3);\n      }\n    };\n    this._callback = async () => {\n      const logger2 = this._logger.create(\"_callback\");\n      try {\n        const session = await this._userManager.querySessionStatus();\n        let raiseEvent = true;\n        if (session && this._checkSessionIFrame) {\n          if (session.sub === this._sub) {\n            raiseEvent = false;\n            this._checkSessionIFrame.start(session.session_state);\n            if (session.sid === this._sid) {\n              logger2.debug(\"same sub still logged in at OP, restarting check session iframe; session_state\", session.session_state);\n            } else {\n              logger2.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n              this._userManager.events._raiseUserSessionChanged();\n            }\n          } else {\n            logger2.debug(\"different subject signed into OP\", session.sub);\n          }\n        } else {\n          logger2.debug(\"subject no longer signed into OP\");\n        }\n        if (raiseEvent) {\n          if (this._sub) {\n            this._userManager.events._raiseUserSignedOut();\n          } else {\n            this._userManager.events._raiseUserSignedIn();\n          }\n        } else {\n          logger2.debug(\"no change in session detected, no event to raise\");\n        }\n      } catch (err) {\n        if (this._sub) {\n          logger2.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n          this._userManager.events._raiseUserSignedOut();\n        }\n      }\n    };\n    if (!_userManager) {\n      this._logger.throw(new Error(\"No user manager passed\"));\n    }\n    this._userManager.events.addUserLoaded(this._start);\n    this._userManager.events.addUserUnloaded(this._stop);\n    this._init().catch((err) => {\n      this._logger.error(err);\n    });\n  }\n  async _init() {\n    this._logger.create(\"_init\");\n    const user = await this._userManager.getUser();\n    if (user) {\n      void this._start(user);\n    } else if (this._userManager.settings.monitorAnonymousSession) {\n      const session = await this._userManager.querySessionStatus();\n      if (session) {\n        const tmpUser = {\n          session_state: session.session_state,\n          profile: session.sub && session.sid ? {\n            sub: session.sub,\n            sid: session.sid\n          } : null\n        };\n        void this._start(tmpUser);\n      }\n    }\n  }\n};\n\n// src/User.ts\nvar User = class {\n  constructor(args) {\n    var _a;\n    this.id_token = args.id_token;\n    this.session_state = (_a = args.session_state) != null ? _a : null;\n    this.access_token = args.access_token;\n    this.refresh_token = args.refresh_token;\n    this.token_type = args.token_type;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.expires_at = args.expires_at;\n    this.state = args.userState;\n    this.url_state = args.url_state;\n  }\n  /** Computed number of seconds the access token has remaining. */\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (value !== void 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  /** Computed value indicating if the access token is expired. */\n  get expired() {\n    const expires_in = this.expires_in;\n    if (expires_in === void 0) {\n      return void 0;\n    }\n    return expires_in <= 0;\n  }\n  /** Array representing the parsed values from the `scope`. */\n  get scopes() {\n    var _a, _b;\n    return (_b = (_a = this.scope) == null ? void 0 : _a.split(\" \")) != null ? _b : [];\n  }\n  toStorageString() {\n    new Logger(\"User\").create(\"toStorageString\");\n    return JSON.stringify({\n      id_token: this.id_token,\n      session_state: this.session_state,\n      access_token: this.access_token,\n      refresh_token: this.refresh_token,\n      token_type: this.token_type,\n      scope: this.scope,\n      profile: this.profile,\n      expires_at: this.expires_at\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"User\", \"fromStorageString\");\n    return new User(JSON.parse(storageString));\n  }\n};\n\n// src/navigators/AbstractChildWindow.ts\nvar messageSource = \"oidc-client\";\nvar AbstractChildWindow = class {\n  constructor() {\n    this._abort = new Event(\"Window navigation aborted\");\n    this._disposeHandlers = /* @__PURE__ */ new Set();\n    this._window = null;\n  }\n  async navigate(params) {\n    const logger2 = this._logger.create(\"navigate\");\n    if (!this._window) {\n      throw new Error(\"Attempted to navigate on a disposed window\");\n    }\n    logger2.debug(\"setting URL in window\");\n    this._window.location.replace(params.url);\n    const { url, keepOpen } = await new Promise((resolve, reject) => {\n      const listener = (e) => {\n        var _a;\n        const data = e.data;\n        const origin = (_a = params.scriptOrigin) != null ? _a : window.location.origin;\n        if (e.origin !== origin || (data == null ? void 0 : data.source) !== messageSource) {\n          return;\n        }\n        try {\n          const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n          if (!state) {\n            logger2.warn(\"no state found in response url\");\n          }\n          if (e.source !== this._window && state !== params.state) {\n            return;\n          }\n        } catch (err) {\n          this._dispose();\n          reject(new Error(\"Invalid response from window\"));\n        }\n        resolve(data);\n      };\n      window.addEventListener(\"message\", listener, false);\n      this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n      this._disposeHandlers.add(this._abort.addHandler((reason) => {\n        this._dispose();\n        reject(reason);\n      }));\n    });\n    logger2.debug(\"got response from window\");\n    this._dispose();\n    if (!keepOpen) {\n      this.close();\n    }\n    return { url };\n  }\n  _dispose() {\n    this._logger.create(\"_dispose\");\n    for (const dispose of this._disposeHandlers) {\n      dispose();\n    }\n    this._disposeHandlers.clear();\n  }\n  static _notifyParent(parent, url, keepOpen = false, targetOrigin = window.location.origin) {\n    parent.postMessage({\n      source: messageSource,\n      url,\n      keepOpen\n    }, targetOrigin);\n  }\n};\n\n// src/UserManagerSettings.ts\nvar DefaultPopupWindowFeatures = {\n  location: false,\n  toolbar: false,\n  height: 640,\n  closePopupWindowAfterInSeconds: -1\n};\nvar DefaultPopupTarget = \"_blank\";\nvar DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nvar DefaultCheckSessionIntervalInSeconds = 2;\nvar DefaultSilentRequestTimeoutInSeconds = 10;\nvar UserManagerSettingsStore = class extends OidcClientSettingsStore {\n  constructor(args) {\n    const {\n      popup_redirect_uri = args.redirect_uri,\n      popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n      popupWindowFeatures = DefaultPopupWindowFeatures,\n      popupWindowTarget = DefaultPopupTarget,\n      redirectMethod = \"assign\",\n      redirectTarget = \"self\",\n      iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n      iframeScriptOrigin = args.iframeScriptOrigin,\n      silent_redirect_uri = args.redirect_uri,\n      silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n      automaticSilentRenew = true,\n      validateSubOnSilentRenew = true,\n      includeIdTokenInSilentRenew = false,\n      monitorSession = false,\n      monitorAnonymousSession = false,\n      checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n      query_status_response_type = \"code\",\n      stopCheckSessionOnError = true,\n      revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n      revokeTokensOnSignout = false,\n      includeIdTokenInSilentSignout = false,\n      accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n      userStore\n    } = args;\n    super(args);\n    this.popup_redirect_uri = popup_redirect_uri;\n    this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n    this.popupWindowFeatures = popupWindowFeatures;\n    this.popupWindowTarget = popupWindowTarget;\n    this.redirectMethod = redirectMethod;\n    this.redirectTarget = redirectTarget;\n    this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n    this.iframeScriptOrigin = iframeScriptOrigin;\n    this.silent_redirect_uri = silent_redirect_uri;\n    this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds;\n    this.automaticSilentRenew = automaticSilentRenew;\n    this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n    this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n    this.monitorSession = monitorSession;\n    this.monitorAnonymousSession = monitorAnonymousSession;\n    this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n    this.stopCheckSessionOnError = stopCheckSessionOnError;\n    this.query_status_response_type = query_status_response_type;\n    this.revokeTokenTypes = revokeTokenTypes;\n    this.revokeTokensOnSignout = revokeTokensOnSignout;\n    this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n    this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n    if (userStore) {\n      this.userStore = userStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n      this.userStore = new WebStorageStateStore({ store });\n    }\n  }\n};\n\n// src/navigators/IFrameWindow.ts\nvar IFrameWindow = class extends AbstractChildWindow {\n  constructor({\n    silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds\n  }) {\n    super();\n    this._logger = new Logger(\"IFrameWindow\");\n    this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n    this._frame = IFrameWindow.createHiddenIframe();\n    this._window = this._frame.contentWindow;\n  }\n  static createHiddenIframe() {\n    const iframe = window.document.createElement(\"iframe\");\n    iframe.style.visibility = \"hidden\";\n    iframe.style.position = \"fixed\";\n    iframe.style.left = \"-1000px\";\n    iframe.style.top = \"0\";\n    iframe.width = \"0\";\n    iframe.height = \"0\";\n    window.document.body.appendChild(iframe);\n    return iframe;\n  }\n  async navigate(params) {\n    this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n    const timer = setTimeout(() => this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1e3);\n    this._disposeHandlers.add(() => clearTimeout(timer));\n    return await super.navigate(params);\n  }\n  close() {\n    var _a;\n    if (this._frame) {\n      if (this._frame.parentNode) {\n        this._frame.addEventListener(\"load\", (ev) => {\n          var _a2;\n          const frame = ev.target;\n          (_a2 = frame.parentNode) == null ? void 0 : _a2.removeChild(frame);\n          this._abort.raise(new Error(\"IFrame removed from DOM\"));\n        }, true);\n        (_a = this._frame.contentWindow) == null ? void 0 : _a.location.replace(\"about:blank\");\n      }\n      this._frame = null;\n    }\n    this._window = null;\n  }\n  static notifyParent(url, targetOrigin) {\n    return super._notifyParent(window.parent, url, false, targetOrigin);\n  }\n};\n\n// src/navigators/IFrameNavigator.ts\nvar IFrameNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"IFrameNavigator\");\n  }\n  async prepare({\n    silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds\n  }) {\n    return new IFrameWindow({ silentRequestTimeoutInSeconds });\n  }\n  async callback(url) {\n    this._logger.create(\"callback\");\n    IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n  }\n};\n\n// src/navigators/PopupWindow.ts\nvar checkForPopupClosedInterval = 500;\nvar second = 1e3;\nvar PopupWindow = class extends AbstractChildWindow {\n  constructor({\n    popupWindowTarget = DefaultPopupTarget,\n    popupWindowFeatures = {}\n  }) {\n    super();\n    this._logger = new Logger(\"PopupWindow\");\n    const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures, ...popupWindowFeatures });\n    this._window = window.open(void 0, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n    if (popupWindowFeatures.closePopupWindowAfterInSeconds && popupWindowFeatures.closePopupWindowAfterInSeconds > 0) {\n      setTimeout(() => {\n        if (!this._window || typeof this._window.closed !== \"boolean\" || this._window.closed) {\n          this._abort.raise(new Error(\"Popup blocked by user\"));\n          return;\n        }\n        this.close();\n      }, popupWindowFeatures.closePopupWindowAfterInSeconds * second);\n    }\n  }\n  async navigate(params) {\n    var _a;\n    (_a = this._window) == null ? void 0 : _a.focus();\n    const popupClosedInterval = setInterval(() => {\n      if (!this._window || this._window.closed) {\n        this._abort.raise(new Error(\"Popup closed by user\"));\n      }\n    }, checkForPopupClosedInterval);\n    this._disposeHandlers.add(() => clearInterval(popupClosedInterval));\n    return await super.navigate(params);\n  }\n  close() {\n    if (this._window) {\n      if (!this._window.closed) {\n        this._window.close();\n        this._abort.raise(new Error(\"Popup closed\"));\n      }\n    }\n    this._window = null;\n  }\n  static notifyOpener(url, keepOpen) {\n    if (!window.opener) {\n      throw new Error(\"No window.opener. Can't complete notification.\");\n    }\n    return super._notifyParent(window.opener, url, keepOpen);\n  }\n};\n\n// src/navigators/PopupNavigator.ts\nvar PopupNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"PopupNavigator\");\n  }\n  async prepare({\n    popupWindowFeatures = this._settings.popupWindowFeatures,\n    popupWindowTarget = this._settings.popupWindowTarget\n  }) {\n    return new PopupWindow({ popupWindowFeatures, popupWindowTarget });\n  }\n  async callback(url, { keepOpen = false }) {\n    this._logger.create(\"callback\");\n    PopupWindow.notifyOpener(url, keepOpen);\n  }\n};\n\n// src/navigators/RedirectNavigator.ts\nvar RedirectNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"RedirectNavigator\");\n  }\n  async prepare({\n    redirectMethod = this._settings.redirectMethod,\n    redirectTarget = this._settings.redirectTarget\n  }) {\n    var _a;\n    this._logger.create(\"prepare\");\n    let targetWindow = window.self;\n    if (redirectTarget === \"top\") {\n      targetWindow = (_a = window.top) != null ? _a : window.self;\n    }\n    const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location);\n    let abort;\n    return {\n      navigate: async (params) => {\n        this._logger.create(\"navigate\");\n        const promise = new Promise((resolve, reject) => {\n          abort = reject;\n        });\n        redirect(params.url);\n        return await promise;\n      },\n      close: () => {\n        this._logger.create(\"close\");\n        abort == null ? void 0 : abort(new Error(\"Redirect aborted\"));\n        targetWindow.stop();\n      }\n    };\n  }\n  async callback() {\n    return;\n  }\n};\n\n// src/UserManagerEvents.ts\nvar UserManagerEvents = class extends AccessTokenEvents {\n  constructor(settings) {\n    super({ expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds });\n    this._logger = new Logger(\"UserManagerEvents\");\n    this._userLoaded = new Event(\"User loaded\");\n    this._userUnloaded = new Event(\"User unloaded\");\n    this._silentRenewError = new Event(\"Silent renew error\");\n    this._userSignedIn = new Event(\"User signed in\");\n    this._userSignedOut = new Event(\"User signed out\");\n    this._userSessionChanged = new Event(\"User session changed\");\n  }\n  load(user, raiseEvent = true) {\n    super.load(user);\n    if (raiseEvent) {\n      this._userLoaded.raise(user);\n    }\n  }\n  unload() {\n    super.unload();\n    this._userUnloaded.raise();\n  }\n  /**\n   * Add callback: Raised when a user session has been established (or re-established).\n   */\n  addUserLoaded(cb) {\n    return this._userLoaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been established (or re-established).\n   */\n  removeUserLoaded(cb) {\n    return this._userLoaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when a user session has been terminated.\n   */\n  addUserUnloaded(cb) {\n    return this._userUnloaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been terminated.\n   */\n  removeUserUnloaded(cb) {\n    return this._userUnloaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when the automatic silent renew has failed.\n   */\n  addSilentRenewError(cb) {\n    return this._silentRenewError.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the automatic silent renew has failed.\n   */\n  removeSilentRenewError(cb) {\n    return this._silentRenewError.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  _raiseSilentRenewError(e) {\n    this._silentRenewError.raise(e);\n  }\n  /**\n   * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedIn(cb) {\n    return this._userSignedIn.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n   */\n  removeUserSignedIn(cb) {\n    this._userSignedIn.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  _raiseUserSignedIn() {\n    this._userSignedIn.raise();\n  }\n  /**\n   * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedOut(cb) {\n    return this._userSignedOut.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   */\n  removeUserSignedOut(cb) {\n    this._userSignedOut.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  _raiseUserSignedOut() {\n    this._userSignedOut.raise();\n  }\n  /**\n   * Add callback: Raised when the user session changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSessionChanged(cb) {\n    return this._userSessionChanged.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n   */\n  removeUserSessionChanged(cb) {\n    this._userSessionChanged.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  _raiseUserSessionChanged() {\n    this._userSessionChanged.raise();\n  }\n};\n\n// src/SilentRenewService.ts\nvar SilentRenewService = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SilentRenewService\");\n    this._isStarted = false;\n    this._retryTimer = new Timer(\"Retry Silent Renew\");\n    this._tokenExpiring = async () => {\n      const logger2 = this._logger.create(\"_tokenExpiring\");\n      try {\n        await this._userManager.signinSilent();\n        logger2.debug(\"silent token renewal successful\");\n      } catch (err) {\n        if (err instanceof ErrorTimeout) {\n          logger2.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n          this._retryTimer.init(5);\n          return;\n        }\n        logger2.error(\"Error from signinSilent:\", err);\n        this._userManager.events._raiseSilentRenewError(err);\n      }\n    };\n  }\n  async start() {\n    const logger2 = this._logger.create(\"start\");\n    if (!this._isStarted) {\n      this._isStarted = true;\n      this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n      this._retryTimer.addHandler(this._tokenExpiring);\n      try {\n        await this._userManager.getUser();\n      } catch (err) {\n        logger2.error(\"getUser error\", err);\n      }\n    }\n  }\n  stop() {\n    if (this._isStarted) {\n      this._retryTimer.cancel();\n      this._retryTimer.removeHandler(this._tokenExpiring);\n      this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n      this._isStarted = false;\n    }\n  }\n};\n\n// src/RefreshState.ts\nvar RefreshState = class {\n  constructor(args, resource) {\n    this.refresh_token = args.refresh_token;\n    this.id_token = args.id_token;\n    this.session_state = args.session_state;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.resource = resource;\n    this.data = args.state;\n  }\n};\n\n// src/UserManager.ts\nvar UserManager = class {\n  constructor(settings, redirectNavigator, popupNavigator, iframeNavigator) {\n    this._logger = new Logger(\"UserManager\");\n    this.settings = new UserManagerSettingsStore(settings);\n    this._client = new OidcClient(settings);\n    this._redirectNavigator = redirectNavigator != null ? redirectNavigator : new RedirectNavigator(this.settings);\n    this._popupNavigator = popupNavigator != null ? popupNavigator : new PopupNavigator(this.settings);\n    this._iframeNavigator = iframeNavigator != null ? iframeNavigator : new IFrameNavigator(this.settings);\n    this._events = new UserManagerEvents(this.settings);\n    this._silentRenewService = new SilentRenewService(this);\n    if (this.settings.automaticSilentRenew) {\n      this.startSilentRenew();\n    }\n    this._sessionMonitor = null;\n    if (this.settings.monitorSession) {\n      this._sessionMonitor = new SessionMonitor(this);\n    }\n  }\n  /** Returns an object used to register for events raised by the `UserManager`. */\n  get events() {\n    return this._events;\n  }\n  /** Returns an object used to access the metadata configuration of the OIDC provider. */\n  get metadataService() {\n    return this._client.metadataService;\n  }\n  /**\n   * Returns promise to load the `User` object for the currently authenticated user.\n   */\n  async getUser() {\n    const logger2 = this._logger.create(\"getUser\");\n    const user = await this._loadUser();\n    if (user) {\n      logger2.info(\"user loaded\");\n      this._events.load(user, false);\n      return user;\n    }\n    logger2.info(\"user not found in storage\");\n    return null;\n  }\n  /**\n   * Returns promise to remove from any storage the currently authenticated user.\n   */\n  async removeUser() {\n    const logger2 = this._logger.create(\"removeUser\");\n    await this.storeUser(null);\n    logger2.info(\"user removed from storage\");\n    this._events.unload();\n  }\n  /**\n   * Returns promise to trigger a redirect of the current window to the authorization endpoint.\n   */\n  async signinRedirect(args = {}) {\n    this._logger.create(\"signinRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    const handle = await this._redirectNavigator.prepare({ redirectMethod });\n    await this._signinStart({\n      request_type: \"si:r\",\n      ...requestArgs\n    }, handle);\n  }\n  /**\n   * Returns promise to process response from the authorization endpoint. The result of the promise is the authenticated `User`.\n   */\n  async signinRedirectCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signinRedirectCallback\");\n    const user = await this._signinEnd(url);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  /**\n   * Returns promise to process the signin with user/password. The result of the promise is the authenticated `User`.\n   *\n   * Throws an ErrorResponse in case of wrong authentication.\n   */\n  async signinResourceOwnerCredentials({\n    username,\n    password,\n    skipUserInfo = false\n  }) {\n    const logger2 = this._logger.create(\"signinResourceOwnerCredential\");\n    const signinResponse = await this._client.processResourceOwnerPasswordCredentials({ username, password, skipUserInfo, extraTokenParams: this.settings.extraTokenParams });\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  /**\n   * Returns promise to trigger a request (via a popup window) to the authorization endpoint. The result of the promise is the authenticated `User`.\n   */\n  async signinPopup(args = {}) {\n    const logger2 = this._logger.create(\"signinPopup\");\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No popup_redirect_uri configured\"));\n    }\n    const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });\n    const user = await this._signin({\n      request_type: \"si:p\",\n      redirect_uri: url,\n      display: \"popup\",\n      ...requestArgs\n    }, handle);\n    if (user) {\n      if (user.profile && user.profile.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  /**\n   * Returns promise to notify the opening window of response from the authorization endpoint.\n   */\n  async signinPopupCallback(url = window.location.href, keepOpen = false) {\n    const logger2 = this._logger.create(\"signinPopupCallback\");\n    await this._popupNavigator.callback(url, { keepOpen });\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to trigger a silent request (via an iframe) to the authorization endpoint.\n   * The result of the promise is the authenticated `User`.\n   */\n  async signinSilent(args = {}) {\n    var _a;\n    const logger2 = this._logger.create(\"signinSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      resource,\n      ...requestArgs\n    } = args;\n    let user = await this._loadUser();\n    if (user == null ? void 0 : user.refresh_token) {\n      logger2.debug(\"using refresh token\");\n      const state = new RefreshState(user, resource);\n      return await this._useRefreshToken(state);\n    }\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    let verifySub;\n    if (user && this.settings.validateSubOnSilentRenew) {\n      logger2.debug(\"subject prior to silent renew:\", user.profile.sub);\n      verifySub = user.profile.sub;\n    }\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    user = await this._signin({\n      request_type: \"si:s\",\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      ...requestArgs\n    }, handle, verifySub);\n    if (user) {\n      if ((_a = user.profile) == null ? void 0 : _a.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  async _useRefreshToken(state) {\n    const response = await this._client.useRefreshToken({\n      state,\n      timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds\n    });\n    const user = new User({ ...state, ...response });\n    await this.storeUser(user);\n    this._events.load(user);\n    return user;\n  }\n  /**\n   * Returns promise to notify the parent window of response from the authorization endpoint.\n   */\n  async signinSilentCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signinSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  async signinCallback(url = window.location.href) {\n    const { state } = await this._client.readSigninResponseState(url);\n    switch (state.request_type) {\n      case \"si:r\":\n        return await this.signinRedirectCallback(url);\n      case \"si:p\":\n        return await this.signinPopupCallback(url);\n      case \"si:s\":\n        return await this.signinSilentCallback(url);\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n  }\n  async signoutCallback(url = window.location.href, keepOpen = false) {\n    const { state } = await this._client.readSignoutResponseState(url);\n    if (!state) {\n      return;\n    }\n    switch (state.request_type) {\n      case \"so:r\":\n        await this.signoutRedirectCallback(url);\n        break;\n      case \"so:p\":\n        await this.signoutPopupCallback(url, keepOpen);\n        break;\n      case \"so:s\":\n        await this.signoutSilentCallback(url);\n        break;\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n  }\n  /**\n   * Returns promise to query OP for user's current signin status. Returns object with session_state and subject identifier.\n   */\n  async querySessionStatus(args = {}) {\n    const logger2 = this._logger.create(\"querySessionStatus\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    const user = await this._loadUser();\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    const navResponse = await this._signinStart({\n      request_type: \"si:s\",\n      // this acts like a signin silent\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      response_type: this.settings.query_status_response_type,\n      scope: \"openid\",\n      skipUserInfo: true,\n      ...requestArgs\n    }, handle);\n    try {\n      const signinResponse = await this._client.processSigninResponse(navResponse.url);\n      logger2.debug(\"got signin response\");\n      if (signinResponse.session_state && signinResponse.profile.sub) {\n        logger2.info(\"success for subject\", signinResponse.profile.sub);\n        return {\n          session_state: signinResponse.session_state,\n          sub: signinResponse.profile.sub,\n          sid: signinResponse.profile.sid\n        };\n      }\n      logger2.info(\"success, user not authenticated\");\n      return null;\n    } catch (err) {\n      if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n        switch (err.error) {\n          case \"login_required\":\n          case \"consent_required\":\n          case \"interaction_required\":\n          case \"account_selection_required\":\n            logger2.info(\"success for anonymous user\");\n            return {\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              session_state: err.session_state\n            };\n        }\n      }\n      throw err;\n    }\n  }\n  async _signin(args, handle, verifySub) {\n    const navResponse = await this._signinStart(args, handle);\n    return await this._signinEnd(navResponse.url, verifySub);\n  }\n  async _signinStart(args, handle) {\n    const logger2 = this._logger.create(\"_signinStart\");\n    try {\n      const signinRequest = await this._client.createSigninRequest(args);\n      logger2.debug(\"got signin request\");\n      return await handle.navigate({\n        url: signinRequest.url,\n        state: signinRequest.state.id,\n        response_mode: signinRequest.state.response_mode,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signinEnd(url, verifySub) {\n    const logger2 = this._logger.create(\"_signinEnd\");\n    const signinResponse = await this._client.processSigninResponse(url);\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse, verifySub);\n    return user;\n  }\n  async _buildUser(signinResponse, verifySub) {\n    const logger2 = this._logger.create(\"_buildUser\");\n    const user = new User(signinResponse);\n    if (verifySub) {\n      if (verifySub !== user.profile.sub) {\n        logger2.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n        throw new ErrorResponse({ ...signinResponse, error: \"login_required\" });\n      }\n      logger2.debug(\"current user matches user returned from signin\");\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    this._events.load(user);\n    return user;\n  }\n  /**\n   * Returns promise to trigger a redirect of the current window to the end session endpoint.\n   */\n  async signoutRedirect(args = {}) {\n    const logger2 = this._logger.create(\"signoutRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    const handle = await this._redirectNavigator.prepare({ redirectMethod });\n    await this._signoutStart({\n      request_type: \"so:r\",\n      post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to process response from the end session endpoint.\n   */\n  async signoutRedirectCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signoutRedirectCallback\");\n    const response = await this._signoutEnd(url);\n    logger2.info(\"success\");\n    return response;\n  }\n  /**\n   * Returns promise to trigger a redirect of a popup window window to the end session endpoint.\n   */\n  async signoutPopup(args = {}) {\n    const logger2 = this._logger.create(\"signoutPopup\");\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });\n    await this._signout({\n      request_type: \"so:p\",\n      post_logout_redirect_uri: url,\n      // we're putting a dummy entry in here because we\n      // need a unique id from the state for notification\n      // to the parent window, which is necessary if we\n      // plan to return back to the client after signout\n      // and so we can close the popup after signout\n      state: url == null ? void 0 : {},\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to process response from the end session endpoint from a popup window.\n   */\n  async signoutPopupCallback(url = window.location.href, keepOpen = false) {\n    const logger2 = this._logger.create(\"signoutPopupCallback\");\n    await this._popupNavigator.callback(url, { keepOpen });\n    logger2.info(\"success\");\n  }\n  async _signout(args, handle) {\n    const navResponse = await this._signoutStart(args, handle);\n    return await this._signoutEnd(navResponse.url);\n  }\n  async _signoutStart(args = {}, handle) {\n    var _a;\n    const logger2 = this._logger.create(\"_signoutStart\");\n    try {\n      const user = await this._loadUser();\n      logger2.debug(\"loaded current user from storage\");\n      if (this.settings.revokeTokensOnSignout) {\n        await this._revokeInternal(user);\n      }\n      const id_token = args.id_token_hint || user && user.id_token;\n      if (id_token) {\n        logger2.debug(\"setting id_token_hint in signout request\");\n        args.id_token_hint = id_token;\n      }\n      await this.removeUser();\n      logger2.debug(\"user removed, creating signout request\");\n      const signoutRequest = await this._client.createSignoutRequest(args);\n      logger2.debug(\"got signout request\");\n      return await handle.navigate({\n        url: signoutRequest.url,\n        state: (_a = signoutRequest.state) == null ? void 0 : _a.id,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signoutEnd(url) {\n    const logger2 = this._logger.create(\"_signoutEnd\");\n    const signoutResponse = await this._client.processSignoutResponse(url);\n    logger2.debug(\"got signout response\");\n    return signoutResponse;\n  }\n  /**\n   * Returns promise to trigger a silent request (via an iframe) to the end session endpoint.\n   */\n  async signoutSilent(args = {}) {\n    var _a;\n    const logger2 = this._logger.create(\"signoutSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const id_token_hint = this.settings.includeIdTokenInSilentSignout ? (_a = await this._loadUser()) == null ? void 0 : _a.id_token : void 0;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    await this._signout({\n      request_type: \"so:s\",\n      post_logout_redirect_uri: url,\n      id_token_hint,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Returns promise to notify the parent window of response from the end session endpoint.\n   */\n  async signoutSilentCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signoutSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  async revokeTokens(types) {\n    const user = await this._loadUser();\n    await this._revokeInternal(user, types);\n  }\n  async _revokeInternal(user, types = this.settings.revokeTokenTypes) {\n    const logger2 = this._logger.create(\"_revokeInternal\");\n    if (!user)\n      return;\n    const typesPresent = types.filter((type) => typeof user[type] === \"string\");\n    if (!typesPresent.length) {\n      logger2.debug(\"no need to revoke due to no token(s)\");\n      return;\n    }\n    for (const type of typesPresent) {\n      await this._client.revokeToken(\n        user[type],\n        // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        type\n      );\n      logger2.info(`${type} revoked successfully`);\n      if (type !== \"access_token\") {\n        user[type] = null;\n      }\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    this._events.load(user);\n  }\n  /**\n   * Enables silent renew for the `UserManager`.\n   */\n  startSilentRenew() {\n    this._logger.create(\"startSilentRenew\");\n    void this._silentRenewService.start();\n  }\n  /**\n   * Disables silent renew for the `UserManager`.\n   */\n  stopSilentRenew() {\n    this._silentRenewService.stop();\n  }\n  get _userStoreKey() {\n    return `user:${this.settings.authority}:${this.settings.client_id}`;\n  }\n  async _loadUser() {\n    const logger2 = this._logger.create(\"_loadUser\");\n    const storageString = await this.settings.userStore.get(this._userStoreKey);\n    if (storageString) {\n      logger2.debug(\"user storageString loaded\");\n      return User.fromStorageString(storageString);\n    }\n    logger2.debug(\"no user storageString\");\n    return null;\n  }\n  async storeUser(user) {\n    const logger2 = this._logger.create(\"storeUser\");\n    if (user) {\n      logger2.debug(\"storing user\");\n      const storageString = user.toStorageString();\n      await this.settings.userStore.set(this._userStoreKey, storageString);\n    } else {\n      this._logger.debug(\"removing user\");\n      await this.settings.userStore.remove(this._userStoreKey);\n    }\n  }\n  /**\n   * Removes stale state entries in storage for incomplete authorize requests.\n   */\n  async clearStaleState() {\n    await this._client.clearStaleState();\n  }\n};\n\n// package.json\nvar version = \"2.4.0\";\n\n// src/Version.ts\nvar Version = version;\n\n//# sourceMappingURL=oidc-client-ts.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL29pZGMtY2xpZW50LXRzQDIuNC4wL25vZGVfbW9kdWxlcy9vaWRjLWNsaWVudC10cy9kaXN0L2VzbS9vaWRjLWNsaWVudC10cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDeUM7QUFDQTtBQUNJO0FBQ0o7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxXQUFXO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUssR0FBRyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUIsdUJBQXVCLFFBQVEsRUFBRSxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdEQUFNO0FBQzNCLGFBQWEsOERBQWdCO0FBQzdCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFVO0FBQ2hDLFdBQVcsOERBQWdCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0RBQVU7QUFDdkIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csSUFBSSxHQUFHLDBEQUEwRDtBQUNuSztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQ0FBcUM7QUFDekYsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnREFBZ0QsY0FBYyxJQUFJO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUIsR0FBRyxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQixHQUFHLGdCQUFnQixLQUFLLHFCQUFxQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwrRUFBK0U7QUFDbkksTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnREFBZ0QsY0FBYyxJQUFJO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCLEdBQUcsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQixHQUFHLGdCQUFnQixLQUFLLHFCQUFxQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsNENBQTRDO0FBQ3RIO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxLQUFLO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwQkFBMEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrRkFBa0Y7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrRkFBa0Y7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsb0dBQW9HO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnRUFBZ0U7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNLEVBQUUsb0JBQW9CLEVBQUUsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1REFBdUQ7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQ0FBZ0M7QUFDakU7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdFQUF3RSx5Q0FBeUM7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxNQUFNO0FBQ04sNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUYsY0FBYztBQUNkLHlIQUF5SDtBQUN6SDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw4Q0FBOEMsdURBQXVEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw2QkFBNkIsd0NBQXdDO0FBQ3JFO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEZBQTBGO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0ZBQXdGLG9GQUFvRjtBQUM1SztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHdDQUF3QztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELCtCQUErQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsK0JBQStCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRDQUE0QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJEQUEyRCxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esd0RBQXdELHdDQUF3QztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx5REFBeUQsK0JBQStCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QixHQUFHLHdCQUF3QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBc0JFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZXhhbXBsZXMvbG9naW4td2l0aC1wYXNzcG9ydC1wcm92aWRlci1hbm5vdW5jZS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vb2lkYy1jbGllbnQtdHNAMi40LjAvbm9kZV9tb2R1bGVzL29pZGMtY2xpZW50LXRzL2Rpc3QvZXNtL29pZGMtY2xpZW50LXRzLmpzP2JmODUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzL0NyeXB0b1V0aWxzLnRzXG5pbXBvcnQgQ3J5cHRvSlMgZnJvbSBcImNyeXB0by1qcy9jb3JlLmpzXCI7XG5pbXBvcnQgc2hhMjU2IGZyb20gXCJjcnlwdG8tanMvc2hhMjU2LmpzXCI7XG5pbXBvcnQgQmFzZTY0IGZyb20gXCJjcnlwdG8tanMvZW5jLWJhc2U2NC5qc1wiO1xuaW1wb3J0IFV0ZjggZnJvbSBcImNyeXB0by1qcy9lbmMtdXRmOC5qc1wiO1xuXG4vLyBzcmMvdXRpbHMvTG9nZ2VyLnRzXG52YXIgbm9wTG9nZ2VyID0ge1xuICBkZWJ1ZzogKCkgPT4gdm9pZCAwLFxuICBpbmZvOiAoKSA9PiB2b2lkIDAsXG4gIHdhcm46ICgpID0+IHZvaWQgMCxcbiAgZXJyb3I6ICgpID0+IHZvaWQgMFxufTtcbnZhciBsZXZlbDtcbnZhciBsb2dnZXI7XG52YXIgTG9nID0gLyogQF9fUFVSRV9fICovICgoTG9nMikgPT4ge1xuICBMb2cyW0xvZzJbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgTG9nMltMb2cyW1wiRVJST1JcIl0gPSAxXSA9IFwiRVJST1JcIjtcbiAgTG9nMltMb2cyW1wiV0FSTlwiXSA9IDJdID0gXCJXQVJOXCI7XG4gIExvZzJbTG9nMltcIklORk9cIl0gPSAzXSA9IFwiSU5GT1wiO1xuICBMb2cyW0xvZzJbXCJERUJVR1wiXSA9IDRdID0gXCJERUJVR1wiO1xuICByZXR1cm4gTG9nMjtcbn0pKExvZyB8fCB7fSk7XG4oKExvZzIpID0+IHtcbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgbGV2ZWwgPSAzIC8qIElORk8gKi87XG4gICAgbG9nZ2VyID0gbm9wTG9nZ2VyO1xuICB9XG4gIExvZzIucmVzZXQgPSByZXNldDtcbiAgZnVuY3Rpb24gc2V0TGV2ZWwodmFsdWUpIHtcbiAgICBpZiAoISgwIC8qIE5PTkUgKi8gPD0gdmFsdWUgJiYgdmFsdWUgPD0gNCAvKiBERUJVRyAqLykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbG9nIGxldmVsXCIpO1xuICAgIH1cbiAgICBsZXZlbCA9IHZhbHVlO1xuICB9XG4gIExvZzIuc2V0TGV2ZWwgPSBzZXRMZXZlbDtcbiAgZnVuY3Rpb24gc2V0TG9nZ2VyKHZhbHVlKSB7XG4gICAgbG9nZ2VyID0gdmFsdWU7XG4gIH1cbiAgTG9nMi5zZXRMb2dnZXIgPSBzZXRMb2dnZXI7XG59KShMb2cgfHwgKExvZyA9IHt9KSk7XG52YXIgTG9nZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfbmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBfbmFtZTtcbiAgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAqL1xuICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgaWYgKGxldmVsID49IDQgLyogREVCVUcgKi8pIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhMb2dnZXIuX2Zvcm1hdCh0aGlzLl9uYW1lLCB0aGlzLl9tZXRob2QpLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgaW5mbyguLi5hcmdzKSB7XG4gICAgaWYgKGxldmVsID49IDMgLyogSU5GTyAqLykge1xuICAgICAgbG9nZ2VyLmluZm8oTG9nZ2VyLl9mb3JtYXQodGhpcy5fbmFtZSwgdGhpcy5fbWV0aG9kKSwgLi4uYXJncyk7XG4gICAgfVxuICB9XG4gIHdhcm4oLi4uYXJncykge1xuICAgIGlmIChsZXZlbCA+PSAyIC8qIFdBUk4gKi8pIHtcbiAgICAgIGxvZ2dlci53YXJuKExvZ2dlci5fZm9ybWF0KHRoaXMuX25hbWUsIHRoaXMuX21ldGhvZCksIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICBlcnJvciguLi5hcmdzKSB7XG4gICAgaWYgKGxldmVsID49IDEgLyogRVJST1IgKi8pIHtcbiAgICAgIGxvZ2dlci5lcnJvcihMb2dnZXIuX2Zvcm1hdCh0aGlzLl9uYW1lLCB0aGlzLl9tZXRob2QpLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAqL1xuICB0aHJvdyhlcnIpIHtcbiAgICB0aGlzLmVycm9yKGVycik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIGNyZWF0ZShtZXRob2QpIHtcbiAgICBjb25zdCBtZXRob2RMb2dnZXIgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgIG1ldGhvZExvZ2dlci5fbWV0aG9kID0gbWV0aG9kO1xuICAgIG1ldGhvZExvZ2dlci5kZWJ1ZyhcImJlZ2luXCIpO1xuICAgIHJldHVybiBtZXRob2RMb2dnZXI7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZVN0YXRpYyhuYW1lLCBzdGF0aWNNZXRob2QpIHtcbiAgICBjb25zdCBzdGF0aWNMb2dnZXIgPSBuZXcgTG9nZ2VyKGAke25hbWV9LiR7c3RhdGljTWV0aG9kfWApO1xuICAgIHN0YXRpY0xvZ2dlci5kZWJ1ZyhcImJlZ2luXCIpO1xuICAgIHJldHVybiBzdGF0aWNMb2dnZXI7XG4gIH1cbiAgc3RhdGljIF9mb3JtYXQobmFtZSwgbWV0aG9kKSB7XG4gICAgY29uc3QgcHJlZml4ID0gYFske25hbWV9XWA7XG4gICAgcmV0dXJuIG1ldGhvZCA/IGAke3ByZWZpeH0gJHttZXRob2R9OmAgOiBwcmVmaXg7XG4gIH1cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gKi9cbiAgLy8gaGVscGVycyBmb3Igc3RhdGljIGNsYXNzIG1ldGhvZHNcbiAgc3RhdGljIGRlYnVnKG5hbWUsIC4uLmFyZ3MpIHtcbiAgICBpZiAobGV2ZWwgPj0gNCAvKiBERUJVRyAqLykge1xuICAgICAgbG9nZ2VyLmRlYnVnKExvZ2dlci5fZm9ybWF0KG5hbWUpLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGluZm8obmFtZSwgLi4uYXJncykge1xuICAgIGlmIChsZXZlbCA+PSAzIC8qIElORk8gKi8pIHtcbiAgICAgIGxvZ2dlci5pbmZvKExvZ2dlci5fZm9ybWF0KG5hbWUpLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHdhcm4obmFtZSwgLi4uYXJncykge1xuICAgIGlmIChsZXZlbCA+PSAyIC8qIFdBUk4gKi8pIHtcbiAgICAgIGxvZ2dlci53YXJuKExvZ2dlci5fZm9ybWF0KG5hbWUpLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGVycm9yKG5hbWUsIC4uLmFyZ3MpIHtcbiAgICBpZiAobGV2ZWwgPj0gMSAvKiBFUlJPUiAqLykge1xuICAgICAgbG9nZ2VyLmVycm9yKExvZ2dlci5fZm9ybWF0KG5hbWUpLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAqL1xufTtcbkxvZy5yZXNldCgpO1xuXG4vLyBzcmMvdXRpbHMvQ3J5cHRvVXRpbHMudHNcbnZhciBVVUlEX1Y0X1RFTVBMQVRFID0gXCIxMDAwMDAwMC0xMDAwLTQwMDAtODAwMC0xMDAwMDAwMDAwMDBcIjtcbnZhciBDcnlwdG9VdGlscyA9IGNsYXNzIHtcbiAgc3RhdGljIF9yYW5kb21Xb3JkKCkge1xuICAgIHJldHVybiBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxKS53b3Jkc1swXTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIFJGQzQxMjIgdmVyc2lvbiA0IGd1aWRcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZVVVSUR2NCgpIHtcbiAgICBjb25zdCB1dWlkID0gVVVJRF9WNF9URU1QTEFURS5yZXBsYWNlKFxuICAgICAgL1swMThdL2csXG4gICAgICAoYykgPT4gKCtjIF4gQ3J5cHRvVXRpbHMuX3JhbmRvbVdvcmQoKSAmIDE1ID4+ICtjIC8gNCkudG9TdHJpbmcoMTYpXG4gICAgKTtcbiAgICByZXR1cm4gdXVpZC5yZXBsYWNlKC8tL2csIFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBQS0NFOiBHZW5lcmF0ZSBhIGNvZGUgdmVyaWZpZXJcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZUNvZGVWZXJpZmllcigpIHtcbiAgICByZXR1cm4gQ3J5cHRvVXRpbHMuZ2VuZXJhdGVVVUlEdjQoKSArIENyeXB0b1V0aWxzLmdlbmVyYXRlVVVJRHY0KCkgKyBDcnlwdG9VdGlscy5nZW5lcmF0ZVVVSUR2NCgpO1xuICB9XG4gIC8qKlxuICAgKiBQS0NFOiBHZW5lcmF0ZSBhIGNvZGUgY2hhbGxlbmdlXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGVDb2RlQ2hhbGxlbmdlKGNvZGVfdmVyaWZpZXIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGFzaGVkID0gc2hhMjU2KGNvZGVfdmVyaWZpZXIpO1xuICAgICAgcmV0dXJuIEJhc2U2NC5zdHJpbmdpZnkoaGFzaGVkKS5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvPSskLywgXCJcIik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBMb2dnZXIuZXJyb3IoXCJDcnlwdG9VdGlscy5nZW5lcmF0ZUNvZGVDaGFsbGVuZ2VcIiwgZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZyBmb3IgYSBiYXNpYyBhdXRoIGhlYWRlclxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlQmFzaWNBdXRoKGNsaWVudF9pZCwgY2xpZW50X3NlY3JldCkge1xuICAgIGNvbnN0IGJhc2ljQXV0aCA9IFV0ZjgucGFyc2UoW2NsaWVudF9pZCwgY2xpZW50X3NlY3JldF0uam9pbihcIjpcIikpO1xuICAgIHJldHVybiBCYXNlNjQuc3RyaW5naWZ5KGJhc2ljQXV0aCk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9FdmVudC50c1xudmFyIEV2ZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfbmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBfbmFtZTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKGBFdmVudCgnJHt0aGlzLl9uYW1lfScpYCk7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG4gIH1cbiAgYWRkSGFuZGxlcihjYikge1xuICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5yZW1vdmVIYW5kbGVyKGNiKTtcbiAgfVxuICByZW1vdmVIYW5kbGVyKGNiKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5fY2FsbGJhY2tzLmxhc3RJbmRleE9mKGNiKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gIH1cbiAgcmFpc2UoLi4uZXYpIHtcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJyYWlzZTpcIiwgLi4uZXYpO1xuICAgIGZvciAoY29uc3QgY2Igb2YgdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICB2b2lkIGNiKC4uLmV2KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9Kd3RVdGlscy50c1xuaW1wb3J0IGp3dF9kZWNvZGUgZnJvbSBcImp3dC1kZWNvZGVcIjtcbnZhciBKd3RVdGlscyA9IGNsYXNzIHtcbiAgLy8gSU1QT1JUQU5UOiBkb2Vzbid0IHZhbGlkYXRlIHRoZSB0b2tlblxuICBzdGF0aWMgZGVjb2RlKHRva2VuKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBqd3RfZGVjb2RlKHRva2VuKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIExvZ2dlci5lcnJvcihcIkp3dFV0aWxzLmRlY29kZVwiLCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL1BvcHVwVXRpbHMudHNcbnZhciBQb3B1cFV0aWxzID0gY2xhc3Mge1xuICAvKipcbiAgICogUG9wdWxhdGVzIGEgbWFwIG9mIHdpbmRvdyBmZWF0dXJlcyB3aXRoIGEgcGxhY2VtZW50IGNlbnRlcmVkIGluIGZyb250IG9mXG4gICAqIHRoZSBjdXJyZW50IHdpbmRvdy4gSWYgbm8gZXhwbGljaXQgd2lkdGggaXMgZ2l2ZW4sIGEgZGVmYXVsdCB2YWx1ZSBpc1xuICAgKiBiaW5uZWQgaW50byBbODAwLCA3MjAsIDYwMCwgNDgwLCAzNjBdIGJhc2VkIG9uIHRoZSBjdXJyZW50IHdpbmRvdydzIHdpZHRoLlxuICAgKi9cbiAgc3RhdGljIGNlbnRlcih7IC4uLmZlYXR1cmVzIH0pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBpZiAoZmVhdHVyZXMud2lkdGggPT0gbnVsbClcbiAgICAgIGZlYXR1cmVzLndpZHRoID0gKF9hID0gWzgwMCwgNzIwLCA2MDAsIDQ4MF0uZmluZCgod2lkdGgpID0+IHdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoIC8gMS42MTgpKSAhPSBudWxsID8gX2EgOiAzNjA7XG4gICAgKF9iID0gZmVhdHVyZXMubGVmdCkgIT0gbnVsbCA/IF9iIDogZmVhdHVyZXMubGVmdCA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQod2luZG93LnNjcmVlblggKyAod2luZG93Lm91dGVyV2lkdGggLSBmZWF0dXJlcy53aWR0aCkgLyAyKSk7XG4gICAgaWYgKGZlYXR1cmVzLmhlaWdodCAhPSBudWxsKVxuICAgICAgKF9jID0gZmVhdHVyZXMudG9wKSAhPSBudWxsID8gX2MgOiBmZWF0dXJlcy50b3AgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHdpbmRvdy5zY3JlZW5ZICsgKHdpbmRvdy5vdXRlckhlaWdodCAtIGZlYXR1cmVzLmhlaWdodCkgLyAyKSk7XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG4gIHN0YXRpYyBzZXJpYWxpemUoZmVhdHVyZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZmVhdHVyZXMpLmZpbHRlcigoWywgdmFsdWVdKSA9PiB2YWx1ZSAhPSBudWxsKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fT0ke3R5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIgPyB2YWx1ZSA6IHZhbHVlID8gXCJ5ZXNcIiA6IFwibm9cIn1gKS5qb2luKFwiLFwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL1RpbWVyLnRzXG52YXIgVGltZXIgPSBjbGFzcyBleHRlbmRzIEV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKGBUaW1lcignJHt0aGlzLl9uYW1lfScpYCk7XG4gICAgdGhpcy5fdGltZXJIYW5kbGUgPSBudWxsO1xuICAgIHRoaXMuX2V4cGlyYXRpb24gPSAwO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgY29uc3QgZGlmZiA9IHRoaXMuX2V4cGlyYXRpb24gLSBUaW1lci5nZXRFcG9jaFRpbWUoKTtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcInRpbWVyIGNvbXBsZXRlcyBpblwiLCBkaWZmKTtcbiAgICAgIGlmICh0aGlzLl9leHBpcmF0aW9uIDw9IFRpbWVyLmdldEVwb2NoVGltZSgpKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIHN1cGVyLnJhaXNlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvLyBnZXQgdGhlIHRpbWVcbiAgc3RhdGljIGdldEVwb2NoVGltZSgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgfVxuICBpbml0KGR1cmF0aW9uSW5TZWNvbmRzKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJpbml0XCIpO1xuICAgIGR1cmF0aW9uSW5TZWNvbmRzID0gTWF0aC5tYXgoTWF0aC5mbG9vcihkdXJhdGlvbkluU2Vjb25kcyksIDEpO1xuICAgIGNvbnN0IGV4cGlyYXRpb24gPSBUaW1lci5nZXRFcG9jaFRpbWUoKSArIGR1cmF0aW9uSW5TZWNvbmRzO1xuICAgIGlmICh0aGlzLmV4cGlyYXRpb24gPT09IGV4cGlyYXRpb24gJiYgdGhpcy5fdGltZXJIYW5kbGUpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJza2lwcGluZyBzaW5jZSBhbHJlYWR5IGluaXRpYWxpemVkIGZvciBleHBpcmF0aW9uIGF0XCIsIHRoaXMuZXhwaXJhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcInVzaW5nIGR1cmF0aW9uXCIsIGR1cmF0aW9uSW5TZWNvbmRzKTtcbiAgICB0aGlzLl9leHBpcmF0aW9uID0gZXhwaXJhdGlvbjtcbiAgICBjb25zdCB0aW1lckR1cmF0aW9uSW5TZWNvbmRzID0gTWF0aC5taW4oZHVyYXRpb25JblNlY29uZHMsIDUpO1xuICAgIHRoaXMuX3RpbWVySGFuZGxlID0gc2V0SW50ZXJ2YWwodGhpcy5fY2FsbGJhY2ssIHRpbWVyRHVyYXRpb25JblNlY29uZHMgKiAxZTMpO1xuICB9XG4gIGdldCBleHBpcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9leHBpcmF0aW9uO1xuICB9XG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiY2FuY2VsXCIpO1xuICAgIGlmICh0aGlzLl90aW1lckhhbmRsZSkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl90aW1lckhhbmRsZSk7XG4gICAgICB0aGlzLl90aW1lckhhbmRsZSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvVXJsVXRpbHMudHNcbnZhciBVcmxVdGlscyA9IGNsYXNzIHtcbiAgc3RhdGljIHJlYWRQYXJhbXModXJsLCByZXNwb25zZU1vZGUgPSBcInF1ZXJ5XCIpIHtcbiAgICBpZiAoIXVybClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIFVSTFwiKTtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCwgXCJodHRwOi8vMTI3LjAuMC4xXCIpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHBhcnNlZFVybFtyZXNwb25zZU1vZGUgPT09IFwiZnJhZ21lbnRcIiA/IFwiaGFzaFwiIDogXCJzZWFyY2hcIl07XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zLnNsaWNlKDEpKTtcbiAgfVxufTtcbnZhciBVUkxfU1RBVEVfREVMSU1JVEVSID0gXCI7XCI7XG5cbi8vIHNyYy9lcnJvcnMvRXJyb3JSZXNwb25zZS50c1xudmFyIEVycm9yUmVzcG9uc2UgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoYXJncywgZm9ybSkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHN1cGVyKGFyZ3MuZXJyb3JfZGVzY3JpcHRpb24gfHwgYXJncy5lcnJvciB8fCBcIlwiKTtcbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIC8qKiBNYXJrZXIgdG8gZGV0ZWN0IGNsYXNzOiBcIkVycm9yUmVzcG9uc2VcIiAqL1xuICAgIHRoaXMubmFtZSA9IFwiRXJyb3JSZXNwb25zZVwiO1xuICAgIGlmICghYXJncy5lcnJvcikge1xuICAgICAgTG9nZ2VyLmVycm9yKFwiRXJyb3JSZXNwb25zZVwiLCBcIk5vIGVycm9yIHBhc3NlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVycm9yIHBhc3NlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5lcnJvciA9IGFyZ3MuZXJyb3I7XG4gICAgdGhpcy5lcnJvcl9kZXNjcmlwdGlvbiA9IChfYSA9IGFyZ3MuZXJyb3JfZGVzY3JpcHRpb24pICE9IG51bGwgPyBfYSA6IG51bGw7XG4gICAgdGhpcy5lcnJvcl91cmkgPSAoX2IgPSBhcmdzLmVycm9yX3VyaSkgIT0gbnVsbCA/IF9iIDogbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gYXJncy51c2VyU3RhdGU7XG4gICAgdGhpcy5zZXNzaW9uX3N0YXRlID0gKF9jID0gYXJncy5zZXNzaW9uX3N0YXRlKSAhPSBudWxsID8gX2MgOiBudWxsO1xuICAgIHRoaXMudXJsX3N0YXRlID0gYXJncy51cmxfc3RhdGU7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvRXJyb3JUaW1lb3V0LnRzXG52YXIgRXJyb3JUaW1lb3V0ID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAvKiogTWFya2VyIHRvIGRldGVjdCBjbGFzczogXCJFcnJvclRpbWVvdXRcIiAqL1xuICAgIHRoaXMubmFtZSA9IFwiRXJyb3JUaW1lb3V0XCI7XG4gIH1cbn07XG5cbi8vIHNyYy9BY2Nlc3NUb2tlbkV2ZW50cy50c1xudmFyIEFjY2Vzc1Rva2VuRXZlbnRzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIkFjY2Vzc1Rva2VuRXZlbnRzXCIpO1xuICAgIHRoaXMuX2V4cGlyaW5nVGltZXIgPSBuZXcgVGltZXIoXCJBY2Nlc3MgdG9rZW4gZXhwaXJpbmdcIik7XG4gICAgdGhpcy5fZXhwaXJlZFRpbWVyID0gbmV3IFRpbWVyKFwiQWNjZXNzIHRva2VuIGV4cGlyZWRcIik7XG4gICAgdGhpcy5fZXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzID0gYXJncy5leHBpcmluZ05vdGlmaWNhdGlvblRpbWVJblNlY29uZHM7XG4gIH1cbiAgbG9hZChjb250YWluZXIpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImxvYWRcIik7XG4gICAgaWYgKGNvbnRhaW5lci5hY2Nlc3NfdG9rZW4gJiYgY29udGFpbmVyLmV4cGlyZXNfaW4gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBjb250YWluZXIuZXhwaXJlc19pbjtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJhY2Nlc3MgdG9rZW4gcHJlc2VudCwgcmVtYWluaW5nIGR1cmF0aW9uOlwiLCBkdXJhdGlvbik7XG4gICAgICBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICAgIGxldCBleHBpcmluZyA9IGR1cmF0aW9uIC0gdGhpcy5fZXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzO1xuICAgICAgICBpZiAoZXhwaXJpbmcgPD0gMCkge1xuICAgICAgICAgIGV4cGlyaW5nID0gMTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIyLmRlYnVnKFwicmVnaXN0ZXJpbmcgZXhwaXJpbmcgdGltZXIsIHJhaXNpbmcgaW5cIiwgZXhwaXJpbmcsIFwic2Vjb25kc1wiKTtcbiAgICAgICAgdGhpcy5fZXhwaXJpbmdUaW1lci5pbml0KGV4cGlyaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJjYW5jZWxpbmcgZXhpc3RpbmcgZXhwaXJpbmcgdGltZXIgYmVjYXVzZSB3ZSdyZSBwYXN0IGV4cGlyYXRpb24uXCIpO1xuICAgICAgICB0aGlzLl9leHBpcmluZ1RpbWVyLmNhbmNlbCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXhwaXJlZCA9IGR1cmF0aW9uICsgMTtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJyZWdpc3RlcmluZyBleHBpcmVkIHRpbWVyLCByYWlzaW5nIGluXCIsIGV4cGlyZWQsIFwic2Vjb25kc1wiKTtcbiAgICAgIHRoaXMuX2V4cGlyZWRUaW1lci5pbml0KGV4cGlyZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9leHBpcmluZ1RpbWVyLmNhbmNlbCgpO1xuICAgICAgdGhpcy5fZXhwaXJlZFRpbWVyLmNhbmNlbCgpO1xuICAgIH1cbiAgfVxuICB1bmxvYWQoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwidW5sb2FkOiBjYW5jZWxpbmcgZXhpc3RpbmcgYWNjZXNzIHRva2VuIHRpbWVyc1wiKTtcbiAgICB0aGlzLl9leHBpcmluZ1RpbWVyLmNhbmNlbCgpO1xuICAgIHRoaXMuX2V4cGlyZWRUaW1lci5jYW5jZWwoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGNhbGxiYWNrOiBSYWlzZWQgcHJpb3IgdG8gdGhlIGFjY2VzcyB0b2tlbiBleHBpcmluZy5cbiAgICovXG4gIGFkZEFjY2Vzc1Rva2VuRXhwaXJpbmcoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwaXJpbmdUaW1lci5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgcHJpb3IgdG8gdGhlIGFjY2VzcyB0b2tlbiBleHBpcmluZy5cbiAgICovXG4gIHJlbW92ZUFjY2Vzc1Rva2VuRXhwaXJpbmcoY2IpIHtcbiAgICB0aGlzLl9leHBpcmluZ1RpbWVyLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCBhZnRlciB0aGUgYWNjZXNzIHRva2VuIGhhcyBleHBpcmVkLlxuICAgKi9cbiAgYWRkQWNjZXNzVG9rZW5FeHBpcmVkKGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cGlyZWRUaW1lci5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgYWZ0ZXIgdGhlIGFjY2VzcyB0b2tlbiBoYXMgZXhwaXJlZC5cbiAgICovXG4gIHJlbW92ZUFjY2Vzc1Rva2VuRXhwaXJlZChjYikge1xuICAgIHRoaXMuX2V4cGlyZWRUaW1lci5yZW1vdmVIYW5kbGVyKGNiKTtcbiAgfVxufTtcblxuLy8gc3JjL0NoZWNrU2Vzc2lvbklGcmFtZS50c1xudmFyIENoZWNrU2Vzc2lvbklGcmFtZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX2NhbGxiYWNrLCBfY2xpZW50X2lkLCB1cmwsIF9pbnRlcnZhbEluU2Vjb25kcywgX3N0b3BPbkVycm9yKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBfY2FsbGJhY2s7XG4gICAgdGhpcy5fY2xpZW50X2lkID0gX2NsaWVudF9pZDtcbiAgICB0aGlzLl9pbnRlcnZhbEluU2Vjb25kcyA9IF9pbnRlcnZhbEluU2Vjb25kcztcbiAgICB0aGlzLl9zdG9wT25FcnJvciA9IF9zdG9wT25FcnJvcjtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiQ2hlY2tTZXNzaW9uSUZyYW1lXCIpO1xuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9zZXNzaW9uX3N0YXRlID0gbnVsbDtcbiAgICB0aGlzLl9tZXNzYWdlID0gKGUpID0+IHtcbiAgICAgIGlmIChlLm9yaWdpbiA9PT0gdGhpcy5fZnJhbWVfb3JpZ2luICYmIGUuc291cmNlID09PSB0aGlzLl9mcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgIGlmIChlLmRhdGEgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImVycm9yIG1lc3NhZ2UgZnJvbSBjaGVjayBzZXNzaW9uIG9wIGlmcmFtZVwiKTtcbiAgICAgICAgICBpZiAodGhpcy5fc3RvcE9uRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEgPT09IFwiY2hhbmdlZFwiKSB7XG4gICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiY2hhbmdlZCBtZXNzYWdlIGZyb20gY2hlY2sgc2Vzc2lvbiBvcCBpZnJhbWVcIik7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgdm9pZCB0aGlzLl9jYWxsYmFjaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhlLmRhdGEgKyBcIiBtZXNzYWdlIGZyb20gY2hlY2sgc2Vzc2lvbiBvcCBpZnJhbWVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgICB0aGlzLl9mcmFtZV9vcmlnaW4gPSBwYXJzZWRVcmwub3JpZ2luO1xuICAgIHRoaXMuX2ZyYW1lID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgdGhpcy5fZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgdGhpcy5fZnJhbWUuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgdGhpcy5fZnJhbWUuc3R5bGUubGVmdCA9IFwiLTEwMDBweFwiO1xuICAgIHRoaXMuX2ZyYW1lLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgIHRoaXMuX2ZyYW1lLndpZHRoID0gXCIwXCI7XG4gICAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gXCIwXCI7XG4gICAgdGhpcy5fZnJhbWUuc3JjID0gcGFyc2VkVXJsLmhyZWY7XG4gIH1cbiAgbG9hZCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX2ZyYW1lLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2ZyYW1lKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9tZXNzYWdlLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhcnQoc2Vzc2lvbl9zdGF0ZSkge1xuICAgIGlmICh0aGlzLl9zZXNzaW9uX3N0YXRlID09PSBzZXNzaW9uX3N0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzdGFydFwiKTtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLl9zZXNzaW9uX3N0YXRlID0gc2Vzc2lvbl9zdGF0ZTtcbiAgICBjb25zdCBzZW5kID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9mcmFtZS5jb250ZW50V2luZG93IHx8ICF0aGlzLl9zZXNzaW9uX3N0YXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UodGhpcy5fY2xpZW50X2lkICsgXCIgXCIgKyB0aGlzLl9zZXNzaW9uX3N0YXRlLCB0aGlzLl9mcmFtZV9vcmlnaW4pO1xuICAgIH07XG4gICAgc2VuZCgpO1xuICAgIHRoaXMuX3RpbWVyID0gc2V0SW50ZXJ2YWwoc2VuZCwgdGhpcy5faW50ZXJ2YWxJblNlY29uZHMgKiAxZTMpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInN0b3BcIik7XG4gICAgdGhpcy5fc2Vzc2lvbl9zdGF0ZSA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3RpbWVyKTtcbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9Jbk1lbW9yeVdlYlN0b3JhZ2UudHNcbnZhciBJbk1lbW9yeVdlYlN0b3JhZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJJbk1lbW9yeVdlYlN0b3JhZ2VcIik7XG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjbGVhclwiKTtcbiAgICB0aGlzLl9kYXRhID0ge307XG4gIH1cbiAgZ2V0SXRlbShrZXkpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKGBnZXRJdGVtKCcke2tleX0nKWApO1xuICAgIHJldHVybiB0aGlzLl9kYXRhW2tleV07XG4gIH1cbiAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShgc2V0SXRlbSgnJHtrZXl9JylgKTtcbiAgICB0aGlzLl9kYXRhW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZW1vdmVJdGVtKGtleSkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoYHJlbW92ZUl0ZW0oJyR7a2V5fScpYCk7XG4gICAgZGVsZXRlIHRoaXMuX2RhdGFba2V5XTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9kYXRhKS5sZW5ndGg7XG4gIH1cbiAga2V5KGluZGV4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX2RhdGEpW2luZGV4XTtcbiAgfVxufTtcblxuLy8gc3JjL0pzb25TZXJ2aWNlLnRzXG52YXIgSnNvblNlcnZpY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFkZGl0aW9uYWxDb250ZW50VHlwZXMgPSBbXSwgX2p3dEhhbmRsZXIgPSBudWxsLCBfZXh0cmFIZWFkZXJzID0ge30pIHtcbiAgICB0aGlzLl9qd3RIYW5kbGVyID0gX2p3dEhhbmRsZXI7XG4gICAgdGhpcy5fZXh0cmFIZWFkZXJzID0gX2V4dHJhSGVhZGVycztcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiSnNvblNlcnZpY2VcIik7XG4gICAgdGhpcy5fY29udGVudFR5cGVzID0gW107XG4gICAgdGhpcy5fY29udGVudFR5cGVzLnB1c2goLi4uYWRkaXRpb25hbENvbnRlbnRUeXBlcywgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgIGlmIChfand0SGFuZGxlcikge1xuICAgICAgdGhpcy5fY29udGVudFR5cGVzLnB1c2goXCJhcHBsaWNhdGlvbi9qd3RcIik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZldGNoV2l0aFRpbWVvdXQoaW5wdXQsIGluaXQgPSB7fSkge1xuICAgIGNvbnN0IHsgdGltZW91dEluU2Vjb25kcywgLi4uaW5pdEZldGNoIH0gPSBpbml0O1xuICAgIGlmICghdGltZW91dEluU2Vjb25kcykge1xuICAgICAgcmV0dXJuIGF3YWl0IGZldGNoKGlucHV0LCBpbml0RmV0Y2gpO1xuICAgIH1cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0SW5TZWNvbmRzICogMWUzKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChpbnB1dCwge1xuICAgICAgICAuLi5pbml0LFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBET01FeGNlcHRpb24gJiYgZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvclRpbWVvdXQoXCJOZXR3b3JrIHRpbWVkIG91dFwiKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldEpzb24odXJsLCB7XG4gICAgdG9rZW4sXG4gICAgY3JlZGVudGlhbHNcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJnZXRKc29uXCIpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIkFjY2VwdFwiOiB0aGlzLl9jb250ZW50VHlwZXMuam9pbihcIiwgXCIpXG4gICAgfTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJ0b2tlbiBwYXNzZWQsIHNldHRpbmcgQXV0aG9yaXphdGlvbiBoZWFkZXJcIik7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IFwiQmVhcmVyIFwiICsgdG9rZW47XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kRXh0cmFIZWFkZXJzKGhlYWRlcnMpO1xuICAgIGxldCByZXNwb25zZTtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInVybDpcIiwgdXJsKTtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhUaW1lb3V0KHVybCwgeyBtZXRob2Q6IFwiR0VUXCIsIGhlYWRlcnMsIGNyZWRlbnRpYWxzIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyMi5lcnJvcihcIk5ldHdvcmsgRXJyb3JcIik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJIVFRQIHJlc3BvbnNlIHJlY2VpdmVkLCBzdGF0dXNcIiwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgIGlmIChjb250ZW50VHlwZSAmJiAhdGhpcy5fY29udGVudFR5cGVzLmZpbmQoKGl0ZW0pID0+IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoaXRlbSkpKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihgSW52YWxpZCByZXNwb25zZSBDb250ZW50LVR5cGU6ICR7Y29udGVudFR5cGUgIT0gbnVsbCA/IGNvbnRlbnRUeXBlIDogXCJ1bmRlZmluZWRcIn0sIGZyb20gVVJMOiAke3VybH1gKSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5vayAmJiB0aGlzLl9qd3RIYW5kbGVyICYmIChjb250ZW50VHlwZSA9PSBudWxsID8gdm9pZCAwIDogY29udGVudFR5cGUuc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL2p3dFwiKSkpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9qd3RIYW5kbGVyKGF3YWl0IHJlc3BvbnNlLnRleHQoKSk7XG4gICAgfVxuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyMi5lcnJvcihcIkVycm9yIHBhcnNpbmcgSlNPTiByZXNwb25zZVwiLCBlcnIpO1xuICAgICAgaWYgKHJlc3BvbnNlLm9rKVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gKCR7cmVzcG9uc2Uuc3RhdHVzfSlgKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbG9nZ2VyMi5lcnJvcihcIkVycm9yIGZyb20gc2VydmVyOlwiLCBqc29uKTtcbiAgICAgIGlmIChqc29uLmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlKGpzb24pO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c1RleHR9ICgke3Jlc3BvbnNlLnN0YXR1c30pOiAke0pTT04uc3RyaW5naWZ5KGpzb24pfWApO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuICBhc3luYyBwb3N0Rm9ybSh1cmwsIHtcbiAgICBib2R5LFxuICAgIGJhc2ljQXV0aCxcbiAgICB0aW1lb3V0SW5TZWNvbmRzLFxuICAgIGluaXRDcmVkZW50aWFsc1xuICB9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJwb3N0Rm9ybVwiKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgXCJBY2NlcHRcIjogdGhpcy5fY29udGVudFR5cGVzLmpvaW4oXCIsIFwiKSxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICB9O1xuICAgIGlmIChiYXNpY0F1dGggIT09IHZvaWQgMCkge1xuICAgICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJhc2ljIFwiICsgYmFzaWNBdXRoO1xuICAgIH1cbiAgICB0aGlzLmFwcGVuZEV4dHJhSGVhZGVycyhoZWFkZXJzKTtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJ1cmw6XCIsIHVybCk7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoVGltZW91dCh1cmwsIHsgbWV0aG9kOiBcIlBPU1RcIiwgaGVhZGVycywgYm9keSwgdGltZW91dEluU2Vjb25kcywgY3JlZGVudGlhbHM6IGluaXRDcmVkZW50aWFscyB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlcjIuZXJyb3IoXCJOZXR3b3JrIGVycm9yXCIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwiSFRUUCByZXNwb25zZSByZWNlaXZlZCwgc3RhdHVzXCIsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICBpZiAoY29udGVudFR5cGUgJiYgIXRoaXMuX2NvbnRlbnRUeXBlcy5maW5kKChpdGVtKSA9PiBjb250ZW50VHlwZS5zdGFydHNXaXRoKGl0ZW0pKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIENvbnRlbnQtVHlwZTogJHtjb250ZW50VHlwZSAhPSBudWxsID8gY29udGVudFR5cGUgOiBcInVuZGVmaW5lZFwifSwgZnJvbSBVUkw6ICR7dXJsfWApO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgbGV0IGpzb24gPSB7fTtcbiAgICBpZiAocmVzcG9uc2VUZXh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlcjIuZXJyb3IoXCJFcnJvciBwYXJzaW5nIEpTT04gcmVzcG9uc2VcIiwgZXJyKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c1RleHR9ICgke3Jlc3BvbnNlLnN0YXR1c30pYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxvZ2dlcjIuZXJyb3IoXCJFcnJvciBmcm9tIHNlcnZlcjpcIiwganNvbik7XG4gICAgICBpZiAoanNvbi5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZShqc29uLCBib2R5KTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAoJHtyZXNwb25zZS5zdGF0dXN9KTogJHtKU09OLnN0cmluZ2lmeShqc29uKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbiAgYXBwZW5kRXh0cmFIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImFwcGVuZEV4dHJhSGVhZGVyc1wiKTtcbiAgICBjb25zdCBjdXN0b21LZXlzID0gT2JqZWN0LmtleXModGhpcy5fZXh0cmFIZWFkZXJzKTtcbiAgICBjb25zdCBwcm90ZWN0ZWRIZWFkZXJzID0gW1xuICAgICAgXCJhdXRob3JpemF0aW9uXCIsXG4gICAgICBcImFjY2VwdFwiLFxuICAgICAgXCJjb250ZW50LXR5cGVcIlxuICAgIF07XG4gICAgaWYgKGN1c3RvbUtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1c3RvbUtleXMuZm9yRWFjaCgoaGVhZGVyTmFtZSkgPT4ge1xuICAgICAgaWYgKHByb3RlY3RlZEhlYWRlcnMuaW5jbHVkZXMoaGVhZGVyTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSkge1xuICAgICAgICBsb2dnZXIyLndhcm4oXCJQcm90ZWN0ZWQgaGVhZGVyIGNvdWxkIG5vdCBiZSBvdmVycmlkZGVuXCIsIGhlYWRlck5hbWUsIHByb3RlY3RlZEhlYWRlcnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjb250ZW50ID0gdHlwZW9mIHRoaXMuX2V4dHJhSGVhZGVyc1toZWFkZXJOYW1lXSA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5fZXh0cmFIZWFkZXJzW2hlYWRlck5hbWVdKCkgOiB0aGlzLl9leHRyYUhlYWRlcnNbaGVhZGVyTmFtZV07XG4gICAgICBpZiAoY29udGVudCAmJiBjb250ZW50ICE9PSBcIlwiKSB7XG4gICAgICAgIGhlYWRlcnNbaGVhZGVyTmFtZV0gPSBjb250ZW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvTWV0YWRhdGFTZXJ2aWNlLnRzXG52YXIgTWV0YWRhdGFTZXJ2aWNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc2V0dGluZ3MpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiTWV0YWRhdGFTZXJ2aWNlXCIpO1xuICAgIHRoaXMuX3NpZ25pbmdLZXlzID0gbnVsbDtcbiAgICB0aGlzLl9tZXRhZGF0YSA9IG51bGw7XG4gICAgdGhpcy5fbWV0YWRhdGFVcmwgPSB0aGlzLl9zZXR0aW5ncy5tZXRhZGF0YVVybDtcbiAgICB0aGlzLl9qc29uU2VydmljZSA9IG5ldyBKc29uU2VydmljZShcbiAgICAgIFtcImFwcGxpY2F0aW9uL2p3ay1zZXQranNvblwiXSxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLl9zZXR0aW5ncy5leHRyYUhlYWRlcnNcbiAgICApO1xuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zaWduaW5nS2V5cykge1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwidXNpbmcgc2lnbmluZ0tleXMgZnJvbSBzZXR0aW5nc1wiKTtcbiAgICAgIHRoaXMuX3NpZ25pbmdLZXlzID0gdGhpcy5fc2V0dGluZ3Muc2lnbmluZ0tleXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tZXRhZGF0YSkge1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwidXNpbmcgbWV0YWRhdGEgZnJvbSBzZXR0aW5nc1wiKTtcbiAgICAgIHRoaXMuX21ldGFkYXRhID0gdGhpcy5fc2V0dGluZ3MubWV0YWRhdGE7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5mZXRjaFJlcXVlc3RDcmVkZW50aWFscykge1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwidXNpbmcgZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMgZnJvbSBzZXR0aW5nc1wiKTtcbiAgICAgIHRoaXMuX2ZldGNoUmVxdWVzdENyZWRlbnRpYWxzID0gdGhpcy5fc2V0dGluZ3MuZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHM7XG4gICAgfVxuICB9XG4gIHJlc2V0U2lnbmluZ0tleXMoKSB7XG4gICAgdGhpcy5fc2lnbmluZ0tleXMgPSBudWxsO1xuICB9XG4gIGFzeW5jIGdldE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZ2V0TWV0YWRhdGFcIik7XG4gICAgaWYgKHRoaXMuX21ldGFkYXRhKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwidXNpbmcgY2FjaGVkIHZhbHVlc1wiKTtcbiAgICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9tZXRhZGF0YVVybCkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJObyBhdXRob3JpdHkgb3IgbWV0YWRhdGFVcmwgY29uZmlndXJlZCBvbiBzZXR0aW5nc1wiKSk7XG4gICAgICB0aHJvdyBudWxsO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwiZ2V0dGluZyBtZXRhZGF0YSBmcm9tXCIsIHRoaXMuX21ldGFkYXRhVXJsKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuX2pzb25TZXJ2aWNlLmdldEpzb24odGhpcy5fbWV0YWRhdGFVcmwsIHsgY3JlZGVudGlhbHM6IHRoaXMuX2ZldGNoUmVxdWVzdENyZWRlbnRpYWxzIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJtZXJnaW5nIHJlbW90ZSBKU09OIHdpdGggc2VlZCBtZXRhZGF0YVwiKTtcbiAgICB0aGlzLl9tZXRhZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3NldHRpbmdzLm1ldGFkYXRhU2VlZCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YTtcbiAgfVxuICBnZXRJc3N1ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE1ldGFkYXRhUHJvcGVydHkoXCJpc3N1ZXJcIik7XG4gIH1cbiAgZ2V0QXV0aG9yaXphdGlvbkVuZHBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRNZXRhZGF0YVByb3BlcnR5KFwiYXV0aG9yaXphdGlvbl9lbmRwb2ludFwiKTtcbiAgfVxuICBnZXRVc2VySW5mb0VuZHBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRNZXRhZGF0YVByb3BlcnR5KFwidXNlcmluZm9fZW5kcG9pbnRcIik7XG4gIH1cbiAgZ2V0VG9rZW5FbmRwb2ludChvcHRpb25hbCA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcInRva2VuX2VuZHBvaW50XCIsIG9wdGlvbmFsKTtcbiAgfVxuICBnZXRDaGVja1Nlc3Npb25JZnJhbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE1ldGFkYXRhUHJvcGVydHkoXCJjaGVja19zZXNzaW9uX2lmcmFtZVwiLCB0cnVlKTtcbiAgfVxuICBnZXRFbmRTZXNzaW9uRW5kcG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE1ldGFkYXRhUHJvcGVydHkoXCJlbmRfc2Vzc2lvbl9lbmRwb2ludFwiLCB0cnVlKTtcbiAgfVxuICBnZXRSZXZvY2F0aW9uRW5kcG9pbnQob3B0aW9uYWwgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE1ldGFkYXRhUHJvcGVydHkoXCJyZXZvY2F0aW9uX2VuZHBvaW50XCIsIG9wdGlvbmFsKTtcbiAgfVxuICBnZXRLZXlzRW5kcG9pbnQob3B0aW9uYWwgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE1ldGFkYXRhUHJvcGVydHkoXCJqd2tzX3VyaVwiLCBvcHRpb25hbCk7XG4gIH1cbiAgYXN5bmMgX2dldE1ldGFkYXRhUHJvcGVydHkobmFtZSwgb3B0aW9uYWwgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKGBfZ2V0TWV0YWRhdGFQcm9wZXJ0eSgnJHtuYW1lfScpYCk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKCk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcInJlc29sdmVkXCIpO1xuICAgIGlmIChtZXRhZGF0YVtuYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAob3B0aW9uYWwgPT09IHRydWUpIHtcbiAgICAgICAgbG9nZ2VyMi53YXJuKFwiTWV0YWRhdGEgZG9lcyBub3QgY29udGFpbiBvcHRpb25hbCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTWV0YWRhdGEgZG9lcyBub3QgY29udGFpbiBwcm9wZXJ0eSBcIiArIG5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFkYXRhW25hbWVdO1xuICB9XG4gIGFzeW5jIGdldFNpZ25pbmdLZXlzKCkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZ2V0U2lnbmluZ0tleXNcIik7XG4gICAgaWYgKHRoaXMuX3NpZ25pbmdLZXlzKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwicmV0dXJuaW5nIHNpZ25pbmdLZXlzIGZyb20gY2FjaGVcIik7XG4gICAgICByZXR1cm4gdGhpcy5fc2lnbmluZ0tleXM7XG4gICAgfVxuICAgIGNvbnN0IGp3a3NfdXJpID0gYXdhaXQgdGhpcy5nZXRLZXlzRW5kcG9pbnQoZmFsc2UpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qgandrc191cmlcIiwgandrc191cmkpO1xuICAgIGNvbnN0IGtleVNldCA9IGF3YWl0IHRoaXMuX2pzb25TZXJ2aWNlLmdldEpzb24oandrc191cmkpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qga2V5IHNldFwiLCBrZXlTZXQpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlTZXQua2V5cykpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTWlzc2luZyBrZXlzIG9uIGtleXNldFwiKSk7XG4gICAgICB0aHJvdyBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9zaWduaW5nS2V5cyA9IGtleVNldC5rZXlzO1xuICAgIHJldHVybiB0aGlzLl9zaWduaW5nS2V5cztcbiAgfVxufTtcblxuLy8gc3JjL1dlYlN0b3JhZ2VTdGF0ZVN0b3JlLnRzXG52YXIgV2ViU3RvcmFnZVN0YXRlU3RvcmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwcmVmaXggPSBcIm9pZGMuXCIsXG4gICAgc3RvcmUgPSBsb2NhbFN0b3JhZ2VcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIldlYlN0b3JhZ2VTdGF0ZVN0b3JlXCIpO1xuICAgIHRoaXMuX3N0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5fcHJlZml4ID0gcHJlZml4O1xuICB9XG4gIGFzeW5jIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShgc2V0KCcke2tleX0nKWApO1xuICAgIGtleSA9IHRoaXMuX3ByZWZpeCArIGtleTtcbiAgICBhd2FpdCB0aGlzLl9zdG9yZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIGdldChrZXkpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKGBnZXQoJyR7a2V5fScpYCk7XG4gICAga2V5ID0gdGhpcy5fcHJlZml4ICsga2V5O1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0aGlzLl9zdG9yZS5nZXRJdGVtKGtleSk7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgYXN5bmMgcmVtb3ZlKGtleSkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoYHJlbW92ZSgnJHtrZXl9JylgKTtcbiAgICBrZXkgPSB0aGlzLl9wcmVmaXggKyBrZXk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IHRoaXMuX3N0b3JlLmdldEl0ZW0oa2V5KTtcbiAgICBhd2FpdCB0aGlzLl9zdG9yZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgYXN5bmMgZ2V0QWxsS2V5cygpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZ2V0QWxsS2V5c1wiKTtcbiAgICBjb25zdCBsZW4gPSBhd2FpdCB0aGlzLl9zdG9yZS5sZW5ndGg7XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHRoaXMuX3N0b3JlLmtleShpbmRleCk7XG4gICAgICBpZiAoa2V5ICYmIGtleS5pbmRleE9mKHRoaXMuX3ByZWZpeCkgPT09IDApIHtcbiAgICAgICAga2V5cy5wdXNoKGtleS5zdWJzdHIodGhpcy5fcHJlZml4Lmxlbmd0aCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbiAgfVxufTtcblxuLy8gc3JjL09pZGNDbGllbnRTZXR0aW5ncy50c1xudmFyIERlZmF1bHRSZXNwb25zZVR5cGUgPSBcImNvZGVcIjtcbnZhciBEZWZhdWx0U2NvcGUgPSBcIm9wZW5pZFwiO1xudmFyIERlZmF1bHRDbGllbnRBdXRoZW50aWNhdGlvbiA9IFwiY2xpZW50X3NlY3JldF9wb3N0XCI7XG52YXIgRGVmYXVsdFJlc3BvbnNlTW9kZSA9IFwicXVlcnlcIjtcbnZhciBEZWZhdWx0U3RhbGVTdGF0ZUFnZUluU2Vjb25kcyA9IDYwICogMTU7XG52YXIgRGVmYXVsdENsb2NrU2tld0luU2Vjb25kcyA9IDYwICogNTtcbnZhciBPaWRjQ2xpZW50U2V0dGluZ3NTdG9yZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIG1ldGFkYXRhIHJlbGF0ZWRcbiAgICBhdXRob3JpdHksXG4gICAgbWV0YWRhdGFVcmwsXG4gICAgbWV0YWRhdGEsXG4gICAgc2lnbmluZ0tleXMsXG4gICAgbWV0YWRhdGFTZWVkLFxuICAgIC8vIGNsaWVudCByZWxhdGVkXG4gICAgY2xpZW50X2lkLFxuICAgIGNsaWVudF9zZWNyZXQsXG4gICAgcmVzcG9uc2VfdHlwZSA9IERlZmF1bHRSZXNwb25zZVR5cGUsXG4gICAgc2NvcGUgPSBEZWZhdWx0U2NvcGUsXG4gICAgcmVkaXJlY3RfdXJpLFxuICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICBjbGllbnRfYXV0aGVudGljYXRpb24gPSBEZWZhdWx0Q2xpZW50QXV0aGVudGljYXRpb24sXG4gICAgLy8gb3B0aW9uYWwgcHJvdG9jb2xcbiAgICBwcm9tcHQsXG4gICAgZGlzcGxheSxcbiAgICBtYXhfYWdlLFxuICAgIHVpX2xvY2FsZXMsXG4gICAgYWNyX3ZhbHVlcyxcbiAgICByZXNvdXJjZSxcbiAgICByZXNwb25zZV9tb2RlID0gRGVmYXVsdFJlc3BvbnNlTW9kZSxcbiAgICAvLyBiZWhhdmlvciBmbGFnc1xuICAgIGZpbHRlclByb3RvY29sQ2xhaW1zID0gdHJ1ZSxcbiAgICBsb2FkVXNlckluZm8gPSBmYWxzZSxcbiAgICBzdGFsZVN0YXRlQWdlSW5TZWNvbmRzID0gRGVmYXVsdFN0YWxlU3RhdGVBZ2VJblNlY29uZHMsXG4gICAgY2xvY2tTa2V3SW5TZWNvbmRzID0gRGVmYXVsdENsb2NrU2tld0luU2Vjb25kcyxcbiAgICB1c2VySW5mb0p3dElzc3VlciA9IFwiT1BcIixcbiAgICBtZXJnZUNsYWltcyA9IGZhbHNlLFxuICAgIGRpc2FibGVQS0NFID0gZmFsc2UsXG4gICAgLy8gb3RoZXIgYmVoYXZpb3JcbiAgICBzdGF0ZVN0b3JlLFxuICAgIHJlZnJlc2hUb2tlbkNyZWRlbnRpYWxzLFxuICAgIHJldm9rZVRva2VuQWRkaXRpb25hbENvbnRlbnRUeXBlcyxcbiAgICBmZXRjaFJlcXVlc3RDcmVkZW50aWFscyxcbiAgICByZWZyZXNoVG9rZW5BbGxvd2VkU2NvcGUsXG4gICAgLy8gZXh0cmFcbiAgICBleHRyYVF1ZXJ5UGFyYW1zID0ge30sXG4gICAgZXh0cmFUb2tlblBhcmFtcyA9IHt9LFxuICAgIGV4dHJhSGVhZGVycyA9IHt9XG4gIH0pIHtcbiAgICB0aGlzLmF1dGhvcml0eSA9IGF1dGhvcml0eTtcbiAgICBpZiAobWV0YWRhdGFVcmwpIHtcbiAgICAgIHRoaXMubWV0YWRhdGFVcmwgPSBtZXRhZGF0YVVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZXRhZGF0YVVybCA9IGF1dGhvcml0eTtcbiAgICAgIGlmIChhdXRob3JpdHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhVXJsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgIHRoaXMubWV0YWRhdGFVcmwgKz0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXRhZGF0YVVybCArPSBcIi53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB0aGlzLm1ldGFkYXRhU2VlZCA9IG1ldGFkYXRhU2VlZDtcbiAgICB0aGlzLnNpZ25pbmdLZXlzID0gc2lnbmluZ0tleXM7XG4gICAgdGhpcy5jbGllbnRfaWQgPSBjbGllbnRfaWQ7XG4gICAgdGhpcy5jbGllbnRfc2VjcmV0ID0gY2xpZW50X3NlY3JldDtcbiAgICB0aGlzLnJlc3BvbnNlX3R5cGUgPSByZXNwb25zZV90eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnJlZGlyZWN0X3VyaSA9IHJlZGlyZWN0X3VyaTtcbiAgICB0aGlzLnBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaTtcbiAgICB0aGlzLmNsaWVudF9hdXRoZW50aWNhdGlvbiA9IGNsaWVudF9hdXRoZW50aWNhdGlvbjtcbiAgICB0aGlzLnByb21wdCA9IHByb21wdDtcbiAgICB0aGlzLmRpc3BsYXkgPSBkaXNwbGF5O1xuICAgIHRoaXMubWF4X2FnZSA9IG1heF9hZ2U7XG4gICAgdGhpcy51aV9sb2NhbGVzID0gdWlfbG9jYWxlcztcbiAgICB0aGlzLmFjcl92YWx1ZXMgPSBhY3JfdmFsdWVzO1xuICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICB0aGlzLnJlc3BvbnNlX21vZGUgPSByZXNwb25zZV9tb2RlO1xuICAgIHRoaXMuZmlsdGVyUHJvdG9jb2xDbGFpbXMgPSBmaWx0ZXJQcm90b2NvbENsYWltcyAhPSBudWxsID8gZmlsdGVyUHJvdG9jb2xDbGFpbXMgOiB0cnVlO1xuICAgIHRoaXMubG9hZFVzZXJJbmZvID0gISFsb2FkVXNlckluZm87XG4gICAgdGhpcy5zdGFsZVN0YXRlQWdlSW5TZWNvbmRzID0gc3RhbGVTdGF0ZUFnZUluU2Vjb25kcztcbiAgICB0aGlzLmNsb2NrU2tld0luU2Vjb25kcyA9IGNsb2NrU2tld0luU2Vjb25kcztcbiAgICB0aGlzLnVzZXJJbmZvSnd0SXNzdWVyID0gdXNlckluZm9Kd3RJc3N1ZXI7XG4gICAgdGhpcy5tZXJnZUNsYWltcyA9ICEhbWVyZ2VDbGFpbXM7XG4gICAgdGhpcy5kaXNhYmxlUEtDRSA9ICEhZGlzYWJsZVBLQ0U7XG4gICAgdGhpcy5yZXZva2VUb2tlbkFkZGl0aW9uYWxDb250ZW50VHlwZXMgPSByZXZva2VUb2tlbkFkZGl0aW9uYWxDb250ZW50VHlwZXM7XG4gICAgaWYgKGZldGNoUmVxdWVzdENyZWRlbnRpYWxzICYmIHJlZnJlc2hUb2tlbkNyZWRlbnRpYWxzKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJCb3RoIGZldGNoUmVxdWVzdENyZWRlbnRpYWxzIGFuZCByZWZyZXNoVG9rZW5DcmVkZW50aWFscyBpcyBzZXQuIE9ubHkgZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMgd2lsbCBiZSB1c2VkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5mZXRjaFJlcXVlc3RDcmVkZW50aWFscyA9IGZldGNoUmVxdWVzdENyZWRlbnRpYWxzID8gZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMgOiByZWZyZXNoVG9rZW5DcmVkZW50aWFscyA/IHJlZnJlc2hUb2tlbkNyZWRlbnRpYWxzIDogXCJzYW1lLW9yaWdpblwiO1xuICAgIGlmIChzdGF0ZVN0b3JlKSB7XG4gICAgICB0aGlzLnN0YXRlU3RvcmUgPSBzdGF0ZVN0b3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdG9yZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cubG9jYWxTdG9yYWdlIDogbmV3IEluTWVtb3J5V2ViU3RvcmFnZSgpO1xuICAgICAgdGhpcy5zdGF0ZVN0b3JlID0gbmV3IFdlYlN0b3JhZ2VTdGF0ZVN0b3JlKHsgc3RvcmUgfSk7XG4gICAgfVxuICAgIHRoaXMucmVmcmVzaFRva2VuQWxsb3dlZFNjb3BlID0gcmVmcmVzaFRva2VuQWxsb3dlZFNjb3BlO1xuICAgIHRoaXMuZXh0cmFRdWVyeVBhcmFtcyA9IGV4dHJhUXVlcnlQYXJhbXM7XG4gICAgdGhpcy5leHRyYVRva2VuUGFyYW1zID0gZXh0cmFUb2tlblBhcmFtcztcbiAgICB0aGlzLmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcbiAgfVxufTtcblxuLy8gc3JjL1VzZXJJbmZvU2VydmljZS50c1xudmFyIFVzZXJJbmZvU2VydmljZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3NldHRpbmdzLCBfbWV0YWRhdGFTZXJ2aWNlKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfc2V0dGluZ3M7XG4gICAgdGhpcy5fbWV0YWRhdGFTZXJ2aWNlID0gX21ldGFkYXRhU2VydmljZTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiVXNlckluZm9TZXJ2aWNlXCIpO1xuICAgIHRoaXMuX2dldENsYWltc0Zyb21Kd3QgPSBhc3luYyAocmVzcG9uc2VUZXh0KSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9nZXRDbGFpbXNGcm9tSnd0XCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IEp3dFV0aWxzLmRlY29kZShyZXNwb25zZVRleHQpO1xuICAgICAgICBsb2dnZXIyLmRlYnVnKFwiSldUIGRlY29kaW5nIHN1Y2Nlc3NmdWxcIik7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlcjIuZXJyb3IoXCJFcnJvciBwYXJzaW5nIEpXVCByZXNwb25zZVwiKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fanNvblNlcnZpY2UgPSBuZXcgSnNvblNlcnZpY2UoXG4gICAgICB2b2lkIDAsXG4gICAgICB0aGlzLl9nZXRDbGFpbXNGcm9tSnd0LFxuICAgICAgdGhpcy5fc2V0dGluZ3MuZXh0cmFIZWFkZXJzXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDbGFpbXModG9rZW4pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImdldENsYWltc1wiKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICB0aGlzLl9sb2dnZXIudGhyb3cobmV3IEVycm9yKFwiTm8gdG9rZW4gcGFzc2VkXCIpKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fbWV0YWRhdGFTZXJ2aWNlLmdldFVzZXJJbmZvRW5kcG9pbnQoKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHVzZXJpbmZvIHVybFwiLCB1cmwpO1xuICAgIGNvbnN0IGNsYWltcyA9IGF3YWl0IHRoaXMuX2pzb25TZXJ2aWNlLmdldEpzb24odXJsLCB7XG4gICAgICB0b2tlbixcbiAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLl9zZXR0aW5ncy5mZXRjaFJlcXVlc3RDcmVkZW50aWFsc1xuICAgIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgY2xhaW1zXCIsIGNsYWltcyk7XG4gICAgcmV0dXJuIGNsYWltcztcbiAgfVxufTtcblxuLy8gc3JjL1Rva2VuQ2xpZW50LnRzXG52YXIgVG9rZW5DbGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9zZXR0aW5ncywgX21ldGFkYXRhU2VydmljZSkge1xuICAgIHRoaXMuX3NldHRpbmdzID0gX3NldHRpbmdzO1xuICAgIHRoaXMuX21ldGFkYXRhU2VydmljZSA9IF9tZXRhZGF0YVNlcnZpY2U7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlRva2VuQ2xpZW50XCIpO1xuICAgIHRoaXMuX2pzb25TZXJ2aWNlID0gbmV3IEpzb25TZXJ2aWNlKFxuICAgICAgdGhpcy5fc2V0dGluZ3MucmV2b2tlVG9rZW5BZGRpdGlvbmFsQ29udGVudFR5cGVzLFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMuX3NldHRpbmdzLmV4dHJhSGVhZGVyc1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEV4Y2hhbmdlIGNvZGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY3NDkjc2VjdGlvbi00LjEuM1xuICAgKi9cbiAgYXN5bmMgZXhjaGFuZ2VDb2RlKHtcbiAgICBncmFudF90eXBlID0gXCJhdXRob3JpemF0aW9uX2NvZGVcIixcbiAgICByZWRpcmVjdF91cmkgPSB0aGlzLl9zZXR0aW5ncy5yZWRpcmVjdF91cmksXG4gICAgY2xpZW50X2lkID0gdGhpcy5fc2V0dGluZ3MuY2xpZW50X2lkLFxuICAgIGNsaWVudF9zZWNyZXQgPSB0aGlzLl9zZXR0aW5ncy5jbGllbnRfc2VjcmV0LFxuICAgIC4uLmFyZ3NcbiAgfSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZXhjaGFuZ2VDb2RlXCIpO1xuICAgIGlmICghY2xpZW50X2lkKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIkEgY2xpZW50X2lkIGlzIHJlcXVpcmVkXCIpKTtcbiAgICB9XG4gICAgaWYgKCFyZWRpcmVjdF91cmkpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSByZWRpcmVjdF91cmkgaXMgcmVxdWlyZWRcIikpO1xuICAgIH1cbiAgICBpZiAoIWFyZ3MuY29kZSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJBIGNvZGUgaXMgcmVxdWlyZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgZ3JhbnRfdHlwZSwgcmVkaXJlY3RfdXJpIH0pO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFyZ3MpKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYmFzaWNBdXRoO1xuICAgIHN3aXRjaCAodGhpcy5fc2V0dGluZ3MuY2xpZW50X2F1dGhlbnRpY2F0aW9uKSB7XG4gICAgICBjYXNlIFwiY2xpZW50X3NlY3JldF9iYXNpY1wiOlxuICAgICAgICBpZiAoIWNsaWVudF9zZWNyZXQpIHtcbiAgICAgICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIkEgY2xpZW50X3NlY3JldCBpcyByZXF1aXJlZFwiKSk7XG4gICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBiYXNpY0F1dGggPSBDcnlwdG9VdGlscy5nZW5lcmF0ZUJhc2ljQXV0aChjbGllbnRfaWQsIGNsaWVudF9zZWNyZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjbGllbnRfc2VjcmV0X3Bvc3RcIjpcbiAgICAgICAgcGFyYW1zLmFwcGVuZChcImNsaWVudF9pZFwiLCBjbGllbnRfaWQpO1xuICAgICAgICBpZiAoY2xpZW50X3NlY3JldCkge1xuICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJjbGllbnRfc2VjcmV0XCIsIGNsaWVudF9zZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9tZXRhZGF0YVNlcnZpY2UuZ2V0VG9rZW5FbmRwb2ludChmYWxzZSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCB0b2tlbiBlbmRwb2ludFwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2pzb25TZXJ2aWNlLnBvc3RGb3JtKHVybCwgeyBib2R5OiBwYXJhbXMsIGJhc2ljQXV0aCwgaW5pdENyZWRlbnRpYWxzOiB0aGlzLl9zZXR0aW5ncy5mZXRjaFJlcXVlc3RDcmVkZW50aWFscyB9KTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHJlc3BvbnNlXCIpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogRXhjaGFuZ2UgY3JlZGVudGlhbHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY3NDkjc2VjdGlvbi00LjMuMlxuICAgKi9cbiAgYXN5bmMgZXhjaGFuZ2VDcmVkZW50aWFscyh7XG4gICAgZ3JhbnRfdHlwZSA9IFwicGFzc3dvcmRcIixcbiAgICBjbGllbnRfaWQgPSB0aGlzLl9zZXR0aW5ncy5jbGllbnRfaWQsXG4gICAgY2xpZW50X3NlY3JldCA9IHRoaXMuX3NldHRpbmdzLmNsaWVudF9zZWNyZXQsXG4gICAgc2NvcGUgPSB0aGlzLl9zZXR0aW5ncy5zY29wZSxcbiAgICAuLi5hcmdzXG4gIH0pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImV4Y2hhbmdlQ3JlZGVudGlhbHNcIik7XG4gICAgaWYgKCFjbGllbnRfaWQpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSBjbGllbnRfaWQgaXMgcmVxdWlyZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgZ3JhbnRfdHlwZSwgc2NvcGUgfSk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXJncykpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBiYXNpY0F1dGg7XG4gICAgc3dpdGNoICh0aGlzLl9zZXR0aW5ncy5jbGllbnRfYXV0aGVudGljYXRpb24pIHtcbiAgICAgIGNhc2UgXCJjbGllbnRfc2VjcmV0X2Jhc2ljXCI6XG4gICAgICAgIGlmICghY2xpZW50X3NlY3JldCkge1xuICAgICAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSBjbGllbnRfc2VjcmV0IGlzIHJlcXVpcmVkXCIpKTtcbiAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJhc2ljQXV0aCA9IENyeXB0b1V0aWxzLmdlbmVyYXRlQmFzaWNBdXRoKGNsaWVudF9pZCwgY2xpZW50X3NlY3JldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNsaWVudF9zZWNyZXRfcG9zdFwiOlxuICAgICAgICBwYXJhbXMuYXBwZW5kKFwiY2xpZW50X2lkXCIsIGNsaWVudF9pZCk7XG4gICAgICAgIGlmIChjbGllbnRfc2VjcmV0KSB7XG4gICAgICAgICAgcGFyYW1zLmFwcGVuZChcImNsaWVudF9zZWNyZXRcIiwgY2xpZW50X3NlY3JldCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuX21ldGFkYXRhU2VydmljZS5nZXRUb2tlbkVuZHBvaW50KGZhbHNlKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHRva2VuIGVuZHBvaW50XCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fanNvblNlcnZpY2UucG9zdEZvcm0odXJsLCB7IGJvZHk6IHBhcmFtcywgYmFzaWNBdXRoLCBpbml0Q3JlZGVudGlhbHM6IHRoaXMuX3NldHRpbmdzLmZldGNoUmVxdWVzdENyZWRlbnRpYWxzIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgcmVzcG9uc2VcIik7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBFeGNoYW5nZSBhIHJlZnJlc2ggdG9rZW4uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY3NDkjc2VjdGlvbi02XG4gICAqL1xuICBhc3luYyBleGNoYW5nZVJlZnJlc2hUb2tlbih7XG4gICAgZ3JhbnRfdHlwZSA9IFwicmVmcmVzaF90b2tlblwiLFxuICAgIGNsaWVudF9pZCA9IHRoaXMuX3NldHRpbmdzLmNsaWVudF9pZCxcbiAgICBjbGllbnRfc2VjcmV0ID0gdGhpcy5fc2V0dGluZ3MuY2xpZW50X3NlY3JldCxcbiAgICB0aW1lb3V0SW5TZWNvbmRzLFxuICAgIC4uLmFyZ3NcbiAgfSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZXhjaGFuZ2VSZWZyZXNoVG9rZW5cIik7XG4gICAgaWYgKCFjbGllbnRfaWQpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSBjbGllbnRfaWQgaXMgcmVxdWlyZWRcIikpO1xuICAgIH1cbiAgICBpZiAoIWFyZ3MucmVmcmVzaF90b2tlbikge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJBIHJlZnJlc2hfdG9rZW4gaXMgcmVxdWlyZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgZ3JhbnRfdHlwZSB9KTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhcmdzKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKHBhcmFtKSA9PiBwYXJhbXMuYXBwZW5kKGtleSwgcGFyYW0pKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYmFzaWNBdXRoO1xuICAgIHN3aXRjaCAodGhpcy5fc2V0dGluZ3MuY2xpZW50X2F1dGhlbnRpY2F0aW9uKSB7XG4gICAgICBjYXNlIFwiY2xpZW50X3NlY3JldF9iYXNpY1wiOlxuICAgICAgICBpZiAoIWNsaWVudF9zZWNyZXQpIHtcbiAgICAgICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIkEgY2xpZW50X3NlY3JldCBpcyByZXF1aXJlZFwiKSk7XG4gICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBiYXNpY0F1dGggPSBDcnlwdG9VdGlscy5nZW5lcmF0ZUJhc2ljQXV0aChjbGllbnRfaWQsIGNsaWVudF9zZWNyZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjbGllbnRfc2VjcmV0X3Bvc3RcIjpcbiAgICAgICAgcGFyYW1zLmFwcGVuZChcImNsaWVudF9pZFwiLCBjbGllbnRfaWQpO1xuICAgICAgICBpZiAoY2xpZW50X3NlY3JldCkge1xuICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJjbGllbnRfc2VjcmV0XCIsIGNsaWVudF9zZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9tZXRhZGF0YVNlcnZpY2UuZ2V0VG9rZW5FbmRwb2ludChmYWxzZSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCB0b2tlbiBlbmRwb2ludFwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2pzb25TZXJ2aWNlLnBvc3RGb3JtKHVybCwgeyBib2R5OiBwYXJhbXMsIGJhc2ljQXV0aCwgdGltZW91dEluU2Vjb25kcywgaW5pdENyZWRlbnRpYWxzOiB0aGlzLl9zZXR0aW5ncy5mZXRjaFJlcXVlc3RDcmVkZW50aWFscyB9KTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHJlc3BvbnNlXCIpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogUmV2b2tlIGFuIGFjY2VzcyBvciByZWZyZXNoIHRva2VuLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzAwOSNzZWN0aW9uLTIuMVxuICAgKi9cbiAgYXN5bmMgcmV2b2tlKGFyZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJyZXZva2VcIik7XG4gICAgaWYgKCFhcmdzLnRva2VuKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIkEgdG9rZW4gaXMgcmVxdWlyZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9tZXRhZGF0YVNlcnZpY2UuZ2V0UmV2b2NhdGlvbkVuZHBvaW50KGZhbHNlKTtcbiAgICBsb2dnZXIyLmRlYnVnKGBnb3QgcmV2b2NhdGlvbiBlbmRwb2ludCwgcmV2b2tpbmcgJHsoX2EgPSBhcmdzLnRva2VuX3R5cGVfaGludCkgIT0gbnVsbCA/IF9hIDogXCJkZWZhdWx0IHRva2VuIHR5cGVcIn1gKTtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXJncykpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBhcmFtcy5zZXQoXCJjbGllbnRfaWRcIiwgdGhpcy5fc2V0dGluZ3MuY2xpZW50X2lkKTtcbiAgICBpZiAodGhpcy5fc2V0dGluZ3MuY2xpZW50X3NlY3JldCkge1xuICAgICAgcGFyYW1zLnNldChcImNsaWVudF9zZWNyZXRcIiwgdGhpcy5fc2V0dGluZ3MuY2xpZW50X3NlY3JldCk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuX2pzb25TZXJ2aWNlLnBvc3RGb3JtKHVybCwgeyBib2R5OiBwYXJhbXMgfSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCByZXNwb25zZVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL1Jlc3BvbnNlVmFsaWRhdG9yLnRzXG52YXIgUmVzcG9uc2VWYWxpZGF0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9zZXR0aW5ncywgX21ldGFkYXRhU2VydmljZSwgX2NsYWltc1NlcnZpY2UpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9tZXRhZGF0YVNlcnZpY2UgPSBfbWV0YWRhdGFTZXJ2aWNlO1xuICAgIHRoaXMuX2NsYWltc1NlcnZpY2UgPSBfY2xhaW1zU2VydmljZTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiUmVzcG9uc2VWYWxpZGF0b3JcIik7XG4gICAgdGhpcy5fdXNlckluZm9TZXJ2aWNlID0gbmV3IFVzZXJJbmZvU2VydmljZSh0aGlzLl9zZXR0aW5ncywgdGhpcy5fbWV0YWRhdGFTZXJ2aWNlKTtcbiAgICB0aGlzLl90b2tlbkNsaWVudCA9IG5ldyBUb2tlbkNsaWVudCh0aGlzLl9zZXR0aW5ncywgdGhpcy5fbWV0YWRhdGFTZXJ2aWNlKTtcbiAgfVxuICBhc3luYyB2YWxpZGF0ZVNpZ25pblJlc3BvbnNlKHJlc3BvbnNlLCBzdGF0ZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwidmFsaWRhdGVTaWduaW5SZXNwb25zZVwiKTtcbiAgICB0aGlzLl9wcm9jZXNzU2lnbmluU3RhdGUocmVzcG9uc2UsIHN0YXRlKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwic3RhdGUgcHJvY2Vzc2VkXCIpO1xuICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NDb2RlKHJlc3BvbnNlLCBzdGF0ZSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImNvZGUgcHJvY2Vzc2VkXCIpO1xuICAgIGlmIChyZXNwb25zZS5pc09wZW5JZCkge1xuICAgICAgdGhpcy5fdmFsaWRhdGVJZFRva2VuQXR0cmlidXRlcyhyZXNwb25zZSk7XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJ0b2tlbnMgdmFsaWRhdGVkXCIpO1xuICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NDbGFpbXMocmVzcG9uc2UsIHN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5za2lwVXNlckluZm8sIHJlc3BvbnNlLmlzT3BlbklkKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiY2xhaW1zIHByb2Nlc3NlZFwiKTtcbiAgfVxuICBhc3luYyB2YWxpZGF0ZUNyZWRlbnRpYWxzUmVzcG9uc2UocmVzcG9uc2UsIHNraXBVc2VySW5mbykge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwidmFsaWRhdGVDcmVkZW50aWFsc1Jlc3BvbnNlXCIpO1xuICAgIGlmIChyZXNwb25zZS5pc09wZW5JZCAmJiAhIXJlc3BvbnNlLmlkX3Rva2VuKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZUlkVG9rZW5BdHRyaWJ1dGVzKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcInRva2VucyB2YWxpZGF0ZWRcIik7XG4gICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0NsYWltcyhyZXNwb25zZSwgc2tpcFVzZXJJbmZvLCByZXNwb25zZS5pc09wZW5JZCk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImNsYWltcyBwcm9jZXNzZWRcIik7XG4gIH1cbiAgYXN5bmMgdmFsaWRhdGVSZWZyZXNoUmVzcG9uc2UocmVzcG9uc2UsIHN0YXRlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInZhbGlkYXRlUmVmcmVzaFJlc3BvbnNlXCIpO1xuICAgIHJlc3BvbnNlLnVzZXJTdGF0ZSA9IHN0YXRlLmRhdGE7XG4gICAgKF9hID0gcmVzcG9uc2Uuc2Vzc2lvbl9zdGF0ZSkgIT0gbnVsbCA/IF9hIDogcmVzcG9uc2Uuc2Vzc2lvbl9zdGF0ZSA9IHN0YXRlLnNlc3Npb25fc3RhdGU7XG4gICAgKF9iID0gcmVzcG9uc2Uuc2NvcGUpICE9IG51bGwgPyBfYiA6IHJlc3BvbnNlLnNjb3BlID0gc3RhdGUuc2NvcGU7XG4gICAgaWYgKHJlc3BvbnNlLmlzT3BlbklkICYmICEhcmVzcG9uc2UuaWRfdG9rZW4pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlSWRUb2tlbkF0dHJpYnV0ZXMocmVzcG9uc2UsIHN0YXRlLmlkX3Rva2VuKTtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJJRCBUb2tlbiB2YWxpZGF0ZWRcIik7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuaWRfdG9rZW4pIHtcbiAgICAgIHJlc3BvbnNlLmlkX3Rva2VuID0gc3RhdGUuaWRfdG9rZW47XG4gICAgICByZXNwb25zZS5wcm9maWxlID0gc3RhdGUucHJvZmlsZTtcbiAgICB9XG4gICAgY29uc3QgaGFzSWRUb2tlbiA9IHJlc3BvbnNlLmlzT3BlbklkICYmICEhcmVzcG9uc2UuaWRfdG9rZW47XG4gICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0NsYWltcyhyZXNwb25zZSwgZmFsc2UsIGhhc0lkVG9rZW4pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJjbGFpbXMgcHJvY2Vzc2VkXCIpO1xuICB9XG4gIHZhbGlkYXRlU2lnbm91dFJlc3BvbnNlKHJlc3BvbnNlLCBzdGF0ZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwidmFsaWRhdGVTaWdub3V0UmVzcG9uc2VcIik7XG4gICAgaWYgKHN0YXRlLmlkICE9PSByZXNwb25zZS5zdGF0ZSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJTdGF0ZSBkb2VzIG5vdCBtYXRjaFwiKSk7XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJzdGF0ZSB2YWxpZGF0ZWRcIik7XG4gICAgcmVzcG9uc2UudXNlclN0YXRlID0gc3RhdGUuZGF0YTtcbiAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjIud2FybihcIlJlc3BvbnNlIHdhcyBlcnJvclwiLCByZXNwb25zZS5lcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfVxuICB9XG4gIF9wcm9jZXNzU2lnbmluU3RhdGUocmVzcG9uc2UsIHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX3Byb2Nlc3NTaWduaW5TdGF0ZVwiKTtcbiAgICBpZiAoc3RhdGUuaWQgIT09IHJlc3BvbnNlLnN0YXRlKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIlN0YXRlIGRvZXMgbm90IG1hdGNoXCIpKTtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5jbGllbnRfaWQpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gY2xpZW50X2lkIG9uIHN0YXRlXCIpKTtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5hdXRob3JpdHkpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gYXV0aG9yaXR5IG9uIHN0YXRlXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmF1dGhvcml0eSAhPT0gc3RhdGUuYXV0aG9yaXR5KSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcImF1dGhvcml0eSBtaXNtYXRjaCBvbiBzZXR0aW5ncyB2cy4gc2lnbmluIHN0YXRlXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmNsaWVudF9pZCAmJiB0aGlzLl9zZXR0aW5ncy5jbGllbnRfaWQgIT09IHN0YXRlLmNsaWVudF9pZCkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJjbGllbnRfaWQgbWlzbWF0Y2ggb24gc2V0dGluZ3MgdnMuIHNpZ25pbiBzdGF0ZVwiKSk7XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJzdGF0ZSB2YWxpZGF0ZWRcIik7XG4gICAgcmVzcG9uc2UudXNlclN0YXRlID0gc3RhdGUuZGF0YTtcbiAgICByZXNwb25zZS51cmxfc3RhdGUgPSBzdGF0ZS51cmxfc3RhdGU7XG4gICAgKF9hID0gcmVzcG9uc2Uuc2NvcGUpICE9IG51bGwgPyBfYSA6IHJlc3BvbnNlLnNjb3BlID0gc3RhdGUuc2NvcGU7XG4gICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICBsb2dnZXIyLndhcm4oXCJSZXNwb25zZSB3YXMgZXJyb3JcIiwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29kZV92ZXJpZmllciAmJiAhcmVzcG9uc2UuY29kZSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJFeHBlY3RlZCBjb2RlIGluIHJlc3BvbnNlXCIpKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX3Byb2Nlc3NDbGFpbXMocmVzcG9uc2UsIHNraXBVc2VySW5mbyA9IGZhbHNlLCB2YWxpZGF0ZVN1YiA9IHRydWUpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9wcm9jZXNzQ2xhaW1zXCIpO1xuICAgIHJlc3BvbnNlLnByb2ZpbGUgPSB0aGlzLl9jbGFpbXNTZXJ2aWNlLmZpbHRlclByb3RvY29sQ2xhaW1zKHJlc3BvbnNlLnByb2ZpbGUpO1xuICAgIGlmIChza2lwVXNlckluZm8gfHwgIXRoaXMuX3NldHRpbmdzLmxvYWRVc2VySW5mbyB8fCAhcmVzcG9uc2UuYWNjZXNzX3Rva2VuKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwibm90IGxvYWRpbmcgdXNlciBpbmZvXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwibG9hZGluZyB1c2VyIGluZm9cIik7XG4gICAgY29uc3QgY2xhaW1zID0gYXdhaXQgdGhpcy5fdXNlckluZm9TZXJ2aWNlLmdldENsYWltcyhyZXNwb25zZS5hY2Nlc3NfdG9rZW4pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJ1c2VyIGluZm8gY2xhaW1zIHJlY2VpdmVkIGZyb20gdXNlciBpbmZvIGVuZHBvaW50XCIpO1xuICAgIGlmICh2YWxpZGF0ZVN1YiAmJiBjbGFpbXMuc3ViICE9PSByZXNwb25zZS5wcm9maWxlLnN1Yikge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJzdWJqZWN0IGZyb20gVXNlckluZm8gcmVzcG9uc2UgZG9lcyBub3QgbWF0Y2ggc3ViamVjdCBpbiBJRCBUb2tlblwiKSk7XG4gICAgfVxuICAgIHJlc3BvbnNlLnByb2ZpbGUgPSB0aGlzLl9jbGFpbXNTZXJ2aWNlLm1lcmdlQ2xhaW1zKHJlc3BvbnNlLnByb2ZpbGUsIHRoaXMuX2NsYWltc1NlcnZpY2UuZmlsdGVyUHJvdG9jb2xDbGFpbXMoY2xhaW1zKSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcInVzZXIgaW5mbyBjbGFpbXMgcmVjZWl2ZWQsIHVwZGF0ZWQgcHJvZmlsZTpcIiwgcmVzcG9uc2UucHJvZmlsZSk7XG4gIH1cbiAgYXN5bmMgX3Byb2Nlc3NDb2RlKHJlc3BvbnNlLCBzdGF0ZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX3Byb2Nlc3NDb2RlXCIpO1xuICAgIGlmIChyZXNwb25zZS5jb2RlKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiVmFsaWRhdGluZyBjb2RlXCIpO1xuICAgICAgY29uc3QgdG9rZW5SZXNwb25zZSA9IGF3YWl0IHRoaXMuX3Rva2VuQ2xpZW50LmV4Y2hhbmdlQ29kZSh7XG4gICAgICAgIGNsaWVudF9pZDogc3RhdGUuY2xpZW50X2lkLFxuICAgICAgICBjbGllbnRfc2VjcmV0OiBzdGF0ZS5jbGllbnRfc2VjcmV0LFxuICAgICAgICBjb2RlOiByZXNwb25zZS5jb2RlLFxuICAgICAgICByZWRpcmVjdF91cmk6IHN0YXRlLnJlZGlyZWN0X3VyaSxcbiAgICAgICAgY29kZV92ZXJpZmllcjogc3RhdGUuY29kZV92ZXJpZmllcixcbiAgICAgICAgLi4uc3RhdGUuZXh0cmFUb2tlblBhcmFtc1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuYXNzaWduKHJlc3BvbnNlLCB0b2tlblJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIk5vIGNvZGUgdG8gcHJvY2Vzc1wiKTtcbiAgICB9XG4gIH1cbiAgX3ZhbGlkYXRlSWRUb2tlbkF0dHJpYnV0ZXMocmVzcG9uc2UsIGV4aXN0aW5nVG9rZW4pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfdmFsaWRhdGVJZFRva2VuQXR0cmlidXRlc1wiKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZGVjb2RpbmcgSUQgVG9rZW4gSldUXCIpO1xuICAgIGNvbnN0IGluY29taW5nID0gSnd0VXRpbHMuZGVjb2RlKChfYSA9IHJlc3BvbnNlLmlkX3Rva2VuKSAhPSBudWxsID8gX2EgOiBcIlwiKTtcbiAgICBpZiAoIWluY29taW5nLnN1Yikge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJJRCBUb2tlbiBpcyBtaXNzaW5nIGEgc3ViamVjdCBjbGFpbVwiKSk7XG4gICAgfVxuICAgIGlmIChleGlzdGluZ1Rva2VuKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IEp3dFV0aWxzLmRlY29kZShleGlzdGluZ1Rva2VuKTtcbiAgICAgIGlmIChpbmNvbWluZy5zdWIgIT09IGV4aXN0aW5nLnN1Yikge1xuICAgICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcInN1YiBpbiBpZF90b2tlbiBkb2VzIG5vdCBtYXRjaCBjdXJyZW50IHN1YlwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5jb21pbmcuYXV0aF90aW1lICYmIGluY29taW5nLmF1dGhfdGltZSAhPT0gZXhpc3RpbmcuYXV0aF90aW1lKSB7XG4gICAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiYXV0aF90aW1lIGluIGlkX3Rva2VuIGRvZXMgbm90IG1hdGNoIG9yaWdpbmFsIGF1dGhfdGltZVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5jb21pbmcuYXpwICYmIGluY29taW5nLmF6cCAhPT0gZXhpc3RpbmcuYXpwKSB7XG4gICAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiYXpwIGluIGlkX3Rva2VuIGRvZXMgbm90IG1hdGNoIG9yaWdpbmFsIGF6cFwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWluY29taW5nLmF6cCAmJiBleGlzdGluZy5henApIHtcbiAgICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJhenAgbm90IGluIGlkX3Rva2VuLCBidXQgcHJlc2VudCBpbiBvcmlnaW5hbCBpZF90b2tlblwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3BvbnNlLnByb2ZpbGUgPSBpbmNvbWluZztcbiAgfVxufTtcblxuLy8gc3JjL1N0YXRlLnRzXG52YXIgU3RhdGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmlkID0gYXJncy5pZCB8fCBDcnlwdG9VdGlscy5nZW5lcmF0ZVVVSUR2NCgpO1xuICAgIHRoaXMuZGF0YSA9IGFyZ3MuZGF0YTtcbiAgICBpZiAoYXJncy5jcmVhdGVkICYmIGFyZ3MuY3JlYXRlZCA+IDApIHtcbiAgICAgIHRoaXMuY3JlYXRlZCA9IGFyZ3MuY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVkID0gVGltZXIuZ2V0RXBvY2hUaW1lKCk7XG4gICAgfVxuICAgIHRoaXMucmVxdWVzdF90eXBlID0gYXJncy5yZXF1ZXN0X3R5cGU7XG4gICAgdGhpcy51cmxfc3RhdGUgPSBhcmdzLnVybF9zdGF0ZTtcbiAgfVxuICB0b1N0b3JhZ2VTdHJpbmcoKSB7XG4gICAgbmV3IExvZ2dlcihcIlN0YXRlXCIpLmNyZWF0ZShcInRvU3RvcmFnZVN0cmluZ1wiKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICBjcmVhdGVkOiB0aGlzLmNyZWF0ZWQsXG4gICAgICByZXF1ZXN0X3R5cGU6IHRoaXMucmVxdWVzdF90eXBlLFxuICAgICAgdXJsX3N0YXRlOiB0aGlzLnVybF9zdGF0ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tU3RvcmFnZVN0cmluZyhzdG9yYWdlU3RyaW5nKSB7XG4gICAgTG9nZ2VyLmNyZWF0ZVN0YXRpYyhcIlN0YXRlXCIsIFwiZnJvbVN0b3JhZ2VTdHJpbmdcIik7XG4gICAgcmV0dXJuIG5ldyBTdGF0ZShKU09OLnBhcnNlKHN0b3JhZ2VTdHJpbmcpKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY2xlYXJTdGFsZVN0YXRlKHN0b3JhZ2UsIGFnZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSBMb2dnZXIuY3JlYXRlU3RhdGljKFwiU3RhdGVcIiwgXCJjbGVhclN0YWxlU3RhdGVcIik7XG4gICAgY29uc3QgY3V0b2ZmID0gVGltZXIuZ2V0RXBvY2hUaW1lKCkgLSBhZ2U7XG4gICAgY29uc3Qga2V5cyA9IGF3YWl0IHN0b3JhZ2UuZ2V0QWxsS2V5cygpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qga2V5c1wiLCBrZXlzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBjb25zdCBpdGVtID0gYXdhaXQgc3RvcmFnZS5nZXQoa2V5KTtcbiAgICAgIGxldCByZW1vdmUgPSBmYWxzZTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBTdGF0ZS5mcm9tU3RvcmFnZVN0cmluZyhpdGVtKTtcbiAgICAgICAgICBsb2dnZXIyLmRlYnVnKFwiZ290IGl0ZW0gZnJvbSBrZXk6XCIsIGtleSwgc3RhdGUuY3JlYXRlZCk7XG4gICAgICAgICAgaWYgKHN0YXRlLmNyZWF0ZWQgPD0gY3V0b2ZmKSB7XG4gICAgICAgICAgICByZW1vdmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyMi5lcnJvcihcIkVycm9yIHBhcnNpbmcgc3RhdGUgZm9yIGtleTpcIiwga2V5LCBlcnIpO1xuICAgICAgICAgIHJlbW92ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJubyBpdGVtIGluIHN0b3JhZ2UgZm9yIGtleTpcIiwga2V5KTtcbiAgICAgICAgcmVtb3ZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInJlbW92ZWQgaXRlbSBmb3Iga2V5OlwiLCBrZXkpO1xuICAgICAgICB2b2lkIHN0b3JhZ2UucmVtb3ZlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvU2lnbmluU3RhdGUudHNcbnZhciBTaWduaW5TdGF0ZSA9IGNsYXNzIGV4dGVuZHMgU3RhdGUge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgc3VwZXIoYXJncyk7XG4gICAgaWYgKGFyZ3MuY29kZV92ZXJpZmllciA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5jb2RlX3ZlcmlmaWVyID0gQ3J5cHRvVXRpbHMuZ2VuZXJhdGVDb2RlVmVyaWZpZXIoKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3MuY29kZV92ZXJpZmllcikge1xuICAgICAgdGhpcy5jb2RlX3ZlcmlmaWVyID0gYXJncy5jb2RlX3ZlcmlmaWVyO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb2RlX3ZlcmlmaWVyKSB7XG4gICAgICB0aGlzLmNvZGVfY2hhbGxlbmdlID0gQ3J5cHRvVXRpbHMuZ2VuZXJhdGVDb2RlQ2hhbGxlbmdlKHRoaXMuY29kZV92ZXJpZmllcik7XG4gICAgfVxuICAgIHRoaXMuYXV0aG9yaXR5ID0gYXJncy5hdXRob3JpdHk7XG4gICAgdGhpcy5jbGllbnRfaWQgPSBhcmdzLmNsaWVudF9pZDtcbiAgICB0aGlzLnJlZGlyZWN0X3VyaSA9IGFyZ3MucmVkaXJlY3RfdXJpO1xuICAgIHRoaXMuc2NvcGUgPSBhcmdzLnNjb3BlO1xuICAgIHRoaXMuY2xpZW50X3NlY3JldCA9IGFyZ3MuY2xpZW50X3NlY3JldDtcbiAgICB0aGlzLmV4dHJhVG9rZW5QYXJhbXMgPSBhcmdzLmV4dHJhVG9rZW5QYXJhbXM7XG4gICAgdGhpcy5yZXNwb25zZV9tb2RlID0gYXJncy5yZXNwb25zZV9tb2RlO1xuICAgIHRoaXMuc2tpcFVzZXJJbmZvID0gYXJncy5za2lwVXNlckluZm87XG4gIH1cbiAgdG9TdG9yYWdlU3RyaW5nKCkge1xuICAgIG5ldyBMb2dnZXIoXCJTaWduaW5TdGF0ZVwiKS5jcmVhdGUoXCJ0b1N0b3JhZ2VTdHJpbmdcIik7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgY3JlYXRlZDogdGhpcy5jcmVhdGVkLFxuICAgICAgcmVxdWVzdF90eXBlOiB0aGlzLnJlcXVlc3RfdHlwZSxcbiAgICAgIHVybF9zdGF0ZTogdGhpcy51cmxfc3RhdGUsXG4gICAgICBjb2RlX3ZlcmlmaWVyOiB0aGlzLmNvZGVfdmVyaWZpZXIsXG4gICAgICBhdXRob3JpdHk6IHRoaXMuYXV0aG9yaXR5LFxuICAgICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudF9pZCxcbiAgICAgIHJlZGlyZWN0X3VyaTogdGhpcy5yZWRpcmVjdF91cmksXG4gICAgICBzY29wZTogdGhpcy5zY29wZSxcbiAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuY2xpZW50X3NlY3JldCxcbiAgICAgIGV4dHJhVG9rZW5QYXJhbXM6IHRoaXMuZXh0cmFUb2tlblBhcmFtcyxcbiAgICAgIHJlc3BvbnNlX21vZGU6IHRoaXMucmVzcG9uc2VfbW9kZSxcbiAgICAgIHNraXBVc2VySW5mbzogdGhpcy5za2lwVXNlckluZm9cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZnJvbVN0b3JhZ2VTdHJpbmcoc3RvcmFnZVN0cmluZykge1xuICAgIExvZ2dlci5jcmVhdGVTdGF0aWMoXCJTaWduaW5TdGF0ZVwiLCBcImZyb21TdG9yYWdlU3RyaW5nXCIpO1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHN0b3JhZ2VTdHJpbmcpO1xuICAgIHJldHVybiBuZXcgU2lnbmluU3RhdGUoZGF0YSk7XG4gIH1cbn07XG5cbi8vIHNyYy9TaWduaW5SZXF1ZXN0LnRzXG52YXIgU2lnbmluUmVxdWVzdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIG1hbmRhdG9yeVxuICAgIHVybCxcbiAgICBhdXRob3JpdHksXG4gICAgY2xpZW50X2lkLFxuICAgIHJlZGlyZWN0X3VyaSxcbiAgICByZXNwb25zZV90eXBlLFxuICAgIHNjb3BlLFxuICAgIC8vIG9wdGlvbmFsXG4gICAgc3RhdGVfZGF0YSxcbiAgICByZXNwb25zZV9tb2RlLFxuICAgIHJlcXVlc3RfdHlwZSxcbiAgICBjbGllbnRfc2VjcmV0LFxuICAgIG5vbmNlLFxuICAgIHVybF9zdGF0ZSxcbiAgICByZXNvdXJjZSxcbiAgICBza2lwVXNlckluZm8sXG4gICAgZXh0cmFRdWVyeVBhcmFtcyxcbiAgICBleHRyYVRva2VuUGFyYW1zLFxuICAgIGRpc2FibGVQS0NFLFxuICAgIC4uLm9wdGlvbmFsUGFyYW1zXG4gIH0pIHtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiU2lnbmluUmVxdWVzdFwiKTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKFwiY3RvcjogTm8gdXJsIHBhc3NlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVybFwiKTtcbiAgICB9XG4gICAgaWYgKCFjbGllbnRfaWQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImN0b3I6IE5vIGNsaWVudF9pZCBwYXNzZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjbGllbnRfaWRcIik7XG4gICAgfVxuICAgIGlmICghcmVkaXJlY3RfdXJpKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoXCJjdG9yOiBObyByZWRpcmVjdF91cmkgcGFzc2VkXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVkaXJlY3RfdXJpXCIpO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlX3R5cGUpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImN0b3I6IE5vIHJlc3BvbnNlX3R5cGUgcGFzc2VkXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzcG9uc2VfdHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKCFzY29wZSkge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKFwiY3RvcjogTm8gc2NvcGUgcGFzc2VkXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NvcGVcIik7XG4gICAgfVxuICAgIGlmICghYXV0aG9yaXR5KSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoXCJjdG9yOiBObyBhdXRob3JpdHkgcGFzc2VkXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXV0aG9yaXR5XCIpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gbmV3IFNpZ25pblN0YXRlKHtcbiAgICAgIGRhdGE6IHN0YXRlX2RhdGEsXG4gICAgICByZXF1ZXN0X3R5cGUsXG4gICAgICB1cmxfc3RhdGUsXG4gICAgICBjb2RlX3ZlcmlmaWVyOiAhZGlzYWJsZVBLQ0UsXG4gICAgICBjbGllbnRfaWQsXG4gICAgICBhdXRob3JpdHksXG4gICAgICByZWRpcmVjdF91cmksXG4gICAgICByZXNwb25zZV9tb2RlLFxuICAgICAgY2xpZW50X3NlY3JldCxcbiAgICAgIHNjb3BlLFxuICAgICAgZXh0cmFUb2tlblBhcmFtcyxcbiAgICAgIHNraXBVc2VySW5mb1xuICAgIH0pO1xuICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImNsaWVudF9pZFwiLCBjbGllbnRfaWQpO1xuICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwicmVkaXJlY3RfdXJpXCIsIHJlZGlyZWN0X3VyaSk7XG4gICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJyZXNwb25zZV90eXBlXCIsIHJlc3BvbnNlX3R5cGUpO1xuICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwic2NvcGVcIiwgc2NvcGUpO1xuICAgIGlmIChub25jZSkge1xuICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJub25jZVwiLCBub25jZSk7XG4gICAgfVxuICAgIGxldCBzdGF0ZSA9IHRoaXMuc3RhdGUuaWQ7XG4gICAgaWYgKHVybF9zdGF0ZSkge1xuICAgICAgc3RhdGUgPSBgJHtzdGF0ZX0ke1VSTF9TVEFURV9ERUxJTUlURVJ9JHt1cmxfc3RhdGV9YDtcbiAgICB9XG4gICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJzdGF0ZVwiLCBzdGF0ZSk7XG4gICAgaWYgKHRoaXMuc3RhdGUuY29kZV9jaGFsbGVuZ2UpIHtcbiAgICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiY29kZV9jaGFsbGVuZ2VcIiwgdGhpcy5zdGF0ZS5jb2RlX2NoYWxsZW5nZSk7XG4gICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImNvZGVfY2hhbGxlbmdlX21ldGhvZFwiLCBcIlMyNTZcIik7XG4gICAgfVxuICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgY29uc3QgcmVzb3VyY2VzID0gQXJyYXkuaXNBcnJheShyZXNvdXJjZSkgPyByZXNvdXJjZSA6IFtyZXNvdXJjZV07XG4gICAgICByZXNvdXJjZXMuZm9yRWFjaCgocikgPT4gcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJyZXNvdXJjZVwiLCByKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHsgcmVzcG9uc2VfbW9kZSwgLi4ub3B0aW9uYWxQYXJhbXMsIC4uLmV4dHJhUXVlcnlQYXJhbXMgfSkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXJsID0gcGFyc2VkVXJsLmhyZWY7XG4gIH1cbn07XG5cbi8vIHNyYy9TaWduaW5SZXNwb25zZS50c1xudmFyIE9pZGNTY29wZSA9IFwib3BlbmlkXCI7XG52YXIgU2lnbmluUmVzcG9uc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIC8qKiBAc2VlIHtAbGluayBVc2VyLmFjY2Vzc190b2tlbn0gKi9cbiAgICB0aGlzLmFjY2Vzc190b2tlbiA9IFwiXCI7XG4gICAgLyoqIEBzZWUge0BsaW5rIFVzZXIudG9rZW5fdHlwZX0gKi9cbiAgICB0aGlzLnRva2VuX3R5cGUgPSBcIlwiO1xuICAgIC8qKiBAc2VlIHtAbGluayBVc2VyLnByb2ZpbGV9ICovXG4gICAgdGhpcy5wcm9maWxlID0ge307XG4gICAgdGhpcy5zdGF0ZSA9IHBhcmFtcy5nZXQoXCJzdGF0ZVwiKTtcbiAgICB0aGlzLnNlc3Npb25fc3RhdGUgPSBwYXJhbXMuZ2V0KFwic2Vzc2lvbl9zdGF0ZVwiKTtcbiAgICBpZiAodGhpcy5zdGF0ZSkge1xuICAgICAgY29uc3Qgc3BsaXRTdGF0ZSA9IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLnN0YXRlKS5zcGxpdChVUkxfU1RBVEVfREVMSU1JVEVSKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBzcGxpdFN0YXRlWzBdO1xuICAgICAgaWYgKHNwbGl0U3RhdGUubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnVybF9zdGF0ZSA9IHNwbGl0U3RhdGUuc2xpY2UoMSkuam9pbihVUkxfU1RBVEVfREVMSU1JVEVSKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lcnJvciA9IHBhcmFtcy5nZXQoXCJlcnJvclwiKTtcbiAgICB0aGlzLmVycm9yX2Rlc2NyaXB0aW9uID0gcGFyYW1zLmdldChcImVycm9yX2Rlc2NyaXB0aW9uXCIpO1xuICAgIHRoaXMuZXJyb3JfdXJpID0gcGFyYW1zLmdldChcImVycm9yX3VyaVwiKTtcbiAgICB0aGlzLmNvZGUgPSBwYXJhbXMuZ2V0KFwiY29kZVwiKTtcbiAgfVxuICBnZXQgZXhwaXJlc19pbigpIHtcbiAgICBpZiAodGhpcy5leHBpcmVzX2F0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4cGlyZXNfYXQgLSBUaW1lci5nZXRFcG9jaFRpbWUoKTtcbiAgfVxuICBzZXQgZXhwaXJlc19pbih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICB2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgPj0gMCkge1xuICAgICAgdGhpcy5leHBpcmVzX2F0ID0gTWF0aC5mbG9vcih2YWx1ZSkgKyBUaW1lci5nZXRFcG9jaFRpbWUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzT3BlbklkKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHRoaXMuc2NvcGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zcGxpdChcIiBcIikuaW5jbHVkZXMoT2lkY1Njb3BlKSkgfHwgISF0aGlzLmlkX3Rva2VuO1xuICB9XG59O1xuXG4vLyBzcmMvU2lnbm91dFJlcXVlc3QudHNcbnZhciBTaWdub3V0UmVxdWVzdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCxcbiAgICBzdGF0ZV9kYXRhLFxuICAgIGlkX3Rva2VuX2hpbnQsXG4gICAgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpLFxuICAgIGV4dHJhUXVlcnlQYXJhbXMsXG4gICAgcmVxdWVzdF90eXBlLFxuICAgIGNsaWVudF9pZFxuICB9KSB7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlNpZ25vdXRSZXF1ZXN0XCIpO1xuICAgIGlmICghdXJsKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoXCJjdG9yOiBObyB1cmwgcGFzc2VkXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXJsXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgaWYgKGlkX3Rva2VuX2hpbnQpIHtcbiAgICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiaWRfdG9rZW5faGludFwiLCBpZF90b2tlbl9oaW50KTtcbiAgICB9XG4gICAgaWYgKGNsaWVudF9pZCkge1xuICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJjbGllbnRfaWRcIiwgY2xpZW50X2lkKTtcbiAgICB9XG4gICAgaWYgKHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSkge1xuICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJwb3N0X2xvZ291dF9yZWRpcmVjdF91cmlcIiwgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpKTtcbiAgICAgIGlmIChzdGF0ZV9kYXRhKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGUoeyBkYXRhOiBzdGF0ZV9kYXRhLCByZXF1ZXN0X3R5cGUgfSk7XG4gICAgICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwic3RhdGVcIiwgdGhpcy5zdGF0ZS5pZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHsgLi4uZXh0cmFRdWVyeVBhcmFtcyB9KSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51cmwgPSBwYXJzZWRVcmwuaHJlZjtcbiAgfVxufTtcblxuLy8gc3JjL1NpZ25vdXRSZXNwb25zZS50c1xudmFyIFNpZ25vdXRSZXNwb25zZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHBhcmFtcy5nZXQoXCJzdGF0ZVwiKTtcbiAgICB0aGlzLmVycm9yID0gcGFyYW1zLmdldChcImVycm9yXCIpO1xuICAgIHRoaXMuZXJyb3JfZGVzY3JpcHRpb24gPSBwYXJhbXMuZ2V0KFwiZXJyb3JfZGVzY3JpcHRpb25cIik7XG4gICAgdGhpcy5lcnJvcl91cmkgPSBwYXJhbXMuZ2V0KFwiZXJyb3JfdXJpXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvQ2xhaW1zU2VydmljZS50c1xudmFyIERlZmF1bHRQcm90b2NvbENsYWltcyA9IFtcbiAgXCJuYmZcIixcbiAgXCJqdGlcIixcbiAgXCJhdXRoX3RpbWVcIixcbiAgXCJub25jZVwiLFxuICBcImFjclwiLFxuICBcImFtclwiLFxuICBcImF6cFwiLFxuICBcImF0X2hhc2hcIlxuICAvLyBodHRwczovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3QtY29yZS0xXzAuaHRtbCNDb2RlSURUb2tlblxuXTtcbnZhciBJbnRlcm5hbFJlcXVpcmVkUHJvdG9jb2xDbGFpbXMgPSBbXCJzdWJcIiwgXCJpc3NcIiwgXCJhdWRcIiwgXCJleHBcIiwgXCJpYXRcIl07XG52YXIgQ2xhaW1zU2VydmljZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3NldHRpbmdzKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfc2V0dGluZ3M7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIkNsYWltc1NlcnZpY2VcIik7XG4gIH1cbiAgZmlsdGVyUHJvdG9jb2xDbGFpbXMoY2xhaW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyAuLi5jbGFpbXMgfTtcbiAgICBpZiAodGhpcy5fc2V0dGluZ3MuZmlsdGVyUHJvdG9jb2xDbGFpbXMpIHtcbiAgICAgIGxldCBwcm90b2NvbENsYWltcztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX3NldHRpbmdzLmZpbHRlclByb3RvY29sQ2xhaW1zKSkge1xuICAgICAgICBwcm90b2NvbENsYWltcyA9IHRoaXMuX3NldHRpbmdzLmZpbHRlclByb3RvY29sQ2xhaW1zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdG9jb2xDbGFpbXMgPSBEZWZhdWx0UHJvdG9jb2xDbGFpbXM7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNsYWltIG9mIHByb3RvY29sQ2xhaW1zKSB7XG4gICAgICAgIGlmICghSW50ZXJuYWxSZXF1aXJlZFByb3RvY29sQ2xhaW1zLmluY2x1ZGVzKGNsYWltKSkge1xuICAgICAgICAgIGRlbGV0ZSByZXN1bHRbY2xhaW1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbWVyZ2VDbGFpbXMoY2xhaW1zMSwgY2xhaW1zMikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHsgLi4uY2xhaW1zMSB9O1xuICAgIGZvciAoY29uc3QgW2NsYWltLCB2YWx1ZXNdIG9mIE9iamVjdC5lbnRyaWVzKGNsYWltczIpKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFt2YWx1ZXNdKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSByZXN1bHRbY2xhaW1dO1xuICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmVzdWx0W2NsYWltXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgICAgICBpZiAoIXByZXZpb3VzVmFsdWUuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHRbY2xhaW1dICE9PSB2YWx1ZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdGhpcy5fc2V0dGluZ3MubWVyZ2VDbGFpbXMpIHtcbiAgICAgICAgICAgIHJlc3VsdFtjbGFpbV0gPSB0aGlzLm1lcmdlQ2xhaW1zKHByZXZpb3VzVmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2NsYWltXSA9IFtwcmV2aW91c1ZhbHVlLCB2YWx1ZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIHNyYy9PaWRjQ2xpZW50LnRzXG52YXIgT2lkY0NsaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MsIG1ldGFkYXRhU2VydmljZSkge1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJPaWRjQ2xpZW50XCIpO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncyBpbnN0YW5jZW9mIE9pZGNDbGllbnRTZXR0aW5nc1N0b3JlID8gc2V0dGluZ3MgOiBuZXcgT2lkY0NsaWVudFNldHRpbmdzU3RvcmUoc2V0dGluZ3MpO1xuICAgIHRoaXMubWV0YWRhdGFTZXJ2aWNlID0gbWV0YWRhdGFTZXJ2aWNlICE9IG51bGwgPyBtZXRhZGF0YVNlcnZpY2UgOiBuZXcgTWV0YWRhdGFTZXJ2aWNlKHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuX2NsYWltc1NlcnZpY2UgPSBuZXcgQ2xhaW1zU2VydmljZSh0aGlzLnNldHRpbmdzKTtcbiAgICB0aGlzLl92YWxpZGF0b3IgPSBuZXcgUmVzcG9uc2VWYWxpZGF0b3IodGhpcy5zZXR0aW5ncywgdGhpcy5tZXRhZGF0YVNlcnZpY2UsIHRoaXMuX2NsYWltc1NlcnZpY2UpO1xuICAgIHRoaXMuX3Rva2VuQ2xpZW50ID0gbmV3IFRva2VuQ2xpZW50KHRoaXMuc2V0dGluZ3MsIHRoaXMubWV0YWRhdGFTZXJ2aWNlKTtcbiAgfVxuICBhc3luYyBjcmVhdGVTaWduaW5SZXF1ZXN0KHtcbiAgICBzdGF0ZSxcbiAgICByZXF1ZXN0LFxuICAgIHJlcXVlc3RfdXJpLFxuICAgIHJlcXVlc3RfdHlwZSxcbiAgICBpZF90b2tlbl9oaW50LFxuICAgIGxvZ2luX2hpbnQsXG4gICAgc2tpcFVzZXJJbmZvLFxuICAgIG5vbmNlLFxuICAgIHVybF9zdGF0ZSxcbiAgICByZXNwb25zZV90eXBlID0gdGhpcy5zZXR0aW5ncy5yZXNwb25zZV90eXBlLFxuICAgIHNjb3BlID0gdGhpcy5zZXR0aW5ncy5zY29wZSxcbiAgICByZWRpcmVjdF91cmkgPSB0aGlzLnNldHRpbmdzLnJlZGlyZWN0X3VyaSxcbiAgICBwcm9tcHQgPSB0aGlzLnNldHRpbmdzLnByb21wdCxcbiAgICBkaXNwbGF5ID0gdGhpcy5zZXR0aW5ncy5kaXNwbGF5LFxuICAgIG1heF9hZ2UgPSB0aGlzLnNldHRpbmdzLm1heF9hZ2UsXG4gICAgdWlfbG9jYWxlcyA9IHRoaXMuc2V0dGluZ3MudWlfbG9jYWxlcyxcbiAgICBhY3JfdmFsdWVzID0gdGhpcy5zZXR0aW5ncy5hY3JfdmFsdWVzLFxuICAgIHJlc291cmNlID0gdGhpcy5zZXR0aW5ncy5yZXNvdXJjZSxcbiAgICByZXNwb25zZV9tb2RlID0gdGhpcy5zZXR0aW5ncy5yZXNwb25zZV9tb2RlLFxuICAgIGV4dHJhUXVlcnlQYXJhbXMgPSB0aGlzLnNldHRpbmdzLmV4dHJhUXVlcnlQYXJhbXMsXG4gICAgZXh0cmFUb2tlblBhcmFtcyA9IHRoaXMuc2V0dGluZ3MuZXh0cmFUb2tlblBhcmFtc1xuICB9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjcmVhdGVTaWduaW5SZXF1ZXN0XCIpO1xuICAgIGlmIChyZXNwb25zZV90eXBlICE9PSBcImNvZGVcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSB0aGUgQXV0aG9yaXphdGlvbiBDb2RlIGZsb3cgKHdpdGggUEtDRSkgaXMgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLm1ldGFkYXRhU2VydmljZS5nZXRBdXRob3JpemF0aW9uRW5kcG9pbnQoKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiUmVjZWl2ZWQgYXV0aG9yaXphdGlvbiBlbmRwb2ludFwiLCB1cmwpO1xuICAgIGNvbnN0IHNpZ25pblJlcXVlc3QgPSBuZXcgU2lnbmluUmVxdWVzdCh7XG4gICAgICB1cmwsXG4gICAgICBhdXRob3JpdHk6IHRoaXMuc2V0dGluZ3MuYXV0aG9yaXR5LFxuICAgICAgY2xpZW50X2lkOiB0aGlzLnNldHRpbmdzLmNsaWVudF9pZCxcbiAgICAgIHJlZGlyZWN0X3VyaSxcbiAgICAgIHJlc3BvbnNlX3R5cGUsXG4gICAgICBzY29wZSxcbiAgICAgIHN0YXRlX2RhdGE6IHN0YXRlLFxuICAgICAgdXJsX3N0YXRlLFxuICAgICAgcHJvbXB0LFxuICAgICAgZGlzcGxheSxcbiAgICAgIG1heF9hZ2UsXG4gICAgICB1aV9sb2NhbGVzLFxuICAgICAgaWRfdG9rZW5faGludCxcbiAgICAgIGxvZ2luX2hpbnQsXG4gICAgICBhY3JfdmFsdWVzLFxuICAgICAgcmVzb3VyY2UsXG4gICAgICByZXF1ZXN0LFxuICAgICAgcmVxdWVzdF91cmksXG4gICAgICBleHRyYVF1ZXJ5UGFyYW1zLFxuICAgICAgZXh0cmFUb2tlblBhcmFtcyxcbiAgICAgIHJlcXVlc3RfdHlwZSxcbiAgICAgIHJlc3BvbnNlX21vZGUsXG4gICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLnNldHRpbmdzLmNsaWVudF9zZWNyZXQsXG4gICAgICBza2lwVXNlckluZm8sXG4gICAgICBub25jZSxcbiAgICAgIGRpc2FibGVQS0NFOiB0aGlzLnNldHRpbmdzLmRpc2FibGVQS0NFXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5jbGVhclN0YWxlU3RhdGUoKTtcbiAgICBjb25zdCBzaWduaW5TdGF0ZSA9IHNpZ25pblJlcXVlc3Quc3RhdGU7XG4gICAgYXdhaXQgdGhpcy5zZXR0aW5ncy5zdGF0ZVN0b3JlLnNldChzaWduaW5TdGF0ZS5pZCwgc2lnbmluU3RhdGUudG9TdG9yYWdlU3RyaW5nKCkpO1xuICAgIHJldHVybiBzaWduaW5SZXF1ZXN0O1xuICB9XG4gIGFzeW5jIHJlYWRTaWduaW5SZXNwb25zZVN0YXRlKHVybCwgcmVtb3ZlU3RhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwicmVhZFNpZ25pblJlc3BvbnNlU3RhdGVcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgU2lnbmluUmVzcG9uc2UoVXJsVXRpbHMucmVhZFBhcmFtcyh1cmwsIHRoaXMuc2V0dGluZ3MucmVzcG9uc2VfbW9kZSkpO1xuICAgIGlmICghcmVzcG9uc2Uuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gc3RhdGUgaW4gcmVzcG9uc2VcIikpO1xuICAgICAgdGhyb3cgbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkU3RhdGVTdHJpbmcgPSBhd2FpdCB0aGlzLnNldHRpbmdzLnN0YXRlU3RvcmVbcmVtb3ZlU3RhdGUgPyBcInJlbW92ZVwiIDogXCJnZXRcIl0ocmVzcG9uc2Uuc3RhdGUpO1xuICAgIGlmICghc3RvcmVkU3RhdGVTdHJpbmcpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gbWF0Y2hpbmcgc3RhdGUgZm91bmQgaW4gc3RvcmFnZVwiKSk7XG4gICAgICB0aHJvdyBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IFNpZ25pblN0YXRlLmZyb21TdG9yYWdlU3RyaW5nKHN0b3JlZFN0YXRlU3RyaW5nKTtcbiAgICByZXR1cm4geyBzdGF0ZSwgcmVzcG9uc2UgfTtcbiAgfVxuICBhc3luYyBwcm9jZXNzU2lnbmluUmVzcG9uc2UodXJsKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJwcm9jZXNzU2lnbmluUmVzcG9uc2VcIik7XG4gICAgY29uc3QgeyBzdGF0ZSwgcmVzcG9uc2UgfSA9IGF3YWl0IHRoaXMucmVhZFNpZ25pblJlc3BvbnNlU3RhdGUodXJsLCB0cnVlKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwicmVjZWl2ZWQgc3RhdGUgZnJvbSBzdG9yYWdlOyB2YWxpZGF0aW5nIHJlc3BvbnNlXCIpO1xuICAgIGF3YWl0IHRoaXMuX3ZhbGlkYXRvci52YWxpZGF0ZVNpZ25pblJlc3BvbnNlKHJlc3BvbnNlLCBzdGF0ZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NSZXNvdXJjZU93bmVyUGFzc3dvcmRDcmVkZW50aWFscyh7XG4gICAgdXNlcm5hbWUsXG4gICAgcGFzc3dvcmQsXG4gICAgc2tpcFVzZXJJbmZvID0gZmFsc2UsXG4gICAgZXh0cmFUb2tlblBhcmFtcyA9IHt9XG4gIH0pIHtcbiAgICBjb25zdCB0b2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5fdG9rZW5DbGllbnQuZXhjaGFuZ2VDcmVkZW50aWFscyh7IHVzZXJuYW1lLCBwYXNzd29yZCwgLi4uZXh0cmFUb2tlblBhcmFtcyB9KTtcbiAgICBjb25zdCBzaWduaW5SZXNwb25zZSA9IG5ldyBTaWduaW5SZXNwb25zZShuZXcgVVJMU2VhcmNoUGFyYW1zKCkpO1xuICAgIE9iamVjdC5hc3NpZ24oc2lnbmluUmVzcG9uc2UsIHRva2VuUmVzcG9uc2UpO1xuICAgIGF3YWl0IHRoaXMuX3ZhbGlkYXRvci52YWxpZGF0ZUNyZWRlbnRpYWxzUmVzcG9uc2Uoc2lnbmluUmVzcG9uc2UsIHNraXBVc2VySW5mbyk7XG4gICAgcmV0dXJuIHNpZ25pblJlc3BvbnNlO1xuICB9XG4gIGFzeW5jIHVzZVJlZnJlc2hUb2tlbih7XG4gICAgc3RhdGUsXG4gICAgdGltZW91dEluU2Vjb25kc1xuICB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwidXNlUmVmcmVzaFRva2VuXCIpO1xuICAgIGxldCBzY29wZTtcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5yZWZyZXNoVG9rZW5BbGxvd2VkU2NvcGUgPT09IHZvaWQgMCkge1xuICAgICAgc2NvcGUgPSBzdGF0ZS5zY29wZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWxsb3dhYmxlU2NvcGVzID0gdGhpcy5zZXR0aW5ncy5yZWZyZXNoVG9rZW5BbGxvd2VkU2NvcGUuc3BsaXQoXCIgXCIpO1xuICAgICAgY29uc3QgcHJvdmlkZWRTY29wZXMgPSAoKF9hID0gc3RhdGUuc2NvcGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zcGxpdChcIiBcIikpIHx8IFtdO1xuICAgICAgc2NvcGUgPSBwcm92aWRlZFNjb3Blcy5maWx0ZXIoKHMpID0+IGFsbG93YWJsZVNjb3Blcy5pbmNsdWRlcyhzKSkuam9pbihcIiBcIik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3Rva2VuQ2xpZW50LmV4Y2hhbmdlUmVmcmVzaFRva2VuKHtcbiAgICAgIHJlZnJlc2hfdG9rZW46IHN0YXRlLnJlZnJlc2hfdG9rZW4sXG4gICAgICByZXNvdXJjZTogc3RhdGUucmVzb3VyY2UsXG4gICAgICAvLyBwcm92aWRlIHRoZSAocG9zc2libGUgZmlsdGVyZWQpIHNjb3BlIGxpc3RcbiAgICAgIHNjb3BlLFxuICAgICAgdGltZW91dEluU2Vjb25kc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IFNpZ25pblJlc3BvbnNlKG5ldyBVUkxTZWFyY2hQYXJhbXMoKSk7XG4gICAgT2JqZWN0LmFzc2lnbihyZXNwb25zZSwgcmVzdWx0KTtcbiAgICBsb2dnZXIyLmRlYnVnKFwidmFsaWRhdGluZyByZXNwb25zZVwiLCByZXNwb25zZSk7XG4gICAgYXdhaXQgdGhpcy5fdmFsaWRhdG9yLnZhbGlkYXRlUmVmcmVzaFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC8vIG92ZXJpZGUgdGhlIHNjb3BlIGluIHRoZSBzdGF0ZSBoYW5kZWQgb3ZlciB0byB0aGUgdmFsaWRhdG9yXG4gICAgICAvLyBzbyBpdCBjYW4gc2V0IHRoZSBncmFudGVkIHNjb3BlIHRvIHRoZSByZXF1ZXN0ZWQgc2NvcGUgaW4gY2FzZSBub25lIGlzIGluY2x1ZGVkIGluIHRoZSByZXNwb25zZVxuICAgICAgc2NvcGVcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgYXN5bmMgY3JlYXRlU2lnbm91dFJlcXVlc3Qoe1xuICAgIHN0YXRlLFxuICAgIGlkX3Rva2VuX2hpbnQsXG4gICAgY2xpZW50X2lkLFxuICAgIHJlcXVlc3RfdHlwZSxcbiAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmkgPSB0aGlzLnNldHRpbmdzLnBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICBleHRyYVF1ZXJ5UGFyYW1zID0gdGhpcy5zZXR0aW5ncy5leHRyYVF1ZXJ5UGFyYW1zXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiY3JlYXRlU2lnbm91dFJlcXVlc3RcIik7XG4gICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5tZXRhZGF0YVNlcnZpY2UuZ2V0RW5kU2Vzc2lvbkVuZHBvaW50KCk7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gZW5kIHNlc3Npb24gZW5kcG9pbnRcIikpO1xuICAgICAgdGhyb3cgbnVsbDtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcIlJlY2VpdmVkIGVuZCBzZXNzaW9uIGVuZHBvaW50XCIsIHVybCk7XG4gICAgaWYgKCFjbGllbnRfaWQgJiYgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpICYmICFpZF90b2tlbl9oaW50KSB7XG4gICAgICBjbGllbnRfaWQgPSB0aGlzLnNldHRpbmdzLmNsaWVudF9pZDtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBTaWdub3V0UmVxdWVzdCh7XG4gICAgICB1cmwsXG4gICAgICBpZF90b2tlbl9oaW50LFxuICAgICAgY2xpZW50X2lkLFxuICAgICAgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpLFxuICAgICAgc3RhdGVfZGF0YTogc3RhdGUsXG4gICAgICBleHRyYVF1ZXJ5UGFyYW1zLFxuICAgICAgcmVxdWVzdF90eXBlXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5jbGVhclN0YWxlU3RhdGUoKTtcbiAgICBjb25zdCBzaWdub3V0U3RhdGUgPSByZXF1ZXN0LnN0YXRlO1xuICAgIGlmIChzaWdub3V0U3RhdGUpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJTaWdub3V0IHJlcXVlc3QgaGFzIHN0YXRlIHRvIHBlcnNpc3RcIik7XG4gICAgICBhd2FpdCB0aGlzLnNldHRpbmdzLnN0YXRlU3RvcmUuc2V0KHNpZ25vdXRTdGF0ZS5pZCwgc2lnbm91dFN0YXRlLnRvU3RvcmFnZVN0cmluZygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbiAgYXN5bmMgcmVhZFNpZ25vdXRSZXNwb25zZVN0YXRlKHVybCwgcmVtb3ZlU3RhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwicmVhZFNpZ25vdXRSZXNwb25zZVN0YXRlXCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IFNpZ25vdXRSZXNwb25zZShVcmxVdGlscy5yZWFkUGFyYW1zKHVybCwgdGhpcy5zZXR0aW5ncy5yZXNwb25zZV9tb2RlKSk7XG4gICAgaWYgKCFyZXNwb25zZS5zdGF0ZSkge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIk5vIHN0YXRlIGluIHJlc3BvbnNlXCIpO1xuICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgIGxvZ2dlcjIud2FybihcIlJlc3BvbnNlIHdhcyBlcnJvcjpcIiwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0ZTogdm9pZCAwLCByZXNwb25zZSB9O1xuICAgIH1cbiAgICBjb25zdCBzdG9yZWRTdGF0ZVN0cmluZyA9IGF3YWl0IHRoaXMuc2V0dGluZ3Muc3RhdGVTdG9yZVtyZW1vdmVTdGF0ZSA/IFwicmVtb3ZlXCIgOiBcImdldFwiXShyZXNwb25zZS5zdGF0ZSk7XG4gICAgaWYgKCFzdG9yZWRTdGF0ZVN0cmluZykge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJObyBtYXRjaGluZyBzdGF0ZSBmb3VuZCBpbiBzdG9yYWdlXCIpKTtcbiAgICAgIHRocm93IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gU3RhdGUuZnJvbVN0b3JhZ2VTdHJpbmcoc3RvcmVkU3RhdGVTdHJpbmcpO1xuICAgIHJldHVybiB7IHN0YXRlLCByZXNwb25zZSB9O1xuICB9XG4gIGFzeW5jIHByb2Nlc3NTaWdub3V0UmVzcG9uc2UodXJsKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJwcm9jZXNzU2lnbm91dFJlc3BvbnNlXCIpO1xuICAgIGNvbnN0IHsgc3RhdGUsIHJlc3BvbnNlIH0gPSBhd2FpdCB0aGlzLnJlYWRTaWdub3V0UmVzcG9uc2VTdGF0ZSh1cmwsIHRydWUpO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIlJlY2VpdmVkIHN0YXRlIGZyb20gc3RvcmFnZTsgdmFsaWRhdGluZyByZXNwb25zZVwiKTtcbiAgICAgIHRoaXMuX3ZhbGlkYXRvci52YWxpZGF0ZVNpZ25vdXRSZXNwb25zZShyZXNwb25zZSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiTm8gc3RhdGUgZnJvbSBzdG9yYWdlOyBza2lwcGluZyByZXNwb25zZSB2YWxpZGF0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgY2xlYXJTdGFsZVN0YXRlKCkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjbGVhclN0YWxlU3RhdGVcIik7XG4gICAgcmV0dXJuIFN0YXRlLmNsZWFyU3RhbGVTdGF0ZSh0aGlzLnNldHRpbmdzLnN0YXRlU3RvcmUsIHRoaXMuc2V0dGluZ3Muc3RhbGVTdGF0ZUFnZUluU2Vjb25kcyk7XG4gIH1cbiAgYXN5bmMgcmV2b2tlVG9rZW4odG9rZW4sIHR5cGUpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwicmV2b2tlVG9rZW5cIik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3Rva2VuQ2xpZW50LnJldm9rZSh7XG4gICAgICB0b2tlbixcbiAgICAgIHRva2VuX3R5cGVfaGludDogdHlwZVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvU2Vzc2lvbk1vbml0b3IudHNcbnZhciBTZXNzaW9uTW9uaXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3VzZXJNYW5hZ2VyKSB7XG4gICAgdGhpcy5fdXNlck1hbmFnZXIgPSBfdXNlck1hbmFnZXI7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlNlc3Npb25Nb25pdG9yXCIpO1xuICAgIHRoaXMuX3N0YXJ0ID0gYXN5bmMgKHVzZXIpID0+IHtcbiAgICAgIGNvbnN0IHNlc3Npb25fc3RhdGUgPSB1c2VyLnNlc3Npb25fc3RhdGU7XG4gICAgICBpZiAoIXNlc3Npb25fc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfc3RhcnRcIik7XG4gICAgICBpZiAodXNlci5wcm9maWxlKSB7XG4gICAgICAgIHRoaXMuX3N1YiA9IHVzZXIucHJvZmlsZS5zdWI7XG4gICAgICAgIHRoaXMuX3NpZCA9IHVzZXIucHJvZmlsZS5zaWQ7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJzZXNzaW9uX3N0YXRlXCIsIHNlc3Npb25fc3RhdGUsIFwiLCBzdWJcIiwgdGhpcy5fc3ViKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N1YiA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5fc2lkID0gdm9pZCAwO1xuICAgICAgICBsb2dnZXIyLmRlYnVnKFwic2Vzc2lvbl9zdGF0ZVwiLCBzZXNzaW9uX3N0YXRlLCBcIiwgYW5vbnltb3VzIHVzZXJcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrU2Vzc2lvbklGcmFtZS5zdGFydChzZXNzaW9uX3N0YXRlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fdXNlck1hbmFnZXIubWV0YWRhdGFTZXJ2aWNlLmdldENoZWNrU2Vzc2lvbklmcmFtZSgpO1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImluaXRpYWxpemluZyBjaGVjayBzZXNzaW9uIGlmcmFtZVwiKTtcbiAgICAgICAgICBjb25zdCBjbGllbnRfaWQgPSB0aGlzLl91c2VyTWFuYWdlci5zZXR0aW5ncy5jbGllbnRfaWQ7XG4gICAgICAgICAgY29uc3QgaW50ZXJ2YWxJblNlY29uZHMgPSB0aGlzLl91c2VyTWFuYWdlci5zZXR0aW5ncy5jaGVja1Nlc3Npb25JbnRlcnZhbEluU2Vjb25kcztcbiAgICAgICAgICBjb25zdCBzdG9wT25FcnJvciA9IHRoaXMuX3VzZXJNYW5hZ2VyLnNldHRpbmdzLnN0b3BDaGVja1Nlc3Npb25PbkVycm9yO1xuICAgICAgICAgIGNvbnN0IGNoZWNrU2Vzc2lvbklGcmFtZSA9IG5ldyBDaGVja1Nlc3Npb25JRnJhbWUodGhpcy5fY2FsbGJhY2ssIGNsaWVudF9pZCwgdXJsLCBpbnRlcnZhbEluU2Vjb25kcywgc3RvcE9uRXJyb3IpO1xuICAgICAgICAgIGF3YWl0IGNoZWNrU2Vzc2lvbklGcmFtZS5sb2FkKCk7XG4gICAgICAgICAgdGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lID0gY2hlY2tTZXNzaW9uSUZyYW1lO1xuICAgICAgICAgIGNoZWNrU2Vzc2lvbklGcmFtZS5zdGFydChzZXNzaW9uX3N0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIyLndhcm4oXCJubyBjaGVjayBzZXNzaW9uIGlmcmFtZSBmb3VuZCBpbiB0aGUgbWV0YWRhdGFcIik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dnZXIyLmVycm9yKFwiRXJyb3IgZnJvbSBnZXRDaGVja1Nlc3Npb25JZnJhbWU6XCIsIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fc3RvcCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX3N0b3BcIik7XG4gICAgICB0aGlzLl9zdWIgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9zaWQgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrU2Vzc2lvbklGcmFtZS5zdG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fdXNlck1hbmFnZXIuc2V0dGluZ3MubW9uaXRvckFub255bW91c1Nlc3Npb24pIHtcbiAgICAgICAgY29uc3QgdGltZXJIYW5kbGUgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lckhhbmRsZSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCB0aGlzLl91c2VyTWFuYWdlci5xdWVyeVNlc3Npb25TdGF0dXMoKTtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRtcFVzZXIgPSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbl9zdGF0ZTogc2Vzc2lvbi5zZXNzaW9uX3N0YXRlLFxuICAgICAgICAgICAgICAgIHByb2ZpbGU6IHNlc3Npb24uc3ViICYmIHNlc3Npb24uc2lkID8ge1xuICAgICAgICAgICAgICAgICAgc3ViOiBzZXNzaW9uLnN1YixcbiAgICAgICAgICAgICAgICAgIHNpZDogc2Vzc2lvbi5zaWRcbiAgICAgICAgICAgICAgICB9IDogbnVsbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB2b2lkIHRoaXMuX3N0YXJ0KHRtcFVzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyMi5lcnJvcihcImVycm9yIGZyb20gcXVlcnlTZXNzaW9uU3RhdHVzXCIsIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMWUzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2NhbGxiYWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfY2FsbGJhY2tcIik7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgdGhpcy5fdXNlck1hbmFnZXIucXVlcnlTZXNzaW9uU3RhdHVzKCk7XG4gICAgICAgIGxldCByYWlzZUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNlc3Npb24gJiYgdGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lKSB7XG4gICAgICAgICAgaWYgKHNlc3Npb24uc3ViID09PSB0aGlzLl9zdWIpIHtcbiAgICAgICAgICAgIHJhaXNlRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrU2Vzc2lvbklGcmFtZS5zdGFydChzZXNzaW9uLnNlc3Npb25fc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24uc2lkID09PSB0aGlzLl9zaWQpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInNhbWUgc3ViIHN0aWxsIGxvZ2dlZCBpbiBhdCBPUCwgcmVzdGFydGluZyBjaGVjayBzZXNzaW9uIGlmcmFtZTsgc2Vzc2lvbl9zdGF0ZVwiLCBzZXNzaW9uLnNlc3Npb25fc3RhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInNhbWUgc3ViIHN0aWxsIGxvZ2dlZCBpbiBhdCBPUCwgc2Vzc2lvbiBzdGF0ZSBoYXMgY2hhbmdlZCwgcmVzdGFydGluZyBjaGVjayBzZXNzaW9uIGlmcmFtZTsgc2Vzc2lvbl9zdGF0ZVwiLCBzZXNzaW9uLnNlc3Npb25fc3RhdGUpO1xuICAgICAgICAgICAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMuX3JhaXNlVXNlclNlc3Npb25DaGFuZ2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlcjIuZGVidWcoXCJkaWZmZXJlbnQgc3ViamVjdCBzaWduZWQgaW50byBPUFwiLCBzZXNzaW9uLnN1Yik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlcjIuZGVidWcoXCJzdWJqZWN0IG5vIGxvbmdlciBzaWduZWQgaW50byBPUFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFpc2VFdmVudCkge1xuICAgICAgICAgIGlmICh0aGlzLl9zdWIpIHtcbiAgICAgICAgICAgIHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5fcmFpc2VVc2VyU2lnbmVkT3V0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5fcmFpc2VVc2VyU2lnbmVkSW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIm5vIGNoYW5nZSBpbiBzZXNzaW9uIGRldGVjdGVkLCBubyBldmVudCB0byByYWlzZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWIpIHtcbiAgICAgICAgICBsb2dnZXIyLmRlYnVnKFwiRXJyb3IgY2FsbGluZyBxdWVyeUN1cnJlbnRTaWduaW5TZXNzaW9uOyByYWlzaW5nIHNpZ25lZCBvdXQgZXZlbnRcIiwgZXJyKTtcbiAgICAgICAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMuX3JhaXNlVXNlclNpZ25lZE91dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIV91c2VyTWFuYWdlcikge1xuICAgICAgdGhpcy5fbG9nZ2VyLnRocm93KG5ldyBFcnJvcihcIk5vIHVzZXIgbWFuYWdlciBwYXNzZWRcIikpO1xuICAgIH1cbiAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMuYWRkVXNlckxvYWRlZCh0aGlzLl9zdGFydCk7XG4gICAgdGhpcy5fdXNlck1hbmFnZXIuZXZlbnRzLmFkZFVzZXJVbmxvYWRlZCh0aGlzLl9zdG9wKTtcbiAgICB0aGlzLl9pbml0KCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGVycik7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2luaXQoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9pbml0XCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl91c2VyTWFuYWdlci5nZXRVc2VyKCk7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIHZvaWQgdGhpcy5fc3RhcnQodXNlcik7XG4gICAgfSBlbHNlIGlmICh0aGlzLl91c2VyTWFuYWdlci5zZXR0aW5ncy5tb25pdG9yQW5vbnltb3VzU2Vzc2lvbikge1xuICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLnF1ZXJ5U2Vzc2lvblN0YXR1cygpO1xuICAgICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgY29uc3QgdG1wVXNlciA9IHtcbiAgICAgICAgICBzZXNzaW9uX3N0YXRlOiBzZXNzaW9uLnNlc3Npb25fc3RhdGUsXG4gICAgICAgICAgcHJvZmlsZTogc2Vzc2lvbi5zdWIgJiYgc2Vzc2lvbi5zaWQgPyB7XG4gICAgICAgICAgICBzdWI6IHNlc3Npb24uc3ViLFxuICAgICAgICAgICAgc2lkOiBzZXNzaW9uLnNpZFxuICAgICAgICAgIH0gOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHZvaWQgdGhpcy5fc3RhcnQodG1wVXNlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvVXNlci50c1xudmFyIFVzZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5pZF90b2tlbiA9IGFyZ3MuaWRfdG9rZW47XG4gICAgdGhpcy5zZXNzaW9uX3N0YXRlID0gKF9hID0gYXJncy5zZXNzaW9uX3N0YXRlKSAhPSBudWxsID8gX2EgOiBudWxsO1xuICAgIHRoaXMuYWNjZXNzX3Rva2VuID0gYXJncy5hY2Nlc3NfdG9rZW47XG4gICAgdGhpcy5yZWZyZXNoX3Rva2VuID0gYXJncy5yZWZyZXNoX3Rva2VuO1xuICAgIHRoaXMudG9rZW5fdHlwZSA9IGFyZ3MudG9rZW5fdHlwZTtcbiAgICB0aGlzLnNjb3BlID0gYXJncy5zY29wZTtcbiAgICB0aGlzLnByb2ZpbGUgPSBhcmdzLnByb2ZpbGU7XG4gICAgdGhpcy5leHBpcmVzX2F0ID0gYXJncy5leHBpcmVzX2F0O1xuICAgIHRoaXMuc3RhdGUgPSBhcmdzLnVzZXJTdGF0ZTtcbiAgICB0aGlzLnVybF9zdGF0ZSA9IGFyZ3MudXJsX3N0YXRlO1xuICB9XG4gIC8qKiBDb21wdXRlZCBudW1iZXIgb2Ygc2Vjb25kcyB0aGUgYWNjZXNzIHRva2VuIGhhcyByZW1haW5pbmcuICovXG4gIGdldCBleHBpcmVzX2luKCkge1xuICAgIGlmICh0aGlzLmV4cGlyZXNfYXQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXhwaXJlc19hdCAtIFRpbWVyLmdldEVwb2NoVGltZSgpO1xuICB9XG4gIHNldCBleHBpcmVzX2luKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuZXhwaXJlc19hdCA9IE1hdGguZmxvb3IodmFsdWUpICsgVGltZXIuZ2V0RXBvY2hUaW1lKCk7XG4gICAgfVxuICB9XG4gIC8qKiBDb21wdXRlZCB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBhY2Nlc3MgdG9rZW4gaXMgZXhwaXJlZC4gKi9cbiAgZ2V0IGV4cGlyZWQoKSB7XG4gICAgY29uc3QgZXhwaXJlc19pbiA9IHRoaXMuZXhwaXJlc19pbjtcbiAgICBpZiAoZXhwaXJlc19pbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gZXhwaXJlc19pbiA8PSAwO1xuICB9XG4gIC8qKiBBcnJheSByZXByZXNlbnRpbmcgdGhlIHBhcnNlZCB2YWx1ZXMgZnJvbSB0aGUgYHNjb3BlYC4gKi9cbiAgZ2V0IHNjb3BlcygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnNjb3BlKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3BsaXQoXCIgXCIpKSAhPSBudWxsID8gX2IgOiBbXTtcbiAgfVxuICB0b1N0b3JhZ2VTdHJpbmcoKSB7XG4gICAgbmV3IExvZ2dlcihcIlVzZXJcIikuY3JlYXRlKFwidG9TdG9yYWdlU3RyaW5nXCIpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBpZF90b2tlbjogdGhpcy5pZF90b2tlbixcbiAgICAgIHNlc3Npb25fc3RhdGU6IHRoaXMuc2Vzc2lvbl9zdGF0ZSxcbiAgICAgIGFjY2Vzc190b2tlbjogdGhpcy5hY2Nlc3NfdG9rZW4sXG4gICAgICByZWZyZXNoX3Rva2VuOiB0aGlzLnJlZnJlc2hfdG9rZW4sXG4gICAgICB0b2tlbl90eXBlOiB0aGlzLnRva2VuX3R5cGUsXG4gICAgICBzY29wZTogdGhpcy5zY29wZSxcbiAgICAgIHByb2ZpbGU6IHRoaXMucHJvZmlsZSxcbiAgICAgIGV4cGlyZXNfYXQ6IHRoaXMuZXhwaXJlc19hdFxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tU3RvcmFnZVN0cmluZyhzdG9yYWdlU3RyaW5nKSB7XG4gICAgTG9nZ2VyLmNyZWF0ZVN0YXRpYyhcIlVzZXJcIiwgXCJmcm9tU3RvcmFnZVN0cmluZ1wiKTtcbiAgICByZXR1cm4gbmV3IFVzZXIoSlNPTi5wYXJzZShzdG9yYWdlU3RyaW5nKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9uYXZpZ2F0b3JzL0Fic3RyYWN0Q2hpbGRXaW5kb3cudHNcbnZhciBtZXNzYWdlU291cmNlID0gXCJvaWRjLWNsaWVudFwiO1xudmFyIEFic3RyYWN0Q2hpbGRXaW5kb3cgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2Fib3J0ID0gbmV3IEV2ZW50KFwiV2luZG93IG5hdmlnYXRpb24gYWJvcnRlZFwiKTtcbiAgICB0aGlzLl9kaXNwb3NlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gIH1cbiAgYXN5bmMgbmF2aWdhdGUocGFyYW1zKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJuYXZpZ2F0ZVwiKTtcbiAgICBpZiAoIXRoaXMuX3dpbmRvdykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIG5hdmlnYXRlIG9uIGEgZGlzcG9zZWQgd2luZG93XCIpO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwic2V0dGluZyBVUkwgaW4gd2luZG93XCIpO1xuICAgIHRoaXMuX3dpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHBhcmFtcy51cmwpO1xuICAgIGNvbnN0IHsgdXJsLCBrZWVwT3BlbiB9ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBlLmRhdGE7XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IChfYSA9IHBhcmFtcy5zY3JpcHRPcmlnaW4pICE9IG51bGwgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgICAgIGlmIChlLm9yaWdpbiAhPT0gb3JpZ2luIHx8IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLnNvdXJjZSkgIT09IG1lc3NhZ2VTb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IFVybFV0aWxzLnJlYWRQYXJhbXMoZGF0YS51cmwsIHBhcmFtcy5yZXNwb25zZV9tb2RlKS5nZXQoXCJzdGF0ZVwiKTtcbiAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICBsb2dnZXIyLndhcm4oXCJubyBzdGF0ZSBmb3VuZCBpbiByZXNwb25zZSB1cmxcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlLnNvdXJjZSAhPT0gdGhpcy5fd2luZG93ICYmIHN0YXRlICE9PSBwYXJhbXMuc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmcm9tIHdpbmRvd1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgIHRoaXMuX2Rpc3Bvc2VIYW5kbGVycy5hZGQoKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbmVyLCBmYWxzZSkpO1xuICAgICAgdGhpcy5fZGlzcG9zZUhhbmRsZXJzLmFkZCh0aGlzLl9hYm9ydC5hZGRIYW5kbGVyKChyZWFzb24pID0+IHtcbiAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHJlc3BvbnNlIGZyb20gd2luZG93XCIpO1xuICAgIHRoaXMuX2Rpc3Bvc2UoKTtcbiAgICBpZiAoIWtlZXBPcGVuKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICAgIHJldHVybiB7IHVybCB9O1xuICB9XG4gIF9kaXNwb3NlKCkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfZGlzcG9zZVwiKTtcbiAgICBmb3IgKGNvbnN0IGRpc3Bvc2Ugb2YgdGhpcy5fZGlzcG9zZUhhbmRsZXJzKSB7XG4gICAgICBkaXNwb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuX2Rpc3Bvc2VIYW5kbGVycy5jbGVhcigpO1xuICB9XG4gIHN0YXRpYyBfbm90aWZ5UGFyZW50KHBhcmVudCwgdXJsLCBrZWVwT3BlbiA9IGZhbHNlLCB0YXJnZXRPcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luKSB7XG4gICAgcGFyZW50LnBvc3RNZXNzYWdlKHtcbiAgICAgIHNvdXJjZTogbWVzc2FnZVNvdXJjZSxcbiAgICAgIHVybCxcbiAgICAgIGtlZXBPcGVuXG4gICAgfSwgdGFyZ2V0T3JpZ2luKTtcbiAgfVxufTtcblxuLy8gc3JjL1VzZXJNYW5hZ2VyU2V0dGluZ3MudHNcbnZhciBEZWZhdWx0UG9wdXBXaW5kb3dGZWF0dXJlcyA9IHtcbiAgbG9jYXRpb246IGZhbHNlLFxuICB0b29sYmFyOiBmYWxzZSxcbiAgaGVpZ2h0OiA2NDAsXG4gIGNsb3NlUG9wdXBXaW5kb3dBZnRlckluU2Vjb25kczogLTFcbn07XG52YXIgRGVmYXVsdFBvcHVwVGFyZ2V0ID0gXCJfYmxhbmtcIjtcbnZhciBEZWZhdWx0QWNjZXNzVG9rZW5FeHBpcmluZ05vdGlmaWNhdGlvblRpbWVJblNlY29uZHMgPSA2MDtcbnZhciBEZWZhdWx0Q2hlY2tTZXNzaW9uSW50ZXJ2YWxJblNlY29uZHMgPSAyO1xudmFyIERlZmF1bHRTaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyA9IDEwO1xudmFyIFVzZXJNYW5hZ2VyU2V0dGluZ3NTdG9yZSA9IGNsYXNzIGV4dGVuZHMgT2lkY0NsaWVudFNldHRpbmdzU3RvcmUge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcG9wdXBfcmVkaXJlY3RfdXJpID0gYXJncy5yZWRpcmVjdF91cmksXG4gICAgICBwb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmkgPSBhcmdzLnBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICAgIHBvcHVwV2luZG93RmVhdHVyZXMgPSBEZWZhdWx0UG9wdXBXaW5kb3dGZWF0dXJlcyxcbiAgICAgIHBvcHVwV2luZG93VGFyZ2V0ID0gRGVmYXVsdFBvcHVwVGFyZ2V0LFxuICAgICAgcmVkaXJlY3RNZXRob2QgPSBcImFzc2lnblwiLFxuICAgICAgcmVkaXJlY3RUYXJnZXQgPSBcInNlbGZcIixcbiAgICAgIGlmcmFtZU5vdGlmeVBhcmVudE9yaWdpbiA9IGFyZ3MuaWZyYW1lTm90aWZ5UGFyZW50T3JpZ2luLFxuICAgICAgaWZyYW1lU2NyaXB0T3JpZ2luID0gYXJncy5pZnJhbWVTY3JpcHRPcmlnaW4sXG4gICAgICBzaWxlbnRfcmVkaXJlY3RfdXJpID0gYXJncy5yZWRpcmVjdF91cmksXG4gICAgICBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyA9IERlZmF1bHRTaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyxcbiAgICAgIGF1dG9tYXRpY1NpbGVudFJlbmV3ID0gdHJ1ZSxcbiAgICAgIHZhbGlkYXRlU3ViT25TaWxlbnRSZW5ldyA9IHRydWUsXG4gICAgICBpbmNsdWRlSWRUb2tlbkluU2lsZW50UmVuZXcgPSBmYWxzZSxcbiAgICAgIG1vbml0b3JTZXNzaW9uID0gZmFsc2UsXG4gICAgICBtb25pdG9yQW5vbnltb3VzU2Vzc2lvbiA9IGZhbHNlLFxuICAgICAgY2hlY2tTZXNzaW9uSW50ZXJ2YWxJblNlY29uZHMgPSBEZWZhdWx0Q2hlY2tTZXNzaW9uSW50ZXJ2YWxJblNlY29uZHMsXG4gICAgICBxdWVyeV9zdGF0dXNfcmVzcG9uc2VfdHlwZSA9IFwiY29kZVwiLFxuICAgICAgc3RvcENoZWNrU2Vzc2lvbk9uRXJyb3IgPSB0cnVlLFxuICAgICAgcmV2b2tlVG9rZW5UeXBlcyA9IFtcImFjY2Vzc190b2tlblwiLCBcInJlZnJlc2hfdG9rZW5cIl0sXG4gICAgICByZXZva2VUb2tlbnNPblNpZ25vdXQgPSBmYWxzZSxcbiAgICAgIGluY2x1ZGVJZFRva2VuSW5TaWxlbnRTaWdub3V0ID0gZmFsc2UsXG4gICAgICBhY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZUluU2Vjb25kcyA9IERlZmF1bHRBY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZUluU2Vjb25kcyxcbiAgICAgIHVzZXJTdG9yZVxuICAgIH0gPSBhcmdzO1xuICAgIHN1cGVyKGFyZ3MpO1xuICAgIHRoaXMucG9wdXBfcmVkaXJlY3RfdXJpID0gcG9wdXBfcmVkaXJlY3RfdXJpO1xuICAgIHRoaXMucG9wdXBfcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpID0gcG9wdXBfcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpO1xuICAgIHRoaXMucG9wdXBXaW5kb3dGZWF0dXJlcyA9IHBvcHVwV2luZG93RmVhdHVyZXM7XG4gICAgdGhpcy5wb3B1cFdpbmRvd1RhcmdldCA9IHBvcHVwV2luZG93VGFyZ2V0O1xuICAgIHRoaXMucmVkaXJlY3RNZXRob2QgPSByZWRpcmVjdE1ldGhvZDtcbiAgICB0aGlzLnJlZGlyZWN0VGFyZ2V0ID0gcmVkaXJlY3RUYXJnZXQ7XG4gICAgdGhpcy5pZnJhbWVOb3RpZnlQYXJlbnRPcmlnaW4gPSBpZnJhbWVOb3RpZnlQYXJlbnRPcmlnaW47XG4gICAgdGhpcy5pZnJhbWVTY3JpcHRPcmlnaW4gPSBpZnJhbWVTY3JpcHRPcmlnaW47XG4gICAgdGhpcy5zaWxlbnRfcmVkaXJlY3RfdXJpID0gc2lsZW50X3JlZGlyZWN0X3VyaTtcbiAgICB0aGlzLnNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzID0gc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHM7XG4gICAgdGhpcy5hdXRvbWF0aWNTaWxlbnRSZW5ldyA9IGF1dG9tYXRpY1NpbGVudFJlbmV3O1xuICAgIHRoaXMudmFsaWRhdGVTdWJPblNpbGVudFJlbmV3ID0gdmFsaWRhdGVTdWJPblNpbGVudFJlbmV3O1xuICAgIHRoaXMuaW5jbHVkZUlkVG9rZW5JblNpbGVudFJlbmV3ID0gaW5jbHVkZUlkVG9rZW5JblNpbGVudFJlbmV3O1xuICAgIHRoaXMubW9uaXRvclNlc3Npb24gPSBtb25pdG9yU2Vzc2lvbjtcbiAgICB0aGlzLm1vbml0b3JBbm9ueW1vdXNTZXNzaW9uID0gbW9uaXRvckFub255bW91c1Nlc3Npb247XG4gICAgdGhpcy5jaGVja1Nlc3Npb25JbnRlcnZhbEluU2Vjb25kcyA9IGNoZWNrU2Vzc2lvbkludGVydmFsSW5TZWNvbmRzO1xuICAgIHRoaXMuc3RvcENoZWNrU2Vzc2lvbk9uRXJyb3IgPSBzdG9wQ2hlY2tTZXNzaW9uT25FcnJvcjtcbiAgICB0aGlzLnF1ZXJ5X3N0YXR1c19yZXNwb25zZV90eXBlID0gcXVlcnlfc3RhdHVzX3Jlc3BvbnNlX3R5cGU7XG4gICAgdGhpcy5yZXZva2VUb2tlblR5cGVzID0gcmV2b2tlVG9rZW5UeXBlcztcbiAgICB0aGlzLnJldm9rZVRva2Vuc09uU2lnbm91dCA9IHJldm9rZVRva2Vuc09uU2lnbm91dDtcbiAgICB0aGlzLmluY2x1ZGVJZFRva2VuSW5TaWxlbnRTaWdub3V0ID0gaW5jbHVkZUlkVG9rZW5JblNpbGVudFNpZ25vdXQ7XG4gICAgdGhpcy5hY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZUluU2Vjb25kcyA9IGFjY2Vzc1Rva2VuRXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzO1xuICAgIGlmICh1c2VyU3RvcmUpIHtcbiAgICAgIHRoaXMudXNlclN0b3JlID0gdXNlclN0b3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdG9yZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UgOiBuZXcgSW5NZW1vcnlXZWJTdG9yYWdlKCk7XG4gICAgICB0aGlzLnVzZXJTdG9yZSA9IG5ldyBXZWJTdG9yYWdlU3RhdGVTdG9yZSh7IHN0b3JlIH0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL25hdmlnYXRvcnMvSUZyYW1lV2luZG93LnRzXG52YXIgSUZyYW1lV2luZG93ID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdENoaWxkV2luZG93IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzID0gRGVmYXVsdFNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzXG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJJRnJhbWVXaW5kb3dcIik7XG4gICAgdGhpcy5fdGltZW91dEluU2Vjb25kcyA9IHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzO1xuICAgIHRoaXMuX2ZyYW1lID0gSUZyYW1lV2luZG93LmNyZWF0ZUhpZGRlbklmcmFtZSgpO1xuICAgIHRoaXMuX3dpbmRvdyA9IHRoaXMuX2ZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUhpZGRlbklmcmFtZSgpIHtcbiAgICBjb25zdCBpZnJhbWUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICBpZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgIGlmcmFtZS5zdHlsZS5sZWZ0ID0gXCItMTAwMHB4XCI7XG4gICAgaWZyYW1lLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgIGlmcmFtZS53aWR0aCA9IFwiMFwiO1xuICAgIGlmcmFtZS5oZWlnaHQgPSBcIjBcIjtcbiAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHJldHVybiBpZnJhbWU7XG4gIH1cbiAgYXN5bmMgbmF2aWdhdGUocGFyYW1zKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwibmF2aWdhdGU6IFVzaW5nIHRpbWVvdXQgb2Y6XCIsIHRoaXMuX3RpbWVvdXRJblNlY29uZHMpO1xuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9hYm9ydC5yYWlzZShuZXcgRXJyb3JUaW1lb3V0KFwiSUZyYW1lIHRpbWVkIG91dCB3aXRob3V0IGEgcmVzcG9uc2VcIikpLCB0aGlzLl90aW1lb3V0SW5TZWNvbmRzICogMWUzKTtcbiAgICB0aGlzLl9kaXNwb3NlSGFuZGxlcnMuYWRkKCgpID0+IGNsZWFyVGltZW91dCh0aW1lcikpO1xuICAgIHJldHVybiBhd2FpdCBzdXBlci5uYXZpZ2F0ZShwYXJhbXMpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5fZnJhbWUpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFtZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuX2ZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIChldikgPT4ge1xuICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgY29uc3QgZnJhbWUgPSBldi50YXJnZXQ7XG4gICAgICAgICAgKF9hMiA9IGZyYW1lLnBhcmVudE5vZGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucmVtb3ZlQ2hpbGQoZnJhbWUpO1xuICAgICAgICAgIHRoaXMuX2Fib3J0LnJhaXNlKG5ldyBFcnJvcihcIklGcmFtZSByZW1vdmVkIGZyb20gRE9NXCIpKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIChfYSA9IHRoaXMuX2ZyYW1lLmNvbnRlbnRXaW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYS5sb2NhdGlvbi5yZXBsYWNlKFwiYWJvdXQ6YmxhbmtcIik7XG4gICAgICB9XG4gICAgICB0aGlzLl9mcmFtZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RhdGljIG5vdGlmeVBhcmVudCh1cmwsIHRhcmdldE9yaWdpbikge1xuICAgIHJldHVybiBzdXBlci5fbm90aWZ5UGFyZW50KHdpbmRvdy5wYXJlbnQsIHVybCwgZmFsc2UsIHRhcmdldE9yaWdpbik7XG4gIH1cbn07XG5cbi8vIHNyYy9uYXZpZ2F0b3JzL0lGcmFtZU5hdmlnYXRvci50c1xudmFyIElGcmFtZU5hdmlnYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3NldHRpbmdzKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfc2V0dGluZ3M7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIklGcmFtZU5hdmlnYXRvclwiKTtcbiAgfVxuICBhc3luYyBwcmVwYXJlKHtcbiAgICBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyA9IHRoaXMuX3NldHRpbmdzLnNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzXG4gIH0pIHtcbiAgICByZXR1cm4gbmV3IElGcmFtZVdpbmRvdyh7IHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzIH0pO1xuICB9XG4gIGFzeW5jIGNhbGxiYWNrKHVybCkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjYWxsYmFja1wiKTtcbiAgICBJRnJhbWVXaW5kb3cubm90aWZ5UGFyZW50KHVybCwgdGhpcy5fc2V0dGluZ3MuaWZyYW1lTm90aWZ5UGFyZW50T3JpZ2luKTtcbiAgfVxufTtcblxuLy8gc3JjL25hdmlnYXRvcnMvUG9wdXBXaW5kb3cudHNcbnZhciBjaGVja0ZvclBvcHVwQ2xvc2VkSW50ZXJ2YWwgPSA1MDA7XG52YXIgc2Vjb25kID0gMWUzO1xudmFyIFBvcHVwV2luZG93ID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdENoaWxkV2luZG93IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBvcHVwV2luZG93VGFyZ2V0ID0gRGVmYXVsdFBvcHVwVGFyZ2V0LFxuICAgIHBvcHVwV2luZG93RmVhdHVyZXMgPSB7fVxuICB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiUG9wdXBXaW5kb3dcIik7XG4gICAgY29uc3QgY2VudGVyZWRQb3B1cCA9IFBvcHVwVXRpbHMuY2VudGVyKHsgLi4uRGVmYXVsdFBvcHVwV2luZG93RmVhdHVyZXMsIC4uLnBvcHVwV2luZG93RmVhdHVyZXMgfSk7XG4gICAgdGhpcy5fd2luZG93ID0gd2luZG93Lm9wZW4odm9pZCAwLCBwb3B1cFdpbmRvd1RhcmdldCwgUG9wdXBVdGlscy5zZXJpYWxpemUoY2VudGVyZWRQb3B1cCkpO1xuICAgIGlmIChwb3B1cFdpbmRvd0ZlYXR1cmVzLmNsb3NlUG9wdXBXaW5kb3dBZnRlckluU2Vjb25kcyAmJiBwb3B1cFdpbmRvd0ZlYXR1cmVzLmNsb3NlUG9wdXBXaW5kb3dBZnRlckluU2Vjb25kcyA+IDApIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX3dpbmRvdyB8fCB0eXBlb2YgdGhpcy5fd2luZG93LmNsb3NlZCAhPT0gXCJib29sZWFuXCIgfHwgdGhpcy5fd2luZG93LmNsb3NlZCkge1xuICAgICAgICAgIHRoaXMuX2Fib3J0LnJhaXNlKG5ldyBFcnJvcihcIlBvcHVwIGJsb2NrZWQgYnkgdXNlclwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH0sIHBvcHVwV2luZG93RmVhdHVyZXMuY2xvc2VQb3B1cFdpbmRvd0FmdGVySW5TZWNvbmRzICogc2Vjb25kKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbmF2aWdhdGUocGFyYW1zKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuX3dpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgY29uc3QgcG9wdXBDbG9zZWRJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fd2luZG93IHx8IHRoaXMuX3dpbmRvdy5jbG9zZWQpIHtcbiAgICAgICAgdGhpcy5fYWJvcnQucmFpc2UobmV3IEVycm9yKFwiUG9wdXAgY2xvc2VkIGJ5IHVzZXJcIikpO1xuICAgICAgfVxuICAgIH0sIGNoZWNrRm9yUG9wdXBDbG9zZWRJbnRlcnZhbCk7XG4gICAgdGhpcy5fZGlzcG9zZUhhbmRsZXJzLmFkZCgoKSA9PiBjbGVhckludGVydmFsKHBvcHVwQ2xvc2VkSW50ZXJ2YWwpKTtcbiAgICByZXR1cm4gYXdhaXQgc3VwZXIubmF2aWdhdGUocGFyYW1zKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5fd2luZG93KSB7XG4gICAgICBpZiAoIXRoaXMuX3dpbmRvdy5jbG9zZWQpIHtcbiAgICAgICAgdGhpcy5fd2luZG93LmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2Fib3J0LnJhaXNlKG5ldyBFcnJvcihcIlBvcHVwIGNsb3NlZFwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RhdGljIG5vdGlmeU9wZW5lcih1cmwsIGtlZXBPcGVuKSB7XG4gICAgaWYgKCF3aW5kb3cub3BlbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB3aW5kb3cub3BlbmVyLiBDYW4ndCBjb21wbGV0ZSBub3RpZmljYXRpb24uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuX25vdGlmeVBhcmVudCh3aW5kb3cub3BlbmVyLCB1cmwsIGtlZXBPcGVuKTtcbiAgfVxufTtcblxuLy8gc3JjL25hdmlnYXRvcnMvUG9wdXBOYXZpZ2F0b3IudHNcbnZhciBQb3B1cE5hdmlnYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3NldHRpbmdzKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfc2V0dGluZ3M7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlBvcHVwTmF2aWdhdG9yXCIpO1xuICB9XG4gIGFzeW5jIHByZXBhcmUoe1xuICAgIHBvcHVwV2luZG93RmVhdHVyZXMgPSB0aGlzLl9zZXR0aW5ncy5wb3B1cFdpbmRvd0ZlYXR1cmVzLFxuICAgIHBvcHVwV2luZG93VGFyZ2V0ID0gdGhpcy5fc2V0dGluZ3MucG9wdXBXaW5kb3dUYXJnZXRcbiAgfSkge1xuICAgIHJldHVybiBuZXcgUG9wdXBXaW5kb3coeyBwb3B1cFdpbmRvd0ZlYXR1cmVzLCBwb3B1cFdpbmRvd1RhcmdldCB9KTtcbiAgfVxuICBhc3luYyBjYWxsYmFjayh1cmwsIHsga2VlcE9wZW4gPSBmYWxzZSB9KSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImNhbGxiYWNrXCIpO1xuICAgIFBvcHVwV2luZG93Lm5vdGlmeU9wZW5lcih1cmwsIGtlZXBPcGVuKTtcbiAgfVxufTtcblxuLy8gc3JjL25hdmlnYXRvcnMvUmVkaXJlY3ROYXZpZ2F0b3IudHNcbnZhciBSZWRpcmVjdE5hdmlnYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3NldHRpbmdzKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfc2V0dGluZ3M7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlJlZGlyZWN0TmF2aWdhdG9yXCIpO1xuICB9XG4gIGFzeW5jIHByZXBhcmUoe1xuICAgIHJlZGlyZWN0TWV0aG9kID0gdGhpcy5fc2V0dGluZ3MucmVkaXJlY3RNZXRob2QsXG4gICAgcmVkaXJlY3RUYXJnZXQgPSB0aGlzLl9zZXR0aW5ncy5yZWRpcmVjdFRhcmdldFxuICB9KSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJwcmVwYXJlXCIpO1xuICAgIGxldCB0YXJnZXRXaW5kb3cgPSB3aW5kb3cuc2VsZjtcbiAgICBpZiAocmVkaXJlY3RUYXJnZXQgPT09IFwidG9wXCIpIHtcbiAgICAgIHRhcmdldFdpbmRvdyA9IChfYSA9IHdpbmRvdy50b3ApICE9IG51bGwgPyBfYSA6IHdpbmRvdy5zZWxmO1xuICAgIH1cbiAgICBjb25zdCByZWRpcmVjdCA9IHRhcmdldFdpbmRvdy5sb2NhdGlvbltyZWRpcmVjdE1ldGhvZF0uYmluZCh0YXJnZXRXaW5kb3cubG9jYXRpb24pO1xuICAgIGxldCBhYm9ydDtcbiAgICByZXR1cm4ge1xuICAgICAgbmF2aWdhdGU6IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIm5hdmlnYXRlXCIpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGFib3J0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmVkaXJlY3QocGFyYW1zLnVybCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjbG9zZVwiKTtcbiAgICAgICAgYWJvcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0KG5ldyBFcnJvcihcIlJlZGlyZWN0IGFib3J0ZWRcIikpO1xuICAgICAgICB0YXJnZXRXaW5kb3cuc3RvcCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgY2FsbGJhY2soKSB7XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG4vLyBzcmMvVXNlck1hbmFnZXJFdmVudHMudHNcbnZhciBVc2VyTWFuYWdlckV2ZW50cyA9IGNsYXNzIGV4dGVuZHMgQWNjZXNzVG9rZW5FdmVudHMge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHsgZXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzOiBzZXR0aW5ncy5hY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZUluU2Vjb25kcyB9KTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiVXNlck1hbmFnZXJFdmVudHNcIik7XG4gICAgdGhpcy5fdXNlckxvYWRlZCA9IG5ldyBFdmVudChcIlVzZXIgbG9hZGVkXCIpO1xuICAgIHRoaXMuX3VzZXJVbmxvYWRlZCA9IG5ldyBFdmVudChcIlVzZXIgdW5sb2FkZWRcIik7XG4gICAgdGhpcy5fc2lsZW50UmVuZXdFcnJvciA9IG5ldyBFdmVudChcIlNpbGVudCByZW5ldyBlcnJvclwiKTtcbiAgICB0aGlzLl91c2VyU2lnbmVkSW4gPSBuZXcgRXZlbnQoXCJVc2VyIHNpZ25lZCBpblwiKTtcbiAgICB0aGlzLl91c2VyU2lnbmVkT3V0ID0gbmV3IEV2ZW50KFwiVXNlciBzaWduZWQgb3V0XCIpO1xuICAgIHRoaXMuX3VzZXJTZXNzaW9uQ2hhbmdlZCA9IG5ldyBFdmVudChcIlVzZXIgc2Vzc2lvbiBjaGFuZ2VkXCIpO1xuICB9XG4gIGxvYWQodXNlciwgcmFpc2VFdmVudCA9IHRydWUpIHtcbiAgICBzdXBlci5sb2FkKHVzZXIpO1xuICAgIGlmIChyYWlzZUV2ZW50KSB7XG4gICAgICB0aGlzLl91c2VyTG9hZGVkLnJhaXNlKHVzZXIpO1xuICAgIH1cbiAgfVxuICB1bmxvYWQoKSB7XG4gICAgc3VwZXIudW5sb2FkKCk7XG4gICAgdGhpcy5fdXNlclVubG9hZGVkLnJhaXNlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjYWxsYmFjazogUmFpc2VkIHdoZW4gYSB1c2VyIHNlc3Npb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQgKG9yIHJlLWVzdGFibGlzaGVkKS5cbiAgICovXG4gIGFkZFVzZXJMb2FkZWQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckxvYWRlZC5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiBhIHVzZXIgc2Vzc2lvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZCAob3IgcmUtZXN0YWJsaXNoZWQpLlxuICAgKi9cbiAgcmVtb3ZlVXNlckxvYWRlZChjYikge1xuICAgIHJldHVybiB0aGlzLl91c2VyTG9hZGVkLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIGEgdXNlciBzZXNzaW9uIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAqL1xuICBhZGRVc2VyVW5sb2FkZWQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclVubG9hZGVkLmFkZEhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIGEgdXNlciBzZXNzaW9uIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAqL1xuICByZW1vdmVVc2VyVW5sb2FkZWQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclVubG9hZGVkLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSBhdXRvbWF0aWMgc2lsZW50IHJlbmV3IGhhcyBmYWlsZWQuXG4gICAqL1xuICBhZGRTaWxlbnRSZW5ld0Vycm9yKGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpbGVudFJlbmV3RXJyb3IuYWRkSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBjYWxsYmFjazogUmFpc2VkIHdoZW4gdGhlIGF1dG9tYXRpYyBzaWxlbnQgcmVuZXcgaGFzIGZhaWxlZC5cbiAgICovXG4gIHJlbW92ZVNpbGVudFJlbmV3RXJyb3IoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lsZW50UmVuZXdFcnJvci5yZW1vdmVIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcmFpc2VTaWxlbnRSZW5ld0Vycm9yKGUpIHtcbiAgICB0aGlzLl9zaWxlbnRSZW5ld0Vycm9yLnJhaXNlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSB1c2VyIGlzIHNpZ25lZCBpbiAod2hlbiBgbW9uaXRvclNlc3Npb25gIGlzIHNldCkuXG4gICAqIEBzZWUge0BsaW5rIFVzZXJNYW5hZ2VyU2V0dGluZ3MubW9uaXRvclNlc3Npb259XG4gICAqL1xuICBhZGRVc2VyU2lnbmVkSW4oY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclNpZ25lZEluLmFkZEhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSB1c2VyIGlzIHNpZ25lZCBpbiAod2hlbiBgbW9uaXRvclNlc3Npb25gIGlzIHNldCkuXG4gICAqL1xuICByZW1vdmVVc2VyU2lnbmVkSW4oY2IpIHtcbiAgICB0aGlzLl91c2VyU2lnbmVkSW4ucmVtb3ZlSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3JhaXNlVXNlclNpZ25lZEluKCkge1xuICAgIHRoaXMuX3VzZXJTaWduZWRJbi5yYWlzZSgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSB1c2VyJ3Mgc2lnbi1pbiBzdGF0dXMgYXQgdGhlIE9QIGhhcyBjaGFuZ2VkICh3aGVuIGBtb25pdG9yU2Vzc2lvbmAgaXMgc2V0KS5cbiAgICogQHNlZSB7QGxpbmsgVXNlck1hbmFnZXJTZXR0aW5ncy5tb25pdG9yU2Vzc2lvbn1cbiAgICovXG4gIGFkZFVzZXJTaWduZWRPdXQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclNpZ25lZE91dC5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiB0aGUgdXNlcidzIHNpZ24taW4gc3RhdHVzIGF0IHRoZSBPUCBoYXMgY2hhbmdlZCAod2hlbiBgbW9uaXRvclNlc3Npb25gIGlzIHNldCkuXG4gICAqL1xuICByZW1vdmVVc2VyU2lnbmVkT3V0KGNiKSB7XG4gICAgdGhpcy5fdXNlclNpZ25lZE91dC5yZW1vdmVIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcmFpc2VVc2VyU2lnbmVkT3V0KCkge1xuICAgIHRoaXMuX3VzZXJTaWduZWRPdXQucmFpc2UoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiB0aGUgdXNlciBzZXNzaW9uIGNoYW5nZWQgKHdoZW4gYG1vbml0b3JTZXNzaW9uYCBpcyBzZXQpLlxuICAgKiBAc2VlIHtAbGluayBVc2VyTWFuYWdlclNldHRpbmdzLm1vbml0b3JTZXNzaW9ufVxuICAgKi9cbiAgYWRkVXNlclNlc3Npb25DaGFuZ2VkKGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJTZXNzaW9uQ2hhbmdlZC5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiB0aGUgdXNlciBzZXNzaW9uIGNoYW5nZWQgKHdoZW4gYG1vbml0b3JTZXNzaW9uYCBpcyBzZXQpLlxuICAgKi9cbiAgcmVtb3ZlVXNlclNlc3Npb25DaGFuZ2VkKGNiKSB7XG4gICAgdGhpcy5fdXNlclNlc3Npb25DaGFuZ2VkLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9yYWlzZVVzZXJTZXNzaW9uQ2hhbmdlZCgpIHtcbiAgICB0aGlzLl91c2VyU2Vzc2lvbkNoYW5nZWQucmFpc2UoKTtcbiAgfVxufTtcblxuLy8gc3JjL1NpbGVudFJlbmV3U2VydmljZS50c1xudmFyIFNpbGVudFJlbmV3U2VydmljZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3VzZXJNYW5hZ2VyKSB7XG4gICAgdGhpcy5fdXNlck1hbmFnZXIgPSBfdXNlck1hbmFnZXI7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlNpbGVudFJlbmV3U2VydmljZVwiKTtcbiAgICB0aGlzLl9pc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXRyeVRpbWVyID0gbmV3IFRpbWVyKFwiUmV0cnkgU2lsZW50IFJlbmV3XCIpO1xuICAgIHRoaXMuX3Rva2VuRXhwaXJpbmcgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl90b2tlbkV4cGlyaW5nXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5fdXNlck1hbmFnZXIuc2lnbmluU2lsZW50KCk7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJzaWxlbnQgdG9rZW4gcmVuZXdhbCBzdWNjZXNzZnVsXCIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvclRpbWVvdXQpIHtcbiAgICAgICAgICBsb2dnZXIyLndhcm4oXCJFcnJvclRpbWVvdXQgZnJvbSBzaWduaW5TaWxlbnQ6XCIsIGVyciwgXCJyZXRyeSBpbiA1c1wiKTtcbiAgICAgICAgICB0aGlzLl9yZXRyeVRpbWVyLmluaXQoNSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcjIuZXJyb3IoXCJFcnJvciBmcm9tIHNpZ25pblNpbGVudDpcIiwgZXJyKTtcbiAgICAgICAgdGhpcy5fdXNlck1hbmFnZXIuZXZlbnRzLl9yYWlzZVNpbGVudFJlbmV3RXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic3RhcnRcIik7XG4gICAgaWYgKCF0aGlzLl9pc1N0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuX2lzU3RhcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMuYWRkQWNjZXNzVG9rZW5FeHBpcmluZyh0aGlzLl90b2tlbkV4cGlyaW5nKTtcbiAgICAgIHRoaXMuX3JldHJ5VGltZXIuYWRkSGFuZGxlcih0aGlzLl90b2tlbkV4cGlyaW5nKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLmdldFVzZXIoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dnZXIyLmVycm9yKFwiZ2V0VXNlciBlcnJvclwiLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLl9pc1N0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuX3JldHJ5VGltZXIuY2FuY2VsKCk7XG4gICAgICB0aGlzLl9yZXRyeVRpbWVyLnJlbW92ZUhhbmRsZXIodGhpcy5fdG9rZW5FeHBpcmluZyk7XG4gICAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMucmVtb3ZlQWNjZXNzVG9rZW5FeHBpcmluZyh0aGlzLl90b2tlbkV4cGlyaW5nKTtcbiAgICAgIHRoaXMuX2lzU3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL1JlZnJlc2hTdGF0ZS50c1xudmFyIFJlZnJlc2hTdGF0ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXJncywgcmVzb3VyY2UpIHtcbiAgICB0aGlzLnJlZnJlc2hfdG9rZW4gPSBhcmdzLnJlZnJlc2hfdG9rZW47XG4gICAgdGhpcy5pZF90b2tlbiA9IGFyZ3MuaWRfdG9rZW47XG4gICAgdGhpcy5zZXNzaW9uX3N0YXRlID0gYXJncy5zZXNzaW9uX3N0YXRlO1xuICAgIHRoaXMuc2NvcGUgPSBhcmdzLnNjb3BlO1xuICAgIHRoaXMucHJvZmlsZSA9IGFyZ3MucHJvZmlsZTtcbiAgICB0aGlzLnJlc291cmNlID0gcmVzb3VyY2U7XG4gICAgdGhpcy5kYXRhID0gYXJncy5zdGF0ZTtcbiAgfVxufTtcblxuLy8gc3JjL1VzZXJNYW5hZ2VyLnRzXG52YXIgVXNlck1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzLCByZWRpcmVjdE5hdmlnYXRvciwgcG9wdXBOYXZpZ2F0b3IsIGlmcmFtZU5hdmlnYXRvcikge1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJVc2VyTWFuYWdlclwiKTtcbiAgICB0aGlzLnNldHRpbmdzID0gbmV3IFVzZXJNYW5hZ2VyU2V0dGluZ3NTdG9yZShzZXR0aW5ncyk7XG4gICAgdGhpcy5fY2xpZW50ID0gbmV3IE9pZGNDbGllbnQoc2V0dGluZ3MpO1xuICAgIHRoaXMuX3JlZGlyZWN0TmF2aWdhdG9yID0gcmVkaXJlY3ROYXZpZ2F0b3IgIT0gbnVsbCA/IHJlZGlyZWN0TmF2aWdhdG9yIDogbmV3IFJlZGlyZWN0TmF2aWdhdG9yKHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuX3BvcHVwTmF2aWdhdG9yID0gcG9wdXBOYXZpZ2F0b3IgIT0gbnVsbCA/IHBvcHVwTmF2aWdhdG9yIDogbmV3IFBvcHVwTmF2aWdhdG9yKHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuX2lmcmFtZU5hdmlnYXRvciA9IGlmcmFtZU5hdmlnYXRvciAhPSBudWxsID8gaWZyYW1lTmF2aWdhdG9yIDogbmV3IElGcmFtZU5hdmlnYXRvcih0aGlzLnNldHRpbmdzKTtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgVXNlck1hbmFnZXJFdmVudHModGhpcy5zZXR0aW5ncyk7XG4gICAgdGhpcy5fc2lsZW50UmVuZXdTZXJ2aWNlID0gbmV3IFNpbGVudFJlbmV3U2VydmljZSh0aGlzKTtcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvbWF0aWNTaWxlbnRSZW5ldykge1xuICAgICAgdGhpcy5zdGFydFNpbGVudFJlbmV3KCk7XG4gICAgfVxuICAgIHRoaXMuX3Nlc3Npb25Nb25pdG9yID0gbnVsbDtcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5tb25pdG9yU2Vzc2lvbikge1xuICAgICAgdGhpcy5fc2Vzc2lvbk1vbml0b3IgPSBuZXcgU2Vzc2lvbk1vbml0b3IodGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBSZXR1cm5zIGFuIG9iamVjdCB1c2VkIHRvIHJlZ2lzdGVyIGZvciBldmVudHMgcmFpc2VkIGJ5IHRoZSBgVXNlck1hbmFnZXJgLiAqL1xuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudHM7XG4gIH1cbiAgLyoqIFJldHVybnMgYW4gb2JqZWN0IHVzZWQgdG8gYWNjZXNzIHRoZSBtZXRhZGF0YSBjb25maWd1cmF0aW9uIG9mIHRoZSBPSURDIHByb3ZpZGVyLiAqL1xuICBnZXQgbWV0YWRhdGFTZXJ2aWNlKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQubWV0YWRhdGFTZXJ2aWNlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb21pc2UgdG8gbG9hZCB0aGUgYFVzZXJgIG9iamVjdCBmb3IgdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHVzZXIuXG4gICAqL1xuICBhc3luYyBnZXRVc2VyKCkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZ2V0VXNlclwiKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5fbG9hZFVzZXIoKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgbG9nZ2VyMi5pbmZvKFwidXNlciBsb2FkZWRcIik7XG4gICAgICB0aGlzLl9ldmVudHMubG9hZCh1c2VyLCBmYWxzZSk7XG4gICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG4gICAgbG9nZ2VyMi5pbmZvKFwidXNlciBub3QgZm91bmQgaW4gc3RvcmFnZVwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcm9taXNlIHRvIHJlbW92ZSBmcm9tIGFueSBzdG9yYWdlIHRoZSBjdXJyZW50bHkgYXV0aGVudGljYXRlZCB1c2VyLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlVXNlcigpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInJlbW92ZVVzZXJcIik7XG4gICAgYXdhaXQgdGhpcy5zdG9yZVVzZXIobnVsbCk7XG4gICAgbG9nZ2VyMi5pbmZvKFwidXNlciByZW1vdmVkIGZyb20gc3RvcmFnZVwiKTtcbiAgICB0aGlzLl9ldmVudHMudW5sb2FkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcHJvbWlzZSB0byB0cmlnZ2VyIGEgcmVkaXJlY3Qgb2YgdGhlIGN1cnJlbnQgd2luZG93IHRvIHRoZSBhdXRob3JpemF0aW9uIGVuZHBvaW50LlxuICAgKi9cbiAgYXN5bmMgc2lnbmluUmVkaXJlY3QoYXJncyA9IHt9KSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25pblJlZGlyZWN0XCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZGlyZWN0TWV0aG9kLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9ID0gYXJncztcbiAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB0aGlzLl9yZWRpcmVjdE5hdmlnYXRvci5wcmVwYXJlKHsgcmVkaXJlY3RNZXRob2QgfSk7XG4gICAgYXdhaXQgdGhpcy5fc2lnbmluU3RhcnQoe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInNpOnJcIixcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSwgaGFuZGxlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcm9taXNlIHRvIHByb2Nlc3MgcmVzcG9uc2UgZnJvbSB0aGUgYXV0aG9yaXphdGlvbiBlbmRwb2ludC4gVGhlIHJlc3VsdCBvZiB0aGUgcHJvbWlzZSBpcyB0aGUgYXV0aGVudGljYXRlZCBgVXNlcmAuXG4gICAqL1xuICBhc3luYyBzaWduaW5SZWRpcmVjdENhbGxiYWNrKHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWduaW5SZWRpcmVjdENhbGxiYWNrXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9zaWduaW5FbmQodXJsKTtcbiAgICBpZiAodXNlci5wcm9maWxlICYmIHVzZXIucHJvZmlsZS5zdWIpIHtcbiAgICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3MsIHNpZ25lZCBpbiBzdWJqZWN0XCIsIHVzZXIucHJvZmlsZS5zdWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIyLmluZm8oXCJubyBzdWJqZWN0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcm9taXNlIHRvIHByb2Nlc3MgdGhlIHNpZ25pbiB3aXRoIHVzZXIvcGFzc3dvcmQuIFRoZSByZXN1bHQgb2YgdGhlIHByb21pc2UgaXMgdGhlIGF1dGhlbnRpY2F0ZWQgYFVzZXJgLlxuICAgKlxuICAgKiBUaHJvd3MgYW4gRXJyb3JSZXNwb25zZSBpbiBjYXNlIG9mIHdyb25nIGF1dGhlbnRpY2F0aW9uLlxuICAgKi9cbiAgYXN5bmMgc2lnbmluUmVzb3VyY2VPd25lckNyZWRlbnRpYWxzKHtcbiAgICB1c2VybmFtZSxcbiAgICBwYXNzd29yZCxcbiAgICBza2lwVXNlckluZm8gPSBmYWxzZVxuICB9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWduaW5SZXNvdXJjZU93bmVyQ3JlZGVudGlhbFwiKTtcbiAgICBjb25zdCBzaWduaW5SZXNwb25zZSA9IGF3YWl0IHRoaXMuX2NsaWVudC5wcm9jZXNzUmVzb3VyY2VPd25lclBhc3N3b3JkQ3JlZGVudGlhbHMoeyB1c2VybmFtZSwgcGFzc3dvcmQsIHNraXBVc2VySW5mbywgZXh0cmFUb2tlblBhcmFtczogdGhpcy5zZXR0aW5ncy5leHRyYVRva2VuUGFyYW1zIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qgc2lnbmluIHJlc3BvbnNlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9idWlsZFVzZXIoc2lnbmluUmVzcG9uc2UpO1xuICAgIGlmICh1c2VyLnByb2ZpbGUgJiYgdXNlci5wcm9maWxlLnN1Yikge1xuICAgICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzcywgc2lnbmVkIGluIHN1YmplY3RcIiwgdXNlci5wcm9maWxlLnN1Yik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjIuaW5mbyhcIm5vIHN1YmplY3RcIik7XG4gICAgfVxuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb21pc2UgdG8gdHJpZ2dlciBhIHJlcXVlc3QgKHZpYSBhIHBvcHVwIHdpbmRvdykgdG8gdGhlIGF1dGhvcml6YXRpb24gZW5kcG9pbnQuIFRoZSByZXN1bHQgb2YgdGhlIHByb21pc2UgaXMgdGhlIGF1dGhlbnRpY2F0ZWQgYFVzZXJgLlxuICAgKi9cbiAgYXN5bmMgc2lnbmluUG9wdXAoYXJncyA9IHt9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWduaW5Qb3B1cFwiKTtcbiAgICBjb25zdCB7XG4gICAgICBwb3B1cFdpbmRvd0ZlYXR1cmVzLFxuICAgICAgcG9wdXBXaW5kb3dUYXJnZXQsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0gPSBhcmdzO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuc2V0dGluZ3MucG9wdXBfcmVkaXJlY3RfdXJpO1xuICAgIGlmICghdXJsKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk5vIHBvcHVwX3JlZGlyZWN0X3VyaSBjb25maWd1cmVkXCIpKTtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy5fcG9wdXBOYXZpZ2F0b3IucHJlcGFyZSh7IHBvcHVwV2luZG93RmVhdHVyZXMsIHBvcHVwV2luZG93VGFyZ2V0IH0pO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9zaWduaW4oe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInNpOnBcIixcbiAgICAgIHJlZGlyZWN0X3VyaTogdXJsLFxuICAgICAgZGlzcGxheTogXCJwb3B1cFwiLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9LCBoYW5kbGUpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICBpZiAodXNlci5wcm9maWxlICYmIHVzZXIucHJvZmlsZS5zdWIpIHtcbiAgICAgICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzcywgc2lnbmVkIGluIHN1YmplY3RcIiwgdXNlci5wcm9maWxlLnN1Yik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIyLmluZm8oXCJubyBzdWJqZWN0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcm9taXNlIHRvIG5vdGlmeSB0aGUgb3BlbmluZyB3aW5kb3cgb2YgcmVzcG9uc2UgZnJvbSB0aGUgYXV0aG9yaXphdGlvbiBlbmRwb2ludC5cbiAgICovXG4gIGFzeW5jIHNpZ25pblBvcHVwQ2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYsIGtlZXBPcGVuID0gZmFsc2UpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25pblBvcHVwQ2FsbGJhY2tcIik7XG4gICAgYXdhaXQgdGhpcy5fcG9wdXBOYXZpZ2F0b3IuY2FsbGJhY2sodXJsLCB7IGtlZXBPcGVuIH0pO1xuICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3NcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcHJvbWlzZSB0byB0cmlnZ2VyIGEgc2lsZW50IHJlcXVlc3QgKHZpYSBhbiBpZnJhbWUpIHRvIHRoZSBhdXRob3JpemF0aW9uIGVuZHBvaW50LlxuICAgKiBUaGUgcmVzdWx0IG9mIHRoZSBwcm9taXNlIGlzIHRoZSBhdXRoZW50aWNhdGVkIGBVc2VyYC5cbiAgICovXG4gIGFzeW5jIHNpZ25pblNpbGVudChhcmdzID0ge30pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWduaW5TaWxlbnRcIik7XG4gICAgY29uc3Qge1xuICAgICAgc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMsXG4gICAgICByZXNvdXJjZSxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgbGV0IHVzZXIgPSBhd2FpdCB0aGlzLl9sb2FkVXNlcigpO1xuICAgIGlmICh1c2VyID09IG51bGwgPyB2b2lkIDAgOiB1c2VyLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJ1c2luZyByZWZyZXNoIHRva2VuXCIpO1xuICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgUmVmcmVzaFN0YXRlKHVzZXIsIHJlc291cmNlKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VSZWZyZXNoVG9rZW4oc3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSB0aGlzLnNldHRpbmdzLnNpbGVudF9yZWRpcmVjdF91cmk7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gc2lsZW50X3JlZGlyZWN0X3VyaSBjb25maWd1cmVkXCIpKTtcbiAgICB9XG4gICAgbGV0IHZlcmlmeVN1YjtcbiAgICBpZiAodXNlciAmJiB0aGlzLnNldHRpbmdzLnZhbGlkYXRlU3ViT25TaWxlbnRSZW5ldykge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInN1YmplY3QgcHJpb3IgdG8gc2lsZW50IHJlbmV3OlwiLCB1c2VyLnByb2ZpbGUuc3ViKTtcbiAgICAgIHZlcmlmeVN1YiA9IHVzZXIucHJvZmlsZS5zdWI7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZSA9IGF3YWl0IHRoaXMuX2lmcmFtZU5hdmlnYXRvci5wcmVwYXJlKHsgc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMgfSk7XG4gICAgdXNlciA9IGF3YWl0IHRoaXMuX3NpZ25pbih7XG4gICAgICByZXF1ZXN0X3R5cGU6IFwic2k6c1wiLFxuICAgICAgcmVkaXJlY3RfdXJpOiB1cmwsXG4gICAgICBwcm9tcHQ6IFwibm9uZVwiLFxuICAgICAgaWRfdG9rZW5faGludDogdGhpcy5zZXR0aW5ncy5pbmNsdWRlSWRUb2tlbkluU2lsZW50UmVuZXcgPyB1c2VyID09IG51bGwgPyB2b2lkIDAgOiB1c2VyLmlkX3Rva2VuIDogdm9pZCAwLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9LCBoYW5kbGUsIHZlcmlmeVN1Yik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGlmICgoX2EgPSB1c2VyLnByb2ZpbGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdWIpIHtcbiAgICAgICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzcywgc2lnbmVkIGluIHN1YmplY3RcIiwgdXNlci5wcm9maWxlLnN1Yik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIyLmluZm8oXCJubyBzdWJqZWN0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICBhc3luYyBfdXNlUmVmcmVzaFRva2VuKHN0YXRlKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9jbGllbnQudXNlUmVmcmVzaFRva2VuKHtcbiAgICAgIHN0YXRlLFxuICAgICAgdGltZW91dEluU2Vjb25kczogdGhpcy5zZXR0aW5ncy5zaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kc1xuICAgIH0pO1xuICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcih7IC4uLnN0YXRlLCAuLi5yZXNwb25zZSB9KTtcbiAgICBhd2FpdCB0aGlzLnN0b3JlVXNlcih1c2VyKTtcbiAgICB0aGlzLl9ldmVudHMubG9hZCh1c2VyKTtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcm9taXNlIHRvIG5vdGlmeSB0aGUgcGFyZW50IHdpbmRvdyBvZiByZXNwb25zZSBmcm9tIHRoZSBhdXRob3JpemF0aW9uIGVuZHBvaW50LlxuICAgKi9cbiAgYXN5bmMgc2lnbmluU2lsZW50Q2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25pblNpbGVudENhbGxiYWNrXCIpO1xuICAgIGF3YWl0IHRoaXMuX2lmcmFtZU5hdmlnYXRvci5jYWxsYmFjayh1cmwpO1xuICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3NcIik7XG4gIH1cbiAgYXN5bmMgc2lnbmluQ2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBhd2FpdCB0aGlzLl9jbGllbnQucmVhZFNpZ25pblJlc3BvbnNlU3RhdGUodXJsKTtcbiAgICBzd2l0Y2ggKHN0YXRlLnJlcXVlc3RfdHlwZSkge1xuICAgICAgY2FzZSBcInNpOnJcIjpcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbmluUmVkaXJlY3RDYWxsYmFjayh1cmwpO1xuICAgICAgY2FzZSBcInNpOnBcIjpcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbmluUG9wdXBDYWxsYmFjayh1cmwpO1xuICAgICAgY2FzZSBcInNpOnNcIjpcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbmluU2lsZW50Q2FsbGJhY2sodXJsKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2VfdHlwZSBpbiBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2lnbm91dENhbGxiYWNrKHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBrZWVwT3BlbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gYXdhaXQgdGhpcy5fY2xpZW50LnJlYWRTaWdub3V0UmVzcG9uc2VTdGF0ZSh1cmwpO1xuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChzdGF0ZS5yZXF1ZXN0X3R5cGUpIHtcbiAgICAgIGNhc2UgXCJzbzpyXCI6XG4gICAgICAgIGF3YWl0IHRoaXMuc2lnbm91dFJlZGlyZWN0Q2FsbGJhY2sodXJsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic286cFwiOlxuICAgICAgICBhd2FpdCB0aGlzLnNpZ25vdXRQb3B1cENhbGxiYWNrKHVybCwga2VlcE9wZW4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzbzpzXCI6XG4gICAgICAgIGF3YWl0IHRoaXMuc2lnbm91dFNpbGVudENhbGxiYWNrKHVybCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZV90eXBlIGluIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcm9taXNlIHRvIHF1ZXJ5IE9QIGZvciB1c2VyJ3MgY3VycmVudCBzaWduaW4gc3RhdHVzLiBSZXR1cm5zIG9iamVjdCB3aXRoIHNlc3Npb25fc3RhdGUgYW5kIHN1YmplY3QgaWRlbnRpZmllci5cbiAgICovXG4gIGFzeW5jIHF1ZXJ5U2Vzc2lvblN0YXR1cyhhcmdzID0ge30pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInF1ZXJ5U2Vzc2lvblN0YXR1c1wiKTtcbiAgICBjb25zdCB7XG4gICAgICBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5zaWxlbnRfcmVkaXJlY3RfdXJpO1xuICAgIGlmICghdXJsKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk5vIHNpbGVudF9yZWRpcmVjdF91cmkgY29uZmlndXJlZFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9sb2FkVXNlcigpO1xuICAgIGNvbnN0IGhhbmRsZSA9IGF3YWl0IHRoaXMuX2lmcmFtZU5hdmlnYXRvci5wcmVwYXJlKHsgc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMgfSk7XG4gICAgY29uc3QgbmF2UmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9zaWduaW5TdGFydCh7XG4gICAgICByZXF1ZXN0X3R5cGU6IFwic2k6c1wiLFxuICAgICAgLy8gdGhpcyBhY3RzIGxpa2UgYSBzaWduaW4gc2lsZW50XG4gICAgICByZWRpcmVjdF91cmk6IHVybCxcbiAgICAgIHByb21wdDogXCJub25lXCIsXG4gICAgICBpZF90b2tlbl9oaW50OiB0aGlzLnNldHRpbmdzLmluY2x1ZGVJZFRva2VuSW5TaWxlbnRSZW5ldyA/IHVzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZXIuaWRfdG9rZW4gOiB2b2lkIDAsXG4gICAgICByZXNwb25zZV90eXBlOiB0aGlzLnNldHRpbmdzLnF1ZXJ5X3N0YXR1c19yZXNwb25zZV90eXBlLFxuICAgICAgc2NvcGU6IFwib3BlbmlkXCIsXG4gICAgICBza2lwVXNlckluZm86IHRydWUsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNpZ25pblJlc3BvbnNlID0gYXdhaXQgdGhpcy5fY2xpZW50LnByb2Nlc3NTaWduaW5SZXNwb25zZShuYXZSZXNwb25zZS51cmwpO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBzaWduaW4gcmVzcG9uc2VcIik7XG4gICAgICBpZiAoc2lnbmluUmVzcG9uc2Uuc2Vzc2lvbl9zdGF0ZSAmJiBzaWduaW5SZXNwb25zZS5wcm9maWxlLnN1Yikge1xuICAgICAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzIGZvciBzdWJqZWN0XCIsIHNpZ25pblJlc3BvbnNlLnByb2ZpbGUuc3ViKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzZXNzaW9uX3N0YXRlOiBzaWduaW5SZXNwb25zZS5zZXNzaW9uX3N0YXRlLFxuICAgICAgICAgIHN1Yjogc2lnbmluUmVzcG9uc2UucHJvZmlsZS5zdWIsXG4gICAgICAgICAgc2lkOiBzaWduaW5SZXNwb25zZS5wcm9maWxlLnNpZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbG9nZ2VyMi5pbmZvKFwic3VjY2VzcywgdXNlciBub3QgYXV0aGVudGljYXRlZFwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubW9uaXRvckFub255bW91c1Nlc3Npb24gJiYgZXJyIGluc3RhbmNlb2YgRXJyb3JSZXNwb25zZSkge1xuICAgICAgICBzd2l0Y2ggKGVyci5lcnJvcikge1xuICAgICAgICAgIGNhc2UgXCJsb2dpbl9yZXF1aXJlZFwiOlxuICAgICAgICAgIGNhc2UgXCJjb25zZW50X3JlcXVpcmVkXCI6XG4gICAgICAgICAgY2FzZSBcImludGVyYWN0aW9uX3JlcXVpcmVkXCI6XG4gICAgICAgICAgY2FzZSBcImFjY291bnRfc2VsZWN0aW9uX3JlcXVpcmVkXCI6XG4gICAgICAgICAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzIGZvciBhbm9ueW1vdXMgdXNlclwiKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgIHNlc3Npb25fc3RhdGU6IGVyci5zZXNzaW9uX3N0YXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9zaWduaW4oYXJncywgaGFuZGxlLCB2ZXJpZnlTdWIpIHtcbiAgICBjb25zdCBuYXZSZXNwb25zZSA9IGF3YWl0IHRoaXMuX3NpZ25pblN0YXJ0KGFyZ3MsIGhhbmRsZSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NpZ25pbkVuZChuYXZSZXNwb25zZS51cmwsIHZlcmlmeVN1Yik7XG4gIH1cbiAgYXN5bmMgX3NpZ25pblN0YXJ0KGFyZ3MsIGhhbmRsZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX3NpZ25pblN0YXJ0XCIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzaWduaW5SZXF1ZXN0ID0gYXdhaXQgdGhpcy5fY2xpZW50LmNyZWF0ZVNpZ25pblJlcXVlc3QoYXJncyk7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHNpZ25pbiByZXF1ZXN0XCIpO1xuICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZS5uYXZpZ2F0ZSh7XG4gICAgICAgIHVybDogc2lnbmluUmVxdWVzdC51cmwsXG4gICAgICAgIHN0YXRlOiBzaWduaW5SZXF1ZXN0LnN0YXRlLmlkLFxuICAgICAgICByZXNwb25zZV9tb2RlOiBzaWduaW5SZXF1ZXN0LnN0YXRlLnJlc3BvbnNlX21vZGUsXG4gICAgICAgIHNjcmlwdE9yaWdpbjogdGhpcy5zZXR0aW5ncy5pZnJhbWVTY3JpcHRPcmlnaW5cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImVycm9yIGFmdGVyIHByZXBhcmluZyBuYXZpZ2F0b3IsIGNsb3NpbmcgbmF2aWdhdG9yIHdpbmRvd1wiKTtcbiAgICAgIGhhbmRsZS5jbG9zZSgpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBhc3luYyBfc2lnbmluRW5kKHVybCwgdmVyaWZ5U3ViKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfc2lnbmluRW5kXCIpO1xuICAgIGNvbnN0IHNpZ25pblJlc3BvbnNlID0gYXdhaXQgdGhpcy5fY2xpZW50LnByb2Nlc3NTaWduaW5SZXNwb25zZSh1cmwpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qgc2lnbmluIHJlc3BvbnNlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9idWlsZFVzZXIoc2lnbmluUmVzcG9uc2UsIHZlcmlmeVN1Yik7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgYXN5bmMgX2J1aWxkVXNlcihzaWduaW5SZXNwb25zZSwgdmVyaWZ5U3ViKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfYnVpbGRVc2VyXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcihzaWduaW5SZXNwb25zZSk7XG4gICAgaWYgKHZlcmlmeVN1Yikge1xuICAgICAgaWYgKHZlcmlmeVN1YiAhPT0gdXNlci5wcm9maWxlLnN1Yikge1xuICAgICAgICBsb2dnZXIyLmRlYnVnKFwiY3VycmVudCB1c2VyIGRvZXMgbm90IG1hdGNoIHVzZXIgcmV0dXJuZWQgZnJvbSBzaWduaW4uIHN1YiBmcm9tIHNpZ25pbjpcIiwgdXNlci5wcm9maWxlLnN1Yik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlKHsgLi4uc2lnbmluUmVzcG9uc2UsIGVycm9yOiBcImxvZ2luX3JlcXVpcmVkXCIgfSk7XG4gICAgICB9XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiY3VycmVudCB1c2VyIG1hdGNoZXMgdXNlciByZXR1cm5lZCBmcm9tIHNpZ25pblwiKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zdG9yZVVzZXIodXNlcik7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcInVzZXIgc3RvcmVkXCIpO1xuICAgIHRoaXMuX2V2ZW50cy5sb2FkKHVzZXIpO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb21pc2UgdG8gdHJpZ2dlciBhIHJlZGlyZWN0IG9mIHRoZSBjdXJyZW50IHdpbmRvdyB0byB0aGUgZW5kIHNlc3Npb24gZW5kcG9pbnQuXG4gICAqL1xuICBhc3luYyBzaWdub3V0UmVkaXJlY3QoYXJncyA9IHt9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWdub3V0UmVkaXJlY3RcIik7XG4gICAgY29uc3Qge1xuICAgICAgcmVkaXJlY3RNZXRob2QsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0gPSBhcmdzO1xuICAgIGNvbnN0IGhhbmRsZSA9IGF3YWl0IHRoaXMuX3JlZGlyZWN0TmF2aWdhdG9yLnByZXBhcmUoeyByZWRpcmVjdE1ldGhvZCB9KTtcbiAgICBhd2FpdCB0aGlzLl9zaWdub3V0U3RhcnQoe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInNvOnJcIixcbiAgICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaTogdGhpcy5zZXR0aW5ncy5wb3N0X2xvZ291dF9yZWRpcmVjdF91cmksXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcm9taXNlIHRvIHByb2Nlc3MgcmVzcG9uc2UgZnJvbSB0aGUgZW5kIHNlc3Npb24gZW5kcG9pbnQuXG4gICAqL1xuICBhc3luYyBzaWdub3V0UmVkaXJlY3RDYWxsYmFjayh1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZikge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbm91dFJlZGlyZWN0Q2FsbGJhY2tcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9zaWdub3V0RW5kKHVybCk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcHJvbWlzZSB0byB0cmlnZ2VyIGEgcmVkaXJlY3Qgb2YgYSBwb3B1cCB3aW5kb3cgd2luZG93IHRvIHRoZSBlbmQgc2Vzc2lvbiBlbmRwb2ludC5cbiAgICovXG4gIGFzeW5jIHNpZ25vdXRQb3B1cChhcmdzID0ge30pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25vdXRQb3B1cFwiKTtcbiAgICBjb25zdCB7XG4gICAgICBwb3B1cFdpbmRvd0ZlYXR1cmVzLFxuICAgICAgcG9wdXBXaW5kb3dUYXJnZXQsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0gPSBhcmdzO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuc2V0dGluZ3MucG9wdXBfcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpO1xuICAgIGNvbnN0IGhhbmRsZSA9IGF3YWl0IHRoaXMuX3BvcHVwTmF2aWdhdG9yLnByZXBhcmUoeyBwb3B1cFdpbmRvd0ZlYXR1cmVzLCBwb3B1cFdpbmRvd1RhcmdldCB9KTtcbiAgICBhd2FpdCB0aGlzLl9zaWdub3V0KHtcbiAgICAgIHJlcXVlc3RfdHlwZTogXCJzbzpwXCIsXG4gICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk6IHVybCxcbiAgICAgIC8vIHdlJ3JlIHB1dHRpbmcgYSBkdW1teSBlbnRyeSBpbiBoZXJlIGJlY2F1c2Ugd2VcbiAgICAgIC8vIG5lZWQgYSB1bmlxdWUgaWQgZnJvbSB0aGUgc3RhdGUgZm9yIG5vdGlmaWNhdGlvblxuICAgICAgLy8gdG8gdGhlIHBhcmVudCB3aW5kb3csIHdoaWNoIGlzIG5lY2Vzc2FyeSBpZiB3ZVxuICAgICAgLy8gcGxhbiB0byByZXR1cm4gYmFjayB0byB0aGUgY2xpZW50IGFmdGVyIHNpZ25vdXRcbiAgICAgIC8vIGFuZCBzbyB3ZSBjYW4gY2xvc2UgdGhlIHBvcHVwIGFmdGVyIHNpZ25vdXRcbiAgICAgIHN0YXRlOiB1cmwgPT0gbnVsbCA/IHZvaWQgMCA6IHt9LFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9LCBoYW5kbGUpO1xuICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3NcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcHJvbWlzZSB0byBwcm9jZXNzIHJlc3BvbnNlIGZyb20gdGhlIGVuZCBzZXNzaW9uIGVuZHBvaW50IGZyb20gYSBwb3B1cCB3aW5kb3cuXG4gICAqL1xuICBhc3luYyBzaWdub3V0UG9wdXBDYWxsYmFjayh1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZiwga2VlcE9wZW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbm91dFBvcHVwQ2FsbGJhY2tcIik7XG4gICAgYXdhaXQgdGhpcy5fcG9wdXBOYXZpZ2F0b3IuY2FsbGJhY2sodXJsLCB7IGtlZXBPcGVuIH0pO1xuICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3NcIik7XG4gIH1cbiAgYXN5bmMgX3NpZ25vdXQoYXJncywgaGFuZGxlKSB7XG4gICAgY29uc3QgbmF2UmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9zaWdub3V0U3RhcnQoYXJncywgaGFuZGxlKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2lnbm91dEVuZChuYXZSZXNwb25zZS51cmwpO1xuICB9XG4gIGFzeW5jIF9zaWdub3V0U3RhcnQoYXJncyA9IHt9LCBoYW5kbGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfc2lnbm91dFN0YXJ0XCIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5fbG9hZFVzZXIoKTtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJsb2FkZWQgY3VycmVudCB1c2VyIGZyb20gc3RvcmFnZVwiKTtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnJldm9rZVRva2Vuc09uU2lnbm91dCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9yZXZva2VJbnRlcm5hbCh1c2VyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlkX3Rva2VuID0gYXJncy5pZF90b2tlbl9oaW50IHx8IHVzZXIgJiYgdXNlci5pZF90b2tlbjtcbiAgICAgIGlmIChpZF90b2tlbikge1xuICAgICAgICBsb2dnZXIyLmRlYnVnKFwic2V0dGluZyBpZF90b2tlbl9oaW50IGluIHNpZ25vdXQgcmVxdWVzdFwiKTtcbiAgICAgICAgYXJncy5pZF90b2tlbl9oaW50ID0gaWRfdG9rZW47XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLnJlbW92ZVVzZXIoKTtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJ1c2VyIHJlbW92ZWQsIGNyZWF0aW5nIHNpZ25vdXQgcmVxdWVzdFwiKTtcbiAgICAgIGNvbnN0IHNpZ25vdXRSZXF1ZXN0ID0gYXdhaXQgdGhpcy5fY2xpZW50LmNyZWF0ZVNpZ25vdXRSZXF1ZXN0KGFyZ3MpO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBzaWdub3V0IHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXdhaXQgaGFuZGxlLm5hdmlnYXRlKHtcbiAgICAgICAgdXJsOiBzaWdub3V0UmVxdWVzdC51cmwsXG4gICAgICAgIHN0YXRlOiAoX2EgPSBzaWdub3V0UmVxdWVzdC5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmlkLFxuICAgICAgICBzY3JpcHRPcmlnaW46IHRoaXMuc2V0dGluZ3MuaWZyYW1lU2NyaXB0T3JpZ2luXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJlcnJvciBhZnRlciBwcmVwYXJpbmcgbmF2aWdhdG9yLCBjbG9zaW5nIG5hdmlnYXRvciB3aW5kb3dcIik7XG4gICAgICBoYW5kbGUuY2xvc2UoKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX3NpZ25vdXRFbmQodXJsKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfc2lnbm91dEVuZFwiKTtcbiAgICBjb25zdCBzaWdub3V0UmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9jbGllbnQucHJvY2Vzc1NpZ25vdXRSZXNwb25zZSh1cmwpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qgc2lnbm91dCByZXNwb25zZVwiKTtcbiAgICByZXR1cm4gc2lnbm91dFJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb21pc2UgdG8gdHJpZ2dlciBhIHNpbGVudCByZXF1ZXN0ICh2aWEgYW4gaWZyYW1lKSB0byB0aGUgZW5kIHNlc3Npb24gZW5kcG9pbnQuXG4gICAqL1xuICBhc3luYyBzaWdub3V0U2lsZW50KGFyZ3MgPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25vdXRTaWxlbnRcIik7XG4gICAgY29uc3Qge1xuICAgICAgc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0gPSBhcmdzO1xuICAgIGNvbnN0IGlkX3Rva2VuX2hpbnQgPSB0aGlzLnNldHRpbmdzLmluY2x1ZGVJZFRva2VuSW5TaWxlbnRTaWdub3V0ID8gKF9hID0gYXdhaXQgdGhpcy5fbG9hZFVzZXIoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmlkX3Rva2VuIDogdm9pZCAwO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuc2V0dGluZ3MucG9wdXBfcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpO1xuICAgIGNvbnN0IGhhbmRsZSA9IGF3YWl0IHRoaXMuX2lmcmFtZU5hdmlnYXRvci5wcmVwYXJlKHsgc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMgfSk7XG4gICAgYXdhaXQgdGhpcy5fc2lnbm91dCh7XG4gICAgICByZXF1ZXN0X3R5cGU6IFwic286c1wiLFxuICAgICAgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpOiB1cmwsXG4gICAgICBpZF90b2tlbl9oaW50LFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9LCBoYW5kbGUpO1xuICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3NcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcHJvbWlzZSB0byBub3RpZnkgdGhlIHBhcmVudCB3aW5kb3cgb2YgcmVzcG9uc2UgZnJvbSB0aGUgZW5kIHNlc3Npb24gZW5kcG9pbnQuXG4gICAqL1xuICBhc3luYyBzaWdub3V0U2lsZW50Q2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25vdXRTaWxlbnRDYWxsYmFja1wiKTtcbiAgICBhd2FpdCB0aGlzLl9pZnJhbWVOYXZpZ2F0b3IuY2FsbGJhY2sodXJsKTtcbiAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzXCIpO1xuICB9XG4gIGFzeW5jIHJldm9rZVRva2Vucyh0eXBlcykge1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9sb2FkVXNlcigpO1xuICAgIGF3YWl0IHRoaXMuX3Jldm9rZUludGVybmFsKHVzZXIsIHR5cGVzKTtcbiAgfVxuICBhc3luYyBfcmV2b2tlSW50ZXJuYWwodXNlciwgdHlwZXMgPSB0aGlzLnNldHRpbmdzLnJldm9rZVRva2VuVHlwZXMpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9yZXZva2VJbnRlcm5hbFwiKTtcbiAgICBpZiAoIXVzZXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdHlwZXNQcmVzZW50ID0gdHlwZXMuZmlsdGVyKCh0eXBlKSA9PiB0eXBlb2YgdXNlclt0eXBlXSA9PT0gXCJzdHJpbmdcIik7XG4gICAgaWYgKCF0eXBlc1ByZXNlbnQubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwibm8gbmVlZCB0byByZXZva2UgZHVlIHRvIG5vIHRva2VuKHMpXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXNQcmVzZW50KSB7XG4gICAgICBhd2FpdCB0aGlzLl9jbGllbnQucmV2b2tlVG9rZW4oXG4gICAgICAgIHVzZXJbdHlwZV0sXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICB0eXBlXG4gICAgICApO1xuICAgICAgbG9nZ2VyMi5pbmZvKGAke3R5cGV9IHJldm9rZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICBpZiAodHlwZSAhPT0gXCJhY2Nlc3NfdG9rZW5cIikge1xuICAgICAgICB1c2VyW3R5cGVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zdG9yZVVzZXIodXNlcik7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcInVzZXIgc3RvcmVkXCIpO1xuICAgIHRoaXMuX2V2ZW50cy5sb2FkKHVzZXIpO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHNpbGVudCByZW5ldyBmb3IgdGhlIGBVc2VyTWFuYWdlcmAuXG4gICAqL1xuICBzdGFydFNpbGVudFJlbmV3KCkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzdGFydFNpbGVudFJlbmV3XCIpO1xuICAgIHZvaWQgdGhpcy5fc2lsZW50UmVuZXdTZXJ2aWNlLnN0YXJ0KCk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIHNpbGVudCByZW5ldyBmb3IgdGhlIGBVc2VyTWFuYWdlcmAuXG4gICAqL1xuICBzdG9wU2lsZW50UmVuZXcoKSB7XG4gICAgdGhpcy5fc2lsZW50UmVuZXdTZXJ2aWNlLnN0b3AoKTtcbiAgfVxuICBnZXQgX3VzZXJTdG9yZUtleSgpIHtcbiAgICByZXR1cm4gYHVzZXI6JHt0aGlzLnNldHRpbmdzLmF1dGhvcml0eX06JHt0aGlzLnNldHRpbmdzLmNsaWVudF9pZH1gO1xuICB9XG4gIGFzeW5jIF9sb2FkVXNlcigpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9sb2FkVXNlclwiKTtcbiAgICBjb25zdCBzdG9yYWdlU3RyaW5nID0gYXdhaXQgdGhpcy5zZXR0aW5ncy51c2VyU3RvcmUuZ2V0KHRoaXMuX3VzZXJTdG9yZUtleSk7XG4gICAgaWYgKHN0b3JhZ2VTdHJpbmcpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJ1c2VyIHN0b3JhZ2VTdHJpbmcgbG9hZGVkXCIpO1xuICAgICAgcmV0dXJuIFVzZXIuZnJvbVN0b3JhZ2VTdHJpbmcoc3RvcmFnZVN0cmluZyk7XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJubyB1c2VyIHN0b3JhZ2VTdHJpbmdcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYXN5bmMgc3RvcmVVc2VyKHVzZXIpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInN0b3JlVXNlclwiKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInN0b3JpbmcgdXNlclwiKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VTdHJpbmcgPSB1c2VyLnRvU3RvcmFnZVN0cmluZygpO1xuICAgICAgYXdhaXQgdGhpcy5zZXR0aW5ncy51c2VyU3RvcmUuc2V0KHRoaXMuX3VzZXJTdG9yZUtleSwgc3RvcmFnZVN0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcInJlbW92aW5nIHVzZXJcIik7XG4gICAgICBhd2FpdCB0aGlzLnNldHRpbmdzLnVzZXJTdG9yZS5yZW1vdmUodGhpcy5fdXNlclN0b3JlS2V5KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3RhbGUgc3RhdGUgZW50cmllcyBpbiBzdG9yYWdlIGZvciBpbmNvbXBsZXRlIGF1dGhvcml6ZSByZXF1ZXN0cy5cbiAgICovXG4gIGFzeW5jIGNsZWFyU3RhbGVTdGF0ZSgpIHtcbiAgICBhd2FpdCB0aGlzLl9jbGllbnQuY2xlYXJTdGFsZVN0YXRlKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIHZlcnNpb24gPSBcIjIuNC4wXCI7XG5cbi8vIHNyYy9WZXJzaW9uLnRzXG52YXIgVmVyc2lvbiA9IHZlcnNpb247XG5leHBvcnQge1xuICBBY2Nlc3NUb2tlbkV2ZW50cyxcbiAgQ2hlY2tTZXNzaW9uSUZyYW1lLFxuICBFcnJvclJlc3BvbnNlLFxuICBFcnJvclRpbWVvdXQsXG4gIEluTWVtb3J5V2ViU3RvcmFnZSxcbiAgTG9nLFxuICBMb2dnZXIsXG4gIE1ldGFkYXRhU2VydmljZSxcbiAgT2lkY0NsaWVudCxcbiAgT2lkY0NsaWVudFNldHRpbmdzU3RvcmUsXG4gIFNlc3Npb25Nb25pdG9yLFxuICBTaWduaW5SZXNwb25zZSxcbiAgU2lnbmluU3RhdGUsXG4gIFNpZ25vdXRSZXNwb25zZSxcbiAgU3RhdGUsXG4gIFVzZXIsXG4gIFVzZXJNYW5hZ2VyLFxuICBVc2VyTWFuYWdlclNldHRpbmdzU3RvcmUsXG4gIFZlcnNpb24sXG4gIFdlYlN0b3JhZ2VTdGF0ZVN0b3JlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2lkYy1jbGllbnQtdHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/.pnpm/oidc-client-ts@2.4.0/node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js\n");

/***/ })

};
;