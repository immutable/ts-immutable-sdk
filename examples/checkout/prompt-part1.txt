## Immutable Checkout SDK Example App Generator - Part 1: Create the App

# Overview
This prompt helps you create a new React example app that demonstrates the {feature name} feature of the Immutable Checkout SDK. The output will be a fully functional, self-contained example with proper documentation and adherence to best practices.

# App Information
- Feature name: {feature name}
- Framework: nextjs

# Step 1: Core Setup
Create a new example app named {feature name}-with-nextjs in /examples/checkout/ with this structure:

```
/examples/checkout/{feature name}-with-nextjs/
├── src/app/
│ ├── page.tsx # Main landing page with feature links
│ ├── {feature name}/page.tsx # Primary feature implementation
│ ├── redirect/page.tsx # Auth redirect handler
│ ├── logout/page.tsx # Logout functionality
│ ├── utils/ # Shared utilities
│ │ ├── setupDefault.ts # SDK initialization
│ │ └── wrapper.tsx # App context wrapper
│ ├── tests/ # Test directory
│ │ └── base.spec.js # E2E Feature tests
│ ├── layout.tsx # App layout with wrapper
│ └── globals.css # Basic styles
├── README.md # Documentation
├── package.json # Dependencies
├── next.config.mjs # Next.js config
├── tsconfig.json # TypeScript config
├── .env.example # Environment variables
├── .gitignore # Git ignore file
├── playwright.config.ts # Playwright configuration
├── coverage/ # Coverage output directory
└── eslintrc.json                   # ESLint configuration
└── babel.config.jest.js            # Babel config for tests
```
Copy these essential files from an existing example (e.g., login-with-nextjs):
- package.json (update the name to "{feature name}-with-nextjs", but keep ALL dependency versions the same)
- next.config.mjs
- tsconfig.json
- .env.example
- .gitignore
- src/app/utils/setupDefault.ts
- src/app/utils/wrapper.tsx
- src/app/layout.tsx (modify to use AppWrapper)
- src/app/globals.css
- playwright.config.ts
- .eslintrc.json

IMPORTANT: Ensure that you've gone through the checkout SDK Documentation and have a very deep understanding of the SDK before you start.
IMPORTANT: We have an internal UI Library called Biom3. Make sure that you thoroughly understand all of the components. DON'T ASSUME that a component exists. ALWAYS DOUBLE CHECK BEFORE YOU IMPORT OR USE ANYTHING
IF THE COMPONENT THAT YOU WANT DOESN'T EXIST IN BIOM3, ALWAYS USE NORMAL CSS/HTML AND NEVER ASSUME. (https://github.com/immutable/biom3 | https://immutable.atlassian.net/wiki/spaces/DS/pages/2335965298/BIOME+Docs)

# Step 2: Component Implementation

## Critical Import/Export Requirements
For ALL component files:
- ALWAYS use default exports for page components (export default function ComponentName)
- ALWAYS import React explicitly if using JSX fragments (<>...</>): import React from 'react'
- Verify all imports are correctly spelled and point to existing files
- When importing from libraries, verify the component exists in that library
- For Next.js client components, always include 'use client' at the top of the file

IMPORTANT: MAKE SURE THAT THE checkout SDK IS INITIALIZED CORRECTLY IN THE SETUPDEFAULT.TS FILE. REFER TO OTHER EXAMPLE APPS LIKE LOGIN-WITH-NEXTJS FOR THE CORRECT SETUP.
IMPORTANT: DON'T IMPLEMENT THE {feature name} AT ALL. JUST SETUP THE PROJECT STRUCTURE AND DOCUMENTATION.

## Main Landing Page (src/app/page.tsx)
Create a simple landing page with:
- Brief description of the checkout {feature name} features
- Link to the {feature name} implementation page
- Clear, concise UI using standard HTML (h1, h2, p) and Biom3 Button components

## Redirect and Logout Pages
Create minimal, functional redirect and logout pages:
- Ensure the redirect page properly handles the authentication callback
- Implement robust error handling for failed auth callbacks
- For the logout page, implement proper token cleanup
- VERIFY that all components used in these pages are properly imported

## Feature Implementation (src/app/{feature name}/page.tsx)
- THIS PAGE SHOULD JUST BE A PLACEHOLDER FOR NOW. IT SHOULD NOT IMPLEMENT ANY FUNCTIONALITY.

# Step 3: Documentation
IMPORTANT: Ensure that the command for installation, etc uses pnpm not npm.
Create a comprehensive README.md including:
- {feature name} feature description and purpose
- Setup instructions including environment variables
- Usage instructions with code examples for all {feature name} types
- Common issues and troubleshooting
- References to official documentation
- {feature name} cleanup best practices

# Step 4: Testing Files and Coverage Setup
COPY OVER THE RELEVANT E2E TEST FILES (INCLUDING SETUP, ETC) FROM OTHER EXAMPLE APPS SUCH AS LOGIN-WITH-NEXTJS

## Test Coverage Configuration
- Update the playwright.config.ts to enable test coverage collection:
  - Configure the coverage reporter in playwright.config.ts
  - Enable JavaScript coverage collection with contextOptions
  - Set proper coverage output directories
  - Add coverage thresholds (aim for >90% code coverage)

- Add the following dependencies to package.json:
  - @playwright/test
  - istanbul-lib-coverage
  - nyc
  - @istanbuljs/nyc-config-typescript (for TypeScript projects)

- Create coverage collection script in package.json:
  ```json
  "scripts": {
    "test": "playwright test",
    "test:coverage": "nyc --reporter=html --reporter=text --reporter=lcov playwright test"
  }
  ```

- Add a coverage helper file in tests/coverage-helper.ts:
  ```typescript
  import * as fs from 'fs';
  import * as path from 'path';

  export async function saveCoverage(page, testInfo) {
    const coverage = await page.evaluate(() => JSON.stringify(window.__coverage__));
    if (!coverage) return;
    
    const coverageDir = path.join(process.cwd(), '.nyc_output');
    if (!fs.existsSync(coverageDir)) {
      fs.mkdirSync(coverageDir, { recursive: true });
    }
    
    const id = testInfo.testId || Date.now();
    fs.writeFileSync(path.join(coverageDir, `coverage-${id}.json`), coverage);
  }
  ```

- Update your test files to collect coverage:
  ```typescript
  import { test, expect } from '@playwright/test';
  import { saveCoverage } from './coverage-helper';

  test('feature functionality', async ({ page }, testInfo) => {
    // Test implementation...
    
    // Save coverage at the end of the test
    await saveCoverage(page, testInfo);
  });
  ```

- Add .nyc_output and coverage/ to .gitignore file

- Document in README.md how to run tests with coverage and interpret results

- Create a .nycrc file for coverage configuration:
  ```json
  {
    "extends": "@istanbuljs/nyc-config-typescript",
    "all": true,
    "check-coverage": true,
    "include": ["src/app/{feature name}/**/*.tsx", "src/app/{feature name}/**/*.ts"],
    "exclude": ["**/*.spec.ts", "**/*.test.ts"],
    "branches": 70,
    "lines": 70,
    "functions": 70,
    "statements": 70
  }
  ```
- Test all pages renders perfectly
- Test {feature name} functionality thoroughly with all possible scenarios. (If it's checkout specific, this is not required)
- Test all {feature name} handling and cleanup
- Explicitly validate that components render without errors
- Use act() for all asynchronous operations
- Write tests that exercise all code paths to achieve high coverage

# Step 5: Implementation Guidelines
IMPORTANT: MAKE SURE THAT THE checkout SDK IS INITIALIZED CORRECTLY IN THE SETUPDEFAULT.TS FILE. REFER TO OTHER EXAMPLE APPS LIKE LOGIN-WITH-NEXTJS FOR THE CORRECT SETUP.
## SDK Usage Best Practices
- Use only documented public SDK methods
- If using internal properties, document with comments and type assertions
- Always implement proper cleanup in useEffect hooks
- Use local type definitions instead of importing non-exported types
- Add robust error handling for all {feature name} and operations
- Add TypeScript type guards for any SDK properties that might be undefined

# Step 6: Final Checks
- Ensure that the app can build.
- Ensure that all of the components, etc are used appropriately.
- run `pnpm build` and ensure that the setup is perfect.
- Ensure that there's no problem in all files. Make sure that when using a component, you use the available properties and values.

## UI Best Practices
- Always ensure that you ONLY use available Biom3 Components without assuming they exist. (Text and Spinner DOES NOT exist in the Biom3 UI Library)
- Use standard HTML elements (h1, h2, h3, p) for text content. 
- Use Biom3 Button and other UI components as documented
- Show clear loading/error states
- Keep UI simple and focused on demonstrating the {feature name}

## Critical Error Prevention
- Always check if objects exist before accessing their properties or methods
- Use optional chaining when accessing potentially undefined properties: obj?.prop?.method?.()
- Wrap all {feature name} setup and teardown in try/catch blocks
- Test component mounting/unmounting thoroughly to catch cleanup issues

## Common Pitfalls to Avoid
- DO NOT call methods that don't exist on the SDK instances
- DO NOT try to import types that aren't explicitly exported
- DO NOT forget to clean up {feature name} setup and teardown
- DO NOT use custom components or providers unless necessary
- DO NOT modify dependency versions in package.json
- DO NOT use inconsistent import methods (mixing default and named imports)
- DO NOT forget to include 'use client' directive in client components
- DO NOT assume any property or method exists without checking first 