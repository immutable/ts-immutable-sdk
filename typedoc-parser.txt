/* eslint-disable eol-last */
const fs = require('fs');
const path = require('path');

// Paths for input and output files
const inputFilePath = 'docs/typedoc_raw_export.json';
const outputFilePath = 'docs/parsed/{package_name}.json';

let typeToString;
let extractClassDetails;
let extractInterfaceDetails;

/**
 * Converts a reflection type to a string representation by examining its children properties.
 * @param {Object} type - Reflection type object from TypeDoc.
 * @returns {string} - A string representation of the reflection type.
 */
function reflectionToString(type) {
  if (!type.declaration || !Array.isArray(type.declaration.children)) {
    return 'unknown';
  }

  const childrenStr = type.declaration.children.map((child) => {
    const childType = child.type ? typeToString(child.type) : 'unknown';
    return `${child.name}: ${childType}`;
  }).join('; ');

  return `{ ${childrenStr} }`;
}

/**
 * Converts a TypeDoc type object into a human-readable string format.
 * Handles various type kinds like intrinsic, literal, reference, union, array, and reflection.
 * @param {Object} type - TypeDoc type object.
 * @returns {string} - Readable string representation of the type.
 */
typeToString = function typeToStringImpl(type) {
  if (!type) return '';
  switch (type.type) {
    case 'intrinsic':
      return type.name;
    case 'literal':
      return JSON.stringify(type.value);
    case 'reference':
      return type.name + (type.typeArguments ? `<${type.typeArguments.map(typeToString).join(', ')}>` : '');
    case 'union':
      return type.types.map(typeToString).join(' | ');
    case 'array':
      return `${typeToString(type.elementType)}[]`;
    case 'reflection':
      return reflectionToString(type);
    default:
      return 'unknown';
  }
};

/**
 * Extracts main type information and its arguments (if any) from a TypeDoc type object.
 * @param {Object} type - TypeDoc type object.
 * @returns {Object} - An object containing main type and its stringified arguments.
 */
function extractTypeInfo(type) {
  let mainType = '';
  let typeArguments = [];

  if (type) {
    mainType = type.name;

    if (type.typeArguments) {
      typeArguments = type.typeArguments.map(typeToString);
    }
  }

  return { mainType, typeArguments };
}

/**
 * Extracts the return description from the comments of a method or function.
 * @param {Object} comment - Comment object from TypeDoc structure.
 * @returns {string} - Description of the return value if available.
 */
function extractReturnDescription(comment) {
  if (comment && comment.blockTags) {
    const returnsTag = comment.blockTags.find((tag) => tag.tag === '@returns');
    if (returnsTag) {
      return returnsTag.content.map((c) => c.text).join(' ');
    }
  }
  return '';
}

/**
 * Extracts the source file information and line numbers from type source nodes.
 * @param {Array} sources - Array of source objects from TypeDoc.
 * @returns {Array} - Array of formatted source details including file name and position.
 */
function extractSources(sources) {
  if (!sources) return [];
  return sources.map((source) => ({
    fileName: source.fileName,
    line: source.line,
    character: source.character,
  }));
}

/**
 * Extracts detailed information about methods, including name, description, parameters, return types,
 * and whether it's deprecated.
 * @param {Object} node - The method node from TypeDoc.
 * @returns {Object|null} - An object with details of the method, or null if no signatures exist.
 */
function extractMethodDetails(node) {
  if (node.signatures && node.signatures.length > 0) {
    const signature = node.signatures[0];
    const { mainType, typeArguments } = extractTypeInfo(signature.type);

    // Extract deprecation details
    let deprecated = false;
    let deprecatedMessage = '';
    if (signature.comment && signature.comment.blockTags) {
      const deprecatedTag = signature.comment.blockTags.find(tag => tag.tag === '@deprecated');
      if (deprecatedTag) {
        deprecated = true;
        deprecatedMessage = deprecatedTag.content.map(c => c.text || '').join(' ');
      }
    }

    return {
      kind: 'Method',
      name: node.name,
      description: signature.comment ? signature.comment.summary.map(s => s.text).join(' ') : '',
      deprecated,
      deprecatedMessage,
      parameters: signature.parameters ? signature.parameters.map(param => ({
        name: param.name,
        type: param.type ? typeToString(param.type) : '',
        description: param.comment ? param.comment.summary.map(s => s.text).join(' ') : '',
        isOptional: param.flags?.isOptional || false,
      })) : [],
      returnType: mainType,
      returnTypeArguments: typeArguments,
      returnDescription: extractReturnDescription(signature.comment),
      sources: extractSources(signature.sources),
    };
  }
  return null;
}

/**
 * Extracts function details mimicking method detail extraction due to similar structure.
 * @param {Object} node - The function node from TypeDoc.
 * @returns {Object|null} - An object with details of the function, or null if none exist.
 */
function extractFunctionDetails(node) {
  return extractMethodDetails(node);
}

/**
 * Extracts detailed information from a collection of nodes.
 * Iterates over various TypeDoc node kinds to collect relevant details.
 * @param {Array} nodes - Array of TypeDoc nodes.
 * @param {string|null} currentPackage - The package name associated with the nodes.
 * @returns {Array} - Array of extracted details for each node.
 */
function extractDetails(nodes, currentPackage = null) {
  const details = [];
  nodes.forEach((node) => {
    let detail;
    switch (node.kind) {
      case 2048: // Method
        detail = extractMethodDetails(node);
        break;
      case 64: // Function
        detail = extractFunctionDetails(node);
        break;
      case 128: // Class
        detail = extractClassDetails(node);
        break;
      case 256: // Interface
        detail = extractInterfaceDetails(node);
        break;
      default:
        break;
    }
    if (detail) {
      detail.package = currentPackage;
      details.push(detail);
    }
    if (node.children) {
      details.push(...extractDetails(node.children, currentPackage));
    }
  });
  return details;
}

/**
 * Extracts class details from a TypeDoc node and recursively gathers information about its children.
 * @param {Object} node - The class node from TypeDoc.
 * @returns {Object} - An object containing class details and its child elements.
 */
extractClassDetails = function extractClassDetailsImpl(node) {
  return {
    kind: 'Class',
    name: node.name,
    description: node.comment ? node.comment.summary.map((s) => s.text).join(' ') : '',
    children: node.children ? extractDetails(node.children) : [],
    sources: extractSources(node.sources),
  };
};

/**
 * Extracts interface details from a TypeDoc node and recursively gathers information about its children.
 * @param {Object} node - The interface node from TypeDoc.
 * @returns {Object} - An object containing interface details and its child elements.
 */
extractInterfaceDetails = function extractInterfaceDetailsImpl(node) {
  return {
    kind: 'Interface',
    name: node.name,
    description: node.comment ? node.comment.summary.map((s) => s.text).join(' ') : '',
    children: node.children ? extractDetails(node.children) : [],
    sources: extractSources(node.sources),
  };
};

/**
 * Organizes nodes by their package groupings and extracts relevant details.
 * Handles package-specific logic for TypeDoc structures.
 * @param {Array} nodes - Array of TypeDoc nodes.
 * @param {string|null} currentPackage - The package name currently being processed.
 * @returns {Object} - An object with packages as keys and corresponding extracted details.
 */
function extractByPackage(nodes, currentPackage = null) {
  const packages = {};
  nodes.forEach((node) => {
    let packageName = currentPackage;
    if (node.kind === 2 || node.kind === 4) {
      packageName = node.name;
    }

    const details = extractDetails([node], packageName);

    if (details.length > 0 && packageName) {
      packages[packageName] = packages[packageName] || [];
      packages[packageName].push(...details);
    }
  });

  return packages;
}

/**
 * Main function to read TypeDoc JSON, extract structured details, and write to output files.
 * Reads input JSON data, processes it by package, and creates respective output JSON files.
 */
function main() {
  const rawData = fs.readFileSync(inputFilePath, 'utf-8');
  const typeDocData = JSON.parse(rawData);
  const categorizedData = extractByPackage(typeDocData.children || []);

  // Ensure the 'parsed' directory exists
  const parsedDirectory = path.dirname(outputFilePath.replace('{package_name}', 'dummy')); // Example to get directory name
  if (!fs.existsSync(parsedDirectory)) {
    fs.mkdirSync(parsedDirectory, { recursive: true });
  }

  for (const [packageName, data] of Object.entries(categorizedData)) {
    const packageOutputFilePath = outputFilePath.replace('{package_name}', packageName);
    fs.writeFileSync(packageOutputFilePath, JSON.stringify(data, null, 2), 'utf-8');
  }
}

main();