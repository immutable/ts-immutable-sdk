/* eslint-disable eol-last */
const fs = require('fs');

// Paths for input and output files
const inputFilePath = 'docs/typedoc_raw_export.json';
const outputFilePath = 'docs/parsed/{package_name}.json';

let typeToString;
let extractClassDetails;
let extractInterfaceDetails;

function reflectionToString(type) {
  if (!type.declaration || !Array.isArray(type.declaration.children)) {
    return 'unknown';
  }

  const childrenStr = type.declaration.children.map((child) => {
    const childType = child.type ? typeToString(child.type) : 'unknown';
    return `${child.name}: ${childType}`;
  }).join('; ');

  return `{ ${childrenStr} }`;
}

typeToString = function typeToStringImpl(type) {
  if (!type) return '';
  switch (type.type) {
    case 'intrinsic':
      return type.name;
    case 'reference':
      return type.name + (type.typeArguments ? `<${type.typeArguments.map(typeToString).join(', ')}>` : '');
    case 'union':
      return type.types.map(typeToString).join(' | ');
    case 'array':
      return `${typeToString(type.elementType)}[]`;
    case 'reflection':
      return reflectionToString(type);
    default:
      return JSON.stringify(type);
  }
};

function extractTypeInfo(type) {
  let mainType = '';
  let typeArguments = [];

  if (type) {
    mainType = type.name;

    if (type.typeArguments) {
      typeArguments = type.typeArguments.map(typeToString);
    }
  }

  return { mainType, typeArguments };
}

function extractReturnDescription(comment) {
  if (comment && comment.blockTags) {
    const returnsTag = comment.blockTags.find((tag) => tag.tag === '@returns');
    if (returnsTag) {
      return returnsTag.content.map((c) => c.text).join(' ');
    }
  }
  return '';
}

function extractSources(sources) {
  if (!sources) return [];
  return sources.map((source) => ({
    fileName: source.fileName,
    line: source.line,
    character: source.character,
  }));
}

function extractMethodDetails(node) {
  if (node.signatures && node.signatures.length > 0) {
    const signature = node.signatures[0];
    const { mainType, typeArguments } = extractTypeInfo(signature.type);

    return {
      kind: 'Method',
      name: node.name,
      description: signature.comment ? signature.comment.summary.map((s) => s.text).join(' ') : '',
      parameters: signature.parameters ? signature.parameters.map((param) => ({
        name: param.name,
        type: param.type ? typeToString(param.type) : '',
        description: param.comment ? param.comment.summary.map((s) => s.text).join(' ') : '',
        isOptional: param.flags?.isOptional || false,
      })) : [],
      returnType: mainType,
      returnTypeArguments: typeArguments,
      returnDescription: extractReturnDescription(signature.comment),
      sources: extractSources(signature.sources),
    };
  }
  return null;
}

function extractFunctionDetails(node) {
  return extractMethodDetails(node); // Functions are processed similarly to methods
}

function extractDetails(nodes, currentPackage = null) {
  const details = [];
  nodes.forEach((node) => {
    let detail;
    switch (node.kind) {
      case 2048: // Method
        detail = extractMethodDetails(node);
        break;
      case 64: // Function
        detail = extractFunctionDetails(node);
        break;
      case 128: // Class
        detail = extractClassDetails(node);
        break;
      case 256: // Interface
        detail = extractInterfaceDetails(node);
        break;
      default:
        break;
    }
    if (detail) {
      detail.package = currentPackage;
      details.push(detail);
    }
    if (node.children) {
      details.push(...extractDetails(node.children, currentPackage));
    }
  });
  return details;
}

extractClassDetails = function extractClassDetailsImpl(node) {
  return {
    kind: 'Class',
    name: node.name,
    description: node.comment ? node.comment.summary.map((s) => s.text).join(' ') : '',
    children: node.children ? extractDetails(node.children) : [],
    sources: extractSources(node.sources),
  };
};

extractInterfaceDetails = function extractInterfaceDetailsImpl(node) {
  return {
    kind: 'Interface',
    name: node.name,
    description: node.comment ? node.comment.summary.map((s) => s.text).join(' ') : '',
    children: node.children ? extractDetails(node.children) : [],
    sources: extractSources(node.sources),
  };
};

function extractByPackage(nodes, currentPackage = null) {
  const packages = {};
  nodes.forEach((node) => {
    let packageName = currentPackage; // Create local variable
    if (node.kind === 2 || node.kind === 4) {
      packageName = node.name;
    }

    const details = extractDetails([node], packageName);

    if (details.length > 0 && packageName) {
      packages[packageName] = packages[packageName] || [];
      packages[packageName].push(...details);
    }
  });

  return packages;
}

/**
 * Main function to read, extract details, and write JSON
 */
function main() {
  const rawData = fs.readFileSync(inputFilePath, 'utf-8');
  const typeDocData = JSON.parse(rawData);
  const categorizedData = extractByPackage(typeDocData.children || []);
  for (const [packageName, data] of Object.entries(categorizedData)) {
    const packageOutputFilePath = outputFilePath.replace('{package_name}', packageName);
    fs.writeFileSync(packageOutputFilePath, JSON.stringify(data, null, 2), 'utf-8');
  }
}

main();